<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章是leetcode刷题系列的第6部分——动态规划。这里把有代表性的题目发出来，共计33道。动态规划题目变化多端，目前旨在于习得通用的解题技巧，这些只是比较经典的动态规划题目。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少200道！">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题系列之动态规划">
<meta property="og:url" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="这篇文章是leetcode刷题系列的第6部分——动态规划。这里把有代表性的题目发出来，共计33道。动态规划题目变化多端，目前旨在于习得通用的解题技巧，这些只是比较经典的动态规划题目。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少200道！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/minpath.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/image-20210428181037785.png">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/image-20210428181149058.png">
<meta property="og:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/1601009732-AqPWoe-file_1601009732619.jpg">
<meta property="article:published_time" content="2021-05-01T13:35:42.000Z">
<meta property="article:modified_time" content="2021-05-01T13:35:42.000Z">
<meta property="article:author" content="Liu Y.L.">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/minpath.jpg">

<link rel="canonical" href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode刷题系列之动态规划 | LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode刷题系列之动态规划
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-01 21:35:42" itemprop="dateCreated datePublished" datetime="2021-05-01T21:35:42+08:00">2021-05-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>49k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>45 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章是<code>leetcode</code>刷题系列的第<code>6</code>部分——动态规划。这里把有代表性的题目发出来，共计<code>33</code>道。动态规划题目变化多端，目前旨在于习得通用的解题技巧，这些只是比较经典的动态规划题目。</p>
<p>接下来这几个月，计划完成的<code>leetcode</code>刷题系列其组织如下：</p>
<p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. 字符串</p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p>
<p><code>7</code>. 数据结构设计</p>
<p>预计涉及题目至少<code>200</code>道！</p>
<a id="more"></a>


<h5 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. Minimum Path Sum</a></h5><blockquote>
<p>给定一个<code>m × n</code>的网格，其中填充了非负数，请找到从左上到右下的路径，这将沿其路径的所有数字的总和最小化。</p>
<p>注意：您只能在任何时间点向下或向右移动。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<p><strong>Example:</strong></p>
<p><img src="minpath.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示从起点走到第 i 行, 第 j 列的最小路径和</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写可避免循环内每次的判断语句, 效率提升那么一丢丢</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">72. Edit Distance</a></h5><blockquote>
<p>  Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p>
<p>  You have the following three operations permitted on a word:</p>
<ul>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (remove &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (remove &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (insert &#39;u&#39;)</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般来说, 解决字符串的动态规划问题, 是用两个指针 i, j 分别指向两个字符串的尾</span></span><br><span class="line"><span class="comment">// 一步一步向前走, 缩小问题的规模</span></span><br><span class="line"><span class="comment">// 如果我们定义一个 dp 函数 dp(i, j)</span></span><br><span class="line"><span class="comment">// 表示将 word1[0, i] 变为 word2[0, j] 的最小编辑距离的话</span></span><br><span class="line"><span class="comment">// 那么我们要求的就是 dp(word1.size() - 1, word2.size() - 1)</span></span><br><span class="line"><span class="comment">// 那么 dp(i, j) 怎么求呢？</span></span><br><span class="line"><span class="comment">// 考虑之前的状态, 共有 dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1) 三种</span></span><br><span class="line"><span class="comment">// 在编辑 word1 的第 i + 1 个字符时</span></span><br><span class="line"><span class="comment">// 1. 如果 word1[i] == word2[j], 那么直接跳过即可, dp(i, j) = dp(i - 1, j - 1)</span></span><br><span class="line"><span class="comment">// 2. 如果 word1[i] != word2[j] 我们有三种选择</span></span><br><span class="line"><span class="comment">// - 插入一个字符使得其与 word2[j] 匹配, 那么 dp(i, j) = dp(i, j - 1) + 1</span></span><br><span class="line"><span class="comment">// - 删除这个字符, word2[j] 没有得到匹配, 那么 dp(i, j) = dp(i - 1, j) + 1</span></span><br><span class="line"><span class="comment">// - 替换这个字符使得其与 word2[j] 匹配, 那么 dp(i, j) = dp(i - 1, j - 1) + 1</span></span><br><span class="line"><span class="comment">// 要求最小编辑距离的话, 这三种都试一下, 取最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面相当于暴力解法, 把每一个操作都试一遍取最小值</span></span><br><span class="line"><span class="comment">// 会出现非常多的重叠子问题, 因此需要用备忘录优化一下</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp(word1, word2, word1.size() - <span class="number">1</span>, word2.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">string</span>&amp; word1, <span class="built_in">string</span>&amp; word2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 如果 word1 走到头了, word2 没有, 那么只能插入 word2 剩下的所有字符</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果 word2 走到头了, word1 没有, 那么只能删除 word1 剩下的所有字符</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> key = to_string(i) + <span class="string">","</span> + to_string(j);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line">    <span class="keyword">if</span>(word1[i] == word2[j])</span><br><span class="line">        memo[key] = dp(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        memo[key] = <span class="number">1</span> + min(&#123;dp(word1, word2, i - <span class="number">1</span>, j),</span><br><span class="line">                             dp(word1, word2, i, j - <span class="number">1</span>),</span><br><span class="line">                             dp(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>)&#125;);</span><br><span class="line">    <span class="keyword">return</span> memo[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 dp table</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.size();</span><br><span class="line">    <span class="keyword">int</span> n = word2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + min(&#123;dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. Longest Increasing Subsequence</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>  子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>是数组<code>[0,3,1,6,2,2,7]</code>的子序列。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>  <strong>Follow up:</strong></p>
<ul>
<li>Could you come up with the <code>O(n2)</code> solution?</li>
<li>Could you improve it to <code>O(n log(n))</code> time complexity?</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划 dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span></span><br><span class="line"><span class="comment">// 要求的目标为 dp 数组中的最大值</span></span><br><span class="line"><span class="comment">// base case 以 nums[i] 结尾的最长递增子序列至少要包含它自己 dp[0..] = 1</span></span><br><span class="line"><span class="comment">// dp[i] = max(dp[i], dp[j] + 1) j 属于 [0..i) 且 nums[j] &lt; nums[i]</span></span><br><span class="line"><span class="comment">// 就是在前面找到结尾的比 nums[i] 小的子序列, 把 nums[i] 接到后面, 长度加 1 即可</span></span><br><span class="line"><span class="comment">// 可能有很多个满足条件的接法, 选择长度最大的接法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = *max_element(dp.begin(), dp.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 既然题目提示我们这题的时间复杂度可以优化到 O(nlogn)</span></span><br><span class="line"><span class="comment">// logn 的复杂度只有二分法能办到了</span></span><br><span class="line"><span class="comment">// 我们把这些数分成许多堆, 按照下面定义的规则:</span></span><br><span class="line"><span class="comment">// 1. 依次从数组中拿出一个数, 首先第一个数就放在第 1 个堆就行</span></span><br><span class="line"><span class="comment">// 2. 之后每次取出的数必须放在所有堆顶的不小于它的数上面</span></span><br><span class="line"><span class="comment">// 3. 如果有多个堆顶的数都不小于它, 就放在最靠左边的堆上面</span></span><br><span class="line"><span class="comment">// 4. 如果没有这样的堆, 就从右边新起一个堆放</span></span><br><span class="line"><span class="comment">// 这个规则的限制下, 所有堆顶的元素从左到右始终都是有序的</span></span><br><span class="line"><span class="comment">// 这样我们就可以应用二分搜索, 来找第 1 个不小于待放数的堆了</span></span><br><span class="line"><span class="comment">// 那么这和我们的问题: 寻找最长递增子序列有什么关系呢？</span></span><br><span class="line"><span class="comment">// 可以证明, 最长递增子序列就是堆的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pilesTop;</span><br><span class="line">    <span class="comment">// 最多分了 n 个堆, 我们提前分配空间提升效率</span></span><br><span class="line">    pilesTop.reserve(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 寻找左边界二分搜索</span></span><br><span class="line">        <span class="keyword">auto</span> left = lower_bound(pilesTop.begin(), pilesTop.end(), nums[i]);</span><br><span class="line">        <span class="comment">// 如果没有合适的堆, 自己单放</span></span><br><span class="line">        <span class="keyword">if</span>(left == pilesTop.end())</span><br><span class="line">            pilesTop.push_back(nums[i]);</span><br><span class="line">        <span class="comment">// 否则, 放堆顶上</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *left = nums[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pilesTop.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="354-Russian-Doll-Envelopes"><a href="#354-Russian-Doll-Envelopes" class="headerlink" title="354. Russian Doll Envelopes"></a><a href="https://leetcode.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. Russian Doll Envelopes</a></h5><blockquote>
<p>  给你一个二维整数数组<code>envelopes</code>，其中<code>envelopes[i] = [wi, hi]</code>，表示第<code>i</code>个信封的宽度和高度。</p>
<p>  当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>  请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p>  注意：不允许旋转信封。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]).</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: envelopes &#x3D; [[1,1],[1,1],[1,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照信封的宽度递增排序, 宽度相等的信封按高度递减排序</span></span><br><span class="line"><span class="comment">// 最大嵌套信封数就是高度序列的最长递增子序列</span></span><br><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(envelopes.begin(), envelopes.end(), cmp);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(envelopes.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; envelopes.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res = *max_element(dp.begin(), dp.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样的使用二分搜索解法提升效率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(envelopes.begin(), envelopes.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> n = envelopes.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        nums[i] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; piles;</span><br><span class="line">    piles.reserve(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = lower_bound(piles.begin(), piles.end(), nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(it == piles.end())</span><br><span class="line">            piles.push_back(nums[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *it = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> piles.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">494. Target Sum</a></h5><blockquote>
<p>  给定一个非负整数数组，<code>a1, a2, ..., an</code>和一个目标数<code>S</code>。现在你有两个符号<code>+</code>和<code>-</code>。对于数组中的任意一个整数，你都可以从<code>+</code>或<code>-</code>中选择一个符号添加在前面。</p>
<p>  返回可以使最终数组和为目标数<code>S</code>的所有添加符号的方法数。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这道题虽然通常想到的都是 dfs 的方法</span></span><br><span class="line"><span class="comment">// 现在让我们再转化一下思路, 看它和动态规划有什么关系</span></span><br><span class="line"><span class="comment">// 数组中的数都是非负数, 把所有数得和表示为 sums</span></span><br><span class="line"><span class="comment">// 我们把前面加正号的数的和 表示为 sumA, 把前面加负号的数的和 表示为 sumB</span></span><br><span class="line"><span class="comment">// 有 sumA - sumB = target</span></span><br><span class="line"><span class="comment">// 移项得 sumA = target + sumB</span></span><br><span class="line"><span class="comment">// 两边加上 sumA 有 sumA + sumA = target + sumA + sumB = target + sums</span></span><br><span class="line"><span class="comment">// 最后 sumA = (target + sums) / 2  = newTarget右边都是已知的</span></span><br><span class="line"><span class="comment">// 也就是说我们把问题转化为了</span></span><br><span class="line"><span class="comment">// 从这些数中选出一个子集, 问我们有多少种选法可使得子集的和等于目标数</span></span><br><span class="line"><span class="comment">// 换种表达方式, 我们把目标数表示为一个背包的载重量</span></span><br><span class="line"><span class="comment">// 数组中的值为一个个石头的重量, 问我们有多少种装法可以把背包装满</span></span><br><span class="line"><span class="comment">// 这是动态规划中典型的背包问题</span></span><br><span class="line"><span class="comment">// 首先在装石头的过程中, 问题中的状态和选择有: 状态就是背包的可载重量和可选择的石头序列</span></span><br><span class="line"><span class="comment">// 选择就是装还是不装</span></span><br><span class="line"><span class="comment">// 由于有两个状态, 所以我们定义一个二维 dp 数组</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示在前 i 个石头中, 背包的可载重量为 j 时, 有多少种装法</span></span><br><span class="line"><span class="comment">// 那么当 i = 0 时, 没有石头, 装法为 0</span></span><br><span class="line"><span class="comment">// 当 j = 0 时, 背包的可载重量为 0 时, 只有 1 种装法, 就是一个也不装</span></span><br><span class="line"><span class="comment">// 那么状态转移方程怎么写呢?</span></span><br><span class="line"><span class="comment">// 对于可选择前 i 个石头, 可载重量为 j 时</span></span><br><span class="line"><span class="comment">// 1. 如果第 i 个石头不装, 那么 dp[i][j] = dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 2. 如果第 i 个石头装, 那么 dp[i][j] = dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 它们都取决于上一次装的情况, 两种情况要加起来</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 我们最终要求的目标就是 dp[n][m], 其中 n 表示给定数组的长度, m 表示新目标和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 问题转化</span></span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果总和都小于目标和(表示全加正号)或者 sum + target 为奇数(表示 sumA 都不是个整数)</span></span><br><span class="line">    <span class="keyword">if</span>(sum &lt; target || ((sum + target) &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> newTarget = (sum + target) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义 dp 数组</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(newTarget + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 注意 dp[0][0] 也是 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.size(); i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= newTarget; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.size()][newTarget];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="91-Decode-Ways、-639-Decode-Ways-II"><a href="#91-Decode-Ways、-639-Decode-Ways-II" class="headerlink" title="91. Decode Ways、 639. Decode Ways II"></a><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">91. Decode Ways</a>、 <a href="https://leetcode.com/problems/decode-ways-ii/" target="_blank" rel="noopener">639. Decode Ways II</a></h5><blockquote>
<p>  一条包含字母<code>A - Z</code>的消息通过以下映射进行了编码：</p>
<p>  <code>&#39;A&#39; -&gt; 1</code><br>  <code>&#39;B&#39; -&gt; 2</code><br>      …<br>  <code>&#39;Z&#39; -&gt; 26</code><br>  要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code>可以映射为：</p>
<p>  <code>&quot;AAJF&quot;</code>，将消息分组为<code>(1 1 10 6)</code><br>  <code>&quot;KJF&quot;</code>，将消息分组为<code>(11 10 6)</code><br>  注意，消息不能分组为<code>(1 11 06)</code>，因为<code>&quot;06&quot;</code>不能映射为<code>&quot;F&quot;</code>，这是由于<code>&quot;6&quot;</code>和<code>&quot;06&quot;</code>在映射中并不等价。</p>
<p>  给你一个只含数字的非空字符串<code>s</code>，请计算并返回解码方法的总数 。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;0&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no character that is mapped to a number starting with 0.</span><br><span class="line">The only valid mappings with 0 are &#39;J&#39; -&gt; &quot;10&quot; and &#39;T&#39; -&gt; &quot;20&quot;, neither of which start with 0.</span><br><span class="line">Hence, there are no valid ways to decode this since all digits need to be mapped.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;06&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;).</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> contains only digits and may contain leading zero(s).</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case 前两个字符组成的串单放用</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] != <span class="string">'0'</span>) dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单放</span></span><br><span class="line">        <span class="keyword">int</span> num = stoi(s[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">1</span> &amp;&amp; num &lt;= <span class="number">9</span>)</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 拼着放</span></span><br><span class="line">        num = stoi(s.substr(i - <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">26</span>)</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="516-Longest-Palindromic-Subsequence"><a href="#516-Longest-Palindromic-Subsequence" class="headerlink" title="516. Longest Palindromic Subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. Longest Palindromic Subsequence</a></h5><blockquote>
<p>  给定一个字符串<code>s</code>，找到其中最长的回文子序列，并返回该序列的长度。可以假设<code>s</code>的最大长度为<code>1000</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bbbab&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbbd&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: One possible longest palindromic subsequence is &quot;bb&quot;.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示子串 s[i..j] 中的最长回文子序列</span></span><br><span class="line"><span class="comment">// if s[i] == s[j]</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = dp[i + 1][j - 1] + 2</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[0][n - 1]</span></span><br><span class="line"><span class="comment">// 显然 i == j 时 dp[i][j] = 1, i &gt; j 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1143-Longest-Common-Subsequence"><a href="#1143-Longest-Common-Subsequence" class="headerlink" title="1143. Longest Common Subsequence"></a><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. Longest Common Subsequence</a></h5><blockquote>
<p>  给定两个字符串<code>text1</code>和<code>text2</code>，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回<code>0</code>。</p>
<p>  一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>  例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的子序列，但<code>&quot;aec&quot;</code>不是<code>&quot;abcde&quot;</code>的子序列。两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度</span></span><br><span class="line"><span class="comment">// if text1[i] == text1[j]</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = 1 + dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[m][n]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 || j == 0 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.size();</span><br><span class="line">    <span class="keyword">int</span> n = text2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="583-Delete-Operation-for-Two-Strings"><a href="#583-Delete-Operation-for-Two-Strings" class="headerlink" title="583. Delete Operation for Two Strings"></a><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. Delete Operation for Two Strings</a></h5><blockquote>
<p>  Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of <strong>steps</strong> required to make</em> <code>word1</code> <em>and</em> <code>word2</code> <em>the same</em>.</p>
<p>  In one <strong>step</strong>, you can delete exactly one character in either string.</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;sea&quot;, word2 &#x3D; &quot;eat&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;leetcode&quot;, word2 &#x3D; &quot;etco&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看出来, 一番删除操作之后剩下的字符串就是它们的最长公共子序列</span></span><br><span class="line"><span class="comment">// 所以就相当于问删除了多少字符后可以变成最长公共子序列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lcs = longestCommonSubsequence(word1, word2);</span><br><span class="line">    <span class="keyword">return</span> word1.size() - lcs + word2.size() - lcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度</span></span><br><span class="line"><span class="comment">// if text1[i] == text1[j]</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = 1 + dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[m][n]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 || j == 0 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.size();</span><br><span class="line">    <span class="keyword">int</span> n = text2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="712-Minimum-ASCII-Delete-Sum-for-Two-Strings"><a href="#712-Minimum-ASCII-Delete-Sum-for-Two-Strings" class="headerlink" title="712. Minimum ASCII Delete Sum for Two Strings"></a><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">712. Minimum ASCII Delete Sum for Two Strings</a></h5><blockquote>
<p>  给定两个字符串<code>s1, s2</code>，找到使两个字符串相等所需删除字符的<code>ASCII</code>值的最小和。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;sea&quot;, s2 &#x3D; &quot;eat&quot;</span><br><span class="line">Output: 231</span><br><span class="line">Explanation: Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.</span><br><span class="line">Deleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.</span><br><span class="line">At the end, both strings are equal, and 115 + 116 &#x3D; 231 is the minimum sum possible to achieve this.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;delete&quot;, s2 &#x3D; &quot;leet&quot;</span><br><span class="line">Output: 403</span><br><span class="line">Explanation: Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,</span><br><span class="line">adds 100[d]+101[e]+101[e] to the sum.  Deleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.</span><br><span class="line">At the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 &#x3D; 403.</span><br><span class="line">If instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher.</span><br></pre></td></tr></table></figure>

<p>  <strong>Note:</strong></p>
<p>  <code>0 &lt; s1.length, s2.length &lt;= 1000</code>.</p>
<p>  All elements of each string will have an ASCII value in <code>[97, 122]</code>.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和 LCS 的思路有些许相似之处</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示把 s1[0..i-1] 和 s2[0..j-1] 变相同所删除字符的最小和</span></span><br><span class="line"><span class="comment">// if s1[i - 1] == s2[j - 1]</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// 		dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1])</span></span><br><span class="line"><span class="comment">// 我们要求的目标是 dp[m][n]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 时 dp[i][j] = sum(s2[0..j-1])</span></span><br><span class="line"><span class="comment">//     j == 0 时 dp[i][j] = sum(s1[0..i-1])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.size();</span><br><span class="line">    <span class="keyword">int</span> n = s2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + s1[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = min(dp[i][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j] + s1[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="368-Largest-Divisible-Subset"><a href="#368-Largest-Divisible-Subset" class="headerlink" title="368. Largest Divisible Subset"></a><a href="https://leetcode.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. Largest Divisible Subset</a></h5><blockquote>
<p>  给你一个由无重复正整数组成的集合<code>nums</code>，请你找出并返回其中最大的整除子集<code>answer</code>，子集中每一元素对<code>(answer[i], answer[j])</code>都应当满足：</p>
<ul>
<li><p><code>answer[i] % answer[j] == 0</code>，或<code>answer[j] % answer[i] == 0</code></p>
<p>如果存在多个有效解子集，返回其中任何一个均可。</p>
</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: [1,3] is also accepted.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,4,8]</span><br><span class="line">Output: [1,2,4,8]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题要先把数组按照升序排列, 排完序之后就是求最长倍增子序列</span></span><br><span class="line"><span class="comment">// 动态规划 dp[i] 表示以 nums[i] 结尾的最长倍增子序列的长度</span></span><br><span class="line"><span class="comment">// 要求的目标为 dp 数组中的最大值</span></span><br><span class="line"><span class="comment">// base case 以 nums[i] 结尾的最长倍增子序列至少要包含它自己 dp[0..] = 1</span></span><br><span class="line"><span class="comment">// dp[i] = max(dp[i], dp[j] + 1) j 属于 [0..i) 且 nums[i] % nums[j] == 0</span></span><br><span class="line"><span class="comment">// 就是在前面找到可以被 nums[i] 整除的子序列, 把 nums[i] 接到后面, 长度加 1 即可</span></span><br><span class="line"><span class="comment">// 可能有很多个满足条件的接法, 选择长度最大的接法</span></span><br><span class="line"><span class="comment">// 但是由于这题不是让我们输出最长倍增子序列的个数, 而是把它们作为数组输出</span></span><br><span class="line"><span class="comment">// 所以 dp 数组里存的不止是最大个数, 还有它上一个数的索引</span></span><br><span class="line"><span class="comment">// 这样最后通过 dp 数组中的最大值, 找到前一个数的索引, 然后反推前面所有的数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// &#123;最长倍增子序列个数, 上一个数的索引&#125;</span></span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; dp(n, &#123;1, -1&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[i].first &lt; dp[j].first + <span class="number">1</span>)</span><br><span class="line">                dp[i] = &#123;dp[j].first + <span class="number">1</span>, j&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = max_element(dp.begin(), dp.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res.push_back(nums[distance(dp.begin(), it)]);</span><br><span class="line">    <span class="keyword">int</span> index = it-&gt;second;</span><br><span class="line">    <span class="keyword">while</span>(index != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(nums[index]);</span><br><span class="line">        index = dp[index].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock</a></h5><blockquote>
<p>  给定一个数组<code>prices</code>，它的第<code>i</code>个元素<code>prices[i]</code>表示一支给定股票第<code>i</code>天的价格。</p>
<p>  你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>  返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code>0</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接贪心算法</span></span><br><span class="line"><span class="comment">// 要在价格最低点买, 价格最高点卖掉</span></span><br><span class="line"><span class="comment">// 从前往后遍历, 记录史最低点</span></span><br><span class="line"><span class="comment">// 今天卖掉的利润等于今天的价格减去历史最低点的价格</span></span><br><span class="line"><span class="comment">// 每一天都考虑是否卖掉, 如果今天卖掉比之前卖掉得到的利润大就卖掉</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="keyword">int</span> minPrice = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="comment">// 如果今天的价格比历史最低点价格还低, 更新最低价格</span></span><br><span class="line">    	<span class="keyword">if</span>(prices[i] &lt; minPrice)</span><br><span class="line">            minPrice = prices[i];</span><br><span class="line">    	<span class="comment">// 否则, 如果今天卖出的话比之前卖出得到的利润大, 就卖出</span></span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(prices[i] - minPrice &gt; maxProfit)</span><br><span class="line">            maxProfit = prices[i] - minPrice;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 但是这种情况下, 【由于只能交易一次】, 你当天才买进的话, 之前的利润肯定是 0, 即 dp[i - 1][0] = 0</span></span><br><span class="line"><span class="comment">// 所以, dp[i][1] = max(dp[i - 1][1], - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="number">0</span> - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II</a></h5><blockquote>
<p>  给定一个数组<code>prices</code>，其中<code>prices[i]</code>是一支给定股票第<code>i</code>天的价格。</p>
<p>  设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e., max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题交易次数不限</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. Best Time to Buy and Sell Stock III</a></h5><blockquote>
<p>  给定一个数组，它的第<code>i</code>个元素是一支给定的股票在第<code>i</code>天的价格。</p>
<p>  设计一个算法来计算你所能获取的最大利润。你最多可以完成<strong>两笔交易</strong>。</p>
<p>  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br><span class="line">Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题就是下一题 k = 2 的情形</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">           dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. Best Time to Buy and Sell Stock IV</a></h5><blockquote>
<p>  给定一个整数数组<code>prices</code>，它的第<code>i</code>个元素<code>prices[i]</code>是一支给定的股票在第<code>i</code>天的价格。</p>
<p>  设计一个算法来计算你所能获取的最大利润。你最多可以<strong>完成<code>k</code>笔交易</strong>。</p>
<p>  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 2) and sell on day 2 (price &#x3D; 4), profit &#x3D; 4-2 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 2) and sell on day 3 (price &#x3D; 6), profit &#x3D; 6-2 &#x3D; 4. Then buy on day 5 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题我们最多可以完成 k 笔交易</span></span><br><span class="line"><span class="comment">// 所以有三个状态 [天数], [交易次数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][j][0] 表示第 i 天没有持有股票, 交易次数为 j 时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][j][1] 表示第 i 天持有股票, 交易次数为 j 时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][j][0] = max(dp[i - 1][j][1] + prices[i - 1], dp[i - 1][j][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票 (买进的时候交易次数加 1)</span></span><br><span class="line"><span class="comment">// dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][k][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][j][0] = 0, dp[0][j][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="comment">// 当 j == 0 时, dp[i][0][0] = 0, dp[i][0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">           dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. Best Time to Buy and Sell Stock with Cooldown</a></h5><blockquote>
<p>  给定一个整数数组，其中第<code>i</code>个元素代表了第<code>i</code>天的股票价格 。</p>
<p>  设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>  你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为<code>1</code>天)。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,0,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: transactions &#x3D; [buy, sell, cooldown, buy, sell]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题交易次数不限, 但是有冷冻期, 因此买进的时候需要看大前天的状态</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 只能大前天没有持有股票且没有卖出股票, 当天才能买进股票</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="comment">// 当 i == 1 时, dp[1][0] = 0, dp[1][1] = -prices[0]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 第 1 天的情况已经知道了, 直接从第 2 天开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. Best Time to Buy and Sell Stock with Transaction Fee</a></h5><blockquote>
<p>给定一个数组<code>prices</code>，其中<code>prices[i]</code>是一支给定股票第<code>i</code>天的价格。非负整数<code>fee</code>表示交易一次股票需要支付的费用。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题交易次数不限</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票</span></span><br><span class="line"><span class="comment">// 这里选择买进股票时支付手续费, 相当于买进价格升高了呗</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1] - fee)</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. Combination Sum IV</a></h5><blockquote>
<p>  给你一个由<strong>不同整数</strong>组成的数组<code>nums</code>，和一个目标整数<code>target</code>。请你从<code>nums</code>中找出并返回总和为<code>target</code>的元素组合的个数。</p>
<p>  题目数据保证<strong>答案符合</strong><code>32</code>位整数范围。</p>
<p>  示例 1：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], target &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。（这特么就是排列呀！！！）</span><br></pre></td></tr></table></figure>

<p>  示例 2：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9], target &#x3D; 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memo.resize(target + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的定义为凑够和为 target 的组合数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[target] != <span class="number">-1</span>) <span class="keyword">return</span> memo[target];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        res += dfs(nums, target - num);</span><br><span class="line">    memo[target] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题其实并不是组合问题, 而是排列问题</span></span><br><span class="line"><span class="comment">// 组合不关注元素顺序, 排列才关注元素顺序, 而这题关注元素的顺序!</span></span><br><span class="line"><span class="comment">// 状态有 [排列和 target]</span></span><br><span class="line"><span class="comment">// dp[i] 表示组合的和等于 i 时的不同组合个数</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[target]</span></span><br><span class="line"><span class="comment">// 如果我们考虑将 nums[j] 加入组合中去, 并且放在最后的位置</span></span><br><span class="line"><span class="comment">// [[也就是关注排列中的最后一个数是多少]]</span></span><br><span class="line"><span class="comment">// 那么此时 dp[i] 就等于所有的 dp[i - nums[j]] (j = 0, ...) 之和</span></span><br><span class="line"><span class="comment">// dp[0] = 1 表示 1 种空组合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            <span class="comment">// dp[i] + dp[i - num] 有可能溢出, 这里为了清晰起见没有考虑</span></span><br><span class="line">            <span class="keyword">if</span>(i - num &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这题还可以将其看作一个爬楼梯问题</span></span><br><span class="line"><span class="comment">// 楼梯的阶数一共为 target, 一次可以走的步数为 nums[i]</span></span><br><span class="line"><span class="comment">// 问你一共有多少种走法 (相当于登上最高阶所走步数的所有排列)</span></span><br><span class="line"><span class="comment">// [[只要关注最后一步走多少阶数就容易写出状态转移方程了]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以看作是完全背包问题</span></span><br><span class="line"><span class="comment">// 背包的容量为 target, 有物品 nums[i] 可以无限选取</span></span><br><span class="line"><span class="comment">// 并且相同的物品选择, 物品选取的顺序不同算是不同的选择</span></span><br><span class="line"><span class="comment">// 问你把背包装满有多少种方法</span></span><br><span class="line"><span class="comment">// 这题为了考虑不同的顺序, 因此外循环遍历背包的容量, 内循环遍历物品</span></span><br><span class="line"><span class="comment">// 对于下题 [换零钱 2] 由于顺序不同也算一种选择, 就要外循环遍历物品, 内循环遍历背包的容量</span></span><br></pre></td></tr></table></figure>

<h5 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change</a></h5><blockquote>
<p>  给定不同面额的硬币<code>coins</code>和一个总金额<code>amount</code>。编写一个函数来计算可以凑成总金额所需的<strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回<code>-1</code>。</p>
<p>  你可以认为每种硬币的数量是无限的。</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 10^4</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1,2,5], amount &#x3D; 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态只有 金额数</span></span><br><span class="line"><span class="comment">// 选择有若干枚硬币</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示凑够金额 i 元的最少硬币数</span></span><br><span class="line"><span class="comment">// dp[i] = min(dp[i - k] + 1) k 为每种硬币的面值</span></span><br><span class="line"><span class="comment">// 目标是求 dp[amount]</span></span><br><span class="line"><span class="comment">// 显然 dp[0] = 0 就是不用任何面值的硬币就凑够了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 数组中每个值初始化为 amount + 1 表示不可能</span></span><br><span class="line">    <span class="comment">// 因为只使用 1 元硬币最多也就需要 amount 个硬币</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= coin)</span><br><span class="line">            	dp[i] = min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以看成是一个完全背包问题</span></span><br><span class="line"><span class="comment">// 状态有 [使用的硬币] 和 [凑成的总金额]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示只使用前 i 个硬币凑成金额为 j 时的最少硬币数</span></span><br><span class="line"><span class="comment">// 对于第 i 枚硬币有使用和不使用两种选择</span></span><br><span class="line"><span class="comment">// 如果不使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j] 继承之前的硬币数</span></span><br><span class="line"><span class="comment">// 如果使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i][j - coins[i - 1]] + 1</span></span><br><span class="line"><span class="comment">// 表示只使用前 i 种硬币凑够 j - coins[i - 1] 的硬币数, 再加上使用的这枚硬币</span></span><br><span class="line"><span class="comment">// 因为要求最少的硬币数, 这两种选择的结果取小值</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1);</span></span><br><span class="line"><span class="comment">// 显然 j == 0 时 dp[i][0] = 0 就是不凑就够了, 数量为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.size();</span><br><span class="line">    <span class="comment">// 都初始化为 amount + 1 表示不可能的结果, min 时会排除掉</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>, amount + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= coins[i - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount] == amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">518. Coin Change 2</a></h5><blockquote>
<p>  给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的<strong>硬币组合数</strong>。假设每一种面额的硬币有无限个。</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= coins.size() &lt;= 300</code></li>
<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>
<li><code>0 &lt;= amount &lt;= 5000</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount &#x3D; 5, coins &#x3D; [1,2,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5 &#x3D; 5</span><br><span class="line">5 &#x3D; 2 + 2 + 1</span><br><span class="line">5 &#x3D; 2 + 1 + 1 + 1</span><br><span class="line">5 &#x3D; 1 + 1 + 1 + 1 + 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: amount &#x3D; 3, coins &#x3D; [2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: the amount of 3 cannot be made up just with coins of 2.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包问题</span></span><br><span class="line"><span class="comment">// 状态有 [使用的硬币] 和 [凑成的总金额]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示只使用前 i 个硬币凑成金额为 j 时的组合数</span></span><br><span class="line"><span class="comment">// 对于第 i 枚硬币有使用和不使用两种选择</span></span><br><span class="line"><span class="comment">// 如果不使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j] 继承之前的组合数</span></span><br><span class="line"><span class="comment">// 如果使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i][j - coins[i - 1]] 表示使用前 i 种硬币凑够 j - coins[i - 1] 的组合数</span></span><br><span class="line"><span class="comment">// 因为要求总的组合数, 这两种选择的结果相加</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 时 dp[0][j] = 0 不使用任何硬币</span></span><br><span class="line"><span class="comment">//     j == 0 时 dp[i][0] = 1 就是不凑就够了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= coins[i - <span class="number">1</span>])</span><br><span class="line">            	dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="474-Ones-and-Zeroes"><a href="#474-Ones-and-Zeroes" class="headerlink" title="474. Ones and Zeroes"></a><a href="https://leetcode.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener">474. Ones and Zeroes</a></h5><blockquote>
<p>  给你一个二进制字符串数组<code>strs</code>和两个整数<code>m</code>和<code>n</code>。</p>
<p>  请你找出并返回<code>strs</code>的最大子集的大小，该子集中最多有<code>m</code>个<code>0</code>和<code>n</code>个<code>1</code>。</p>
<p>  如果<code>x</code>的所有元素也是<code>y</code>的元素，集合<code>x</code>是集合<code>y</code>的子集 。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m &#x3D; 5, n &#x3D; 3</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The largest subset with at most 5 0&#39;s and 3 1&#39;s is &#123;&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, so the answer is 4.</span><br><span class="line">Other valid but smaller subsets include &#123;&quot;0001&quot;, &quot;1&quot;&#125; and &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;.</span><br><span class="line">&#123;&quot;111001&quot;&#125; is an invalid subset because it contains 4 1&#39;s, greater than the maximum of 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The largest subset is &#123;&quot;0&quot;, &quot;1&quot;&#125;, so the answer is 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 600</code></li>
<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> consists only of digits <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>.</li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01背包问题</span></span><br><span class="line"><span class="comment">// 这里有两个背包, 一个装 0, 一个装 1</span></span><br><span class="line"><span class="comment">// 每个物品(串)同时消耗两个背包的容量, 每个物品的价值为 1</span></span><br><span class="line"><span class="comment">// 状态有 [可选择的物品], [背包 0 的容量] 和 [背包 1 的容量]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j][k] 表示只装前 i 个物品, 背包 0 和 1 的容量分别为 j 和 k 时所能装的最大价值</span></span><br><span class="line"><span class="comment">// 对于第 i 个物品 strs[i - 1] 你的选择就是装与不装</span></span><br><span class="line"><span class="comment">// 1. 不装</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j][k]</span></span><br><span class="line"><span class="comment">// 2. 装</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j - cost_0(strs[i - 1])][k - cost_1(strs[i - 1])]</span></span><br><span class="line"><span class="comment">// 因为要求的是最大价值, 那就比较两种选择孰大孰小</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - cost_0(strs[i - 1])][k - cost_1(strs[i - 1])])</span></span><br><span class="line"><span class="comment">// 显然当 i == 0 时, dp[0][j][k] = 0, 没有物品可以装, 价值只能是 0</span></span><br><span class="line"><span class="comment">//       j == 0 || k == 0 时, dp[0][j][k] = 0, 背包没有容量了价值也是 0</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[sz][m][n]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = strs.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(sz + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n  + <span class="number">1</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [zeros, ones] = count_01(strs[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 注意 j 和 k 的起始索引, 有可能物品只消耗其中一种背包的容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; zeros || k &lt; ones)</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                	dp[i][j][k] = max(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - zeros][k - ones] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sz][m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt; count_01(const string&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, n = str.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str) <span class="keyword">if</span>(c == <span class="string">'0'</span>) cnt++;</span><br><span class="line">    <span class="keyword">return</span> &#123;cnt, n - cnt&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">139. Word Break</a></h5><blockquote>
<p>  给定一个非空字符串<code>s</code>和一个包含非空单词的列表<code>wordDict</code>，判定<code>s</code>是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>  说明：</p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;,&quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和背包问题有点类似, 但有不同之处</span></span><br><span class="line"><span class="comment">// 状态有 [可选择的字符]</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示对于前 i 个字符是否有满足条件的划分</span></span><br><span class="line"><span class="comment">// 和背包之处不同在于, 对于第 i 个字符 s[i - 1] 只有一个选择, 就是必须选择</span></span><br><span class="line"><span class="comment">// 这时我们需要将前 i 个字符用索引 j 划分为两部分</span></span><br><span class="line"><span class="comment">// 对于前半部分 s[0..j-1] 可以利用已经算出来的 dp[j]</span></span><br><span class="line"><span class="comment">// 后半部分 s[j..i-1] 需要单独判断是否在单词集合中</span></span><br><span class="line"><span class="comment">// 所以 dp[i] = dp[i] || (dp[j] &amp;&amp; (s[j..i-1] in wordDict)) j 从 0 到 i - 1</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; setting;</span><br><span class="line">    setting.insert(wordDict.begin(), wordDict.end());</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 为了需要, 我们定义空串是有效的</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            dp[i] = dp[i] || (dp[j] &amp;&amp; setting.count(s.substr(j, i - j)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; setting;</span><br><span class="line">    setting.insert(wordDict.begin(), wordDict.end());</span><br><span class="line">    <span class="keyword">return</span> dfs(s, setting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo.count(s)) <span class="keyword">return</span> memo[s];</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(setting.count(s.substr(<span class="number">0</span>, i)) &amp;&amp; dfs(s.substr(i), setting))</span><br><span class="line">            <span class="keyword">return</span> memo[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> memo[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title="140. Word Break II"></a><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">140. Word Break II</a></h5><blockquote>
<p>  给定一个非空字符串<code>s</code>和一个包含非空单词列表的字典<code>wordDict</code>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<p>  说明：</p>
<ul>
<li>分隔时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
<li><code>1 &lt;= s.size() &lt;= 20</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsanddog&quot;, wordDict &#x3D; [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]</span><br><span class="line">Output: [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pineapplepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]</span><br><span class="line">Output: [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]</span><br><span class="line">Explanation: Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sentences;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; setting;</span><br><span class="line">    setting.insert(wordDict.begin(), wordDict.end());</span><br><span class="line">    dfs(s, <span class="string">""</span>, setting);</span><br><span class="line">    <span class="keyword">return</span> sentences;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> sentence, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        sentence.pop_back();</span><br><span class="line">        sentences.push_back(sentence);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!setting.count(s.substr(<span class="number">0</span>, i)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(s.substr(i), sentence + s.substr(<span class="number">0</span>, i) + <span class="string">" "</span>, setting);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum</a></h5><blockquote>
<p>  Given a <strong>non-empty</strong> array <code>num</code> containing <strong>only positive integers</strong>, find if the array can be partitioned into <strong>two subsets</strong> such that <strong>the sum of elements in both subsets is equal</strong>.</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,5]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The array cannot be partitioned into equal sum subsets.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化为背包问题进行求解</span></span><br><span class="line"><span class="comment">// 我们把数组分成两部分</span></span><br><span class="line"><span class="comment">// 1. sumA = sumB</span></span><br><span class="line"><span class="comment">// 2. sumA + sumB = sum</span></span><br><span class="line"><span class="comment">// 所以有 sumA = sum / 2</span></span><br><span class="line"><span class="comment">// 也就是说现在有一个背包的容量恰好是 sum / 2</span></span><br><span class="line"><span class="comment">// 问我们是否有一种装法恰好装满背包</span></span><br><span class="line"><span class="comment">// 背包问题的状态一般就两个 [可选择的物品] 和 [背包的容量]</span></span><br><span class="line"><span class="comment">// 所以我们定义 dp[i][j] 表示使用前 i 个物品, 背包容量为 j 时是否有一种装法给装满</span></span><br><span class="line"><span class="comment">// 对于第 i 个物品 nums[i - 1] 可以选择装进去和不装进去</span></span><br><span class="line"><span class="comment">// 1. 不装 就要看前 i - 1 个物品能不能装满容量为 j 的背包</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 2. 装 就要看前 i - 1 个物品能不能装满容量为 j - nums[i - 1] 的背包</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 这两种任意一种选择为真的话, 就为真</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][sum/2]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 时, dp[0][j] = false, 没有物品装肯定装不满</span></span><br><span class="line"><span class="comment">//     j == 0 时, dp[i][0] = true, 容量为 0 了就是装满了啊</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果 sum 为奇数, 显然不可能</span></span><br><span class="line">    <span class="keyword">if</span>(sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(sum/<span class="number">2</span> + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum/<span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="698-Partition-to-K-Equal-Sum-Subsets"><a href="#698-Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="698. Partition to K Equal Sum Subsets"></a><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener">698. Partition to K Equal Sum Subsets</a></h5><blockquote>
<p>  给定一个整数数组<code>nums</code>和一个正整数<code>k</code>，找出是否有可能把这个数组分成<code>k</code>个非空子集，其总和都相等。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,3,2,3,5,2,1], k &#x3D; 4</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It&#39;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4], k &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>
<li><code>0 &lt;= nums[i] &lt;= 104</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实上题 416(k = 2) 以及 473(k = 4) 都是这题的特例</span></span><br><span class="line"><span class="comment">// 这题很容易超时, 为了尽可能地剪枝我额外做的工作</span></span><br><span class="line"><span class="comment">// 1. 降序排序, 到大于的时候直接 continue</span></span><br><span class="line"><span class="comment">// 2. 去重，相邻元素必须从左往右被使用</span></span><br><span class="line"><span class="comment">// 3. 索引从 start 开始</span></span><br><span class="line"><span class="keyword">int</span> targetSum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(total % k &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    used.resize(nums.size());</span><br><span class="line">    targetSum = total / k;</span><br><span class="line">    sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> canPartitionKSubsets(nums, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> curSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(curSum == targetSum) <span class="keyword">return</span> canPartitionKSubsets(nums, k - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 剪枝 1</span></span><br><span class="line">        <span class="keyword">if</span>(curSum + nums[i] &gt; targetSum)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 剪枝 2</span></span><br><span class="line">        <span class="keyword">if</span>(used[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; !used[i - <span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(canPartitionKSubsets(nums, k, start + <span class="number">1</span>, curSum + nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">55. Jump Game</a></h5><blockquote>
<p>  给定一个非负整数数组<code>nums</code>，你最初位于数组的<strong>第一个下标</strong>。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也就是问你最多能跳多远</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> farthest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        farthest = max(farthest, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i == farthest) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. Jump Game II</a></h5><blockquote>
<p>  给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用<strong>最少的跳跃次数</strong>到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,0,1,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示从索引 i 开始跳, 跳到最后需要跳的最少次数</span></span><br><span class="line"><span class="comment">// 显然 dp[n - 1] = 0, 我们要求的是 dp[0]</span></span><br><span class="line"><span class="comment">// dp[i] = 1 + min(dp[j]) j = i .. (i + nums[i])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    dp[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; n; j++)</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i + j]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">索引 2 的覆盖范围最远</th>
<th align="center">就以其最远索引作为下次起跳的位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="image-20210428181037785.png" alt="image-20210428181037785" style="zoom: 50%;" /></td>
<td align="center"><img src="image-20210428181149058.png" alt="image-20210428181149058" style="zoom:50%;" /></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心, 优先跳到下次能跳最远的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> farthest = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        farthest = max(farthest, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i == end)</span><br><span class="line">        &#123;</span><br><span class="line">            jumps++;</span><br><span class="line">            end = farthest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a><a href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener">1306. Jump Game III</a></h5><blockquote>
<p>  这里有一个非负整数数组<code>arr</code>，你最开始位于该数组的起始下标<code>start</code>处。当你位于下标<code>i</code>处时，你可以跳到<code>i + arr[i]</code>或者<code>i - arr[i]</code>。请你判断自己是否能够跳到对应元素值为<code>0</code>的任一下标处。注意，不管是什么情况下，你都无法跳到数组之外。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">All possible ways to reach at index 3 with value 0 are: </span><br><span class="line">index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br><span class="line">index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 0</span><br><span class="line">Output: true </span><br><span class="line">Explanation: </span><br><span class="line">One possible way to reach at index 3 with value 0 is: </span><br><span class="line">index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [3,0,2,1,2], start &#x3D; 2</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no way to reach at index 1 with value 0.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= start &lt; arr.length</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span>(visited[pos]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[pos] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[pos] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos + arr[pos] &lt; n)</span><br><span class="line">            q.push(pos + arr[pos]);</span><br><span class="line">        <span class="keyword">if</span>(pos - arr[pos] &gt;= <span class="number">0</span>)</span><br><span class="line">            q.push(pos - arr[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> canReach(arr, start, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; <span class="number">0</span> || start &gt;= arr.size() || visited[start])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[start] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(canReach(arr, start - arr[start], visited))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(canReach(arr, start + arr[start], visited))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    visited[start] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1345-Jump-Game-IV"><a href="#1345-Jump-Game-IV" class="headerlink" title="1345. Jump Game IV"></a><a href="https://leetcode.com/problems/jump-game-iv/" target="_blank" rel="noopener">1345. Jump Game IV</a></h5><blockquote>
<p>  给你一个整数数组<code>arr</code>，你一开始在数组的第一个元素处（下标为<code>0</code>）。每一步，你可以从下标<code>i</code>跳到下标：</p>
<ul>
<li><p><code>i + 1</code>满足：<code>i + 1 &lt; arr.length</code></p>
</li>
<li><p><code>i - 1</code>满足：<code>i - 1 &gt;= 0</code></p>
</li>
<li><p><code>j</code>满足：<code>arr[i] == arr[j]</code>且<code>i != j</code></p>
<p>请你返回到达数组最后一个元素的下标处所需的<strong>最少操作次数</strong>。</p>
<p>注意：任何时候你都不能跳到数组外面。</p>
</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [7]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Start index is the last index. You don&#39;t need to jump.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [7,6,9,6,9,6,9,7]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You can jump directly from index 0 to index 7 which is last index of the array.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [6,1,9]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 5:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [11,22,7,7,7,7,7,7,7,22,13]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索最短路径显然用 bfs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; canJumpTo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        canJumpTo[arr[i]].push_back(i);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(pos == n - <span class="number">1</span>) <span class="keyword">return</span> step;</span><br><span class="line">            visited[pos] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[pos - <span class="number">1</span>])</span><br><span class="line">                q.push(pos - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pos + <span class="number">1</span> &lt; n &amp;&amp; !visited[pos + <span class="number">1</span>])</span><br><span class="line">                q.push(pos + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> jumpTo : canJumpTo[arr[pos]])</span><br><span class="line">                <span class="keyword">if</span>(!visited[jumpTo])</span><br><span class="line">                    q.push(jumpTo);</span><br><span class="line">            <span class="comment">// 同一高度的都已经放入队列等待访问了, 下次就不用再放一次了</span></span><br><span class="line">            <span class="comment">// 必须清空, 否则会 TLE</span></span><br><span class="line">            canJumpTo[arr[pos]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这题遇到一个新情况, 把 unordered_map&lt;int, vector&lt;int&gt;&gt; canJumpTo;</span></span><br><span class="line"><span class="comment">// 里的 vector&lt;int&gt; 换成 unordered_set&lt;int&gt;</span></span><br><span class="line"><span class="comment">// 把清空语句 canJumpTo[arr[pos]] = &#123;&#125;; 变成</span></span><br><span class="line"><span class="comment">// canJumpTo[arr[pos]].clear(); 会超时, 但用 swap 函数就不会</span></span><br><span class="line"><span class="comment">// unordered_set&lt;int&gt; temp; canJumpTo[arr[pos]]swap(temp);</span></span><br><span class="line"><span class="comment">// 奇了怪了!</span></span><br></pre></td></tr></table></figure>

<h5 id="403-Frog-Jump"><a href="#403-Frog-Jump" class="headerlink" title="403. Frog Jump"></a><a href="https://leetcode.com/problems/frog-jump/" target="_blank" rel="noopener">403. Frog Jump</a></h5><blockquote>
<p>  一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>
<p>  给你石子的位置列表<code>stones</code>（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p>
<p>  开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格<code>1</code>跳至单元格<code>2</code>）。</p>
<p>  如果青蛙上一步跳跃了<code>k</code>个单位，那么它接下来的跳跃距离只能选择为<code>k - 1</code>、<code>k</code>或<code>k + 1</code>个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [0,1,3,5,6,8,12,17]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [0,1,2,3,4,8,9,11]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= stones.length &lt;= 2000</code></li>
<li><code>0 &lt;= stones[i] &lt;= 231 - 1</code></li>
<li><code>stones[0] == 0</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;stones, <span class="keyword">int</span> pos, <span class="keyword">int</span> lastJump)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos + <span class="number">1</span> == stones.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">string</span> key = to_string(pos) + <span class="string">","</span> + to_string(lastJump);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt; stones.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// k 是下一次必须跳的步数</span></span><br><span class="line">        <span class="keyword">int</span> k = stones[i] - stones[pos];</span><br><span class="line">        <span class="keyword">if</span>(k &lt; lastJump - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; lastJump + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[key] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(stones, i, k))</span><br><span class="line">            <span class="keyword">return</span> memo[key] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[key] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示是否可以用 j 步 跳到 第 i 块石头上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = stones.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = stones[i] - stones[j];</span><br><span class="line">            <span class="comment">// k 是每次跳的步数, 每跳 1 次下次最多加 1 步</span></span><br><span class="line">            <span class="comment">// 但是升序数组的索引 j 每次至少会加 1 所以 k &lt;= j</span></span><br><span class="line">            <span class="comment">// 在第 j 块石头时，再次起跳距离最大为 j + 1</span></span><br><span class="line">            <span class="comment">// 如果和后一块石头的距离大于最大起跳距离, 就不可能跳过去</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; j + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp[n - <span class="number">1</span>][k]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. Regular Expression Matching</a></h5><blockquote>
<p>  给你一个字符串<code>s</code>和一个模式串<code>p</code>，请你来实现一个支持<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式匹配。</p>
<ul>
<li><p><code>&#39;.&#39;</code>匹配任意单个字符</p>
</li>
<li><p><code>&#39;*&#39;</code>匹配零个或多个前面的那一个元素</p>
<p>所谓匹配，是要涵盖整个字符串<code>s</code>的，而不是部分字符串。</p>
</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ab&quot;, p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aab&quot;, p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 5:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;mississippi&quot;, p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 20</code></li>
<li><code>0 &lt;= p.length &lt;= 30</code></li>
<li><code>s</code> contains only lowercase English letters.</li>
<li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.</li>
<li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示 s 的前 i 个字符是否和 p 的前 j 个字符相匹配</span></span><br><span class="line"><span class="comment">// 显然我们的目标是求 dp[n][m]</span></span><br><span class="line"><span class="comment">// 1. 当 p 中的第 j 个字符 p[j - 1] != '*' 时</span></span><br><span class="line"><span class="comment">// p[j - 1] 只能选择和 s[i - 1] 进行匹配</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j - 1] if s[i - 1] == p[j - 1] or p[j - 1] == '.'</span></span><br><span class="line"><span class="comment">//     dp[i][j] = false if s[i - 1] != p[j - 1] and p[j - 1] != '.'</span></span><br><span class="line"><span class="comment">// 2. 当 p 中的第 j 个字符 p[j - 1] == '*' 时</span></span><br><span class="line"><span class="comment">// p[j - 2] 和 '*' 就组合在一起看</span></span><br><span class="line"><span class="comment">// 2.1 匹配 0 次</span></span><br><span class="line"><span class="comment">//     dp[i][j] = dp[i][j - 2] 不管 p[j - 2] 是否匹配 s[i - 1]</span></span><br><span class="line"><span class="comment">// 2.1 匹配多次</span></span><br><span class="line"><span class="comment">//     dp[i][j] = dp[i - 1][j] if s[i - 1] == p[j - 2] or p[j - 2] == '.'</span></span><br><span class="line"><span class="comment">// 两个空串默认可以匹配 dp[0][0] = true</span></span><br><span class="line"><span class="comment">// 但是这题要特别注意的是, 当 s 为空串时, p 为空串的情况可以是</span></span><br><span class="line"><span class="comment">// "", "c*", "c*c*", ... 它们都应该为 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size(), m = p.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 特别处理 p 为 c*c*... 的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 当 p 中的第 j 个字符 p[j - 1] != '*' 时</span></span><br><span class="line">            <span class="keyword">if</span>(p[j - <span class="number">1</span>] != <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// else</span></span><br><span class="line">                <span class="comment">//     dp[i][j] = false;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 当 p 中的第 j 个字符 p[j - 1] == '*' 时</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.1 匹配 0 次</span></span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 2.1 匹配多次</span></span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="312-Burst-Balloons"><a href="#312-Burst-Balloons" class="headerlink" title="312. Burst Balloons"></a><a href="https://leetcode.com/problems/burst-balloons/" target="_blank" rel="noopener">312. Burst Balloons</a></h5><blockquote>
<p>  有<code>n</code>个气球，编号为<code>0</code>到<code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p>
<p>  现在要求你戳破所有的气球。戳破第<code>i</code>个气球，你可以获得<code>nums[i - 1] * nums[i] * nums[i + 1]</code>枚硬币。这里的<code>i - 1</code>和<code>i + 1</code>代表和i相邻的两个气球的序号。如果<code>i - 1</code>或<code>i + 1</code>超出了数组的边界，那么就当它是一个数字为<code>1</code>的气球。</p>
<p>  求所能获得<strong>硬币的最大数量</strong>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,1,5,8]</span><br><span class="line">Output: 167</span><br><span class="line">Explanation:</span><br><span class="line">nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []</span><br><span class="line">coins &#x3D;  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 &#x3D; 167</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示将第 i 个气球和第 j 个气球(左右开区间)之间的气球戳破最多得到的硬币数</span></span><br><span class="line"><span class="comment">// 显然我们是要求 dp[0][n+1]</span></span><br><span class="line"><span class="comment">// 对于第 i 个气球和第 j 个气球之间的所有气球, 我们考虑最后戳破的那一个气球 k</span></span><br><span class="line"><span class="comment">// 于是可得 dp[i][j] = dp[i][k] + dp[k][j] + nums[i - 1] * nums[k - 1] * nums[j - 1]</span></span><br><span class="line"><span class="comment">// 因为我们要求最大得到的硬币数量, 就对每一个 k 分别计算, 取最大呗</span></span><br><span class="line"><span class="comment">// 当 (i, j) 区间内没有气球时得分显然是 0, 即当 i &gt;= j 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 考虑到边界条件, 在最左最右各放两个虚拟气球</span></span><br><span class="line">    nums.insert(nums.begin(), <span class="number">1</span>);</span><br><span class="line">    nums.insert(nums.end(), <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">                dp[i][j] = max(dp[i][j],</span><br><span class="line">                               dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="887-Super-Egg-Drop"><a href="#887-Super-Egg-Drop" class="headerlink" title="887. Super Egg Drop"></a><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">887. Super Egg Drop</a></h5><blockquote>
<p>  给你<code>k</code>枚相同的鸡蛋，并可以使用一栋从第<code>1</code>层到第<code>n</code>层共有<code>n</code>层楼的建筑。</p>
<p>  已知存在楼层<code>f</code>，满足<code>0 &lt;= f &lt;= n</code>，任何从高于<code>f</code>的楼层落下的鸡蛋都会碎，从<code>f</code>楼层或比它低的楼层落下的鸡蛋都不会破。</p>
<p>  每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层<code>x</code>扔下（满足<code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中重复使用这枚鸡蛋。</p>
<p>  请你计算并返回要确定<code>f</code>确切的值的<strong>最坏情况下的最小尝试次数</strong>？</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 1, n &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Drop the egg from floor 1. If it breaks, we know that f &#x3D; 0.</span><br><span class="line">Otherwise, drop the egg from floor 2. If it breaks, we know that f &#x3D; 1.</span><br><span class="line">If it does not break, then we know f &#x3D; 2.</span><br><span class="line">Hence, we need at minimum 2 moves to determine with certainty what the value of f is.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 2, n &#x3D; 6</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 14</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= 104</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line"><span class="comment">// 定义 dp(k, n) 表示有 k 个鸡蛋和 n 层楼时的最坏情况下的最少尝试次数</span></span><br><span class="line"><span class="comment">// 对于从第 1 层到第 n 层中间的某一层 i, 我们扔完之后有两种情况</span></span><br><span class="line"><span class="comment">// 1. 鸡蛋没碎</span></span><br><span class="line"><span class="comment">// 这时我们要寻找的楼层 f 显然在第 i + 1 层到第 n 层之间的共 n - i 层楼</span></span><br><span class="line"><span class="comment">// 于是问题规模缩小至 dp(k, n - i)</span></span><br><span class="line"><span class="comment">// 2. 鸡蛋碎了</span></span><br><span class="line"><span class="comment">// 这时我们要寻找的楼层 f 显然在第 1 层到第 i - 1 层之间的共 i - 1 层楼</span></span><br><span class="line"><span class="comment">// 于是问题规模缩小至 dp(k - 1, i - 1)</span></span><br><span class="line"><span class="comment">// 因为我们要求最坏情况下的最少尝试次数, 什么叫最坏情况下呢？</span></span><br><span class="line"><span class="comment">// 就是说我们并不知道扔完之后鸡蛋碎不碎, 我们要考虑碎或者不碎时的最多尝试次数</span></span><br><span class="line"><span class="comment">// 什么是最少尝试次数呢？就是说我们从第 1 层, 第 2 层...第 n 层依次试一遍, 取最小值</span></span><br><span class="line"><span class="comment">// 所以 dp(k, n) = min(max(dp(k, n - i), dp(k - 1, i - 1))) for x in 1...n</span></span><br><span class="line"><span class="comment">// 当 n == 0 时, 不用扔就可以确定, dp(k, 1) = 0</span></span><br><span class="line"><span class="comment">// 当 n == 1 时, 显然至多至少都是要扔 1 次, dp(k, 1) = 1</span></span><br><span class="line"><span class="comment">// 当 k == 1 时, 显然需要从 1 到 n 一层一层尝试 dp(1, n) = n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> dp(k, n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span> || n == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span>(memo[k][n] != <span class="number">-1</span>) <span class="keyword">return</span> memo[k][n];</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        res = min(res, <span class="number">1</span> + max(dp(k, n - i, memo), dp(k - <span class="number">1</span>, i - <span class="number">1</span>, memo)));</span><br><span class="line">    <span class="keyword">return</span> memo[k][n] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="1601009732-AqPWoe-file_1601009732619.jpg" alt="img" style="zoom: 50%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归 + 二分搜索优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> dp(k, n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 dp(k, n) 我们观察到 这是一个关于 n 的单调递增函数</span></span><br><span class="line"><span class="comment">// 也就是说在鸡蛋数固定的情况下, 楼层 n 越多, 需要的尝试次数一定不会变少</span></span><br><span class="line"><span class="comment">// 对于我们得出的这两个子问题 dp(k, n - i) 和 dp(k - 1, i - 1)</span></span><br><span class="line"><span class="comment">// 前者随着 i 的增加而减少, 后者随着 i 的增加而增加</span></span><br><span class="line"><span class="comment">// 将其想象成两条直线, 一个单调递增一个单调递减, 我们要求得一个位置 i 使得它们的最大值最小</span></span><br><span class="line"><span class="comment">// 交点处！没错在它们的交点处能满足</span></span><br><span class="line"><span class="comment">// 我们可以利用二分来查找它们的交点, 看上面的图形就明白如何应用二分了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span> || n == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span>(memo[k][n] != <span class="number">-1</span>) <span class="keyword">return</span> memo[k][n];</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> notBroken = dp(k, n - mi, memo);</span><br><span class="line">        <span class="keyword">int</span> broken = dp(k - <span class="number">1</span>, mi - <span class="number">1</span>, memo);</span><br><span class="line">        <span class="keyword">if</span>(notBroken &gt;= broken)</span><br><span class="line">        &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">            res = min(res, notBroken + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">            res = min(res, broken + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[k][n] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






































    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/ZUdtS6UUmrVCKLed/" rel="prev" title="牛客2021年4月15号模拟笔试题">
      <i class="fa fa-chevron-left"></i> 牛客2021年4月15号模拟笔试题
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80OTQ0NS8yNTkzNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#64-Minimum-Path-Sum"><span class="nav-number">1.</span> <span class="nav-text">64. Minimum Path Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#72-Edit-Distance"><span class="nav-number">2.</span> <span class="nav-text">72. Edit Distance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#300-Longest-Increasing-Subsequence"><span class="nav-number">3.</span> <span class="nav-text">300. Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#354-Russian-Doll-Envelopes"><span class="nav-number">4.</span> <span class="nav-text">354. Russian Doll Envelopes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#494-Target-Sum"><span class="nav-number">5.</span> <span class="nav-text">494. Target Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#91-Decode-Ways、-639-Decode-Ways-II"><span class="nav-number">6.</span> <span class="nav-text">91. Decode Ways、 639. Decode Ways II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#516-Longest-Palindromic-Subsequence"><span class="nav-number">7.</span> <span class="nav-text">516. Longest Palindromic Subsequence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1143-Longest-Common-Subsequence"><span class="nav-number">8.</span> <span class="nav-text">1143. Longest Common Subsequence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#583-Delete-Operation-for-Two-Strings"><span class="nav-number">9.</span> <span class="nav-text">583. Delete Operation for Two Strings</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#712-Minimum-ASCII-Delete-Sum-for-Two-Strings"><span class="nav-number">10.</span> <span class="nav-text">712. Minimum ASCII Delete Sum for Two Strings</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#368-Largest-Divisible-Subset"><span class="nav-number">11.</span> <span class="nav-text">368. Largest Divisible Subset</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">12.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="nav-number">13.</span> <span class="nav-text">122. Best Time to Buy and Sell Stock II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="nav-number">14.</span> <span class="nav-text">123. Best Time to Buy and Sell Stock III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#188-Best-Time-to-Buy-and-Sell-Stock-IV"><span class="nav-number">15.</span> <span class="nav-text">188. Best Time to Buy and Sell Stock IV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="nav-number">16.</span> <span class="nav-text">309. Best Time to Buy and Sell Stock with Cooldown</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><span class="nav-number">17.</span> <span class="nav-text">714. Best Time to Buy and Sell Stock with Transaction Fee</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#377-Combination-Sum-IV"><span class="nav-number">18.</span> <span class="nav-text">377. Combination Sum IV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#322-Coin-Change"><span class="nav-number">19.</span> <span class="nav-text">322. Coin Change</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#518-Coin-Change-2"><span class="nav-number">20.</span> <span class="nav-text">518. Coin Change 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#474-Ones-and-Zeroes"><span class="nav-number">21.</span> <span class="nav-text">474. Ones and Zeroes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#139-Word-Break"><span class="nav-number">22.</span> <span class="nav-text">139. Word Break</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#140-Word-Break-II"><span class="nav-number">23.</span> <span class="nav-text">140. Word Break II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#416-Partition-Equal-Subset-Sum"><span class="nav-number">24.</span> <span class="nav-text">416. Partition Equal Subset Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#698-Partition-to-K-Equal-Sum-Subsets"><span class="nav-number">25.</span> <span class="nav-text">698. Partition to K Equal Sum Subsets</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#55-Jump-Game"><span class="nav-number">26.</span> <span class="nav-text">55. Jump Game</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#45-Jump-Game-II"><span class="nav-number">27.</span> <span class="nav-text">45. Jump Game II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1306-Jump-Game-III"><span class="nav-number">28.</span> <span class="nav-text">1306. Jump Game III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1345-Jump-Game-IV"><span class="nav-number">29.</span> <span class="nav-text">1345. Jump Game IV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#403-Frog-Jump"><span class="nav-number">30.</span> <span class="nav-text">403. Frog Jump</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-Regular-Expression-Matching"><span class="nav-number">31.</span> <span class="nav-text">10. Regular Expression Matching</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#312-Burst-Balloons"><span class="nav-number">32.</span> <span class="nav-text">312. Burst Balloons</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#887-Super-Egg-Drop"><span class="nav-number">33.</span> <span class="nav-text">887. Super Egg Drop</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>