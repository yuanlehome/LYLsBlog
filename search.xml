<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode刷题系列之小知识点</title>
      <link href="/MK80vfKBcuYfGiyp/"/>
      <url>/MK80vfKBcuYfGiyp/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的番外篇——刷题小知识点。主要是编程题中的一些冷知识、小技巧。</p><p><code>leetcode</code>刷题系列其它文章组织如下：</p><p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p><p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p><p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p><a id="more"></a><h4 id="数字和字符串互转"><a href="#数字和字符串互转" class="headerlink" title="数字和字符串互转"></a>数字和字符串互转</h4><p>数字转字符串使用<code>std::to_string</code>函数。比如可以用来快速得到数字的位数。字符串转数字有<code>std::stoi</code>，<code>std::stol</code>等。</p><h4 id="对于字符串变量使用流stringstream"><a href="#对于字符串变量使用流stringstream" class="headerlink" title="对于字符串变量使用流stringstream"></a>对于字符串变量使用流<code>stringstream</code></h4><p>对于需要将字符串中的子串按照一定的分隔符依次读取，可以这么做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="built_in">string</span> substr;</span><br><span class="line"><span class="keyword">while</span>(getline(ss, substr, <span class="string">','</span>)) <span class="comment">// 分隔符视具体情况而定, 如'/', ' ', '.'</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 依次处理 substr</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数字0-9和单个字符互转"><a href="#数字0-9和单个字符互转" class="headerlink" title="数字0-9和单个字符互转"></a>数字<code>0-9</code>和单个字符互转</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// '0' 的 ASCII 码值为 48 (十进制)</span></span><br><span class="line"><span class="comment">// 'A' 的 ASCII 码值为 65</span></span><br><span class="line"><span class="comment">// 'a' 的 ASCII 码值为 97</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">char</span> c = i + <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'6'</span>;</span><br><span class="line"><span class="keyword">int</span> i = c - <span class="string">'0'</span>;</span><br></pre></td></tr></table></figure><h4 id="单个字符转为字符串"><a href="#单个字符转为字符串" class="headerlink" title="单个字符转为字符串"></a>单个字符转为字符串</h4><ul><li><code>string(1, c)</code></li><li><code>string().append(1, c)</code></li></ul><h4 id="数字转为字符串"><a href="#数字转为字符串" class="headerlink" title="数字转为字符串"></a>数字转为字符串</h4><ul><li><code>std::to_string()</code></li></ul><h4 id="将迭代器前进和后退n步"><a href="#将迭代器前进和后退n步" class="headerlink" title="将迭代器前进和后退n步"></a>将迭代器前进和后退<code>n</code>步</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它们都返回前进或后退之后的迭代器</span></span><br><span class="line"><span class="built_in">std</span>::next(it); <span class="comment">// 前进 1 步</span></span><br><span class="line"><span class="built_in">std</span>::next(it, n); <span class="comment">// 前进 n 步</span></span><br><span class="line"><span class="built_in">std</span>::prev(it); <span class="comment">// 后退 1 步</span></span><br><span class="line"><span class="built_in">std</span>::prev(it, n); <span class="comment">// 后退 n 步</span></span><br></pre></td></tr></table></figure><h4 id="对于vector的push-back不适用的情况"><a href="#对于vector的push-back不适用的情况" class="headerlink" title="对于vector的push_back不适用的情况"></a>对于<code>vector</code>的<code>push_back</code>不适用的情况</h4><p>若已知结果<code>vector</code>的大小，可提前创建一个该大小的<code>vector</code>，然后直接使用索引向<code>vector</code>中从后向前赋值。比如，从大到小地往<code>vector</code>中添加值，但又要求最终<code>vector</code>是递增的情况。</p><h4 id="对于在for循环里使用size-函数可能会出现的意外情况"><a href="#对于在for循环里使用size-函数可能会出现的意外情况" class="headerlink" title="对于在for循环里使用size()函数可能会出现的意外情况"></a>对于在<code>for</code>循环里使用<code>size()</code>函数可能会出现的意外情况</h4><p>拿<code>vector</code>来说，其<code>size()</code>函数接口返回的是向量的元素个数，它是<code>size_t</code>类型，即无符号整型<code>unsigned int</code>或<code>unsigned long</code>类型，如果拿它与另一个整数相减得到了一个负数，那么这个负数将会被隐式的转型为一个超级大的数（因为它的类型是无符号的嘛），这时候在<code>for</code>循环里的判条件将会产生意想不到的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// nums.size() == 3 为 unsigned 类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 将无限循环, 因为 nums.size() - 4 == -1 == INT_MAX 或 LONG_MAX</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以最好在循环外面用一个 int 变量先存一下大小</span></span><br><span class="line"><span class="keyword">int</span> n = nums.size(); <span class="comment">// n == 3 为 int 类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 0 &lt; -1 不会进入循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h4><p><strong>问题</strong>：一个合法的表达式由<code>()</code>包围，<code>()</code>可以嵌套和连接，如<code>(())()</code>也是合法括号表达式。现在有<code>n</code>对<code>()</code>，它们可以组成的合法括号表达式的个数为多少？</p><p>用栈检验括号序列是否有序。设置一个栈，每读入一个括号，若是左括号，则压栈；若是右括号，并且与当前栈顶的左括号相匹配，则出栈，继续读下一个括号，如果读入的右括号与当前栈顶的左括号不匹配，则属于不合法的情况。在初始和结束时，栈应该是空的。<code>n</code>对括号出栈顺序的总数就是本题中所有合法括号表达式的数目。</p><p>假设序列为<code>[0, 1, 2, ..., n-1]</code>。对于序列入栈出栈，长度为<code>0</code>的序列的出栈序列总数记为<code>C(0)</code>，长度为<code>1</code>的序列的出栈序列总数记为<code>C(1)</code>，长度为<code>n</code>的序列的出栈序列总数记为<code>C(n)</code>，易知<code>C(0) = 0</code>，<code>C(1) = 1</code>。</p><p>假设序列为<code>[0, 1, 2, ..., n-1]</code>，其中有<code>k</code>。对于序列入栈出栈，若<code>k</code>最后出栈，则出栈次序为，先是比<code>k</code>小的<code>[0, 1, ... , k-1]</code>，情况有<code>C(k)</code>种，后是比<code>k</code>大的<code>[k+1, ..., n-1]</code>，情况有<code>C(n-k-1)</code>，最后是<code>k</code>。<code>[0, 1, ... , k-1]</code>和<code>[k+1, ..., n-1]</code>都是合法出栈次序。</p><p>例如对于序列<code>[0, 1, 2, 3, 4, 5, 6, 7]</code>，<code>k=5</code>，一种出栈次序为<code>[0, 2, 1, 4, 3, 7, 6, 5]</code>。</p><p>由于<code>k</code>为不同值的情况相互独立，而且比<code>k</code>大的<code>[k+1, ..., n-1]</code>和比<code>k</code>小的<code>[0, 1, ... , k-1]</code>也相互独立，可以推出：</p><p><img src="image-20210908151604357.png" alt="image-20210908151604357"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catalan</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似问题：</p><ol><li><p>圆周上有标号为<code>1, 2, 3, 4, ..., 10</code>的共计<code>10</code>个点，这<code>10</code>个点配对可连成<code>5</code>条弦，且这些弦两两不相交的方式数目？(<code>C(5)</code>)</p></li><li><p>游乐园门票<code>5</code>元一张，每人限购一张。现在有<code>10</code>个小朋友排队购票，其中<code>5</code>个小朋友每人只有<code>5</code>元的钞票一张，另<code>5</code>个小朋友每人只有<code>10</code>元的钞票一张，售票员没有准备零钱。问：有多少种排队方法，使售票员总能找的开零钱？(将持<code>5</code>元者到达视作将<code>5</code>元入栈，持<code>10</code>元者到达视作使栈中某<code>5</code>元出栈，<code>C(5)</code>)</p></li><li><p>饭后，姐姐洗碗，妹妹把姐姐洗过的碗一个一个放进碗橱摞成一摞。一共有<code>n</code>个不同的碗，洗前也是摞成一摞的，也许因为小妹贪玩而使碗拿进碗橱不及时，姐姐则把洗过的碗摞在旁边，问：小妹摞起的碗有多少种可能的方式？(<code>C(n)</code>)</p></li><li><p><code>n + 2</code>条边的多边形，能被分割成三角形的方案数有（<code>C(n)</code>）。例如<code>6</code>边型的分割方案有<code>C(4) = 14</code>。</p><p><img src="400px-Catalan-Hexagons-example.svg.png" alt=""></p></li><li><p>拥有<code>n + 1</code>个叶子节点的二叉树的数量为多少？（<code>C(n)</code>）。例如<code>4</code>个叶子节点的所有二叉树形态有<code>C(3) = 5</code>。</p><img src="Catalan_number_binary_tree_example.png"  /></li><li><p><code>n*n</code>的方格地图中，从一个角到另外一个角，不跨越对角线的路径数，例如，4×4方格地图中的路径有：</p><p><img src="450px-Catalan_number_4x4_grid_example.svg.png" alt=""></p></li><li><p>再来一道阿里巴巴的笔试题目：说16个人按顺序去买烧饼，其中8个人每人身上只有一张5块钱，另外8个人每人身上只有一张10块钱。烧饼5块一个，开始时烧饼店老板身上没有钱。16个顾客互相不通气，每人只买一个。问这16个人共有多少种排列方法能避免找不开钱的情况出现。</p><p><code>C8 = 1430</code>，所以总数为<code>1430 * 8! * 8！</code>。这里乘以两个<code>8!</code>是因为每个人都不一样，持<code>5</code>块和<code>10</code>块分别的有<code>8!</code>中排列方式。它不像括号生成，左括号和左括号，或者右括号和右括号没区别。</p></li><li><p>腾讯实习招聘笔试题：在图书馆一共<code>6</code>个人在排队，<code>3</code>个还《面试宝典》一书，<code>3</code>个在借《面试宝典》一书，图书馆此时没有了面试宝典了，求他们排队的总数？</p><p><code>C3 = 5</code>，同题<code>7</code>理，总数为<code>5 * 3！* 3！= 180</code>。</p></li></ol><h4 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h4><p>如<code>x/y</code>向上取整，可以用<code>(x+y-1)/y</code>。更方便的是调用标准库函数<code>std::ceil(double(x)/y)</code>。</p><h4 id="将一个整数变成无限循环小数"><a href="#将一个整数变成无限循环小数" class="headerlink" title="将一个整数变成无限循环小数"></a>将一个整数变成无限循环小数</h4><p>例如，<code>123</code>变成<code>0.123123123...</code>。可将<code>123</code>除以<code>999</code>。一般的，对于整数<code>a</code>，变成无限循环小数的方式是<code>a / (a的位数 - 1)</code>。</p><p>证明：</p><img src="Image_20210412135943.png" alt="Image_20210412135943" style="zoom: 67%;" /><p>另外，求取一个整数<code>a</code>的位数可以用<code>to_string(a).size()</code>或<code>1 + (int)log10(a)</code>。</p><h4 id="整数拼接比大小"><a href="#整数拼接比大小" class="headerlink" title="整数拼接比大小"></a>整数拼接比大小</h4><p>要求两个整数<code>x</code>，<code>y</code>如何拼接得到结果更大或更小时，就要想到先转成字符串，然后比较<code>string(x) + string(y)</code>和<code>string(y) + string(x)</code>。</p><h4 id="位运算总结"><a href="#位运算总结" class="headerlink" title="位运算总结"></a>位运算总结</h4><ul><li><p>计算二进制数中<code>1</code>的个数</p><ul><li>巧用<code>n &amp; (n - 1)</code>：<code>n - 1</code>导致二进制数字<code>n</code>最右边的<code>1</code>变成<code>0</code>，此<code>1</code>右边的<code>0</code>变成<code>1</code>；<code>n &amp; (n - 1)</code>导致二进制数字<code>n</code>最右边的<code>1</code>变成<code>0</code>，其余位不变。因此可以循环执行此过程并计数，直到<code>n</code>变为<code>0</code>。</li><li><code>n &amp; -n</code>可以获取<code>n</code>的二进制位表示中最低位的<code>1</code>。因为，负数表示正数取反加一，再相与后会导致除了最低位的<code>1</code>保持不变，其它位全变为<code>0</code>。</li></ul></li><li><p>异或运算</p><p>异或运算简单理解就是<strong>不进位的加法</strong>运算。<code>1 + 1 = 0</code>，<code>1 + 0 = 0 + 1 = 1</code>，<code>0 + 0 = 0</code>。所以异或运算满足加法的一些运算规律：</p><ul><li><p>交换律</p><p><code>x ^ y = y ^ x</code>。</p></li><li><p>结合律</p><p><code>(x ^ y) ^ z = x ^ (y ^ z)</code>。</p></li><li><p>分配律</p><p><code>(x1 &amp; y1) ^ (x1 &amp; y2) ^ (x2 &amp; y1) ^ (x2 &amp; y2) = (x1 ^ x2) &amp; (y1 ^ y2)</code>。</p></li><li><p>对任何数<code>x</code>有</p><p><code>x ^ 0 = x</code>，<code>x ^ x = 0</code>，<code>x ^ FFFFFFFF = !x</code>。</p></li></ul></li><li><p>判断奇偶性</p><p>数字的奇偶性取决于其最低位为<code>1</code>还是<code>0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 奇数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="哈希表的键设定问题"><a href="#哈希表的键设定问题" class="headerlink" title="哈希表的键设定问题"></a>哈希表的键设定问题</h4><p>最常用的做为键的就是整数和字符串了，大多数题目都是这样。但有时候会遇到一种情况，就是说我们希望用两个以上的变量值的组合来确定对应的值，这怎么处理呢？</p><p>小技巧是，将这些变量统一转为字符串，再拼接在一起做为键。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line"><span class="keyword">int</span> key1, key2;</span><br><span class="line"><span class="built_in">string</span> key = to_string(key1) + <span class="string">","</span> + to_string(key2);</span><br><span class="line">mapping[key] = value;</span><br></pre></td></tr></table></figure><h4 id="模幂运算的技巧"><a href="#模幂运算的技巧" class="headerlink" title="模幂运算的技巧"></a>模幂运算的技巧</h4><p>先说常用的<strong>求模运算</strong>技巧，对乘积的结果求模，等价于先对每个因子都求模，再对因子求模的结果的乘积再求模。</p><p><img src="image-20210908151709526.png" alt="image-20210908151709526"></p><p>证明过程如下：</p><p>假设<code>A, B, C, D</code>为任意常数，那么，</p><p><img src="image-20210908151737555.png" alt="image-20210908151737555"></p><p>又因为，</p><p><img src="image-20210908151759130.png" alt="image-20210908151759130"></p><p>所以，<br>$$<br>(ab)% n = (a% n)(b% n)% n<br>$$<br><strong>求幂运算</strong>的话，就是要知道可根据幂指数的<strong>奇偶性</strong>优化求解效率：</p><img src="formula2.png" alt="img" style="zoom: 50%;" /><h4 id="同余定理"><a href="#同余定理" class="headerlink" title="同余定理"></a>同余定理</h4><p><img src="image-20210908151821823.png" alt="image-20210908151821823"></p><h4 id="最小公倍数和最大公约数"><a href="#最小公倍数和最大公约数" class="headerlink" title="最小公倍数和最大公约数"></a>最小公倍数和最大公约数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之数据结构设计</title>
      <link href="/GRrK24ZqnqkWXLK0/"/>
      <url>/GRrK24ZqnqkWXLK0/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>7</code>部分——数据结构设计。</p><p><code>leetcode</code>刷题系列其它文章组织如下：</p><p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p><p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p><p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p><a id="more"></a><h5 id="622-Design-Circular-Queue"><a href="#622-Design-Circular-Queue" class="headerlink" title="622. Design Circular Queue"></a><a href="https://leetcode.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. Design Circular Queue</a></h5><blockquote><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于<code>FIFO</code>（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p>你的实现应该支持如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue(k)</span><br><span class="line">构造器, 设置队列长度为 k</span><br><span class="line">Front</span><br><span class="line">从队首获取元素, 如果队列为空，返回 -1</span><br><span class="line">Rear</span><br><span class="line">获取队尾元素, 如果队列为空，返回 -1</span><br><span class="line">enQueue(value)</span><br><span class="line">向循环队列插入一个元素, 如果成功插入则返回真</span><br><span class="line">deQueue()</span><br><span class="line">从循环队列中删除一个元素, 如果成功删除则返回真</span><br><span class="line">isEmpty()</span><br><span class="line">检查循环队列是否为空</span><br><span class="line">isFull()</span><br><span class="line">检查循环队列是否已满</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简单起见, 使用头尾两个索引变量和一个大小变量</span></span><br><span class="line"><span class="comment">// _head 永远指向头元素的前一个位置</span></span><br><span class="line"><span class="comment">// _tail 永远指向尾元素</span></span><br><span class="line"><span class="comment">// _size 指示队列中的元素数</span></span><br><span class="line"><span class="comment">// 队列方向为 _head &lt;----------- _tail</span></span><br><span class="line"><span class="comment">// _head 和 _tail 只加不减, 循环</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _head;</span><br><span class="line">    <span class="keyword">int</span> _tail;</span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化时, 头尾索引为 -1 表示无效, 大小为 0</span></span><br><span class="line">    MyCircularQueue(<span class="keyword">int</span> k) : _head(<span class="number">-1</span>), _tail(<span class="number">-1</span>), _size(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 vector 容量扩充到指定大小, 默认以 0 填充</span></span><br><span class="line">        _data.resize(k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入队时, 判断是否已满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尾指针当前指向尾元素, 添加元素时需要 ++</span></span><br><span class="line">        <span class="comment">// 如果超过 vector 索引范围, 直接回到 0</span></span><br><span class="line">        <span class="keyword">if</span>(++_tail == _data.size()) &#123;</span><br><span class="line">            _tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _data[_tail] = value;</span><br><span class="line">        _size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 出队时先判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为 _head 当前指向首元素前一个位置</span></span><br><span class="line">        <span class="comment">// 需要先 ++ 再赋值</span></span><br><span class="line">        _head++;</span><br><span class="line">        <span class="comment">// 如果超过 vector 索引范围, 直接回到 0</span></span><br><span class="line">        <span class="keyword">if</span>(_head == _data.size()) &#123;</span><br><span class="line">            _head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _head + <span class="number">1</span> == _data.size() ? _data[<span class="number">0</span>] : _data[_head + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? <span class="number">-1</span> : _data[_tail];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size == _data.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache</a></h5><blockquote><p>运用你所掌握的数据结构，设计和实现一个<code>LRU</code>(最近最少使用) 缓存机制 。</p><p><strong>参考链接</strong>：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNDQ3MzgxMw==&mid=2247483929&idx=1&sn=fda81057c47d376917ed142b2661f63a&chksm=e8f49223df831b35deb2e5316caddc241b4aa4bb58e8c66c906bdacfd695aca53aca86a5b173&mpshare=1&scene=23&srcid=0316bjmcFhe5xBzFM5mVMehZ&sharer_sharetime=1622459011412&sharer_shareid=7cbdd205bcb5ea7a7912ce1a62c48cda#rd" target="_blank" rel="noopener">从 LRU Cache 带你看面试的本质</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzk0NTE5MTcxNQ==&mid=2247483722&idx=1&sn=4f5ff638f9e020ad7ee8a3ba2595b8e6&chksm=c3186f06f46fe610a98fcc65e397f22d6d39a25ed32715ae313ec45a0f7f19368c36ec3175bb&mpshare=1&scene=23&srcid=0303Bs1lcVsbvfREx8q7YaqB&sharer_sharetime=1622459025098&sharer_shareid=7cbdd205bcb5ea7a7912ce1a62c48cda#rd" target="_blank" rel="noopener">缓存淘汰算法的实现与应用介绍（LRU、LFU）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647523909&idx=1&sn=fc26b334afcd3b12a130905043e58f20&chksm=87d1bd46b0a634505a619566b7cd56c4f69bec7793d3f6794cef1207c3c40bdc6916da608089&mpshare=1&scene=23&srcid=1226uXTA9n8lmyoSP4zAxDly&sharer_sharetime=1622459037018&sharer_shareid=7cbdd205bcb5ea7a7912ce1a62c48cda#rd" target="_blank" rel="noopener">我竟然跪在了LRU，好亏奥！</a></li></ul><p>实现<code>LRUCache</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LRUCache(int capacity)</span><br><span class="line">以正整数作为容量 capacity 初始化 LRU 缓存</span><br><span class="line">int get(int key)</span><br><span class="line">如果关键字 key 存在于缓存中，则返回关键字的值, 否则返回 -1</span><br><span class="line">void put(int key, int value)</span><br><span class="line">如果关键字已经存在, 则变更其数据值: 如果关键字不存在, 则插入该组「关键字-值」, 当缓存容量达到上限时, 它应该在写入新数据之前删除最久未使用的数据值, 从而为新的数据值留出空间</span><br></pre></td></tr></table></figure></blockquote><img src="dtter.jpg" alt="Image" style="zoom:50%;" /><img src="2341123.jpg" alt="Image" style="zoom:50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> key_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">list</span>&lt;pair&lt;key_type, value_type&gt;&gt;::iterator iterator_to_node;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;key_type, iterator_to_node&gt; _key2item;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;key_type, value_type&gt;&gt; _items;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">size_t</span> capacity) : _capacity(capacity) &#123;&#125;;</span><br><span class="line">    ~LRUCache() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">value_type <span class="title">get</span><span class="params">(key_type key)</span> </span>&#123;</span><br><span class="line">        value_type value;</span><br><span class="line">        <span class="keyword">if</span>(_key2item.count(key)) &#123;</span><br><span class="line">            value = _key2item[key]-&gt;second;</span><br><span class="line">            _items.splice(_items.begin(), _items, _key2item[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(key_type key, value_type value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_key2item.count(key)) &#123;</span><br><span class="line">            _key2item[key]-&gt;second = value;</span><br><span class="line">            _items.splice(_items.begin(), _items, _key2item[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(_capacity &lt;= _items.size()) &#123;</span><br><span class="line">                _key2item.erase(_items.back().first);</span><br><span class="line">                _items.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">             _items.emplace_front(key, value);</span><br><span class="line">            _key2item[key] = _items.begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashmap + list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> key_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">list</span>&lt;pair&lt;key_type, value_type&gt;&gt;::iterator iterator_to_node;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;key_type, iterator_to_node&gt; _keyToItem;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;key_type, value_type&gt;&gt; _itemList;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">size_t</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line">    ~LRUCache() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">value_type <span class="title">get</span><span class="params">(key_type key)</span> </span>&#123;</span><br><span class="line">        value_type value;</span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key)) &#123;</span><br><span class="line">            value = _keyToItem[key]-&gt;second;</span><br><span class="line">            <span class="comment">// 如果 key 存在, 则在 LRUcache 中重新添加这个 key</span></span><br><span class="line">        put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 key 对应的值</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(key_type key, value_type val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 key 已经存在, 则直接删掉链表中对应的条目</span></span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key)) &#123;</span><br><span class="line">            _itemList.erase(_keyToItem[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(_capacity &lt;= _itemList.size()) &#123;</span><br><span class="line">            <span class="comment">// 如果容量已经满, 则删除链表尾部的条目以及 hashmap 中对应的 key</span></span><br><span class="line">            _keyToItem.erase(_itemList.back().first);</span><br><span class="line">            _itemList.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新 key 加入链表首部并在 hashmap 中更新/添加 key</span></span><br><span class="line">        _itemList.emplace_front(key, val);</span><br><span class="line">        _keyToItem[key] = _itemList.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己实现双向链表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    T _value;</span><br><span class="line">    Node* _prev;</span><br><span class="line">    Node* _next;</span><br><span class="line">    Node(<span class="keyword">const</span> T&amp; value) : _value(value), _prev(<span class="literal">nullptr</span>), _next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Node&lt;value_type&gt;* link_type;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    link_type _node;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DoubleLinkedList() : _node(<span class="literal">nullptr</span>), _size(<span class="number">0</span>) &#123;</span><br><span class="line">        _node = <span class="keyword">new</span> Node&lt;value_type&gt;(value_type());</span><br><span class="line">        _node-&gt;_next = _node;</span><br><span class="line">        _node-&gt;_prev = _node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~DoubleLinkedList() &#123;</span><br><span class="line">        <span class="keyword">while</span>(_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> _node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">link_type <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _node-&gt;_next; &#125;</span><br><span class="line">    <span class="function">link_type <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _node; &#125;</span><br><span class="line">    <span class="function">value_type&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _node-&gt;_next-&gt;_value; &#125;</span><br><span class="line">    <span class="function">value_type&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _node-&gt;_prev-&gt;_value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(link_type node)</span> </span>&#123;</span><br><span class="line">        _size--;</span><br><span class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</span><br><span class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; erase(_node-&gt;_next); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; erase(_node-&gt;_prev); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(link_type pos, value_type value)</span> </span>&#123;</span><br><span class="line">        _size++;</span><br><span class="line">        link_type node = <span class="keyword">new</span> Node&lt;value_type&gt;(value);</span><br><span class="line">        pos-&gt;_prev-&gt;_next = node;</span><br><span class="line">        node-&gt;_prev = pos-&gt;_prev;</span><br><span class="line">        pos-&gt;_prev = node;</span><br><span class="line">        node-&gt;_next = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(value_type value)</span> </span>&#123; insert(_node-&gt;_next, value); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(value_type value)</span> </span>&#123; insert(_node, value); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> DoubleLinkedList&lt;pair&lt;<span class="keyword">int</span>, value_type&gt;&gt;::link_type iterator_to_node;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, iterator_to_node&gt; _keyToItem;</span><br><span class="line">    DoubleLinkedList&lt;pair&lt;<span class="keyword">int</span>, value_type&gt;&gt; _itemList;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line">    ~LRUCache() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">value_type <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value_type res = _keyToItem[key]-&gt;_value.second;</span><br><span class="line">        <span class="comment">// 如果 key 存在, 则在 LRUcache 中重新添加这个 key</span></span><br><span class="line">        put(key, res);</span><br><span class="line">        <span class="comment">// 返回 key 对应的值</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, value_type val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 key 已经存在, 则直接删掉链表中对应的条目</span></span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key)) &#123;</span><br><span class="line">            _itemList.erase(_keyToItem[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(_capacity &lt;= _itemList.size()) &#123;</span><br><span class="line">            <span class="comment">// 如果容量已经满, 则删除链表尾部的条目以及 hashmap 中对应的 key</span></span><br><span class="line">            _keyToItem.erase(_itemList.back().first);</span><br><span class="line">            _itemList.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新 key 加入链表首部并在 hashmap 中更新/添加 key</span></span><br><span class="line">        _itemList.push_front(make_pair(key, val));</span><br><span class="line">        _keyToItem[key] = _itemList.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="460-LFU-Cache"><a href="#460-LFU-Cache" class="headerlink" title="460. LFU Cache"></a><a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">460. LFU Cache</a></h5><blockquote><p>请你为最不经常使用（<code>LFU</code>）缓存算法设计并实现数据结构。</p><p>实现<code>LFUCache</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LFUCache(int capacity)</span><br><span class="line">用数据结构的容量 capacity 初始化对象</span><br><span class="line">int get(int key)</span><br><span class="line">如果键存在于缓存中, 则获取键的值, 否则返回 -1</span><br><span class="line">void put(int key, int value)</span><br><span class="line">如果键已存在, 则变更其值; 如果键不存在, 请插入键值对, 当缓存达到其容量时, 则应该在插入新项之前, 使最不经常使用的项无效, 在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键</span><br></pre></td></tr></table></figure><p>注意「项的使用次数」就是自插入该项以来对其调用<code>get</code>和<code>put</code>函数的次数之和。使用次数会在对应项被移除后置为<code>0</code>。</p><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个使用计数器 。使用计数最小的键是最久未使用的键。当一个键首次插入到缓存中时，它的使用计数器被设置为<code>1</code> (由于<code>put</code>操作)。对缓存中的键执行<code>get</code>或<code>put</code>操作，使用计数器的值将会递增。</p></blockquote><img src="dfgdf.jpg" alt="Image" style="zoom:50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双 hashmap + list 方法, 实现的 get 和 put 的操作时间复杂度都为 O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">int</span> _key;</span><br><span class="line">    value_type _value;</span><br><span class="line">    <span class="keyword">size_t</span> _freq;</span><br><span class="line">    Node(<span class="keyword">int</span> key, value_type value, <span class="keyword">size_t</span> freq) : _key(key), _value(value), _freq(freq) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">list</span>&lt;Node&lt;value_type&gt;&gt;::iterator iterator_to_node;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    <span class="keyword">size_t</span> _minFreq;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, iterator_to_node&gt; _keyToItem;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">list</span>&lt;Node&lt;value_type&gt;&gt;&gt; _freqToKeys;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">size_t</span> capacity) : _capacity(capacity), _minFreq(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    ~LFUCache() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">value_type <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value_type();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 key 对应的 _freq + 1</span></span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span> _keyToItem[key]-&gt;_value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, value_type value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 key 已经存在，则更新对应的 _value, 然后将 key 对应的 _freq + 1</span></span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key)) &#123;</span><br><span class="line">            _keyToItem[key]-&gt;_value = value;</span><br><span class="line">            increaseFreq(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果容量已满, 则删除 _minFreq 对应的最久未使用的条目</span></span><br><span class="line">        <span class="keyword">if</span>(_capacity &lt;= _keyToItem.size()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lfu_key = _freqToKeys[_minFreq].back()._key;</span><br><span class="line">            _freqToKeys[_minFreq].pop_back();</span><br><span class="line">            _keyToItem.erase(lfu_key);</span><br><span class="line">            <span class="comment">// 如果 _minFreq 对应的 _key 链表已空, 则删除这个 _minFreq 对应的映射</span></span><br><span class="line">            <span class="keyword">if</span>(_freqToKeys[_minFreq].empty()) &#123;</span><br><span class="line">                _freqToKeys.erase(_minFreq);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此处不需要更新 _minFreq 的值, 因为接下来添加新条目后会将 _minFreq 设为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 腾出空间后, 添加 _freq 为 1 的键值对</span></span><br><span class="line">        _freqToKeys[<span class="number">1</span>].push_front(Node&lt;value_type&gt;(key, value, <span class="number">1</span>));</span><br><span class="line">        _keyToItem[key] = _freqToKeys[<span class="number">1</span>].begin();</span><br><span class="line">        <span class="comment">// 更新目前最小 freq, 因为新添加了一个条目, 所以就是 1</span></span><br><span class="line">        _minFreq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将 key 对应的 freq + 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先缓存一下当前 key 对应的 _freq 和 _value</span></span><br><span class="line">        <span class="keyword">size_t</span> theFreq = _keyToItem[key]-&gt;_freq;</span><br><span class="line">        value_type theValue = _keyToItem[key]-&gt;_value;</span><br><span class="line">        <span class="comment">// 在当前 _freq 所对应的条目列表中删除当前 key 对应的条目并将其添加到 _freq + 1 对应的链表里</span></span><br><span class="line">        _freqToKeys[theFreq].erase(_keyToItem[key]);</span><br><span class="line">        _freqToKeys[theFreq + <span class="number">1</span>].push_front(Node&lt;value_type&gt;(key, theValue, theFreq + <span class="number">1</span>));</span><br><span class="line">        _keyToItem[key] = _freqToKeys[theFreq + <span class="number">1</span>].begin();</span><br><span class="line">        <span class="comment">// 如果当前 _freq 对应的链表为空了, 则删除 _freq 对应的映射</span></span><br><span class="line">        <span class="keyword">if</span>(_freqToKeys[theFreq].empty()) &#123;</span><br><span class="line">            _freqToKeys.erase(theFreq);</span><br><span class="line">            <span class="comment">// 如果删除的这个 key 的 _freq 正好是 _minFreq, 则更新 _minFreq</span></span><br><span class="line">            <span class="keyword">if</span>(theFreq == _minFreq) &#123;</span><br><span class="line">                _minFreq++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree)</a></h5><blockquote><p><code>Trie</code>或者说前缀树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现<code>Trie</code>类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串<code>word</code>。</li><li><code>boolean search(String word)</code> 如果字符串<code>word</code>在前缀树中，返回<code>true</code>（即，在检索之前已经插入）；否则，返回<code>false</code>。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串<code>word</code>的前缀之一为<code>prefix</code>，返回<code>true</code>；否则，返回<code>false</code>。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Trie*&gt; child;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie() : child(<span class="number">26</span>), isEnd(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    ~Trie() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node : child) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node) &#123;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;child[c - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                node-&gt;child[c] = <span class="keyword">new</span> Trie;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;child[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie* node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;child[c - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;child[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295. Find Median from Data Stream"></a><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. Find Median from Data Stream</a></h5><blockquote><p>  The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.</p><ul><li><p>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</p></li><li><p>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</p><p>Implement the <code>MedianFinder</code> class:</p></li><li><p><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</p></li><li><p><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</p></li><li><p><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10-5</code> of the actual answer will be accepted.</p></li></ul><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MedianFinder medianFinder &#x3D; new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    &#x2F;&#x2F; arr &#x3D; [1]</span><br><span class="line">medianFinder.addNum(2);    &#x2F;&#x2F; arr &#x3D; [1, 2]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 1.5 (i.e., (1 + 2) &#x2F; 2)</span><br><span class="line">medianFinder.addNum(3);    &#x2F;&#x2F; arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 2.0</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>-10^5 &lt;= num &lt;= 10^5</code></li><li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li><li>At most <code>5 * 10^4</code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li></ul><p>  <strong>Follow up:</strong></p><ul><li>If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li><li>If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; maxTop;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minTop;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minTop.empty() || minTop.top() &lt;= num)</span><br><span class="line">            minTop.push(num);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            maxTop.push(num);</span><br><span class="line">        <span class="comment">// 放完后 balance</span></span><br><span class="line">        balance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minTop.size() == maxTop.size())</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>(minTop.top()) + <span class="keyword">double</span>(maxTop.top())) * <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">return</span> minTop.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">balance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minTop.size() &lt; maxTop.size())</span><br><span class="line">        &#123;</span><br><span class="line">            minTop.push(maxTop.top());</span><br><span class="line">            maxTop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minTop.size() &gt; maxTop.size() + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxTop.push(minTop.top());</span><br><span class="line">            minTop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化了下逻辑, 减少代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; small;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; large;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 巧妙实现交替放</span></span><br><span class="line">        <span class="keyword">if</span>(small.size() == large.size()) &#123;</span><br><span class="line">            large.push(num);</span><br><span class="line">            small.push(large.top());</span><br><span class="line">            large.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            small.push(num);</span><br><span class="line">            large.push(small.top());</span><br><span class="line">            small.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(small.size() != large.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> small.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>(small.top()) + <span class="keyword">double</span>(large.top())) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="170-两数之和-III-数据结构设计"><a href="#170-两数之和-III-数据结构设计" class="headerlink" title="170. 两数之和 III - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/" target="_blank" rel="noopener">170. 两数之和 III - 数据结构设计</a></h5><blockquote><p>设计一个<code>TwoSum</code>类，拥有两个<code>API</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span></span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">&gt;<span class="comment">// 向数据结构中添加一个数 number</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">&gt;<span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此种解法适用于频繁 add 的情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向数据结构中添加一个数 number</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        mapping[number]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; [first, _] : mapping) &#123;</span><br><span class="line">            <span class="keyword">long</span> second = <span class="keyword">long</span>(value) - first;</span><br><span class="line">            <span class="comment">// 两个相同的数相加等于 value</span></span><br><span class="line">            <span class="keyword">if</span>(second == first &amp;&amp; mapping[first] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不同的两个数相加为 value</span></span><br><span class="line">            <span class="keyword">if</span>(second != first &amp;&amp; mapping.count(second) &amp;&amp; mapping[second] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此种解法适用于频繁 find 的情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; allSum;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向数据结构中添加一个数 number</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录所有可能的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            allSum.insert(num + number);</span><br><span class="line">        &#125;</span><br><span class="line">        nums.push_back(number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allSum.count(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">155. Min Stack</a></h5><blockquote><p>  设计一个支持<code>push</code>，<code>pop</code>，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p><p>  <code>push(x)</code> —— 将元素<code>x</code>推入栈中。<br>  <code>pop()</code> —— 删除栈顶的元素。<br>  <code>top()</code> —— 获取栈顶元素。<br>  <code>getMin()</code> —— 检索栈中的最小元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// &#123;value, value 入栈的时候栈中的最小值&#125;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; _data;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data.empty()) &#123;</span><br><span class="line">            _data.push(&#123;x, x&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        _data.push(&#123;x, min(x, _data.top().second)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.top().first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.top().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="895-Maximum-Frequency-Stack"><a href="#895-Maximum-Frequency-Stack" class="headerlink" title="895. Maximum Frequency Stack"></a><a href="https://leetcode.com/problems/maximum-frequency-stack/" target="_blank" rel="noopener">895. Maximum Frequency Stack</a></h5><blockquote><p>  实现<code>FreqStack</code>，模拟类似栈的数据结构的操作的一个类。</p><p>  <code>FreqStack</code>有两个函数：</p><ul><li><p><code>push(int x)</code>，将整数<code>x</code>推入栈中。</p></li><li><p><code>pop()</code>，它移除并返回栈中出现最频繁的元素。</p><p>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</p><p>提示：</p></li><li><p>对<code>FreqStack.push(int x)</code>的调用中<code>0 &lt;= x &lt;= 10^9</code>。</p></li><li><p>如果栈的元素数目为<code>0</code>，则保证不会调用<code>FreqStack.pop()</code>。</p></li></ul><p>  <strong>示例</strong>：</p>  <img src="8c5d16af06b2bbf15ac75dad30898e99c0b19b83d433b303a4f0fb8ac885387b.jpg" alt="img" style="zoom:50%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">比如执行六次 push 操作后，栈自底向上为 [5,7,5,7,4,5]</span><br><span class="line">然后:</span><br><span class="line">pop() -&gt; 返回 5，因为 5 是出现频率最高的</span><br><span class="line">栈变成 [5,7,5,7,4]</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶</span><br><span class="line">栈变成 [5,7,5,4]</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 5</span><br><span class="line">栈变成 [5,7,4]</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 4</span><br><span class="line">栈变成 [5,7]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> _maxFreq;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; _valToFreq;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&gt; _freqToVals;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FreqStack() : _maxFreq(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        _valToFreq[val]++;</span><br><span class="line">        <span class="keyword">int</span> freq = _valToFreq[val];</span><br><span class="line">        <span class="keyword">if</span>(_maxFreq &lt; freq) &#123;</span><br><span class="line">            _maxFreq = freq;</span><br><span class="line">        &#125;</span><br><span class="line">        _freqToVals[freq].push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = _freqToVals[_maxFreq].top();</span><br><span class="line">        _freqToVals[_maxFreq].pop();</span><br><span class="line">        _valToFreq[res]--;</span><br><span class="line">        <span class="keyword">if</span>(_valToFreq[res] == <span class="number">0</span>) &#123;</span><br><span class="line">            _valToFreq.erase(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(_freqToVals[_maxFreq].empty()) &#123;</span><br><span class="line">            _freqToVals.erase(_maxFreq);</span><br><span class="line">            _maxFreq--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. Implement Queue using Stacks</a></h5><blockquote><p>  请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作：</p><p>  实现<code>MyQueue</code>类：</p><p>  <code>void push(int x)</code>：将元素x推到队列的末尾；<br>  <code>int pop()</code>：从队列的开头移除并返回元素；<br>  <code>int peek()</code>：返回队列开头的元素；<br>  <code>bool empty()</code>：如果队列为空，返回<code>true</code>；否则，返回<code>false</code>。</p>  <img src="2.jpg" alt="img" style="zoom: 33%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如上图, 将两个栈这样放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _front;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _back;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入栈的时候直接放进右边的栈即可</span></span><br><span class="line">        _back.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 出栈的时候从左边出</span></span><br><span class="line">        <span class="comment">// 如果为空, 需要把右边栈的元素搬过来</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) &#123;</span><br><span class="line">            moveData();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬过来之后直接 pop 左边的栈即可</span></span><br><span class="line">        <span class="keyword">int</span> res = _front.top();</span><br><span class="line">        _front.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取的时候和 pop 的情况一样</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) &#123;</span><br><span class="line">            moveData();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只是不出栈, 只取元素</span></span><br><span class="line">        <span class="keyword">return</span> _front.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _front.empty() &amp;&amp; _back.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搬移数据就是简单的将右边栈出栈</span></span><br><span class="line">        <span class="comment">// 左边栈接收元素压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(!_back.empty()) &#123;</span><br><span class="line">            _front.push(move(_back.top()));</span><br><span class="line">            _back.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. Implement Stack using Queues</a></h5><blockquote><p>  请你仅使用两个队列实现一个后入先出的栈，并支持普通队列的全部四种操作。</p><p>  实现<code>MyStack</code>类：</p><p>  <code>void push(int x)</code>：将元素<code>x</code>压入栈顶；<br>  <code>int pop()</code>：移除并返回栈顶元素；<br>  <code>int top()</code>：返回栈顶元素；<br>  <code>bool empty()</code>：如果栈是空的，返回<code>true</code>；否则，返回<code>false</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个复杂点，push 复杂度为 O(1)，pop 复杂度为 O(n)</span></span><br><span class="line"><span class="comment">// 入栈操作很简单, 调用队列的 push 即可</span></span><br><span class="line"><span class="comment">// 出栈麻烦点, 因为队列只能从队头出列, 队头相当于栈的栈底</span></span><br><span class="line"><span class="comment">// 但我们是想 pop 掉队尾元素</span></span><br><span class="line"><span class="comment">// 这时很暴力, 直接把队列中除了队尾之外的所有元素依次出队并依次入队即可</span></span><br><span class="line"><span class="comment">// 这时对头就是原队尾元素了, 再出队就行</span></span><br><span class="line"><span class="comment">// 获取栈顶元素的话, 为了实现 O(1) 复杂度</span></span><br><span class="line"><span class="comment">// 使用一个变量实时记录队尾 (栈顶) 元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line">    <span class="keyword">int</span> _top;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入队的时候要更新栈顶变量</span></span><br><span class="line">        _top = x;</span><br><span class="line">        _queue.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _queue.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            _top = _queue.front();</span><br><span class="line">            _queue.pop();</span><br><span class="line">            _queue.push(_top);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = _queue.front();</span><br><span class="line">        _queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个更简单，只是 push 复杂度为 O(n)，pop 复杂度为 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _queue.size();</span><br><span class="line">        _queue.push(x);</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _queue.push(_queue.front());</span><br><span class="line">            _queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = _queue.front();</span><br><span class="line">        _queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _queue.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="432-All-O-one-Data-Structure-https-leetcode-com-problems-all-oone-data-structure"><a href="#432-All-O-one-Data-Structure-https-leetcode-com-problems-all-oone-data-structure" class="headerlink" title="[432. All O`one Data Structure](https://leetcode.com/problems/all-oone-data-structure/)"></a>[432. All O`one Data Structure](<a href="https://leetcode.com/problems/all-oone-data-structure/" target="_blank" rel="noopener">https://leetcode.com/problems/all-oone-data-structure/</a>)</h5><blockquote><p>  请你实现一个数据结构支持以下操作：</p><ul><li><code>Inc(key)</code> 插入一个新的值为<code>1</code>的<code>key</code>。或者使一个存在的<code>key</code>增加<code>1</code>，保证<code>key</code>不为空字符串。</li><li><code>Dec(key)</code> 如果这个<code>key</code>的值是<code>1</code>，那么把他从数据结构中移除掉。否则使一个存在的<code>key</code>值减<code>1</code>。如果这个<code>key</code>不存在，这个函数不做任何事情。<code>key</code>保证不为空字符串。</li><li><code>GetMaxKey()</code> 返回<code>key</code>中值最大的任意一个。如果没有元素存在，返回一个空字符串<code>&quot;&quot;</code>。</li><li><code>GetMinKey()</code> 返回<code>key</code>中值最小的任意一个。如果没有元素存在，返回一个空字符串<code>&quot;&quot;</code>。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashmap + 双向 list</span></span><br><span class="line"><span class="comment">// 值相同的 key 共用一个 node, keys 用 hashset 存储</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllOne</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span> key_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> value_type;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;key_type, <span class="built_in">list</span>&lt;pair&lt;value_type, <span class="built_in">unordered_set</span>&lt;key_type&gt;&gt;&gt;::iterator&gt; _keyToNode;</span><br><span class="line">    <span class="comment">// 根据 value 的大小从首到尾递增</span></span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;value_type, <span class="built_in">unordered_set</span>&lt;key_type&gt;&gt;&gt; _nodes;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AllOne() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_keyToNode.count(key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = _keyToNode[key];</span><br><span class="line">            <span class="keyword">auto</span> next_it = next(it);</span><br><span class="line">            <span class="keyword">if</span>(next_it == _nodes.end() || next_it-&gt;first != (it-&gt;first + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                _keyToNode[key] = _nodes.insert(next_it, &#123;it-&gt;first + <span class="number">1</span>, &#123;key&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                next_it-&gt;second.insert(key);</span><br><span class="line">                _keyToNode[key] = next_it;</span><br><span class="line">            &#125;</span><br><span class="line">            it-&gt;second.erase(key);</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second.empty())</span><br><span class="line">                _nodes.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(_nodes.empty() || _nodes.begin()-&gt;first != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _keyToNode[key] = _nodes.insert(_nodes.begin(), &#123;<span class="number">1</span>, &#123;key&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _nodes.begin()-&gt;second.insert(key);</span><br><span class="line">                _keyToNode[key] = _nodes.begin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_keyToNode.count(key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = _keyToNode[key];</span><br><span class="line">            <span class="keyword">auto</span> prev_it = prev(it);</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;first &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(it == _nodes.begin() || prev_it-&gt;first != (it-&gt;first - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    _keyToNode[key] = _nodes.insert(it, &#123;it-&gt;first - <span class="number">1</span>, &#123;key&#125;&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    prev_it-&gt;second.insert(key);</span><br><span class="line">                    _keyToNode[key] = prev_it;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _keyToNode.erase(key);</span><br><span class="line">            &#125;</span><br><span class="line">            it-&gt;second.erase(key);</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second.empty())</span><br><span class="line">                _nodes.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getMaxKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _nodes.empty() ? <span class="string">""</span> : *(_nodes.rbegin()-&gt;second.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getMinKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _nodes.empty() ? <span class="string">""</span> : *(_nodes.begin()-&gt;second.begin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a><a href="https://leetcode.com/problems/design-linked-list/" target="_blank" rel="noopener">707. Design Linked List</a></h5><blockquote><p>  设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code>和<code>next</code>。<code>val</code>是当前节点的值，<code>next</code>是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性<code>prev</code>以指示链表中的上一个节点。假设链表中的所有节点都是<code>0 - index</code>的。</p><p>  在链表类中实现这些功能：</p><ul><li><code>get(index)</code>：获取链表中第<code>index</code>个节点的值。如果索引无效，则返回<code>-1</code>。</li><li><code>addAtHead(val)</code>：在链表的第一个元素之前添加一个值为<code>val</code>的节点。插入后，新节点将成为链表的第一个节点。</li><li><code>addAtTail(val)</code>：将值为<code>val</code>的节点追加到链表的最后一个元素。</li><li><code>addAtIndex(index,val)</code>：在链表中的第<code>index</code>个节点之前添加值为<code>val</code>的节点。如果<code>index</code>等于链表的长度，则该节点将附加到链表的末尾。如果<code>index</code>大于链表长度，则不会插入节点。如果<code>index</code>小于<code>0</code>，则在头部插入节点。</li><li><code>deleteAtIndex(index)</code>：如果索引<code>index</code>有效，则删除链表中的第<code>index</code>个节点。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* head_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val_, ListNode* next_ = <span class="literal">nullptr</span>) : val(val_), next(next_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList() : head_(<span class="literal">nullptr</span>), size_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size_)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head_;</span><br><span class="line">        <span class="keyword">while</span>(index--) p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        head_ = <span class="keyword">new</span> ListNode(val, head_);</span><br><span class="line">        size_++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size_ == <span class="number">0</span>) addAtHead(val);</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head_;</span><br><span class="line">        <span class="keyword">int</span> size = size_;</span><br><span class="line">        <span class="keyword">while</span>(--size) p = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        size_++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size_)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index == size_)</span><br><span class="line">        &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = head_;</span><br><span class="line">        ListNode* q = p;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q-&gt;next = <span class="keyword">new</span> ListNode(val, p);</span><br><span class="line">        size_++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size_)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head_ = head_-&gt;next;</span><br><span class="line">            size_--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head_;</span><br><span class="line">        ListNode* q = p;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        size_--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="380-Insert-Delete-GetRandom-O-1-和381-Insert-Delete-GetRandom-O-1-Duplicates-allowed"><a href="#380-Insert-Delete-GetRandom-O-1-和381-Insert-Delete-GetRandom-O-1-Duplicates-allowed" class="headerlink" title="380. Insert Delete GetRandom O(1)和381. Insert Delete GetRandom O(1) - Duplicates allowed"></a><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">380. Insert Delete GetRandom O(1)</a>和<a href="https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">381. Insert Delete GetRandom O(1) - Duplicates allowed</a></h5><blockquote><p><img src="title.jpg" alt="title"></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是集合中元素唯一的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了使得能够以 O(1) 的复杂度随机访问元素, 用于存储数据的结构必须为 vector</span></span><br><span class="line"><span class="comment">// 为了使得删除元素的复杂度为 O(1), 可以通过将被删除元素与末尾元素互换, 再 pop_back()</span></span><br><span class="line"><span class="comment">// 但这必须能够知道每个元素对应的索引</span></span><br><span class="line"><span class="comment">// 所以, 使用一个哈希表来记录 (元素) 和其 (索引)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedSet() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        mapping[val] = nums.size();</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = mapping[val];</span><br><span class="line">        <span class="comment">// 先更新映射, 再操作数据</span></span><br><span class="line">        <span class="comment">// 接下来两条语句的顺序不可颠倒</span></span><br><span class="line">        <span class="comment">// 防止待删除的值就位于尾元素, 即 val == nums.back()</span></span><br><span class="line">        mapping[nums.back()] = i;</span><br><span class="line">        mapping.erase(val);</span><br><span class="line">        </span><br><span class="line">        swap(nums[i], nums.back());</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % nums.size();</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是集合中元素允许重复的情况</span></span><br><span class="line"><span class="comment">// 由于要记录所有重复元素的索引, 就就不能采用 1 对 1 映射了</span></span><br><span class="line"><span class="comment">// 需要采用 1 对 多 映射, 所以使用一个 unordered_map&lt;int, unordered_set&lt;int&gt;&gt;</span></span><br><span class="line"><span class="comment">// 为什么映射到的是一个 unordered_set&lt;int&gt; 而不是 vector&lt;int&gt; 呢?</span></span><br><span class="line"><span class="comment">// 原因是, 交换后, 需要 O(1) 删除末尾元素所对应的索引, 而这个索引值不一定存储在最后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; mapping;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedCollection() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) &gt; <span class="number">0</span>) res = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        mapping[val].insert(nums.size());</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = *(mapping[val].begin()); <span class="comment">// 这个 i 相当于随机选的其中一个</span></span><br><span class="line">        <span class="keyword">if</span>(val == nums.back())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果要删除的值正好位于末元素的话</span></span><br><span class="line">            <span class="comment">// 直接在索引集合中删掉索引即可</span></span><br><span class="line">            <span class="comment">// 这是防止执行 else 中的 mapping[nums.back()].insert(i); 语句</span></span><br><span class="line">            <span class="comment">// 插入另一个和尾元素值相等的位于其他位置的索引</span></span><br><span class="line">            mapping[nums.back()].erase(nums.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 比如说数组中元素为 [2, 2, 2], 索引 set 中为 [0, 1, 2]</span></span><br><span class="line">            <span class="comment">// 现在删除 val == 2, 此时 i 为 0, nums.back() == val, 执行下面三条语句</span></span><br><span class="line">            <span class="comment">// 语句 1 --&gt; set 变为 [0, 1]</span></span><br><span class="line">            <span class="comment">// 语句 2 --&gt; set 变为 [0, 0, 1] --&gt; [0, 1]</span></span><br><span class="line">            <span class="comment">// 语句 3 --&gt; set 变为 [1]</span></span><br><span class="line">            <span class="comment">// 但显然预期的结果为 [0, 1]</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则, 需要删除末元素原本对应的索引, 插入新索引</span></span><br><span class="line">        mapping[nums.back()].erase(nums.size() - <span class="number">1</span>);</span><br><span class="line">        mapping[nums.back()].insert(i);</span><br><span class="line">            <span class="comment">// 删掉待删除元素的索引之一</span></span><br><span class="line">            mapping[val].erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果待删除元素只有一个, 还要删除整个映射项</span></span><br><span class="line">        <span class="keyword">if</span>(mapping[val].empty()) mapping.erase(val);</span><br><span class="line">        </span><br><span class="line">        swap(nums[i], nums.back());</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % nums.size();</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h5 id="1114-按序打印"><a href="#1114-按序打印" class="headerlink" title="1114. 按序打印"></a><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">1114. 按序打印</a></h5><blockquote><p>  三个不同的线程<code>A</code>、<code>B</code>、<code>C</code>将会共用一个<code>Foo</code>实例。</p><ul><li><p>一个将会调用<code>first()</code>方法</p></li><li><p>一个将会调用<code>second()</code>方法</p></li><li><p>还有一个将会调用<code>third()</code>方法</p><p>请设计修改程序，以确保<code>second()</code>方法在<code>first()</code>方法之后被执行，<code>third()</code>方法在<code>second()</code>方法之后被执行。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">    mutex _mutex;</span><br><span class="line">    condition_variable _cond2b;</span><br><span class="line">    condition_variable _cond2c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() : counter(<span class="number">1</span>), _mutex(), _cond2b(), _cond2c() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        counter = <span class="number">2</span>;</span><br><span class="line">        _cond2b.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        _cond2b.wait(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;counter == <span class="number">2</span>; &#125;);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        counter = <span class="number">3</span>;</span><br><span class="line">        _cond2c.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        _cond2c.wait(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;counter == <span class="number">3</span>; &#125;);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"third"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">A</span><span class="params">(bind(Foo::first, &amp;foo))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">B</span><span class="params">(bind(Foo::second, &amp;foo))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">C</span><span class="params">(bind(Foo::third, &amp;foo))</span></span>;</span><br><span class="line">    A.join();</span><br><span class="line">    B.join();</span><br><span class="line">    C.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1115-交替打印FooBar"><a href="#1115-交替打印FooBar" class="headerlink" title="1115. 交替打印FooBar"></a><a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">1115. 交替打印FooBar</a></h5><blockquote><p>  两个不同的线程将会共用一个<code>FooBar</code>实例。其中一个线程将会调用<code>foo()</code>方法，另一个线程将会调用<code>bar()</code>方法。</p><p>  请设计修改程序，以确保<code>&quot;foobar&quot;</code>被输出<code>n</code>次。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用互斥锁 + 两个条件变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">bool</span> counter;</span><br><span class="line">    mutex _mutex;</span><br><span class="line">    condition_variable _cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooBar(<span class="keyword">int</span> n) : counter(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            _cond.wait(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;counter; &#125;);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"foo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            counter = <span class="literal">false</span>;</span><br><span class="line">            _cond.notify_one();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            _cond.wait(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;counter; &#125;);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"bar"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            counter = <span class="literal">true</span>;</span><br><span class="line">            _cond.notify_one();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">FooBar <span class="title">foobar</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">foo</span><span class="params">(bind(FooBar::foo, &amp;foobar))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">bar</span><span class="params">(bind(FooBar::bar, &amp;foobar))</span></span>;</span><br><span class="line">    foo.join();</span><br><span class="line">    bar.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1116-打印零与奇偶数"><a href="#1116-打印零与奇偶数" class="headerlink" title="1116. 打印零与奇偶数"></a><a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">1116. 打印零与奇偶数</a></h5><blockquote><p>  相同的一个<code>ZeroEvenOdd</code>类实例将会传递给三个不同的线程：</p><ul><li><p>线程<code>A</code>将调用<code>zero()</code>，它只输出<code>0</code>。</p></li><li><p>线程<code>B</code>将调用<code>even()</code>，它只输出偶数。</p></li><li><p>线程<code>C</code>将调用<code>odd(</code>)，它只输出奇数。</p><p>每个线程都有一个<code>printNumber</code>方法来输出一个整数。请修改给出的代码以输出整数序列 <code>010203040506...</code>，其中序列的长度必须为<code>2n</code>。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    mutex lockZero;</span><br><span class="line">    mutex lockOdd;</span><br><span class="line">    mutex lockEven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZeroEvenOdd(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        lockOdd.lock();</span><br><span class="line">        lockEven.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lockZero.lock();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                lockOdd.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lockEven.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">even</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            lockEven.lock();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            lockZero.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">odd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            lockOdd.lock();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            lockZero.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ZeroEvenOdd <span class="title">zero</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(bind(ZeroEvenOdd::zero, &amp;zero))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(bind(ZeroEvenOdd::even, &amp;zero))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(bind(ZeroEvenOdd::odd, &amp;zero))</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1188-设计有限阻塞队列"><a href="#1188-设计有限阻塞队列" class="headerlink" title="1188. 设计有限阻塞队列"></a><a href="https://leetcode-cn.com/problems/design-bounded-blocking-queue/" target="_blank" rel="noopener">1188. 设计有限阻塞队列</a></h5><blockquote><p>  实现一个拥有如下方法的线程安全有限阻塞队列：</p><ul><li><p><code>BoundedBlockingQueue(int capacity)</code>构造方法初始化队列，其中<code>capacity</code>代表队列长度上限。</p></li><li><p><code>void enqueue(int element)</code>在队首增加一个<code>element</code>。如果队列满，调用线程被阻塞直到队列非满。</p></li><li><p><code>int dequeue()</code>返回队尾元素并从队列中将其删除。如果队列为空，调用线程被阻塞直到队列非空。</p></li><li><p><code>int size()</code>返回当前队列元素个数。</p><p>你的实现将会被多线程同时访问进行测试。每一个线程要么是一个只调用<code>enqueue</code>方法的生产者线程，要么是一个只调用<code>dequeue</code>方法的消费者线程。<code>size</code>方法将会在每一个测试用例之后进行调用。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁 + 两个条件变量 + 使用 notify_one()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _capacity;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">    mutex _mutex;</span><br><span class="line">    condition_variable _notEmpty;</span><br><span class="line">    condition_variable _notFull;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BoundedBlockingQueue(<span class="keyword">int</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(_data.size() &gt;= _capacity) &#123;</span><br><span class="line">            _notFull.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        _data.push(element);</span><br><span class="line">        _notEmpty.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(_data.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            _notEmpty.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = _data.front();</span><br><span class="line">        _data.pop();</span><br><span class="line">        _notFull.notify_one();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> _data.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁 + 一个条件变量 + 使用 notify_all()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _capacity;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">    mutex _mutex;</span><br><span class="line">    condition_variable _cond;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BoundedBlockingQueue(<span class="keyword">int</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(_data.size() &gt;= _capacity) &#123;</span><br><span class="line">            _cond.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        _data.push(element);</span><br><span class="line">        _cond.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(_data.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            _cond.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = _data.front();</span><br><span class="line">        _data.pop();</span><br><span class="line">        _cond.notify_all();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> _data.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="1226-哲学家进餐"><a href="#1226-哲学家进餐" class="headerlink" title="1226. 哲学家进餐"></a><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">1226. 哲学家进餐</a></h5><blockquote><p>  <code>5</code>个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（<code>5</code> 个哲学家，<code>5</code>根叉子）</p><p>  所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p><p>  假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p><p>  设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>  <img src="an_illustration_of_the_dining_philosophers_problem.png" alt="an_illustration_of_the_dining_philosophers_problem" style="zoom:50%;" /><p>  哲学家从<code>0</code>到<code>4</code>按顺时针编号。请实现函数<code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code>：</p><ul><li><p><code>philosopher</code>哲学家的编号。</p></li><li><p><code>pickLeftFork</code>和<code>pickRightFork</code>表示拿起左边或右边的叉子。</p></li><li><p><code>eat</code>表示吃面。</p></li><li><p><code>putLeftFork</code>和<code>putRightFork</code>表示放下左边或右边的叉子。</p></li><li><p>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</p><p>给你<code>5</code>个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制哲学家必须同时拿起左右的叉子后才能就餐</span></span><br><span class="line"><span class="comment">// 否则，不允许持有任何一只叉子</span></span><br><span class="line"><span class="comment">// 使用 C++11 的 lock 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">array</span>&lt;mutex, 5&gt; mutexs;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiningPhilosophers() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = philosopher;</span><br><span class="line">        <span class="keyword">int</span> right = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        lock(mutexs[left], mutexs[right]);</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock_left</span><span class="params">(mutexs[left], adopt_lock)</span></span>;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock_right</span><span class="params">(mutexs[right], adopt_lock)</span></span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ID: "</span> &lt;&lt; philosopher &lt;&lt; <span class="string">" eatting"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiningPhilosophers dining;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t5</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">4</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">    t5.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个额外的 互斥锁 充当门禁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">array</span>&lt;mutex, 5&gt; mutexs;</span><br><span class="line">    mutex door;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiningPhilosophers() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = philosopher;</span><br><span class="line">        <span class="keyword">int</span> right = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        door.lock();</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock_left</span><span class="params">(mutexs[left])</span></span>;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock_right</span><span class="params">(mutexs[right])</span></span>;</span><br><span class="line">        door.unlock();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ID "</span> &lt;&lt; philosopher &lt;&lt; <span class="string">" is eatting"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiningPhilosophers dining;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t5</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">4</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">    t5.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Undetermined</code></p><h5 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a><a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">343. Integer Break</a></h5><blockquote><p>给定一个整数<code>n</code>，将其分解为<code>k</code>个正整数之和，其中<code>k &gt;= 2</code>，并使这些整数的乘积最大化。返回你可以获得的最大乘积。</p><p>说明: 你可以假设<code>n</code>不小于<code>2</code>且不大于<code>58</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 枚举划分出第一段的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 划分出第一段之后，剩下部分有两种选择</span></span><br><span class="line">            <span class="comment">// 不划分的话长度为 j * (i - j)</span></span><br><span class="line">            <span class="comment">// 划分的话长度为 j * dp[i - j]</span></span><br><span class="line">            <span class="comment">// 两者取较大者</span></span><br><span class="line">            dp[i] = max(&#123;dp[i], j * (i - j), j * dp[i - j]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心算法</span></span><br><span class="line"><span class="comment">// 使用均值不等式可以证明当这 k 个整数相等时，乘积最大</span></span><br><span class="line"><span class="comment">// 使用求导求极大值可以得出 k = 3 时乘积最大 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * <span class="built_in">pow</span>(<span class="number">3</span>, a - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">pow</span>(<span class="number">3</span>, a - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="509-Fibonacci-Number"><a href="#509-Fibonacci-Number" class="headerlink" title="509. Fibonacci Number"></a><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. Fibonacci Number</a></h5><blockquote><p>  斐波那契数，通常用<code>F(n)</code>表示，形成的序列称为斐波那契数列 。该数列由<code>0</code>和<code>1</code>开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>  <code>F(0) = 0，F(1) = 1</code><br>  <code>F(n) = F(n - 1) + F(n - 2)</code>，其中<code>n &gt; 1</code></p><p>  给你<code>n</code>，请计算<code>F(n)</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>; <span class="comment">// 防止溢出</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_0 + dp_1;</span><br><span class="line">        dp_0 = dp_1;</span><br><span class="line">        dp_1 = temp % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归 + 备忘录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> recur = [&amp;](<span class="keyword">auto</span>&amp;&amp; recur, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[n] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[n] = recur(recur, n - <span class="number">1</span>) + recur(recur, n - <span class="number">2</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> recur(recur, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/shenmingxueIT/article/details/117332922?spm=1001.2014.3001.5501" target="_blank" rel="noopener">从小白到大神都会遇到的经典面试题 —— 斐波那契数列_0 error(s)-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵幂次方</span></span><br></pre></td></tr></table></figure><h5 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h5><blockquote><p>  实现<code>pow(x, n)</code>，即计算<code>x</code>的<code>n</code>次幂函数（即 x^n^ ）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> myPow(<span class="number">1.0</span> / x, -n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * myPow(x, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myPow(x * x, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1.0</span> / x;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="372-Super-Pow"><a href="#372-Super-Pow" class="headerlink" title="372. Super Pow"></a><a href="https://leetcode.com/problems/super-pow/" target="_blank" rel="noopener">372. Super Pow</a></h5><blockquote><p>  你的任务是计算 a^b^ 对<code>1337</code>取模，<code>a</code>是一个正整数，<code>b</code>是一个非常大的正整数且会以数组形式给出。</p>  <img src="formu1.png" alt="img" style="zoom: 67%;" /><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= a &lt;= 231 - 1</code></li><li><code>1 &lt;= b.length &lt;= 2000</code></li><li><code>0 &lt;= b[i] &lt;= 9</code></li><li><code>b</code> doesn’t contain leading zeros.</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 2, b &#x3D; [1,0]</span><br><span class="line">Output: 1024</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 1, b &#x3D; [4,3,3,8,5,2]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 2147483647, b &#x3D; [2,0,0]</span><br><span class="line">Output: 1198</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模运算技巧 (a * b) % n = (a % n) * (b % n) % n</span></span><br><span class="line"><span class="comment">// 就是说对乘积的结果求模, 等价于先对每个因子都求模, 再对因子求模的结果的乘积再求模</span></span><br><span class="line"><span class="comment">// 可防止 a * b 过大导致溢出</span></span><br><span class="line"><span class="comment">// 这题主要是学会如何处理指数部分以数组的形式给出</span></span><br><span class="line"><span class="comment">// 处理办法就是找到规律, 利用递归将大问题分解为一个个子问题</span></span><br><span class="line"><span class="comment">// 规律看上面给出的图片</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> back = b.back();</span><br><span class="line">    b.pop_back();</span><br><span class="line">    <span class="keyword">return</span> mypow(a, back) * mypow(superPow(a, b), <span class="number">10</span>) % <span class="number">1337</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这题比较特殊, 因子都相同, 就是 a</span></span><br><span class="line">    <span class="comment">// 对每一个因子求模</span></span><br><span class="line">    a %= <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求每个因子求模结果的乘积</span></span><br><span class="line">        res *= a;</span><br><span class="line">        <span class="comment">// 将乘积结果再求模</span></span><br><span class="line">        res %= <span class="number">1337</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求幂运算可通过判断 n 的奇偶性大幅度优化效率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    a %= <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a * mypow(a, n - <span class="number">1</span>) % <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">return</span> mypow(a * a % <span class="number">1337</span>, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="779-K-th-Symbol-in-Grammar"><a href="#779-K-th-Symbol-in-Grammar" class="headerlink" title="779. K-th Symbol in Grammar"></a><a href="https://leetcode.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">779. K-th Symbol in Grammar</a></h5><blockquote><p>  在第一行我们写上一个<code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p><p>  给定行数<code>N</code>和序数<code>K</code>，返回第<code>N</code>行中第<code>K</code>个字符。</p><p>  <strong>Note:</strong></p><ol><li><p><code>N</code> will be an integer in the range <code>[1, 30]</code>.</p></li><li><p><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">Input: N &#x3D; 1, K &#x3D; 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N &#x3D; 2, K &#x3D; 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N &#x3D; 2, K &#x3D; 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: N &#x3D; 4, K &#x3D; 5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row 1: 0</span><br><span class="line">row 2: 01</span><br><span class="line">row 3: 0110</span><br><span class="line">row 4: 01101001</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(K == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">2</span>, N - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(K &gt; n) <span class="keyword">return</span> <span class="number">1</span> - kthGrammar(N - <span class="number">1</span>, K - n);</span><br><span class="line">    <span class="keyword">return</span> kthGrammar(N - <span class="number">1</span>, K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之字符串</title>
      <link href="/LZqUbK3Z1CXKja4I/"/>
      <url>/LZqUbK3Z1CXKja4I/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>3</code>部分——字符串。这里把有代表性的题目发出来，共计<code>21</code>道。字符串的问题杂且难，这一块，面试时碰到字符串问题时只能随机应变，没有固定的套路。</p><p><code>leetcode</code>刷题系列其它文章组织如下：</p><p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p><p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p><p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p><a id="more"></a><h5 id="880-Decoded-String-at-Index"><a href="#880-Decoded-String-at-Index" class="headerlink" title="880. Decoded String at Index"></a><a href="https://leetcode.com/problems/decoded-string-at-index/" target="_blank" rel="noopener">880. Decoded String at Index</a></h5><blockquote><p>  给定一个编码字符串<code>S</code>。请你找出解码字符串并将其写入磁带。解码时，从编码字符串中每次读取一个字符 ，并采取以下步骤：</p><ul><li>如果所读的字符是字母，则将该字母写在磁带上。</li><li>如果所读的字符是数字（例如<code>d</code>），则整个当前磁带总共会被重复写<code>d - 1</code>次。</li><li>现在，对于给定的编码字符串<code>S</code>和索引<code>K</code>，查找并返回解码字符串中的第<code>K</code>个字母。</li></ul><p>  <strong>Constraints:</strong></p><ul><li><code>2 &lt;= S.length &lt;= 100</code></li><li><code>S</code> will only contain lowercase letters and digits <code>2</code> through <code>9</code>.</li><li><code>S</code> starts with a letter.</li><li><code>1 &lt;= K &lt;= 10^9</code></li><li>It’s guaranteed that <code>K</code> is less than or equal to the length of the decoded string.</li><li>The decoded string is guaranteed to have less than <code>2^63</code> letters.</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;leet2code3&quot;, K &#x3D; 10</span><br><span class="line">Output: &quot;o&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;.</span><br><span class="line">The 10th letter in the string is &quot;o&quot;.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;ha22&quot;, K &#x3D; 5</span><br><span class="line">Output: &quot;h&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The decoded string is &quot;hahahaha&quot;.  The 5th letter is &quot;h&quot;.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般来说, 当解码的字符串等于某个长度为 size 的单词重复一定次数</span></span><br><span class="line"><span class="comment">// 例如 apple(size = 5) 组合重复 6 次时</span></span><br><span class="line"><span class="comment">// 第 k == 24 个的结果与第 k % size == 4 个的结果相同</span></span><br><span class="line"><span class="comment">// 根据这个思路来求解问题</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeAtIndex</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">long</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 先计算解码后的总字符串的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">            sz++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sz *= s[i] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从后向前做逆向搜索</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 如果当前字符是字母, 那么它必然在解码后的最后位置</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">            <span class="comment">// 如果这时就是第 k 个字符的话, 直接返回答案</span></span><br><span class="line">            <span class="keyword">if</span>(k % sz == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">string</span>(<span class="number">1</span>, s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解码字符串的长度减 1</span></span><br><span class="line">            sz--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前字符是数字</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此字符之前的解码字符串的长度就可以计算出来</span></span><br><span class="line">            sz /= s[i] - <span class="string">'0'</span>;</span><br><span class="line">            k %= sz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="87-Scramble-String"><a href="#87-Scramble-String" class="headerlink" title="87. Scramble String"></a><a href="https://leetcode.com/problems/scramble-string/" target="_blank" rel="noopener">87. Scramble String</a></h5><blockquote><p>  使用下面描述的算法可以扰乱字符串<code>s</code>得到字符串<code>t</code>：</p><ol><li><p>如果字符串的长度为<code>1</code>，算法停止</p></li><li><p>如果字符串的长度<code>&gt; 1</code>，执行下述步骤：</p><ul><li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串<code>s</code>，则可以将其分成两个子字符串<code>x</code>和<code>y</code>，且满足<code>s = x + y</code>。</li><li>随机决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code>可能是<code>s = x + y</code>或者<code>s = y + x</code>。</li><li>在<code>x</code>和<code>y</code>这两个子字符串上继续从步骤<code>1</code>开始递归执行此算法。</li></ul><p>给你两个长度相等的字符串<code>s1</code>和<code>s2</code>，判断<code>s2</code>是否是<code>s1</code>的扰乱字符串。如果是，返回<code>true</code>；否则，返回<code>false</code>。</p></li></ol><p>  <strong>示例</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;great&quot;, s2 &#x3D; &quot;rgeat&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s1 上可能发生的一种情形是：</span><br><span class="line">&quot;great&quot; --&gt; &quot;gr&#x2F;eat&quot; 在一个随机下标处分割得到两个子字符串</span><br><span class="line">&quot;gr&#x2F;eat&quot; --&gt; &quot;gr&#x2F;eat&quot; 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="line">&quot;gr&#x2F;eat&quot; --&gt; &quot;g&#x2F;r &#x2F; e&#x2F;at&quot; 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割</span><br><span class="line">&quot;g&#x2F;r &#x2F; e&#x2F;at&quot; --&gt; &quot;r&#x2F;g &#x2F; e&#x2F;at&quot; 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」</span><br><span class="line">&quot;r&#x2F;g &#x2F; e&#x2F;at&quot; --&gt; &quot;r&#x2F;g &#x2F; e&#x2F; a&#x2F;t&quot; 继续递归执行此算法，将 &quot;at&quot; 分割得到 &quot;a&#x2F;t&quot;</span><br><span class="line">&quot;r&#x2F;g &#x2F; e&#x2F; a&#x2F;t&quot; --&gt; &quot;r&#x2F;g &#x2F; e&#x2F; a&#x2F;t&quot; 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="line">算法终止，结果字符串和 s2 相同，都是 &quot;rgeat&quot;</span><br><span class="line">这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于递归过程中会出现许多的重复参数</span></span><br><span class="line"><span class="comment">// 使用一个哈希集合来记忆化递归过程</span></span><br><span class="line"><span class="comment">// 由于函数参数是两个字符串, 可将它们拼接在一起做为 key</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(memo.count(s1 + s2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s1 == s2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s1.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断字符对应个数是否相等</span></span><br><span class="line">    <span class="comment">// 先排序再判断</span></span><br><span class="line">    <span class="built_in">string</span> s1Copy = s1, s2Copy = s2;</span><br><span class="line">    sort(s1Copy.begin(), s1Copy.end());</span><br><span class="line">    sort(s2Copy.begin(), s2Copy.end());</span><br><span class="line">    <span class="keyword">if</span>(s1Copy != s2Copy) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz = s1.size();</span><br><span class="line">    <span class="comment">// s1 = L(s1) + R(s1), s2 = L(s2) + R(s2)</span></span><br><span class="line">    <span class="comment">// 两种情况, 看 L(s1) 是否可以转化为 L(s2) 以及 R(s1) 是否可以转化为 R(s2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sz; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>, i), s2.substr(<span class="number">0</span>, i)) &amp;&amp; isScramble(s1.substr(i, sz - i), s2.substr(i, sz - i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(isScramble(s1.substr(i, sz - i), s2.substr(<span class="number">0</span>, sz - i)) &amp;&amp; isScramble(s1.substr(<span class="number">0</span>, i), s2.substr(sz - i, i)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结果</span></span><br><span class="line">    memo.insert(s1 + s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">28. Implement strStr()</a></h5><blockquote><p>  实现<code>strStr()</code>函数。给你两个字符串<code>haystack</code>和<code>needle</code>，请你在<code>haystack</code>字符串中找出<code>needle</code>字符串出现的第一个位置（下标从<code>0</code>开始）。如果不存在，则返回<code>-1</code> 。当<code>needle</code>是空字符串时，返回<code>0</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kmp 算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = haystack.size();</span><br><span class="line">    <span class="keyword">int</span> m = needle.size();</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dfa</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">128</span>))</span></span>;</span><br><span class="line">    buildStateTransition(needle, dfa);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        j = dfa[j][haystack[i]];</span><br><span class="line">        <span class="keyword">if</span>(j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span> - m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildStateTransition</span><span class="params">(<span class="built_in">string</span>&amp; needle, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dfa)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dfa[<span class="number">0</span>][needle[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; needle.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">128</span>; c++) &#123;</span><br><span class="line">            dfa[i][c] = dfa[x][c];</span><br><span class="line">        &#125;</span><br><span class="line">        dfa[i][needle[i]] = i + <span class="number">1</span>;</span><br><span class="line">        x = dfa[x][needle[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sunday 算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = haystack.size();</span><br><span class="line">    <span class="keyword">int</span> m = needle.size();</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; shift;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        shift[needle[i]] = m - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pos_n = <span class="number">0</span>, pos_m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos_n &lt;= n - m) &#123;</span><br><span class="line">        pos_m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(haystack[pos_n + pos_m] == needle[pos_m]) &#123;</span><br><span class="line">            pos_m++;</span><br><span class="line">            <span class="keyword">if</span>(pos_m == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos_n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(shift.count(haystack[pos_n + m])) &#123;</span><br><span class="line">            pos_n += shift[haystack[pos_n + m]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pos_n += m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="187-Repeated-DNA-Sequences"><a href="#187-Repeated-DNA-Sequences" class="headerlink" title="187. Repeated DNA Sequences"></a><a href="https://leetcode.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">187. Repeated DNA Sequences</a></h5><blockquote><p>  所有<code>DNA</code>都由一系列缩写为<code>&#39;A&#39;</code>，<code>&#39;C&#39;</code>，<code>&#39;G&#39;</code>和<code>&#39;T&#39;</code>的核苷酸组成，例如：<code>&quot;ACGAATTCCG&quot;</code>。在研究<code>DNA</code>时，识别<code>DNA</code>中的重复序列有时会对研究非常有帮助。</p><p>  编写一个函数来找出所有目标子串，目标子串的长度为<code>10</code>，且在<code>DNA</code>字符串<code>s</code>中出现次数超过一次。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br><span class="line">Output: [&quot;AAAAACCCCC&quot;,&quot;CCCCCAAAAA&quot;]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;AAAAAAAAAAAAA&quot;</span><br><span class="line">Output: [&quot;AAAAAAAAAA&quot;]</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> is either <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, or <code>&#39;T&#39;</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口切片 + 哈希集合 切片复杂度为 O(k)</span></span><br><span class="line"><span class="comment">// 总 O(k(n - k))</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = s.size();</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">string</span> subStr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size - k; i++) &#123;</span><br><span class="line">        subStr = s.substr(i, k);</span><br><span class="line">        <span class="keyword">if</span>(visited.count(subStr)) &#123;</span><br><span class="line">            output.insert(subStr);</span><br><span class="line">        &#125;</span><br><span class="line">        visited.insert(subStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> str : output) &#123;</span><br><span class="line">        res.push_back(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Rabin-Karp 字符串编码介绍</span></span><br><span class="line"><span class="comment">由于我们需要频繁判断两个字串是否相同, 直接切片比较的话, 复杂度和子串的长度成正比</span></span><br><span class="line"><span class="comment">这样, 我们将字符串中的字符(全小写)映射到 0-25 的数字</span></span><br><span class="line"><span class="comment">给定窗口长度为 k 的字符串, 窗口内的字符序列可以表示成一个 base = 26 进制的数字序列</span></span><br><span class="line"><span class="comment">比如 将 k = 4 的字符串 c1c2c3c4 转换为数字串 a1a2a3a4, 它对应的十进制值为</span></span><br><span class="line"><span class="comment">key = a1*26^3 + a2*26^2 + a3*26^1 + a4*26</span></span><br><span class="line"><span class="comment">= a1*base^(k-1) + a2*base^(k-2) + a3*base^(k-3) + a4*base</span></span><br><span class="line"><span class="comment">然后将 key 做哈希表的键, 这样我们比较 是否有相同的 key 就可以判断出是否有相同的串</span></span><br><span class="line"><span class="comment">为什么说这样快呢? 对于窗口 a1a2a3a4 -&gt; a2a3a4a5</span></span><br><span class="line"><span class="comment">key = ((a1*base^(k-1) + a2*base^(k-2) + a3*base^(k-3) + a4*base) - a1*base^(k-1))*base + a5*base</span></span><br><span class="line"><span class="comment">= (key - a1*base^(k-1))*base + a5*base</span></span><br><span class="line"><span class="comment">= key*base - a1*base^k + a5*base</span></span><br><span class="line"><span class="comment">可以在 O(1) 时间算出新窗口的 key, 如果直接从字符串中切片的话需要 O(k) 时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口切片 + Rabin-Karp 字符串编码使得切片复杂度为 O(1)</span></span><br><span class="line"><span class="comment">// 总 O(n - k)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = s.size();</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; encode;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将这四个字符分别映射为 0 1 2 3, 所以 base 为 4</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'G'</span>, <span class="string">'T'</span>&#125;) &#123;</span><br><span class="line">        encode[c] = i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(s.size())</span></span>;</span><br><span class="line">    <span class="comment">// 将原字符串中的字符装成数字序列</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        nums[i] = encode[s[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">4</span>, k = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> baseK = <span class="built_in">pow</span>(base, k);</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算第一个窗口的 key</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        key = key * base + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">    <span class="comment">// 将第一个窗口的 key 先放进去表示已经访问</span></span><br><span class="line">    visited.insert(key);</span><br><span class="line">    <span class="comment">// 下面开始滑动窗口</span></span><br><span class="line">    <span class="comment">// i = 10;</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; size) &#123;</span><br><span class="line">        <span class="comment">// 计算新窗口的 key</span></span><br><span class="line">        key = key * base - nums[i - k] * baseK + nums[i];</span><br><span class="line">        <span class="comment">// 如果已经存在, 表示有重复的串</span></span><br><span class="line">        <span class="comment">// 将串取出</span></span><br><span class="line">        <span class="keyword">if</span>(visited.count(key)) &#123;</span><br><span class="line">            output.insert(s.substr(i - k + <span class="number">1</span>, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新窗口也已访问</span></span><br><span class="line">        visited.insert(key);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> str : output) &#123;</span><br><span class="line">        res.push_back(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1044-Longest-Duplicate-Substring"><a href="#1044-Longest-Duplicate-Substring" class="headerlink" title="1044. Longest Duplicate Substring"></a><a href="https://leetcode.com/problems/longest-duplicate-substring/" target="_blank" rel="noopener">1044. Longest Duplicate Substring</a></h5><blockquote><p>  给出一个字符串<code>S</code>，考虑其所有重复子串（<code>S</code>的连续子串，出现两次或多次，可能会有重叠）。</p><p>  返回任何具有最长可能长度的重复子串。（如果<code>S</code>不含重复子串，那么答案为<code>&quot;&quot;</code>。）</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;banana&quot;</span><br><span class="line">Output: &quot;ana&quot;</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcd&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>2 &lt;= s.length &lt;= 3 * 104</code></li><li><code>s</code> consists of lowercase English letters.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口切片 + Rabin-Karp 字符串编码使得切片复杂度为 O(1)</span></span><br><span class="line"><span class="comment">// 由于我们希望找到一个最长的重复串, 最长莫不过 s.size()</span></span><br><span class="line"><span class="comment">// 所以我们每次固定窗口的大小为 k, k 范围时[0, s.size())</span></span><br><span class="line"><span class="comment">// 在这个区间可以使用 二分搜索 提高效率</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestDupSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; digit;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++)</span><br><span class="line">        digit[c] = c - <span class="string">'a'</span>;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="comment">// 外循环二分搜索, 内循环滑动窗口</span></span><br><span class="line">    <span class="keyword">int</span> minK = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxK = (<span class="keyword">int</span>)s.size();</span><br><span class="line">    <span class="keyword">while</span>(minK &lt; maxK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> subStr;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span>&gt; visited;</span><br><span class="line">        <span class="keyword">int</span> k = minK + (maxK - minK &gt;&gt; <span class="number">1</span>); <span class="comment">// 窗口大小</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Rabin-Karp 编码算法 */</span></span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">long</span> baseK = <span class="built_in">pow</span>(base, k);</span><br><span class="line">        <span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算第一个窗口的 key</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; k; i++)</span><br><span class="line">            key = key * base + digit[s[i]];</span><br><span class="line">        visited.insert(key);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            key = key * base - (digit[s[i - k]] * baseK) + digit[s[i]];</span><br><span class="line">            <span class="keyword">if</span>(visited.count(key))</span><br><span class="line">            &#123;</span><br><span class="line">                subStr = s.substr(i - k + <span class="number">1</span>, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.insert(key);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Rabin-Karp 编码算法 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!subStr.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            minK = k + <span class="number">1</span>;</span><br><span class="line">            res = subStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            maxK = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="316-Remove-Duplicate-Letters"><a href="#316-Remove-Duplicate-Letters" class="headerlink" title="316. Remove Duplicate Letters"></a><a href="https://leetcode.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. Remove Duplicate Letters</a></h5><blockquote><p>  给你一个字符串<code>s</code>，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证<strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bcabc&quot;</span><br><span class="line">Output: &quot;abc&quot;</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbacdcbc&quot;</span><br><span class="line">Output: &quot;acdb&quot;</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of lowercase English letters.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似单调栈的技巧</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; counter;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s) counter[c]++;</span><br><span class="line">    <span class="comment">// 记录已经在栈中的字符, 栈中的字符唯一</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; existed;</span><br><span class="line">    <span class="comment">// 把字符串当栈使用</span></span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="comment">// 顺序访问字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每访问一个字符, 相应数量减一</span></span><br><span class="line">        counter[c]--;</span><br><span class="line">        <span class="comment">// 如果该字符已经在栈中了, 直接删除即可</span></span><br><span class="line">        <span class="keyword">if</span>(existed.count(c)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 否则, 如果字典序比栈顶元素小并且在后边还有栈顶的字符, 删除栈顶字符</span></span><br><span class="line">        <span class="comment">// 因为反正后面还会遇到的嘛</span></span><br><span class="line">        <span class="keyword">while</span>(!res.empty() &amp;&amp; res.back() &gt; c &amp;&amp; counter[res.back()] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            existed.erase(res.back());</span><br><span class="line">            res.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前字符入栈</span></span><br><span class="line">        res.push_back(c);</span><br><span class="line">        existed.insert(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1839-Longest-Substring-Of-All-Vowels-in-Order"><a href="#1839-Longest-Substring-Of-All-Vowels-in-Order" class="headerlink" title="1839. Longest Substring Of All Vowels in Order"></a><a href="https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/" target="_blank" rel="noopener">1839. Longest Substring Of All Vowels in Order</a></h5><blockquote><p>  当一个字符串满足如下条件时，我们称它是美丽的 ：</p><p>  所有<code>5</code>个英文元音字母（<code>&#39;a&#39;</code>，<code>&#39;e&#39;</code>，<code>&#39;i&#39;</code>，<code>&#39;o&#39;</code>，<code>&#39;u&#39;</code>）都必须至少出现一次。<br>  这些元音字母的顺序都必须按照字典序升序排布（也就是说所有的<code>&#39;a&#39;</code>都在<code>&#39;e&#39;</code>前面，所有的<code>&#39;e&#39;</code>都在<code>&#39;i&#39;</code>前面，以此类推）<br>  比方说，字符串<code>&quot;aeiou&quot;</code>和<code>&quot;aaaaaaeiiiioou&quot;</code>都是美丽的，但是<code>&quot;uaeio&quot;</code> ，<code>&quot;aeoiu&quot;</code>和<code>&quot;aaaeeeooo&quot;</code>不是美丽的。</p><p>  给你一个只包含英文元音字母的字符串<code>word</code>，请你返回<code>word</code>中最长美丽子字符串的长度。如果不存在这样的子字符串，请返回<code>0</code>。</p><p>  子字符串是字符串中一个连续的字符序列。</p><p>  <strong>示例 1：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word &#x3D; &quot;aeiaaioaaaaeiiiiouuuooaauuaeiu&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 &quot;aaaaeiiiiouuu&quot;, 长度为 13</span><br></pre></td></tr></table></figure><p>  <strong>示例 2：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word &#x3D; &quot;aeeeiiiioooauuuaeiou&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子字符串是 &quot;aeiou&quot;, 长度为 5</span><br></pre></td></tr></table></figure><p>  <strong>提示：</strong></p><ul><li>1 &lt;= <code>word.length</code> &lt;= 5 * 10^5</li><li><code>word</code>只包含字符<code>&#39;a&#39;</code>，<code>&#39;e&#39;</code>，<code>&#39;i&#39;</code>，<code>&#39;o&#39;</code> 和<code>&#39;u&#39;</code>。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestBeautifulSubstring</span><span class="params">(<span class="built_in">string</span> word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; setting;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&gt; mapping;</span><br><span class="line">    mapping[<span class="string">'a'</span>].insert(&#123;<span class="string">'a'</span>, <span class="string">'e'</span>&#125;);</span><br><span class="line">    mapping[<span class="string">'e'</span>].insert(&#123;<span class="string">'e'</span>, <span class="string">'i'</span>&#125;);</span><br><span class="line">    mapping[<span class="string">'i'</span>].insert(&#123;<span class="string">'i'</span>, <span class="string">'o'</span>&#125;);</span><br><span class="line">    mapping[<span class="string">'o'</span>].insert(&#123;<span class="string">'o'</span>, <span class="string">'u'</span>&#125;);</span><br><span class="line">    mapping[<span class="string">'u'</span>].insert(<span class="string">'u'</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; word.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> a = word[right];</span><br><span class="line">        <span class="keyword">if</span>(right &gt; left &amp;&amp; !mapping[word[right - <span class="number">1</span>]].count(a))</span><br><span class="line">        &#123;</span><br><span class="line">            window.clear();</span><br><span class="line">            left = right;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        setting.insert(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(setting.size() == <span class="number">5</span>)</span><br><span class="line">            res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestBeautifulSubstring</span><span class="params">(<span class="built_in">string</span> word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, types = <span class="number">1</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; word.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新当前字符串长度</span></span><br><span class="line">        <span class="keyword">if</span>(word[i] &gt;= word[i - <span class="number">1</span>]) len++;</span><br><span class="line">        <span class="comment">// 更新当前字符种类</span></span><br><span class="line">        <span class="keyword">if</span>(word[i] &gt; word[i - <span class="number">1</span>]) types++;</span><br><span class="line">        <span class="comment">// 当前字符串不美丽，从当前字符重新开始</span></span><br><span class="line">        <span class="keyword">if</span>(word[i] &lt; word[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            types = <span class="number">1</span>;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新最大字符串</span></span><br><span class="line">        <span class="keyword">if</span>(types == <span class="number">5</span>) res = max(res, len);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. Longest Palindromic Substring</a></h5><blockquote><p>  给你一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心开花, 时间复杂度为 O(n2), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">auto</span> palindrome = [&amp;](<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> make_pair(left + <span class="number">1</span>, right - left - <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [start1, len1] = palindrome(i, i);</span><br><span class="line">        <span class="keyword">auto</span> [start2, len2] = palindrome(i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(len &lt; len1) &#123;</span><br><span class="line">            start = start1;</span><br><span class="line">            len = len1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; len2) &#123;</span><br><span class="line">            start = start2;</span><br><span class="line">            len = len2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. Minimum Window Substring</a></h5><blockquote><p>  给你一个字符串<code>s</code>和一个字符串<code>t</code>。返回<code>s</code>中涵盖<code>t</code>所有字符的最小子串。如果<code>s</code>中不存在涵盖<code>t</code>所有字符的子串，则返回空字符串<code>&quot;&quot;</code>。</p><p>  注意：如果<code>s</code>中存在这样的子串，我们保证它是唯一的答案。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;</span><br><span class="line">Output: &quot;a&quot;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window, need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) &#123;</span><br><span class="line">        need[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> a = s[right++];</span><br><span class="line">        <span class="keyword">if</span>(need.count(a)) &#123;</span><br><span class="line">            window[a]++;</span><br><span class="line">            <span class="keyword">if</span>(window[a] == need[a]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(valid == need.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">0</span> || right - left &lt; len) &#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left++];</span><br><span class="line">            <span class="keyword">if</span>(need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="567-Permutation-in-String"><a href="#567-Permutation-in-String" class="headerlink" title="567. Permutation in String"></a><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. Permutation in String</a></h5><blockquote><p>  给定两个字符串<code>s1</code>和<code>s2</code>，写一个函数来判断<code>s2</code>是否包含<code>s1</code>的排列。</p><p>  换句话说，第一个字符串的排列之一是第二个字符串的<strong>子串</strong>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;ab&quot;, s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;ab&quot;, s2 &#x3D; &quot;eidboaoo&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window, need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s1) &#123;</span><br><span class="line">        need[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, n = s2.size(), m = s1.size();</span><br><span class="line">    <span class="keyword">size_t</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; n) &#123;</span><br><span class="line">        <span class="keyword">char</span> a = s2[right++];</span><br><span class="line">        <span class="keyword">if</span>(need.count(a)) &#123;</span><br><span class="line">            window[a]++;</span><br><span class="line">            <span class="keyword">if</span>(window[a] == need[a]) &#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(valid == need.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s2[left++];</span><br><span class="line">            <span class="keyword">if</span>(need.count(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) &#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a></h5><blockquote><p>  给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><p>  <strong>Example 4:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.size()) &#123;</span><br><span class="line">        <span class="keyword">char</span> a = s[right++];</span><br><span class="line">        window[a]++;</span><br><span class="line">        <span class="keyword">while</span>(window[a] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> d = s[left++];</span><br><span class="line">            window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(<span class="number">128</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">while</span>(hi &lt; n) &#123;</span><br><span class="line">        <span class="keyword">while</span>(visited[s[hi]]) &#123;</span><br><span class="line">            visited[s[lo++]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[s[hi++]] = <span class="literal">true</span>;</span><br><span class="line">        len = max(len, hi - lo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="438-Find-All-Anagrams-in-a-String"><a href="#438-Find-All-Anagrams-in-a-String" class="headerlink" title="438. Find All Anagrams in a String"></a><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. Find All Anagrams in a String</a></h5><blockquote><p>  给定一个字符串<code>s</code>和一个非空字符串<code>p</code>，找到<code>s</code>中所有是<code>p</code>的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串<code>s</code>和<code>p</code>的长度都不超过<code>20100</code>。</p><p>  说明：</p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbaebabacd&quot;, p &#x3D; &quot;abc&quot;</span><br><span class="line">Output: [0,6]</span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index &#x3D; 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot;</span><br><span class="line">Output: [0,1,2]</span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index &#x3D; 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index &#x3D; 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    vector&lt;int&gt; window(26), need(26);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p) &#123;</span><br><span class="line">        need[c - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示窗口内字符种类和所需要的字符种类数目的差距</span></span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt : need) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            diff++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n = s.size(), m = p.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; n) &#123;</span><br><span class="line">        <span class="keyword">char</span> a = s[right++] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(need[a] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            window[a]++;</span><br><span class="line">            <span class="keyword">if</span>(window[a] == need[a]) &#123;</span><br><span class="line">                diff--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对每个窗口内数据都判断一下</span></span><br><span class="line">        <span class="keyword">if</span>(right - left == m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(diff == <span class="number">0</span>) &#123;</span><br><span class="line">                res.push_back(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s[left++] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(need[d] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) &#123;</span><br><span class="line">                    diff++;</span><br><span class="line">                &#125;</span><br><span class="line">                window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="395-Longest-Substring-with-At-Least-K-Repeating-Characters"><a href="#395-Longest-Substring-with-At-Least-K-Repeating-Characters" class="headerlink" title="395. Longest Substring with At Least K Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">395. Longest Substring with At Least K Repeating Characters</a></h5><blockquote><p>  给你一个字符串<code>s</code>和一个整数<code>k</code>，请你找出<code>s</code>中的最长子串， 要求该子串中的每一字符出现次数都不少于<code>k</code>。返回这一子串的长度。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aaabb&quot;, k &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest substring is &quot;aaa&quot;, as &#39;a&#39; is repeated 3 times.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ababbc&quot;, k &#x3D; 2</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest substring is &quot;ababb&quot;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题有一个点很关键</span></span><br><span class="line"><span class="comment">// 有一些字符的出现次数小于 k</span></span><br><span class="line"><span class="comment">// 如果窗口内包含这些字符的话, 肯定是不符合要求的</span></span><br><span class="line"><span class="comment">// 常规的滑动窗口思路需要做些改动</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="comment">// 总字符数量小于 k 肯定不符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; char2cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">        char2cnt[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uniqueString</span><span class="params">(s.begin(), s.end())</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; afterSplit;</span><br><span class="line">    <span class="keyword">auto</span> split = [&amp;](<span class="keyword">const</span> <span class="keyword">char</span> sep) &#123;</span><br><span class="line">        <span class="comment">// 清空数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;().swap(afterSplit);</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">while</span>(getline(iss, str, sep)) &#123;</span><br><span class="line">            afterSplit.emplace_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : uniqueString) &#123;</span><br><span class="line">        <span class="keyword">if</span>(char2cnt[c] &lt; k) &#123;</span><br><span class="line">            split(c);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; str : afterSplit) &#123;</span><br><span class="line">                len = max(len, longestSubstring(str, k));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="402-Remove-K-Digits"><a href="#402-Remove-K-Digits" class="headerlink" title="402. Remove K Digits"></a><a href="https://leetcode.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. Remove K Digits</a></h5><blockquote><p>  给定一个以字符串表示的非负整数<code>num</code>，移除这个数中的<code>k</code>位数字，使得剩下的数字最小。</p><p>  注意：</p><ul><li><code>num</code>的长度小于<code>10002</code>且<code>≥ k</code>。</li><li><code>num</code>不会包含任何前导零。</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">Output: &quot;1219&quot;</span><br><span class="line">Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">Output: &quot;200&quot;</span><br><span class="line">Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">Output: &quot;0&quot;</span><br><span class="line">Explanation: Remove all the digits from the number and it is left with nothing which is 0.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心思想 + 单调栈</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = num.size();</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> remain = n - k;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : num) &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; !s.empty() &amp;&amp; s.back() &gt; c) &#123;</span><br><span class="line">            s.pop_back();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        s += c;</span><br><span class="line">    &#125;</span><br><span class="line">    s = s.substr(<span class="number">0</span>, remain);</span><br><span class="line">    /删除前导零</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; remain &amp;&amp; s[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == remain ? <span class="string">"0"</span> : s.substr(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="321-Create-Maximum-Number"><a href="#321-Create-Maximum-Number" class="headerlink" title="321. Create Maximum Number"></a><a href="https://leetcode.com/problems/create-maximum-number/" target="_blank" rel="noopener">321. Create Maximum Number</a></h5><blockquote><p>  给定长度分别为<code>m</code>和<code>n</code>的两个数组，其元素由<code>0-9</code>构成，表示两个自然数各位上的数字。现在从这两个数组中选出<code>k (k &lt;= m + n)</code>个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p><p>  求满足该条件的最大数。结果返回一个表示该最大数的长度为<code>k</code>的数组。</p><p>  说明：请尽可能地优化你算法的时间和空间复杂度。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [3,4,6,5], nums2 &#x3D; [9,1,2,5,8,3], k &#x3D; 5</span><br><span class="line">Output: [9,8,6,5,3]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [6,7], nums2 &#x3D; [6,0,4], k &#x3D; 5</span><br><span class="line">Output: [6,7,6,0,4]</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [3,9], nums2 &#x3D; [8,9], k &#x3D; 3</span><br><span class="line">Output: [9,8,9]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题是上一题 402 的超级进阶</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= m &amp;&amp; k - i &lt;= n) &#123;</span><br><span class="line">            res = max(res, merge(maxNumber(nums1, i), maxNumber(nums2, k - i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 nums 中取出能够拼接得到最大的 k 个数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> del = nums.size() - k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">while</span>(del &gt; <span class="number">0</span> &amp;&amp; !s.empty() &amp;&amp; s.back() &lt; num) &#123;</span><br><span class="line">            s.pop_back();</span><br><span class="line">            del--;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s.size() &gt; k) &#123;</span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个数组, 其中比较大小的规则比较特殊</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merged</span><span class="params">(m + n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(compare(nums1, i, nums2, j)) &#123;</span><br><span class="line">            merged[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            merged[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m) &#123;</span><br><span class="line">        merged[k++] = nums1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n) &#123;</span><br><span class="line">        merged[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并数组时特殊的比较规则, 主要是处理两个数相等的情况, 这时要看后面数字的大小</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= nums1.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= nums2.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(nums1, i + <span class="number">1</span>, nums2, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1754-Largest-Merge-Of-Two-Strings"><a href="#1754-Largest-Merge-Of-Two-Strings" class="headerlink" title="1754. Largest Merge Of Two Strings"></a><a href="https://leetcode.com/problems/largest-merge-of-two-strings/" target="_blank" rel="noopener">1754. Largest Merge Of Two Strings</a></h5><blockquote><p>  给你两个字符串<code>word1</code>和<code>word2</code>。你需要按下述方式构造一个新字符串<code>merge</code>：如果<code>word1</code>或<code>word2</code>非空，选择下面选项之一继续操作：</p><ul><li><p>如果<code>word1</code>非空，将<code>word1</code>中的第一个字符附加到<code>merge</code>的末尾，并将其从<code>word1</code>中移除。<br>例如，<code>word1 = &quot;abc&quot;</code>且<code>merge = &quot;dv&quot;</code>，在执行此选项操作之后，<code>word1 = &quot;bc&quot;</code>，同时<code>merge = &quot;dva&quot;</code>。</p></li><li><p>如果<code>word2</code>非空，将<code>word2</code>中的第一个字符附加到<code>merge</code>的末尾，并将其从<code>word2</code>中移除。<br>例如，<code>word2 = &quot;abc&quot;</code>且<code>merge = &quot;&quot;</code>，在执行此选项操作之后，<code>word2 = &quot;bc&quot;</code>，同时<code>merge = &quot;a&quot;</code>。</p><p>返回你可以构造的字典序最大的合并字符串<code>merge</code>。</p></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;cabaa&quot;, word2 &#x3D; &quot;bcaaa&quot;</span><br><span class="line">Output: &quot;cbcabaaaaa&quot;</span><br><span class="line">Explanation: One way to get the lexicographically largest merge is:</span><br><span class="line">- Take from word1: merge &#x3D; &quot;c&quot;, word1 &#x3D; &quot;abaa&quot;, word2 &#x3D; &quot;bcaaa&quot;</span><br><span class="line">- Take from word2: merge &#x3D; &quot;cb&quot;, word1 &#x3D; &quot;abaa&quot;, word2 &#x3D; &quot;caaa&quot;</span><br><span class="line">- Take from word2: merge &#x3D; &quot;cbc&quot;, word1 &#x3D; &quot;abaa&quot;, word2 &#x3D; &quot;aaa&quot;</span><br><span class="line">- Take from word1: merge &#x3D; &quot;cbca&quot;, word1 &#x3D; &quot;baa&quot;, word2 &#x3D; &quot;aaa&quot;</span><br><span class="line">- Take from word1: merge &#x3D; &quot;cbcab&quot;, word1 &#x3D; &quot;aa&quot;, word2 &#x3D; &quot;aaa&quot;</span><br><span class="line">- Append the remaining 5 a&#39;s from word1 and word2 at the end of merge.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;abcabc&quot;, word2 &#x3D; &quot;abdcaba&quot;</span><br><span class="line">Output: &quot;abdcabcabcaba&quot;</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 3000</code></li><li><code>word1</code> and <code>word2</code> consist only of lowercase English letters.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题就是用到上一题 321 的合并思路</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">largestMerge</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">merged</span><span class="params">(m + n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(compare(word1, i, word2, j)) &#123;</span><br><span class="line">            merged[k++] = word1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            merged[k++] = word2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m) &#123;</span><br><span class="line">        merged[k++] = word1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n) &#123;</span><br><span class="line">        merged[k++] = word2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span>&amp; word1, <span class="keyword">int</span> i, <span class="built_in">string</span>&amp; word2, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= word1.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= word2.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(word1[i] &lt; word2[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(word1[i] &gt; word2[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(word1, i + <span class="number">1</span>, word2, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为这题是处理字符串, 比较函数可以不用单独写</span></span><br><span class="line"><span class="comment">// 但是效率会降低很多</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">largestMerge</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">    <span class="built_in">string</span> merged;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(word1.substr(i) &gt; word2.substr(j)) &#123;</span><br><span class="line">            merged += word1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            merged += word2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接切片就行了</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; m) &#123;</span><br><span class="line">        merged += word1.substr(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; n) &#123;</span><br><span class="line">        merged += word2.substr(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi)</a></h5><blockquote><p>  请你来实现一个<code>myAtoi(string s)</code>函数，使其能将字符串转换成一个<code>32</code>位有符号整数（类似<code>C/C++</code>中的<code>atoi</code>函数）。</p><p>  函数<code>myAtoi(string s)</code>的算法如下：</p><ul><li><p>读入字符串并丢弃无用的前导空格</p></li><li><p>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</p></li><li><p>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</p></li><li><p>将前面步骤读入的这些数字转换为整数（即，<code>&quot;123&quot;</code>-&gt; <code>123</code>，<code>&quot;0032&quot;</code> -&gt; <code>32</code>）。如果没有读入数字，则整数为<code>0</code>。必要时更改符号（从步骤<code>2</code>开始）。</p></li><li><p>如果整数数超过<code>32</code>位有符号整数范围<code>[−2^31, 2^31 − 1]</code>，需要截断这个整数，使其保持在这个范围内。具体来说，小于<code>−2^31</code>的整数应该被固定为<code>−2^31</code>，大于<code>2^31−1</code>的整数应该被固定为<code>2^31−1</code> 。</p></li><li><p>返回整数作为最终结果。</p><p>注意：</p></li><li><p>本题中的空白字符只包括空格字符<code>&#39; &#39;</code>。</p></li><li><p>除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。</p></li></ul><p>  <strong>题解</strong>：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/jin-liang-bu-shi-yong-ku-han-shu-nai-xin-diao-shi-/" target="_blank" rel="noopener">尽量不使用库函数、一次遍历（Java） - 字符串转换整数 (atoi) - 力扣（LeetCode）</a></p><p>  <strong>示例 1</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42</span><br></pre></td></tr></table></figure><p>  <strong>示例 2</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42</span><br></pre></td></tr></table></figure><p>  <strong>示例 3</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193</span><br></pre></td></tr></table></figure><p>  <strong>示例 4</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;words and 987&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;words and 987&quot;（由于当前字符 &#39;w&#39; 不是一个数字，所以读入停止）</span><br><span class="line">         ^</span><br><span class="line">解析得到整数 0，因为没有读入任何数字。</span><br><span class="line">由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0</span><br></pre></td></tr></table></figure><p>  <strong>示例 5</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;-91283472332&quot;</span><br><span class="line">输出：-2147483648</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;-91283472332&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class="line">          ^</span><br><span class="line">第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;）</span><br><span class="line">                     ^</span><br><span class="line">解析得到整数 -91283472332</span><br><span class="line">由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -2^31 &#x3D; -2147483648</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据示例 1, 需要去掉前导空格</span></span><br><span class="line"><span class="comment">// 根据示例 2, 需要判断第 1 个字符为 + 和 - 的情况</span></span><br><span class="line"><span class="comment">// 因此, 可以设计一个变量 sign, 初始化的时候为 1, 如果遇到 -, 将 sign 修正为 -1</span></span><br><span class="line"><span class="comment">// 判断是否是数字, 可以使用字符的 ASCII 码数值进行比较, 即 0 &lt;= c &lt;= '9'</span></span><br><span class="line"><span class="comment">// 根据示例 3 和示例 4, 在遇到第 1 个不是数字的字符的情况下, 转换停止, 退出循环</span></span><br><span class="line"><span class="comment">// 根据示例 5, 如果转换以后的数字超过了 int 类型的范围, 需要截取</span></span><br><span class="line"><span class="comment">// 这里不能将结果 res 变量设计为 long 类型</span></span><br><span class="line"><span class="comment">// 注意: 由于输入的字符串转换以后也有可能超过 long 类型</span></span><br><span class="line"><span class="comment">// 因此需要在循环内部就判断是否越界, 只要越界就退出循环, 这样也可以减少不必要的计算</span></span><br><span class="line"><span class="comment">// 由于涉及下标访问, 因此全程需要考虑数组下标是否越界的情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.size();</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 去除前导空格</span></span><br><span class="line">    <span class="keyword">while</span>(idx &lt; n &amp;&amp; str[idx] == <span class="string">' '</span>) &#123;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(idx == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 处理第 1 个非空字符为正负符号, 这两个判断需要写在一起</span></span><br><span class="line">    <span class="keyword">if</span>(str[idx] == <span class="string">'+'</span>) &#123;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[idx] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx &lt; n) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str[idx];</span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = c - <span class="string">'0'</span>;</span><br><span class="line">        <span class="comment">// 溢出处理</span></span><br><span class="line">        <span class="keyword">if</span>(number &gt; INT_MAX / <span class="number">10</span> || (number == INT_MAX / <span class="number">10</span> &amp;&amp; num &gt; INT_MAX % <span class="number">10</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number &lt; INT_MIN / <span class="number">10</span> || (number == INT_MIN / <span class="number">10</span> &amp;&amp; num &gt; -(INT_MIN % <span class="number">10</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        number = number * <span class="number">10</span> + sign * num;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="43. Multiply Strings"></a><a href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener">43. Multiply Strings</a></h5><blockquote><p>  给定两个以字符串形式表示的非负整数<code>num1</code>和<code>num2</code>，返回<code>num1</code>和<code>num2</code>的乘积，它们的乘积也表示为字符串形式。</p><p>  <strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/" target="_blank" rel="noopener">优化版竖式(打败99.4%) - 字符串相乘 - 力扣（LeetCode）</a></p><p>  <strong>示例 1</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure><p>  <strong>示例 2</strong>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟普通竖式乘法</span></span><br><span class="line"><span class="comment">// 将每一步的乘法结果相加即可</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">int</span> m = num1.size();</span><br><span class="line">    <span class="keyword">int</span> n = num2.size();</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">string</span> num;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (num1[i] - <span class="string">'0'</span>) * (num2[j] - <span class="string">'0'</span>) + carry;</span><br><span class="line">            carry = temp / <span class="number">10</span>;</span><br><span class="line">            num += to_string(temp % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>) &#123;</span><br><span class="line">            num += to_string(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(num.begin(), num.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; times; k++) &#123;</span><br><span class="line">            num += <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        times++;</span><br><span class="line">        res = stringPlus(res, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串数字相加</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">stringPlus</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; num1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = num1.size();</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = num2.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里的一个技巧就是短的字符串前面以 0 补齐</span></span><br><span class="line">        <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2[j] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x + y + carry;</span><br><span class="line">        res += to_string(temp % <span class="number">10</span>);</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原 IP 地址</a></h5><blockquote><p>  给定一个只包含数字的字符串，用以表示一个<code>IP</code>地址，返回所有可能从<code>s</code>获得的有效<code>IP</code>地址 。你可以按任何顺序返回答案。</p><p>  有效<code>IP</code>地址 正好由四个整数（每个整数位于<code>0</code>到<code>255</code>之间组成，且不能含有前导<code>0</code>），整数之间用<code>&#39;.&#39;</code>分隔。</p><p>  例如：”0.1.2.201”和”192.168.1.1”是有效<code>IP</code>地址，但是”0.011.255.245”、”192.168.1.312”和”<a href="mailto:192.168@1.1">192.168@1.1</a>“是无效<code>IP</code>地址。</p><p>  <strong>示例 1：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><p>  <strong>示例 2：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure><p>  <strong>示例 3：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;010010&quot;</span><br><span class="line">输出：[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="keyword">int</span> cnt, <span class="keyword">int</span> idx, <span class="built_in">string</span>&amp;&amp; str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(idx == s.size()) &#123;</span><br><span class="line">                <span class="comment">// 需要将最前面的 '.' 删掉</span></span><br><span class="line">                res.emplace_back(str.substr(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重要的剪枝, 前导符为 0 时, 这一段只能为 0</span></span><br><span class="line">        <span class="keyword">if</span>(s[idx] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            dfs(dfs, cnt + <span class="number">1</span>, idx + <span class="number">1</span>, str + <span class="string">".0"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; s.size(); i++) &#123;</span><br><span class="line">            temp += s[i];</span><br><span class="line">            <span class="keyword">if</span>(stoi(temp) &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">                dfs(dfs, cnt + <span class="number">1</span>, i + <span class="number">1</span>, str + <span class="string">"."</span> + temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(dfs, <span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="468-验证IP地址"><a href="#468-验证IP地址" class="headerlink" title="468. 验证IP地址"></a><a href="https://leetcode-cn.com/problems/validate-ip-address/" target="_blank" rel="noopener">468. 验证IP地址</a></h5><blockquote><p>  编写一个函数来验证输入的字符串是否是有效的<code>IPv4</code>或<code>IPv6</code>地址。</p><ul><li><p>如果是有效的<code>IPv4</code>地址，返回<code>&quot;IPv4&quot;</code>；</p></li><li><p>如果是有效的<code>IPv6</code>地址，返回<code>&quot;IPv6&quot;</code>；</p></li><li><p>如果不是上述类型的<code>IP</code>地址，返回<code>&quot;Neither&quot;</code>。</p><p><code>IPv4</code>地址由十进制数和点来表示，每个地址包含<code>4</code>个十进制数，其范围为<code>0 - 255</code>， 用<code>(&quot;.&quot;)</code>分割。比如，<code>172.16.254.1</code>；同时，<code>IPv4</code>地址内的数不会以<code>0</code>开头。比如，地址<code>172.16.254.01</code>是不合法的。</p><p><code>IPv6</code>地址由<code>8</code>组<code>16</code>进制的数字来表示，每组表示<code>16</code>比特。这些组数字通过<code>(&quot;:&quot;)</code>分割。比如， <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>是一个有效的地址。而且，我们可以加入一些以<code>0</code>开头的数字，字母可以使用大写，也可以是小写。所以，<code>2001:db8:85a3:0:0:8A2E:0370:7334</code>也是一个有效的<code>IPv6 address</code>地址 (即，忽略<code>0</code>开头，忽略大小写）。</p><p>然而，我们不能因为某个组的值为<code>0</code>，而使用一个空的组，以至于出现<code>(::)</code>的情况。 比如，<code>2001:0db8:85a3::8A2E:0370:7334</code>是无效的<code>IPv6</code>地址。</p><p>同时，在<code>IPv6</code>地址中，多余的<code>0</code>也是不被允许的。比如，<code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code>是无效的。</p></li></ul><p>  <strong>示例 1</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：IP &#x3D; &quot;172.16.254.1&quot;</span><br><span class="line">输出：&quot;IPv4&quot;</span><br><span class="line">解释：有效的 IPv4 地址，返回 &quot;IPv4&quot;</span><br></pre></td></tr></table></figure><p>  <strong>示例 2</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：IP &#x3D; &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;</span><br><span class="line">输出：&quot;IPv6&quot;</span><br><span class="line">解释：有效的 IPv6 地址，返回 &quot;IPv6&quot;</span><br></pre></td></tr></table></figure><p>  <strong>示例 3</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：IP &#x3D; &quot;256.256.256.256&quot;</span><br><span class="line">输出：&quot;Neither&quot;</span><br><span class="line">解释：既不是 IPv4 地址，又不是 IPv6 地址</span><br></pre></td></tr></table></figure><p>  <strong>示例 4</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：IP &#x3D; &quot;2001:0db8:85a3:0:0:8A2E:0370:7334:&quot;</span><br><span class="line">输出：&quot;Neither&quot;</span><br></pre></td></tr></table></figure><p>  <strong>示例 5</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：IP &#x3D; &quot;1e1.4.5.6&quot;</span><br><span class="line">输出：&quot;Neither&quot;</span><br></pre></td></tr></table></figure><p>  <strong>提示</strong>：</p><ul><li><code>IP</code>仅由英文字母，数字，字符<code>&#39;.&#39;</code>和<code>&#39;:&#39;</code>组成。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">validIPAddress</span><span class="params">(<span class="built_in">string</span> IP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(validIPv4Address(IP)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IPv4"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(validIPv6Address(IP)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"IPv6"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validIPv4Address</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; IPv4)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ip;</span><br><span class="line">        split(IPv4, ip, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(ip.size() != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; elem : ip) &#123;</span><br><span class="line">            <span class="keyword">if</span>(elem.empty() || elem.size() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理前导符为 0 的情况</span></span><br><span class="line">            <span class="keyword">if</span>(elem.size() &gt; <span class="number">1</span> &amp;&amp; elem[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理非法字符的情况，如 1e1等</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : elem) &#123;</span><br><span class="line">                <span class="keyword">if</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stoi(elem) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validIPv6Address</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; IPv6)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ip;</span><br><span class="line">        split(IPv6, ip, <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span>(ip.size() != <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// unordered_set&lt;char&gt; hexs&#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'&#125;;</span></span><br><span class="line">        <span class="built_in">string</span> hexs&#123;<span class="string">"0123456789abcdefABCDEF"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; elem : ip) &#123;</span><br><span class="line">            <span class="keyword">if</span>(elem.empty() || elem.size() &gt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// for(char c : elem) &#123;</span></span><br><span class="line">            <span class="comment">//     if(hexs.count(c) == 0) &#123;</span></span><br><span class="line">            <span class="comment">//         return false;</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : elem) &#123;</span><br><span class="line">                <span class="keyword">if</span>(hexs.find(c) == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; IP, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ip, <span class="keyword">char</span> delim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(IP.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(IP)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(getline(ss, temp, delim)) &#123;</span><br><span class="line">            ip.emplace_back(move(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理 IP 地址末尾有一个 '.' 或 ':' 的情况</span></span><br><span class="line">        <span class="keyword">if</span>(IP.back() == <span class="string">':'</span> || IP.back() == <span class="string">'.'</span>) &#123;</span><br><span class="line">            ip.push_back(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h5><blockquote><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：&quot;abc&quot;</span><br><span class="line">&gt;输出：3</span><br><span class="line">&gt;解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：&quot;aaa&quot;</span><br><span class="line">&gt;输出：6</span><br><span class="line">&gt;解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心开花</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> palindrome = [&amp;](<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        palindrome(i, i);</span><br><span class="line">        palindrome(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之动态规划</title>
      <link href="/RT66rbCYdVwFEsD8/"/>
      <url>/RT66rbCYdVwFEsD8/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>6</code>部分——动态规划。这里把有代表性的题目发出来，共计<code>56</code>道。动态规划题目变化多端，目前旨在于习得通用的解题技巧，这些只是比较经典的动态规划题目。</p><p><code>leetcode</code>刷题系列其它文章组织如下：</p><p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p><p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p><p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p><a id="more"></a><h5 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. Minimum Path Sum</a></h5><blockquote><p>给定一个<code>m × n</code>的网格，其中填充了非负数，请找到从左上到右下的路径，这将沿其路径的所有数字的总和最小化。</p><p>注意：您只能在任何时间点向下或向右移动。</p><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><p><strong>Example:</strong></p><p><img src="minpath.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示从起点走到第 i 行, 第 j 列的最小路径和</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样写可避免循环内每次的判断语句, 效率提升那么一丢丢</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">72. Edit Distance</a></h5><blockquote><p>  Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p><p>  You have the following three operations permitted on a word:</p><ul><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (remove &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (remove &#39;e&#39;)</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (insert &#39;u&#39;)</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般来说, 解决字符串的动态规划问题, 是用两个指针 i, j 分别指向两个字符串的尾</span></span><br><span class="line"><span class="comment">// 一步一步向前走, 缩小问题的规模</span></span><br><span class="line"><span class="comment">// 如果我们定义一个 dp 函数 dp(i, j)</span></span><br><span class="line"><span class="comment">// 表示将 word1[0, i] 变为 word2[0, j] 的最小编辑距离的话</span></span><br><span class="line"><span class="comment">// 那么我们要求的就是 dp(word1.size() - 1, word2.size() - 1)</span></span><br><span class="line"><span class="comment">// 那么 dp(i, j) 怎么求呢？</span></span><br><span class="line"><span class="comment">// 考虑之前的状态, 共有 dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1) 三种</span></span><br><span class="line"><span class="comment">// 在编辑 word1 的第 i + 1 个字符时</span></span><br><span class="line"><span class="comment">// 1. 如果 word1[i] == word2[j], 那么直接跳过即可, dp(i, j) = dp(i - 1, j - 1)</span></span><br><span class="line"><span class="comment">// 2. 如果 word1[i] != word2[j] 我们有三种选择</span></span><br><span class="line"><span class="comment">// - 插入一个字符使得其与 word2[j] 匹配, 那么 dp(i, j) = dp(i, j - 1) + 1</span></span><br><span class="line"><span class="comment">// - 删除这个字符, word2[j] 没有得到匹配, 那么 dp(i, j) = dp(i - 1, j) + 1</span></span><br><span class="line"><span class="comment">// - 替换这个字符使得其与 word2[j] 匹配, 那么 dp(i, j) = dp(i - 1, j - 1) + 1</span></span><br><span class="line"><span class="comment">// 要求最小编辑距离的话, 这三种都试一下, 取最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面相当于暴力解法, 把每一个操作都试一遍取最小值</span></span><br><span class="line"><span class="comment">// 会出现非常多的重叠子问题, 因此需要用备忘录优化一下</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp(word1, word2, word1.size() - <span class="number">1</span>, word2.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">string</span>&amp; word1, <span class="built_in">string</span>&amp; word2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 如果 word1 走到头了, word2 没有, 那么只能插入 word2 剩下的所有字符</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果 word2 走到头了, word1 没有, 那么只能删除 word1 剩下的所有字符</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> key = to_string(i) + <span class="string">","</span> + to_string(j);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line">    <span class="keyword">if</span>(word1[i] == word2[j])</span><br><span class="line">        memo[key] = dp(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        memo[key] = <span class="number">1</span> + min(&#123;dp(word1, word2, i - <span class="number">1</span>, j),</span><br><span class="line">                             dp(word1, word2, i, j - <span class="number">1</span>),</span><br><span class="line">                             dp(word1, word2, i - <span class="number">1</span>, j - <span class="number">1</span>)&#125;);</span><br><span class="line">    <span class="keyword">return</span> memo[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 dp table</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.size();</span><br><span class="line">    <span class="keyword">int</span> n = word2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + min(&#123;dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. Longest Increasing Subsequence</a></h5><blockquote><p>  给你一个整数数组<code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>  子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>是数组<code>[0,3,1,6,2,2,7]</code>的子序列。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>  <strong>Follow up:</strong></p><ul><li>Could you come up with the <code>O(n2)</code> solution?</li><li>Could you improve it to <code>O(n log(n))</code> time complexity?</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划 dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span></span><br><span class="line"><span class="comment">// 要求的目标为 dp 数组中的最大值</span></span><br><span class="line"><span class="comment">// base case 以 nums[i] 结尾的最长递增子序列至少要包含它自己 dp[0..] = 1</span></span><br><span class="line"><span class="comment">// dp[i] = max(dp[i], dp[j] + 1) j 属于 [0..i) 且 nums[j] &lt; nums[i]</span></span><br><span class="line"><span class="comment">// 就是在前面找到结尾的比 nums[i] 小的子序列, 把 nums[i] 接到后面, 长度加 1 即可</span></span><br><span class="line"><span class="comment">// 可能有很多个满足条件的接法, 选择长度最大的接法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = *max_element(dp.begin(), dp.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 既然题目提示我们这题的时间复杂度可以优化到 O(nlogn)</span></span><br><span class="line"><span class="comment">// logn 的复杂度只有二分法能办到了</span></span><br><span class="line"><span class="comment">// 我们把这些数分成许多堆, 按照下面定义的规则:</span></span><br><span class="line"><span class="comment">// 1. 依次从数组中拿出一个数, 首先第一个数就放在第 1 个堆就行</span></span><br><span class="line"><span class="comment">// 2. 之后每次取出的数必须放在所有堆顶的不小于它的数上面</span></span><br><span class="line"><span class="comment">// 3. 如果有多个堆顶的数都不小于它, 就放在最靠左边的堆上面</span></span><br><span class="line"><span class="comment">// 4. 如果没有这样的堆, 就从右边新起一个堆放</span></span><br><span class="line"><span class="comment">// 这个规则的限制下, 所有堆顶的元素从左到右始终都是有序的</span></span><br><span class="line"><span class="comment">// 这样我们就可以应用二分搜索, 来找第 1 个不小于待放数的堆了</span></span><br><span class="line"><span class="comment">// 那么这和我们的问题: 寻找最长递增子序列有什么关系呢？</span></span><br><span class="line"><span class="comment">// 可以证明, 最长递增子序列就是堆的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pilesTop;</span><br><span class="line">    <span class="comment">// 最多分了 n 个堆, 我们提前分配空间提升效率</span></span><br><span class="line">    pilesTop.reserve(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 寻找左边界二分搜索</span></span><br><span class="line">        <span class="keyword">auto</span> left = lower_bound(pilesTop.begin(), pilesTop.end(), nums[i]);</span><br><span class="line">        <span class="comment">// 如果没有合适的堆, 自己单放</span></span><br><span class="line">        <span class="keyword">if</span>(left == pilesTop.end())</span><br><span class="line">            pilesTop.push_back(nums[i]);</span><br><span class="line">        <span class="comment">// 否则, 放堆顶上</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *left = nums[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pilesTop.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="354-Russian-Doll-Envelopes"><a href="#354-Russian-Doll-Envelopes" class="headerlink" title="354. Russian Doll Envelopes"></a><a href="https://leetcode.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. Russian Doll Envelopes</a></h5><blockquote><p>  给你一个二维整数数组<code>envelopes</code>，其中<code>envelopes[i] = [wi, hi]</code>，表示第<code>i</code>个信封的宽度和高度。</p><p>  当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>  请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>  注意：不允许旋转信封。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]).</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: envelopes &#x3D; [[1,1],[1,1],[1,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照信封的宽度递增排序, 宽度相等的信封按高度递减排序</span></span><br><span class="line"><span class="comment">// 最大嵌套信封数就是高度序列的最长递增子序列</span></span><br><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(envelopes.begin(), envelopes.end(), cmp);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(envelopes.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; envelopes.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>])</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res = *max_element(dp.begin(), dp.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样的使用二分搜索解法提升效率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(envelopes.begin(), envelopes.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> n = envelopes.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        nums[i] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; piles;</span><br><span class="line">    piles.reserve(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = lower_bound(piles.begin(), piles.end(), nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(it == piles.end())</span><br><span class="line">            piles.push_back(nums[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *it = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> piles.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">494. Target Sum</a></h5><blockquote><p>  给定一个非负整数数组，<code>a1, a2, ..., an</code>和一个目标数<code>S</code>。现在你有两个符号<code>+</code>和<code>-</code>。对于数组中的任意一个整数，你都可以从<code>+</code>或<code>-</code>中选择一个符号添加在前面。</p><p>  返回可以使最终数组和为目标数<code>S</code>的所有添加符号的方法数。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这道题虽然通常想到的都是 dfs 的方法</span></span><br><span class="line"><span class="comment">// 现在让我们再转化一下思路, 看它和动态规划有什么关系</span></span><br><span class="line"><span class="comment">// 数组中的数都是非负数, 把所有数得和表示为 sums</span></span><br><span class="line"><span class="comment">// 我们把前面加正号的数的和 表示为 sumA, 把前面加负号的数的和 表示为 sumB</span></span><br><span class="line"><span class="comment">// 有 sumA - sumB = target</span></span><br><span class="line"><span class="comment">// 移项得 sumA = target + sumB</span></span><br><span class="line"><span class="comment">// 两边加上 sumA 有 sumA + sumA = target + sumA + sumB = target + sums</span></span><br><span class="line"><span class="comment">// 最后 sumA = (target + sums) / 2  = newTarget右边都是已知的</span></span><br><span class="line"><span class="comment">// 也就是说我们把问题转化为了</span></span><br><span class="line"><span class="comment">// 从这些数中选出一个子集, 问我们有多少种选法可使得子集的和等于目标数</span></span><br><span class="line"><span class="comment">// 换种表达方式, 我们把目标数表示为一个背包的载重量</span></span><br><span class="line"><span class="comment">// 数组中的值为一个个石头的重量, 问我们有多少种装法可以把背包装满</span></span><br><span class="line"><span class="comment">// 这是动态规划中典型的背包问题</span></span><br><span class="line"><span class="comment">// 首先在装石头的过程中, 问题中的状态和选择有: 状态就是背包的可载重量和可选择的石头序列</span></span><br><span class="line"><span class="comment">// 选择就是装还是不装</span></span><br><span class="line"><span class="comment">// 由于有两个状态, 所以我们定义一个二维 dp 数组</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示在前 i 个石头中, 背包的可载重量为 j 时, 有多少种装法</span></span><br><span class="line"><span class="comment">// 那么当 i = 0 时, 没有石头, 装法为 0</span></span><br><span class="line"><span class="comment">// 当 j = 0 时, 背包的可载重量为 0 时, 只有 1 种装法, 就是一个也不装</span></span><br><span class="line"><span class="comment">// 那么状态转移方程怎么写呢?</span></span><br><span class="line"><span class="comment">// 对于可选择前 i 个石头, 可载重量为 j 时</span></span><br><span class="line"><span class="comment">// 1. 如果第 i 个石头不装, 那么 dp[i][j] = dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 2. 如果第 i 个石头装, 那么 dp[i][j] = dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 它们都取决于上一次装的情况, 两种情况要加起来</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 我们最终要求的目标就是 dp[n][m], 其中 n 表示给定数组的长度, m 表示新目标和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 问题转化</span></span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果总和都小于目标和(表示全加正号)或者 sum + target 为奇数(表示 sumA 都不是个整数)</span></span><br><span class="line">    <span class="keyword">if</span>(sum &lt; target || ((sum + target) &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> newTarget = (sum + target) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义 dp 数组</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(newTarget + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 注意 dp[0][0] 也是 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.size(); i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= newTarget; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.size()][newTarget];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="91-Decode-Ways、-639-Decode-Ways-II"><a href="#91-Decode-Ways、-639-Decode-Ways-II" class="headerlink" title="91. Decode Ways、 639. Decode Ways II"></a><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">91. Decode Ways</a>、 <a href="https://leetcode.com/problems/decode-ways-ii/" target="_blank" rel="noopener">639. Decode Ways II</a></h5><blockquote><p>  一条包含字母<code>A - Z</code>的消息通过以下映射进行了编码：</p><p>  <code>&#39;A&#39; -&gt; 1</code><br>  <code>&#39;B&#39; -&gt; 2</code><br>      …<br>  <code>&#39;Z&#39; -&gt; 26</code><br>  要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code>可以映射为：</p><p>  <code>&quot;AAJF&quot;</code>，将消息分组为<code>(1 1 10 6)</code><br>  <code>&quot;KJF&quot;</code>，将消息分组为<code>(11 10 6)</code><br>  注意，消息不能分组为<code>(1 11 06)</code>，因为<code>&quot;06&quot;</code>不能映射为<code>&quot;F&quot;</code>，这是由于<code>&quot;6&quot;</code>和<code>&quot;06&quot;</code>在映射中并不等价。</p><p>  给你一个只含数字的非空字符串<code>s</code>，请计算并返回解码方法的总数 。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;0&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no character that is mapped to a number starting with 0.</span><br><span class="line">The only valid mappings with 0 are &#39;J&#39; -&gt; &quot;10&quot; and &#39;T&#39; -&gt; &quot;20&quot;, neither of which start with 0.</span><br><span class="line">Hence, there are no valid ways to decode this since all digits need to be mapped.</span><br></pre></td></tr></table></figure><p>  <strong>Example 4:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;06&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;).</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> contains only digits and may contain leading zero(s).</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case 前两个字符组成的串单放用</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] != <span class="string">'0'</span>) dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i - <span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 单放</span></span><br><span class="line">        <span class="keyword">int</span> num = stoi(s[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">1</span> &amp;&amp; num &lt;= <span class="number">9</span>)</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 拼着放</span></span><br><span class="line">        num = stoi(s.substr(i - <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">26</span>)</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="516-Longest-Palindromic-Subsequence"><a href="#516-Longest-Palindromic-Subsequence" class="headerlink" title="516. Longest Palindromic Subsequence"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. Longest Palindromic Subsequence</a></h5><blockquote><p>  给定一个字符串<code>s</code>，找到其中最长的回文子序列，并返回该序列的长度。可以假设<code>s</code>的最大长度为<code>1000</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bbbab&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbbd&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: One possible longest palindromic subsequence is &quot;bb&quot;.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示子串 s[i..j] 中的最长回文子序列</span></span><br><span class="line"><span class="comment">// if s[i] == s[j]</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i + 1][j - 1] + 2</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[0][n - 1]</span></span><br><span class="line"><span class="comment">// 显然 i == j 时 dp[i][j] = 1, i &gt; j 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1143-Longest-Common-Subsequence"><a href="#1143-Longest-Common-Subsequence" class="headerlink" title="1143. Longest Common Subsequence"></a><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. Longest Common Subsequence</a></h5><blockquote><p>  给定两个字符串<code>text1</code>和<code>text2</code>，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回<code>0</code>。</p><p>  一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>  例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的子序列，但<code>&quot;aec&quot;</code>不是<code>&quot;abcde&quot;</code>的子序列。两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度</span></span><br><span class="line"><span class="comment">// if text1[i] == text1[j]</span></span><br><span class="line"><span class="comment">// dp[i][j] = 1 + dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[m][n]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 || j == 0 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.size();</span><br><span class="line">    <span class="keyword">int</span> n = text2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="583-Delete-Operation-for-Two-Strings"><a href="#583-Delete-Operation-for-Two-Strings" class="headerlink" title="583. Delete Operation for Two Strings"></a><a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. Delete Operation for Two Strings</a></h5><blockquote><p>  Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of <strong>steps</strong> required to make</em> <code>word1</code> <em>and</em> <code>word2</code> <em>the same</em>.</p><p>  In one <strong>step</strong>, you can delete exactly one character in either string.</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;sea&quot;, word2 &#x3D; &quot;eat&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;leetcode&quot;, word2 &#x3D; &quot;etco&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看出来, 一番删除操作之后剩下的字符串就是它们的最长公共子序列</span></span><br><span class="line"><span class="comment">// 所以就相当于问删除了多少字符后可以变成最长公共子序列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lcs = longestCommonSubsequence(word1, word2);</span><br><span class="line">    <span class="keyword">return</span> word1.size() - lcs + word2.size() - lcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度</span></span><br><span class="line"><span class="comment">// if text1[i] == text1[j]</span></span><br><span class="line"><span class="comment">// dp[i][j] = 1 + dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[m][n]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 || j == 0 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = text1.size();</span><br><span class="line">    <span class="keyword">int</span> n = text2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="712-Minimum-ASCII-Delete-Sum-for-Two-Strings"><a href="#712-Minimum-ASCII-Delete-Sum-for-Two-Strings" class="headerlink" title="712. Minimum ASCII Delete Sum for Two Strings"></a><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">712. Minimum ASCII Delete Sum for Two Strings</a></h5><blockquote><p>  给定两个字符串<code>s1, s2</code>，找到使两个字符串相等所需删除字符的<code>ASCII</code>值的最小和。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;sea&quot;, s2 &#x3D; &quot;eat&quot;</span><br><span class="line">Output: 231</span><br><span class="line">Explanation: Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.</span><br><span class="line">Deleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.</span><br><span class="line">At the end, both strings are equal, and 115 + 116 &#x3D; 231 is the minimum sum possible to achieve this.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 &#x3D; &quot;delete&quot;, s2 &#x3D; &quot;leet&quot;</span><br><span class="line">Output: 403</span><br><span class="line">Explanation: Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,</span><br><span class="line">adds 100[d]+101[e]+101[e] to the sum.  Deleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.</span><br><span class="line">At the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 &#x3D; 403.</span><br><span class="line">If instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher.</span><br></pre></td></tr></table></figure><p>  <strong>Note:</strong></p><p>  <code>0 &lt; s1.length, s2.length &lt;= 1000</code>.</p><p>  All elements of each string will have an ASCII value in <code>[97, 122]</code>.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和 LCS 的思路有些许相似之处</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示把 s1[0..i-1] 和 s2[0..j-1] 变相同所删除字符的最小和</span></span><br><span class="line"><span class="comment">// if s1[i - 1] == s2[j - 1]</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1])</span></span><br><span class="line"><span class="comment">// 我们要求的目标是 dp[m][n]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 时 dp[i][j] = sum(s2[0..j-1])</span></span><br><span class="line"><span class="comment">//     j == 0 时 dp[i][j] = sum(s1[0..i-1])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.size();</span><br><span class="line">    <span class="keyword">int</span> n = s2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + s1[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = min(dp[i][j - <span class="number">1</span>] + s2[j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j] + s1[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="368-Largest-Divisible-Subset"><a href="#368-Largest-Divisible-Subset" class="headerlink" title="368. Largest Divisible Subset"></a><a href="https://leetcode.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. Largest Divisible Subset</a></h5><blockquote><p>  给你一个由无重复正整数组成的集合<code>nums</code>，请你找出并返回其中最大的整除子集<code>answer</code>，子集中每一元素对<code>(answer[i], answer[j])</code>都应当满足：</p><ul><li><p><code>answer[i] % answer[j] == 0</code>，或<code>answer[j] % answer[i] == 0</code></p><p>如果存在多个有效解子集，返回其中任何一个均可。</p></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: [1,3] is also accepted.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,4,8]</span><br><span class="line">Output: [1,2,4,8]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题要先把数组按照升序排列, 排完序之后就是求最长倍增子序列</span></span><br><span class="line"><span class="comment">// 动态规划 dp[i] 表示以 nums[i] 结尾的最长倍增子序列的长度</span></span><br><span class="line"><span class="comment">// 要求的目标为 dp 数组中的最大值</span></span><br><span class="line"><span class="comment">// base case 以 nums[i] 结尾的最长倍增子序列至少要包含它自己 dp[0..] = 1</span></span><br><span class="line"><span class="comment">// dp[i] = max(dp[i], dp[j] + 1) j 属于 [0..i) 且 nums[i] % nums[j] == 0</span></span><br><span class="line"><span class="comment">// 就是在前面找到可以被 nums[i] 整除的子序列, 把 nums[i] 接到后面, 长度加 1 即可</span></span><br><span class="line"><span class="comment">// 可能有很多个满足条件的接法, 选择长度最大的接法</span></span><br><span class="line"><span class="comment">// 但是由于这题不是让我们输出最长倍增子序列的个数, 而是把它们作为数组输出</span></span><br><span class="line"><span class="comment">// 所以 dp 数组里存的不止是最大个数, 还有它上一个数的索引</span></span><br><span class="line"><span class="comment">// 这样最后通过 dp 数组中的最大值, 找到前一个数的索引, 然后反推前面所有的数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// &#123;最长倍增子序列个数, 上一个数的索引&#125;</span></span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; dp(n, &#123;1, -1&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[i].first &lt; dp[j].first + <span class="number">1</span>)</span><br><span class="line">                dp[i] = &#123;dp[j].first + <span class="number">1</span>, j&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = max_element(dp.begin(), dp.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res.push_back(nums[distance(dp.begin(), it)]);</span><br><span class="line">    <span class="keyword">int</span> index = it-&gt;second;</span><br><span class="line">    <span class="keyword">while</span>(index != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(nums[index]);</span><br><span class="line">        index = dp[index].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock</a></h5><blockquote><p>  给定一个数组<code>prices</code>，它的第<code>i</code>个元素<code>prices[i]</code>表示一支给定股票第<code>i</code>天的价格。</p><p>  你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>  返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code>0</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit &#x3D; 0.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接贪心算法</span></span><br><span class="line"><span class="comment">// 要在价格最低点买, 价格最高点卖掉</span></span><br><span class="line"><span class="comment">// 从前往后遍历, 记录史最低点</span></span><br><span class="line"><span class="comment">// 今天卖掉的利润等于今天的价格减去历史最低点的价格</span></span><br><span class="line"><span class="comment">// 每一天都考虑是否卖掉, 如果今天卖掉比之前卖掉得到的利润大就卖掉</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="keyword">int</span> minPrice = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="comment">// 如果今天的价格比历史最低点价格还低, 更新最低价格</span></span><br><span class="line">    <span class="keyword">if</span>(prices[i] &lt; minPrice)</span><br><span class="line">            minPrice = prices[i];</span><br><span class="line">    <span class="comment">// 否则, 如果今天卖出的话比之前卖出得到的利润大, 就卖出</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prices[i] - minPrice &gt; maxProfit)</span><br><span class="line">            maxProfit = prices[i] - minPrice;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 但是这种情况下, 【由于只能交易一次】, 你当天才买进的话, 之前的利润肯定是 0, 即 dp[i - 1][0] = 0</span></span><br><span class="line"><span class="comment">// 所以, dp[i][1] = max(dp[i - 1][1], - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="number">0</span> - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II</a></h5><blockquote><p>  给定一个数组<code>prices</code>，其中<code>prices[i]</code>是一支给定股票第<code>i</code>天的价格。</p><p>  设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e., max profit &#x3D; 0.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题交易次数不限</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. Best Time to Buy and Sell Stock III</a></h5><blockquote><p>  给定一个数组，它的第<code>i</code>个元素是一支给定的股票在第<code>i</code>天的价格。</p><p>  设计一个算法来计算你所能获取的最大利润。你最多可以完成<strong>两笔交易</strong>。</p><p>  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br><span class="line">Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0.</span><br></pre></td></tr></table></figure><p>  <strong>Example 4:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题就是下一题 k = 2 的情形</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">           dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. Best Time to Buy and Sell Stock IV</a></h5><blockquote><p>  给定一个整数数组<code>prices</code>，它的第<code>i</code>个元素<code>prices[i]</code>是一支给定的股票在第<code>i</code>天的价格。</p><p>  设计一个算法来计算你所能获取的最大利润。你最多可以<strong>完成<code>k</code>笔交易</strong>。</p><p>  注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 2) and sell on day 2 (price &#x3D; 4), profit &#x3D; 4-2 &#x3D; 2.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 2) and sell on day 3 (price &#x3D; 6), profit &#x3D; 6-2 &#x3D; 4. Then buy on day 5 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题我们最多可以完成 k 笔交易</span></span><br><span class="line"><span class="comment">// 所以有三个状态 [天数], [交易次数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][j][0] 表示第 i 天没有持有股票, 交易次数为 j 时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][j][1] 表示第 i 天持有股票, 交易次数为 j 时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][j][0] = max(dp[i - 1][j][1] + prices[i - 1], dp[i - 1][j][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票 (买进的时候交易次数加 1)</span></span><br><span class="line"><span class="comment">// dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][k][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][j][0] = 0, dp[0][j][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="comment">// 当 j == 0 时, dp[i][0][0] = 0, dp[i][0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i][j][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">           dp[i][j][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. Best Time to Buy and Sell Stock with Cooldown</a></h5><blockquote><p>  给定一个整数数组，其中第<code>i</code>个元素代表了第<code>i</code>天的股票价格 。</p><p>  设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>  你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为<code>1</code>天)。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,0,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: transactions &#x3D; [buy, sell, cooldown, buy, sell]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题交易次数不限, 但是有冷冻期, 因此买进的时候需要看大前天的状态</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 只能大前天没有持有股票且没有卖出股票, 当天才能买进股票</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i - 1])</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="comment">// 当 i == 1 时, dp[1][0] = 0, dp[1][1] = -prices[0]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 第 1 天的情况已经知道了, 直接从第 2 天开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. Best Time to Buy and Sell Stock with Transaction Fee</a></h5><blockquote><p>给定一个数组<code>prices</code>，其中<code>prices[i]</code>是一支给定股票第<code>i</code>天的价格。非负整数<code>fee</code>表示交易一次股票需要支付的费用。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题交易次数不限</span></span><br><span class="line"><span class="comment">// 状态有两个 [天数] 和 [是否持有股票]</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润</span></span><br><span class="line"><span class="comment">// 如果在第 i 天没有持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天将股票卖出了</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天也没买进</span></span><br><span class="line"><span class="comment">// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])</span></span><br><span class="line"><span class="comment">// 如果在第 i 天持有股票, 有两种可能</span></span><br><span class="line"><span class="comment">// 1. 前一天持有股票, 当天没有卖出</span></span><br><span class="line"><span class="comment">// 2. 前一天没有持有股票, 当天买进股票</span></span><br><span class="line"><span class="comment">// 这里选择买进股票时支付手续费, 相当于买进价格升高了呗</span></span><br><span class="line"><span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1] - fee)</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. Combination Sum IV</a></h5><blockquote><p>  给你一个由<strong>不同整数</strong>组成的数组<code>nums</code>，和一个目标整数<code>target</code>。请你从<code>nums</code>中找出并返回总和为<code>target</code>的元素组合的个数。</p><p>  题目数据保证<strong>答案符合</strong><code>32</code>位整数范围。</p><p>  示例 1：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], target &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。（这特么就是排列呀！！！）</span><br></pre></td></tr></table></figure><p>  示例 2：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9], target &#x3D; 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memo.resize(target + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的定义为凑够和为 target 的组合数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[target] != <span class="number">-1</span>) <span class="keyword">return</span> memo[target];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        res += dfs(nums, target - num);</span><br><span class="line">    memo[target] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题其实并不是组合问题, 而是排列问题</span></span><br><span class="line"><span class="comment">// 组合不关注元素顺序, 排列才关注元素顺序, 而这题关注元素的顺序!</span></span><br><span class="line"><span class="comment">// 状态有 [排列和 target]</span></span><br><span class="line"><span class="comment">// dp[i] 表示组合的和等于 i 时的不同组合个数</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[target]</span></span><br><span class="line"><span class="comment">// 如果我们考虑将 nums[j] 加入组合中去, 并且放在最后的位置</span></span><br><span class="line"><span class="comment">// [[也就是关注排列中的最后一个数是多少]]</span></span><br><span class="line"><span class="comment">// 那么此时 dp[i] 就等于所有的 dp[i - nums[j]] (j = 0, ...) 之和</span></span><br><span class="line"><span class="comment">// dp[0] = 1 表示 1 种空组合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            <span class="comment">// dp[i] + dp[i - num] 有可能溢出, 这里为了清晰起见没有考虑</span></span><br><span class="line">            <span class="keyword">if</span>(i - num &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这题还可以将其看作一个爬楼梯问题</span></span><br><span class="line"><span class="comment">// 楼梯的阶数一共为 target, 一次可以走的步数为 nums[i]</span></span><br><span class="line"><span class="comment">// 问你一共有多少种走法 (相当于登上最高阶所走步数的所有排列)</span></span><br><span class="line"><span class="comment">// [[只要关注最后一步走多少阶数就容易写出状态转移方程了]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以看作是完全背包问题</span></span><br><span class="line"><span class="comment">// 背包的容量为 target, 有物品 nums[i] 可以无限选取</span></span><br><span class="line"><span class="comment">// 并且相同的物品选择, 物品选取的顺序不同算是不同的选择</span></span><br><span class="line"><span class="comment">// 问你把背包装满有多少种方法</span></span><br><span class="line"><span class="comment">// 这题为了考虑不同的顺序, 因此外循环遍历背包的容量, 内循环遍历物品</span></span><br><span class="line"><span class="comment">// 对于下题 [换零钱 2] 由于顺序不同也算一种选择, 就要外循环遍历物品, 内循环遍历背包的容量</span></span><br></pre></td></tr></table></figure><h5 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change</a></h5><blockquote><p>  给定不同面额的硬币<code>coins</code>和一个总金额<code>amount</code>。编写一个函数来计算可以凑成总金额所需的<strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回<code>-1</code>。</p><p>  你可以认为每种硬币的数量是无限的。</p><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 10^4</code></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1,2,5], amount &#x3D; 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态只有 金额数</span></span><br><span class="line"><span class="comment">// 选择有若干枚硬币</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示凑够金额 i 元的最少硬币数</span></span><br><span class="line"><span class="comment">// dp[i] = min(dp[i - k] + 1) k 为每种硬币的面值</span></span><br><span class="line"><span class="comment">// 目标是求 dp[amount]</span></span><br><span class="line"><span class="comment">// 显然 dp[0] = 0 就是不用任何面值的硬币就凑够了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 数组中每个值初始化为 amount + 1 表示不可能</span></span><br><span class="line">    <span class="comment">// 因为只使用 1 元硬币最多也就需要 amount 个硬币</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= coin)</span><br><span class="line">            dp[i] = min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以看成是一个完全背包问题</span></span><br><span class="line"><span class="comment">// 状态有 [使用的硬币] 和 [凑成的总金额]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示只使用前 i 个硬币凑成金额为 j 时的最少硬币数</span></span><br><span class="line"><span class="comment">// 对于第 i 枚硬币有使用和不使用两种选择</span></span><br><span class="line"><span class="comment">// 如果不使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j] 继承之前的硬币数</span></span><br><span class="line"><span class="comment">// 如果使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i][j - coins[i - 1]] + 1</span></span><br><span class="line"><span class="comment">// 表示只使用前 i 种硬币凑够 j - coins[i - 1] 的硬币数, 再加上使用的这枚硬币</span></span><br><span class="line"><span class="comment">// 因为要求最少的硬币数, 这两种选择的结果取小值</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1);</span></span><br><span class="line"><span class="comment">// 显然 j == 0 时 dp[i][0] = 0 就是不凑就够了, 数量为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.size();</span><br><span class="line">    <span class="comment">// 都初始化为 amount + 1 表示不可能的结果, min 时会排除掉</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>, amount + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= coins[i - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount] == amount + <span class="number">1</span> ? <span class="number">-1</span> : dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">518. Coin Change 2</a></h5><blockquote><p>  给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的<strong>硬币组合数</strong>。假设每一种面额的硬币有无限个。</p><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= coins.size() &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount &#x3D; 5, coins &#x3D; [1,2,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5 &#x3D; 5</span><br><span class="line">5 &#x3D; 2 + 2 + 1</span><br><span class="line">5 &#x3D; 2 + 1 + 1 + 1</span><br><span class="line">5 &#x3D; 1 + 1 + 1 + 1 + 1</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: amount &#x3D; 3, coins &#x3D; [2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: the amount of 3 cannot be made up just with coins of 2.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包问题</span></span><br><span class="line"><span class="comment">// 状态有 [使用的硬币] 和 [凑成的总金额]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示只使用前 i 个硬币凑成金额为 j 时的组合数</span></span><br><span class="line"><span class="comment">// 对于第 i 枚硬币有使用和不使用两种选择</span></span><br><span class="line"><span class="comment">// 如果不使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j] 继承之前的组合数</span></span><br><span class="line"><span class="comment">// 如果使用</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i][j - coins[i - 1]] 表示使用前 i 种硬币凑够 j - coins[i - 1] 的组合数</span></span><br><span class="line"><span class="comment">// 因为要求总的组合数, 这两种选择的结果相加</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 时 dp[0][j] = 0 不使用任何硬币</span></span><br><span class="line"><span class="comment">//     j == 0 时 dp[i][0] = 1 就是不凑就够了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = coins.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(amount + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= coins[i - <span class="number">1</span>])</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - coins[i - <span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="474-Ones-and-Zeroes"><a href="#474-Ones-and-Zeroes" class="headerlink" title="474. Ones and Zeroes"></a><a href="https://leetcode.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener">474. Ones and Zeroes</a></h5><blockquote><p>  给你一个二进制字符串数组<code>strs</code>和两个整数<code>m</code>和<code>n</code>。</p><p>  请你找出并返回<code>strs</code>的最大子集的大小，该子集中最多有<code>m</code>个<code>0</code>和<code>n</code>个<code>1</code>。</p><p>  如果<code>x</code>的所有元素也是<code>y</code>的元素，集合<code>x</code>是集合<code>y</code>的子集 。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m &#x3D; 5, n &#x3D; 3</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The largest subset with at most 5 0&#39;s and 3 1&#39;s is &#123;&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, so the answer is 4.</span><br><span class="line">Other valid but smaller subsets include &#123;&quot;0001&quot;, &quot;1&quot;&#125; and &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;.</span><br><span class="line">&#123;&quot;111001&quot;&#125; is an invalid subset because it contains 4 1&#39;s, greater than the maximum of 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The largest subset is &#123;&quot;0&quot;, &quot;1&quot;&#125;, so the answer is 2.</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 600</code></li><li><code>1 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> consists only of digits <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>.</li><li><code>1 &lt;= m, n &lt;= 100</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01背包问题</span></span><br><span class="line"><span class="comment">// 这里有两个背包, 一个装 0, 一个装 1</span></span><br><span class="line"><span class="comment">// 每个物品(串)同时消耗两个背包的容量, 每个物品的价值为 1</span></span><br><span class="line"><span class="comment">// 状态有 [可选择的物品], [背包 0 的容量] 和 [背包 1 的容量]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j][k] 表示只装前 i 个物品, 背包 0 和 1 的容量分别为 j 和 k 时所能装的最大价值</span></span><br><span class="line"><span class="comment">// 对于第 i 个物品 strs[i - 1] 你的选择就是装与不装</span></span><br><span class="line"><span class="comment">// 1. 不装</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j][k]</span></span><br><span class="line"><span class="comment">// 2. 装</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j - cost_0(strs[i - 1])][k - cost_1(strs[i - 1])]</span></span><br><span class="line"><span class="comment">// 因为要求的是最大价值, 那就比较两种选择孰大孰小</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - cost_0(strs[i - 1])][k - cost_1(strs[i - 1])])</span></span><br><span class="line"><span class="comment">// 显然当 i == 0 时, dp[0][j][k] = 0, 没有物品可以装, 价值只能是 0</span></span><br><span class="line"><span class="comment">//       j == 0 || k == 0 时, dp[0][j][k] = 0, 背包没有容量了价值也是 0</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[sz][m][n]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = strs.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(sz + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n  + <span class="number">1</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [zeros, ones] = count_01(strs[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 注意 j 和 k 的起始索引, 有可能物品只消耗其中一种背包的容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; zeros || k &lt; ones)</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                dp[i][j][k] = max(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - zeros][k - ones] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sz][m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt; count_01(const string&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, n = str.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str) <span class="keyword">if</span>(c == <span class="string">'0'</span>) cnt++;</span><br><span class="line">    <span class="keyword">return</span> &#123;cnt, n - cnt&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">139. Word Break</a></h5><blockquote><p>  给定一个非空字符串<code>s</code>和一个包含非空单词的列表<code>wordDict</code>，判定<code>s</code>是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>  说明：</p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;,&quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和背包问题有点类似, 但有不同之处</span></span><br><span class="line"><span class="comment">// 状态有 [可选择的字符]</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示对于前 i 个字符是否有满足条件的划分</span></span><br><span class="line"><span class="comment">// 和背包之处不同在于, 对于第 i 个字符 s[i - 1] 只有一个选择, 就是必须选择</span></span><br><span class="line"><span class="comment">// 这时我们需要将前 i 个字符用索引 j 划分为两部分</span></span><br><span class="line"><span class="comment">// 对于前半部分 s[0..j-1] 可以利用已经算出来的 dp[j]</span></span><br><span class="line"><span class="comment">// 后半部分 s[j..i-1] 需要单独判断是否在单词集合中</span></span><br><span class="line"><span class="comment">// 所以 dp[i] = dp[i] || (dp[j] &amp;&amp; (s[j..i-1] in wordDict)) j 从 0 到 i - 1</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; setting;</span><br><span class="line">    setting.insert(wordDict.begin(), wordDict.end());</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 为了需要, 我们定义空串是有效的</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            dp[i] = dp[i] || (dp[j] &amp;&amp; setting.count(s.substr(j, i - j)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; setting;</span><br><span class="line">    setting.insert(wordDict.begin(), wordDict.end());</span><br><span class="line">    <span class="keyword">return</span> dfs(s, setting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo.count(s)) <span class="keyword">return</span> memo[s];</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(setting.count(s.substr(<span class="number">0</span>, i)) &amp;&amp; dfs(s.substr(i), setting))</span><br><span class="line">            <span class="keyword">return</span> memo[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> memo[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title="140. Word Break II"></a><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">140. Word Break II</a></h5><blockquote><p>  给定一个非空字符串<code>s</code>和一个包含非空单词列表的字典<code>wordDict</code>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p><p>  说明：</p><ul><li>分隔时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li><li><code>1 &lt;= s.size() &lt;= 20</code></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsanddog&quot;, wordDict &#x3D; [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]</span><br><span class="line">Output: [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pineapplepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]</span><br><span class="line">Output: [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]</span><br><span class="line">Explanation: Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sentences;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; setting;</span><br><span class="line">    setting.insert(wordDict.begin(), wordDict.end());</span><br><span class="line">    dfs(s, <span class="string">""</span>, setting);</span><br><span class="line">    <span class="keyword">return</span> sentences;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> sentence, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        sentence.pop_back();</span><br><span class="line">        sentences.push_back(sentence);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!setting.count(s.substr(<span class="number">0</span>, i)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(s.substr(i), sentence + s.substr(<span class="number">0</span>, i) + <span class="string">" "</span>, setting);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum</a></h5><blockquote><p>  Given a <strong>non-empty</strong> array <code>num</code> containing <strong>only positive integers</strong>, find if the array can be partitioned into <strong>two subsets</strong> such that <strong>the sum of elements in both subsets is equal</strong>.</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,5]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The array cannot be partitioned into equal sum subsets.</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化为背包问题进行求解</span></span><br><span class="line"><span class="comment">// 我们把数组分成两部分</span></span><br><span class="line"><span class="comment">// 1. sumA = sumB</span></span><br><span class="line"><span class="comment">// 2. sumA + sumB = sum</span></span><br><span class="line"><span class="comment">// 所以有 sumA = sum / 2</span></span><br><span class="line"><span class="comment">// 也就是说现在有一个背包的容量恰好是 sum / 2</span></span><br><span class="line"><span class="comment">// 问我们是否有一种装法恰好装满背包</span></span><br><span class="line"><span class="comment">// 背包问题的状态一般就两个 [可选择的物品] 和 [背包的容量]</span></span><br><span class="line"><span class="comment">// 所以我们定义 dp[i][j] 表示使用前 i 个物品, 背包容量为 j 时是否有一种装法给装满</span></span><br><span class="line"><span class="comment">// 对于第 i 个物品 nums[i - 1] 可以选择装进去和不装进去</span></span><br><span class="line"><span class="comment">// 1. 不装 就要看前 i - 1 个物品能不能装满容量为 j 的背包</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 2. 装 就要看前 i - 1 个物品能不能装满容量为 j - nums[i - 1] 的背包</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 这两种任意一种选择为真的话, 就为真</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][sum/2]</span></span><br><span class="line"><span class="comment">// 显然 i == 0 时, dp[0][j] = false, 没有物品装肯定装不满</span></span><br><span class="line"><span class="comment">//     j == 0 时, dp[i][0] = true, 容量为 0 了就是装满了啊</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果 sum 为奇数, 显然不可能</span></span><br><span class="line">    <span class="keyword">if</span>(sum &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(sum/<span class="number">2</span> + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum/<span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="698-Partition-to-K-Equal-Sum-Subsets"><a href="#698-Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="698. Partition to K Equal Sum Subsets"></a><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener">698. Partition to K Equal Sum Subsets</a></h5><blockquote><p>  给定一个整数数组<code>nums</code>和一个正整数<code>k</code>，找出是否有可能把这个数组分成<code>k</code>个非空子集，其总和都相等。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,3,2,3,5,2,1], k &#x3D; 4</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It&#39;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4], k &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li><li><code>0 &lt;= nums[i] &lt;= 104</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实上题 416(k = 2) 以及 473(k = 4) 都是这题的特例</span></span><br><span class="line"><span class="comment">// 这题很容易超时, 为了尽可能地剪枝我额外做的工作</span></span><br><span class="line"><span class="comment">// 1. 降序排序, 到大于的时候直接 continue</span></span><br><span class="line"><span class="comment">// 2. 去重，相邻元素必须从左往右被使用</span></span><br><span class="line"><span class="comment">// 3. 索引从 start 开始</span></span><br><span class="line"><span class="keyword">int</span> targetSum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(total % k &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    used.resize(nums.size());</span><br><span class="line">    targetSum = total / k;</span><br><span class="line">    sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> canPartitionKSubsets(nums, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> curSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(curSum == targetSum) <span class="keyword">return</span> canPartitionKSubsets(nums, k - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 剪枝 1</span></span><br><span class="line">        <span class="keyword">if</span>(curSum + nums[i] &gt; targetSum)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 剪枝 2</span></span><br><span class="line">        <span class="keyword">if</span>(used[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; !used[i - <span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(canPartitionKSubsets(nums, k, start + <span class="number">1</span>, curSum + nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">55. Jump Game</a></h5><blockquote><p>  给定一个非负整数数组<code>nums</code>，你最初位于数组的<strong>第一个下标</strong>。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也就是问你最多能跳多远</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> farthest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        farthest = max(farthest, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i == farthest) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. Jump Game II</a></h5><blockquote><p>  给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用<strong>最少的跳跃次数</strong>到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,0,1,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示从索引 i 开始跳, 跳到最后需要跳的最少次数</span></span><br><span class="line"><span class="comment">// 显然 dp[n - 1] = 0, 我们要求的是 dp[0]</span></span><br><span class="line"><span class="comment">// dp[i] = 1 + min(dp[j]) j = i .. (i + nums[i])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    dp[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i + j &lt; n; j++)</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i + j]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">索引 2 的覆盖范围最远</th><th align="center">就以其最远索引作为下次起跳的位置</th></tr></thead><tbody><tr><td align="center"><img src="image-20210428181037785.png" alt="image-20210428181037785" style="zoom: 50%;" /></td><td align="center"><img src="image-20210428181149058.png" alt="image-20210428181149058" style="zoom:50%;" /></td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心, 优先跳到下次能跳最远的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> farthest = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jumps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        farthest = max(farthest, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i == end)</span><br><span class="line">        &#123;</span><br><span class="line">            jumps++;</span><br><span class="line">            end = farthest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a><a href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener">1306. Jump Game III</a></h5><blockquote><p>  这里有一个非负整数数组<code>arr</code>，你最开始位于该数组的起始下标<code>start</code>处。当你位于下标<code>i</code>处时，你可以跳到<code>i + arr[i]</code>或者<code>i - arr[i]</code>。请你判断自己是否能够跳到对应元素值为<code>0</code>的任一下标处。注意，不管是什么情况下，你都无法跳到数组之外。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">All possible ways to reach at index 3 with value 0 are: </span><br><span class="line">index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br><span class="line">index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 0</span><br><span class="line">Output: true </span><br><span class="line">Explanation: </span><br><span class="line">One possible way to reach at index 3 with value 0 is: </span><br><span class="line">index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3 </span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [3,0,2,1,2], start &#x3D; 2</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no way to reach at index 1 with value 0.</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>0 &lt;= start &lt; arr.length</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span>(visited[pos]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[pos] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[pos] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos + arr[pos] &lt; n)</span><br><span class="line">            q.push(pos + arr[pos]);</span><br><span class="line">        <span class="keyword">if</span>(pos - arr[pos] &gt;= <span class="number">0</span>)</span><br><span class="line">            q.push(pos - arr[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> canReach(arr, start, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; <span class="number">0</span> || start &gt;= arr.size() || visited[start])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[start] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(canReach(arr, start - arr[start], visited))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(canReach(arr, start + arr[start], visited))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    visited[start] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1345-Jump-Game-IV"><a href="#1345-Jump-Game-IV" class="headerlink" title="1345. Jump Game IV"></a><a href="https://leetcode.com/problems/jump-game-iv/" target="_blank" rel="noopener">1345. Jump Game IV</a></h5><blockquote><p>  给你一个整数数组<code>arr</code>，你一开始在数组的第一个元素处（下标为<code>0</code>）。每一步，你可以从下标<code>i</code>跳到下标：</p><ul><li><p><code>i + 1</code>满足：<code>i + 1 &lt; arr.length</code></p></li><li><p><code>i - 1</code>满足：<code>i - 1 &gt;= 0</code></p></li><li><p><code>j</code>满足：<code>arr[i] == arr[j]</code>且<code>i != j</code></p><p>请你返回到达数组最后一个元素的下标处所需的<strong>最少操作次数</strong>。</p><p>注意：任何时候你都不能跳到数组外面。</p></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [7]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Start index is the last index. You don&#39;t need to jump.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [7,6,9,6,9,6,9,7]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You can jump directly from index 0 to index 7 which is last index of the array.</span><br></pre></td></tr></table></figure><p>  <strong>Example 4:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [6,1,9]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>  <strong>Example 5:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [11,22,7,7,7,7,7,7,7,22,13]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搜索最短路径显然用 bfs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; canJumpTo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        canJumpTo[arr[i]].push_back(i);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(pos == n - <span class="number">1</span>) <span class="keyword">return</span> step;</span><br><span class="line">            visited[pos] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[pos - <span class="number">1</span>])</span><br><span class="line">                q.push(pos - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pos + <span class="number">1</span> &lt; n &amp;&amp; !visited[pos + <span class="number">1</span>])</span><br><span class="line">                q.push(pos + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> jumpTo : canJumpTo[arr[pos]])</span><br><span class="line">                <span class="keyword">if</span>(!visited[jumpTo])</span><br><span class="line">                    q.push(jumpTo);</span><br><span class="line">            <span class="comment">// 同一高度的都已经放入队列等待访问了, 下次就不用再放一次了</span></span><br><span class="line">            <span class="comment">// 必须清空, 否则会 TLE</span></span><br><span class="line">            canJumpTo[arr[pos]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这题遇到一个新情况, 把 unordered_map&lt;int, vector&lt;int&gt;&gt; canJumpTo;</span></span><br><span class="line"><span class="comment">// 里的 vector&lt;int&gt; 换成 unordered_set&lt;int&gt;</span></span><br><span class="line"><span class="comment">// 把清空语句 canJumpTo[arr[pos]] = &#123;&#125;; 变成</span></span><br><span class="line"><span class="comment">// canJumpTo[arr[pos]].clear(); 会超时, 但用 swap 函数就不会</span></span><br><span class="line"><span class="comment">// unordered_set&lt;int&gt; temp; canJumpTo[arr[pos]]swap(temp);</span></span><br><span class="line"><span class="comment">// 奇了怪了!</span></span><br></pre></td></tr></table></figure><h5 id="403-Frog-Jump"><a href="#403-Frog-Jump" class="headerlink" title="403. Frog Jump"></a><a href="https://leetcode.com/problems/frog-jump/" target="_blank" rel="noopener">403. Frog Jump</a></h5><blockquote><p>  一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p><p>  给你石子的位置列表<code>stones</code>（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p><p>  开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格<code>1</code>跳至单元格<code>2</code>）。</p><p>  如果青蛙上一步跳跃了<code>k</code>个单位，那么它接下来的跳跃距离只能选择为<code>k - 1</code>、<code>k</code>或<code>k + 1</code>个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [0,1,3,5,6,8,12,17]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [0,1,2,3,4,8,9,11]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>2 &lt;= stones.length &lt;= 2000</code></li><li><code>0 &lt;= stones[i] &lt;= 231 - 1</code></li><li><code>stones[0] == 0</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;stones, <span class="keyword">int</span> pos, <span class="keyword">int</span> lastJump)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos + <span class="number">1</span> == stones.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">string</span> key = to_string(pos) + <span class="string">","</span> + to_string(lastJump);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt; stones.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// k 是下一次必须跳的步数</span></span><br><span class="line">        <span class="keyword">int</span> k = stones[i] - stones[pos];</span><br><span class="line">        <span class="keyword">if</span>(k &lt; lastJump - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; lastJump + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[key] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(stones, i, k))</span><br><span class="line">            <span class="keyword">return</span> memo[key] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[key] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示是否可以用 j 步 跳到 第 i 块石头上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = stones.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = stones[i] - stones[j];</span><br><span class="line">            <span class="comment">// k 是每次跳的步数, 每跳 1 次下次最多加 1 步</span></span><br><span class="line">            <span class="comment">// 但是升序数组的索引 j 每次至少会加 1 所以 k &lt;= j</span></span><br><span class="line">            <span class="comment">// 在第 j 块石头时，再次起跳距离最大为 j + 1</span></span><br><span class="line">            <span class="comment">// 如果和后一块石头的距离大于最大起跳距离, 就不可能跳过去</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; j + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            dp[i][k] = dp[j][k - <span class="number">1</span>] || dp[j][k] || dp[j][k + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp[n - <span class="number">1</span>][k]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. Regular Expression Matching</a></h5><blockquote><p>  给你一个字符串<code>s</code>和一个模式串<code>p</code>，请你来实现一个支持<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式匹配。</p><ul><li><p><code>&#39;.&#39;</code>匹配任意单个字符</p></li><li><p><code>&#39;*&#39;</code>匹配零个或多个前面的那一个元素</p><p>所谓匹配，是要涵盖整个字符串<code>s</code>的，而不是部分字符串。</p></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ab&quot;, p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure><p>  <strong>Example 4:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aab&quot;, p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure><p>  <strong>Example 5:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;mississippi&quot;, p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 20</code></li><li><code>0 &lt;= p.length &lt;= 30</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.</li><li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// dp[i][j] 表示 s 的前 i 个字符是否和 p 的前 j 个字符相匹配</span></span><br><span class="line"><span class="comment">// 显然我们的目标是求 dp[n][m]</span></span><br><span class="line"><span class="comment">// 1. 当 p 中的第 j 个字符 p[j - 1] != '*' 时</span></span><br><span class="line"><span class="comment">// p[j - 1] 只能选择和 s[i - 1] 进行匹配</span></span><br><span class="line"><span class="comment">// 所以 dp[i][j] = dp[i - 1][j - 1] if s[i - 1] == p[j - 1] or p[j - 1] == '.'</span></span><br><span class="line"><span class="comment">//     dp[i][j] = false if s[i - 1] != p[j - 1] and p[j - 1] != '.'</span></span><br><span class="line"><span class="comment">// 2. 当 p 中的第 j 个字符 p[j - 1] == '*' 时</span></span><br><span class="line"><span class="comment">// p[j - 2] 和 '*' 就组合在一起看</span></span><br><span class="line"><span class="comment">// 2.1 匹配 0 次</span></span><br><span class="line"><span class="comment">//     dp[i][j] = dp[i][j - 2] 不管 p[j - 2] 是否匹配 s[i - 1]</span></span><br><span class="line"><span class="comment">// 2.1 匹配多次</span></span><br><span class="line"><span class="comment">//     dp[i][j] = dp[i - 1][j] if s[i - 1] == p[j - 2] or p[j - 2] == '.'</span></span><br><span class="line"><span class="comment">// 两个空串默认可以匹配 dp[0][0] = true</span></span><br><span class="line"><span class="comment">// 但是这题要特别注意的是, 当 s 为空串时, p 为空串的情况可以是</span></span><br><span class="line"><span class="comment">// "", "c*", "c*c*", ... 它们都应该为 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size(), m = p.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 特别处理 p 为 c*c*... 的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 当 p 中的第 j 个字符 p[j - 1] != '*' 时</span></span><br><span class="line">            <span class="keyword">if</span>(p[j - <span class="number">1</span>] != <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// else</span></span><br><span class="line">                <span class="comment">//     dp[i][j] = false;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 当 p 中的第 j 个字符 p[j - 1] == '*' 时</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.1 匹配 0 次</span></span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 2.1 匹配多次</span></span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="312-Burst-Balloons"><a href="#312-Burst-Balloons" class="headerlink" title="312. Burst Balloons"></a><a href="https://leetcode.com/problems/burst-balloons/" target="_blank" rel="noopener">312. Burst Balloons</a></h5><blockquote><p>  有<code>n</code>个气球，编号为<code>0</code>到<code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p><p>  现在要求你戳破所有的气球。戳破第<code>i</code>个气球，你可以获得<code>nums[i - 1] * nums[i] * nums[i + 1]</code>枚硬币。这里的<code>i - 1</code>和<code>i + 1</code>代表和i相邻的两个气球的序号。如果<code>i - 1</code>或<code>i + 1</code>超出了数组的边界，那么就当它是一个数字为<code>1</code>的气球。</p><p>  求所能获得<strong>硬币的最大数量</strong>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,1,5,8]</span><br><span class="line">Output: 167</span><br><span class="line">Explanation:</span><br><span class="line">nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []</span><br><span class="line">coins &#x3D;  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 &#x3D; 167</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示将第 i 个气球和第 j 个气球(左右开区间)之间的气球戳破最多得到的硬币数</span></span><br><span class="line"><span class="comment">// 显然我们是要求 dp[0][n+1]</span></span><br><span class="line"><span class="comment">// 对于第 i 个气球和第 j 个气球之间的所有气球, 我们考虑最后戳破的那一个气球 k</span></span><br><span class="line"><span class="comment">// 于是可得 dp[i][j] = dp[i][k] + dp[k][j] + nums[i - 1] * nums[k - 1] * nums[j - 1]</span></span><br><span class="line"><span class="comment">// 因为我们要求最大得到的硬币数量, 就对每一个 k 分别计算, 取最大呗</span></span><br><span class="line"><span class="comment">// 当 (i, j) 区间内没有气球时得分显然是 0, 即当 i &gt;= j 时 dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 考虑到边界条件, 在最左最右各放两个虚拟气球</span></span><br><span class="line">    nums.insert(nums.begin(), <span class="number">1</span>);</span><br><span class="line">    nums.insert(nums.end(), <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)</span><br><span class="line">                dp[i][j] = max(dp[i][j],</span><br><span class="line">                               dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="887-Super-Egg-Drop"><a href="#887-Super-Egg-Drop" class="headerlink" title="887. Super Egg Drop"></a><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">887. Super Egg Drop</a></h5><blockquote><p>  给你<code>k</code>枚相同的鸡蛋，并可以使用一栋从第<code>1</code>层到第<code>n</code>层共有<code>n</code>层楼的建筑。</p><p>  已知存在楼层<code>f</code>，满足<code>0 &lt;= f &lt;= n</code>，任何从高于<code>f</code>的楼层落下的鸡蛋都会碎，从<code>f</code>楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>  每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层<code>x</code>扔下（满足<code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中重复使用这枚鸡蛋。</p><p>  请你计算并返回要确定<code>f</code>确切的值的<strong>最坏情况下的最小尝试次数</strong>？</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 1, n &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Drop the egg from floor 1. If it breaks, we know that f &#x3D; 0.</span><br><span class="line">Otherwise, drop the egg from floor 2. If it breaks, we know that f &#x3D; 1.</span><br><span class="line">If it does not break, then we know f &#x3D; 2.</span><br><span class="line">Hence, we need at minimum 2 moves to determine with certainty what the value of f is.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 2, n &#x3D; 6</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k &#x3D; 3, n &#x3D; 14</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= k &lt;= 100</code></li><li><code>1 &lt;= n &lt;= 104</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归 TLE!</span></span><br><span class="line"><span class="comment">// 定义 dp(k, n) 表示有 k 个鸡蛋和 n 层楼时的最坏情况下的最少尝试次数</span></span><br><span class="line"><span class="comment">// 对于从第 1 层到第 n 层中间的某一层 i, 我们扔完之后有两种情况</span></span><br><span class="line"><span class="comment">// 1. 鸡蛋没碎</span></span><br><span class="line"><span class="comment">// 这时我们要寻找的楼层 f 显然在第 i + 1 层到第 n 层之间的共 n - i 层楼</span></span><br><span class="line"><span class="comment">// 于是问题规模缩小至 dp(k, n - i)</span></span><br><span class="line"><span class="comment">// 2. 鸡蛋碎了</span></span><br><span class="line"><span class="comment">// 这时我们要寻找的楼层 f 显然在第 1 层到第 i - 1 层之间的共 i - 1 层楼</span></span><br><span class="line"><span class="comment">// 于是问题规模缩小至 dp(k - 1, i - 1)</span></span><br><span class="line"><span class="comment">// 因为我们要求最坏情况下的最少尝试次数, 什么叫最坏情况下呢？</span></span><br><span class="line"><span class="comment">// 就是说我们并不知道扔完之后鸡蛋碎不碎, 我们要考虑碎或者不碎时的最多尝试次数</span></span><br><span class="line"><span class="comment">// 什么是最少尝试次数呢？就是说我们从第 1 层, 第 2 层...第 n 层依次试一遍, 取最小值</span></span><br><span class="line"><span class="comment">// 所以 dp(k, n) = min(max(dp(k, n - i), dp(k - 1, i - 1))) for x in 1...n</span></span><br><span class="line"><span class="comment">// 当 n == 0 时, 不用扔就可以确定, dp(k, 1) = 0</span></span><br><span class="line"><span class="comment">// 当 n == 1 时, 显然至多至少都是要扔 1 次, dp(k, 1) = 1</span></span><br><span class="line"><span class="comment">// 当 k == 1 时, 显然需要从 1 到 n 一层一层尝试 dp(1, n) = n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> dp(k, n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[k][n] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res = min(res, <span class="number">1</span> + max(dp(k, n - i, memo), dp(k - <span class="number">1</span>, i - <span class="number">1</span>, memo)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[k][n] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="1601009732-AqPWoe-file_1601009732619.jpg" alt="img" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归 + 二分搜索优化 AC!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> dp(k, n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 dp(k, n) 我们观察到 这是一个关于 n 的单调递增函数</span></span><br><span class="line"><span class="comment">// 也就是说在鸡蛋数固定的情况下, 楼层 n 越多, 需要的尝试次数一定不会变少</span></span><br><span class="line"><span class="comment">// 对于我们得出的这两个子问题 dp(k, n - i) 和 dp(k - 1, i - 1)</span></span><br><span class="line"><span class="comment">// 前者随着 i 的增加而减少, 后者随着 i 的增加而增加</span></span><br><span class="line"><span class="comment">// 将其想象成两条直线, 一个单调递增一个单调递减, 我们要求得一个位置 i 使得它们的最大值最小</span></span><br><span class="line"><span class="comment">// 交点处！没错在它们的交点处能满足</span></span><br><span class="line"><span class="comment">// 我们可以利用二分来查找它们的交点, 看上面的图形就明白如何应用二分了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[k][n] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> notBroken = dp(k, n - mi, memo);</span><br><span class="line">        <span class="keyword">int</span> broken = dp(k - <span class="number">1</span>, mi - <span class="number">1</span>, memo);</span><br><span class="line">        <span class="keyword">if</span>(notBroken &gt;= broken) &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">            res = min(res, notBroken + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">            res = min(res, broken + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[k][n] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber</a></h5><blockquote><p>  你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果<strong>两间相邻的房屋</strong>在同一晚上被小偷闯入，系统会自动报警。</p><p>  给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).</span><br><span class="line">Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一</span></span><br><span class="line"><span class="comment">// 定义 dp[i] 表示从第 i 间 (i 从 0 算起) 房屋开始打劫最多能抢到的钱</span></span><br><span class="line"><span class="comment">// 对于第 i 间房屋我们有 2 个选择</span></span><br><span class="line"><span class="comment">// 1. 不抢</span></span><br><span class="line"><span class="comment">// dp[i] = dp[i + 1]</span></span><br><span class="line"><span class="comment">// 2. 抢</span></span><br><span class="line"><span class="comment">// dp[i] = nums[i] + dp[i + 2]</span></span><br><span class="line"><span class="comment">// 要求最多能抢多少钱, 两种选择取大值</span></span><br><span class="line"><span class="comment">// 即 dp[i] = max(dp[i + 1], nums[i] + dp[i + 2])</span></span><br><span class="line"><span class="comment">// 我们要求的目标是 dp[0]</span></span><br><span class="line"><span class="comment">// 当 i == n 时, 没房子抢了, dp[n] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i] = max(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前状态只依赖前两个状态, 可进行空间优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> dp_1 = <span class="number">0</span>, dp_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp_0 = max(dp_1, nums[i] + dp_2);</span><br><span class="line">        dp_2 = dp_1;</span><br><span class="line">        dp_1 = dp_0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法二: 重新定义 dp 数组</span></span><br><span class="line"><span class="comment">// dp[i][0] 表示不抢第 i 间房屋时, 经过了前 i 间所获得的金钱</span></span><br><span class="line"><span class="comment">// dp[i][1] 表示抢第 i 间房屋, 经过了前 i 间所获得的金钱</span></span><br><span class="line"><span class="comment">// 那么 dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])</span></span><br><span class="line"><span class="comment">// dp[i][1] = dp[i - 1][0] + nums[i - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 此家不抢, 上家可抢可不抢, 看哪个收益大</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 此家抢, 上家不能抢</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. House Robber II</a></h5><blockquote><p>  你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong>，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>  给定一个代表每个房屋存放金额的非负整数数组，计算你在<strong>不触动警报装置的情况</strong>下，今晚能够偷窃到的最高金额。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2), because they are adjacent houses.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在题 I 的基础上, 只需考虑三种情况</span></span><br><span class="line"><span class="comment">// 1. 第 0 间和第 n - 1 间都不抢</span></span><br><span class="line"><span class="comment">// 2. 第 0 间抢那么第 n - 1 间就不能抢</span></span><br><span class="line"><span class="comment">// 3. 第 n - 1 间抢那么第 0 间就不能抢</span></span><br><span class="line"><span class="comment">// 比较这三种情况, 取大值即可</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(&#123;rob(nums, <span class="number">1</span>, n - <span class="number">2</span>), rob(nums, <span class="number">0</span>, n - <span class="number">2</span>), rob(nums, <span class="number">1</span>, n - <span class="number">1</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp_1 = <span class="number">0</span>, dp_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">        dp_0 = max(dp_1, nums[i] + dp_2);</span><br><span class="line">        dp_2 = dp_1;</span><br><span class="line">        dp_1 = dp_0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="337-House-Robber-III"><a href="#337-House-Robber-III" class="headerlink" title="337. House Robber III"></a><a href="https://leetcode.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. House Robber III</a></h5><blockquote><p>  在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>  计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>  <strong>Example 1:</strong></p>  <img src="rob1-tree.jpg" alt="img" style="zoom: 67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,2,3,null,3,null,1]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Maximum amount of money the thief can rob &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <img src="rob2-tree.jpg" alt="img" style="zoom:67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,4,5,1,3,null,1]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: Maximum amount of money the thief can rob &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 I 题方法 2 的思路下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;不抢 root 最多得到的钱, 抢 root 最多得到的钱&gt;</span></span><br><span class="line">    <span class="keyword">auto</span> dfs = [](<span class="keyword">auto</span>&amp;&amp; dfs, TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [l_norob, l_rob] = dfs(dfs, root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [r_norob, r_rob] = dfs(dfs, root-&gt;right);</span><br><span class="line">        <span class="comment">// 不抢, 左右两家家可抢可不抢, 看哪个收益大</span></span><br><span class="line">        <span class="keyword">auto</span> norob = max(l_norob, l_rob) + max(r_norob, r_rob);</span><br><span class="line">        <span class="comment">// 抢, 左右两家不能抢</span></span><br><span class="line">        <span class="keyword">auto</span> rob = l_norob + root-&gt;val + r_norob;</span><br><span class="line">        <span class="keyword">return</span> make_pair(norob, rob);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> [norob, rob] = dfs(dfs, root);</span><br><span class="line">    <span class="keyword">return</span> max(norob, rob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="740-Delete-and-Earn"><a href="#740-Delete-and-Earn" class="headerlink" title="740. Delete and Earn"></a><a href="https://leetcode.com/problems/delete-and-earn/" target="_blank" rel="noopener">740. Delete and Earn</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>，你可以对它进行一些操作。</p><p>  每次操作中，选择任意一个<code>nums[i]</code>，删除它并获得<code>nums[i]</code>的点数。之后，你必须删除每个等于<code>nums[i] - 1</code>或<code>nums[i] + 1</code>的元素。</p><p>  开始你拥有<code>0</code>个点数。返回你能通过这些操作获得的<strong>最大点数</strong>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,2]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted.</span><br><span class="line">Then, delete 2 to earn 2 points.</span><br><span class="line">6 total points are earned.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,3,3,3,4]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: Delete 3 to earn 3 points, deleting both 2&#39;s and the 4.</span><br><span class="line">Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.</span><br><span class="line">9 total points are earned.</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在选择了元素 x 后, x, x - 1, x + 1 都会被删除</span></span><br><span class="line"><span class="comment">// 并且我们可以一下选择剩余的所有 x 以尽可能多的获得点数</span></span><br><span class="line"><span class="comment">// 如果我们定义 dp[i] 表示元素 i 开始选择可以获得的点数</span></span><br><span class="line"><span class="comment">// 选择元素 i 获得的点数等于 i * (i 出现的次数)</span></span><br><span class="line"><span class="comment">// 那么这题就和上面的打家劫舍题 I 相同了</span></span><br><span class="line"><span class="comment">// 也即是说抢劫了第 i 间房屋, i - 1 和 i + 1 都不能抢了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">counts</span><span class="params">(maxVal + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        counts[num]++;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(maxVal + <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = maxVal; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        dp[i] = max(dp[i + <span class="number">1</span>], i * counts[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理一下, 可以直接调用打家劫舍的 rob 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// sum[x] 等于所有 x 之和</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(maxVal + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        sum[num] += num;</span><br><span class="line">    <span class="keyword">return</span> rob(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        dp[i] = max(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. Maximum Subarray</a></h5><blockquote><p>  给定一个整数数组<code>nums</code>，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,4,-1,7,8]</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力 超时</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n2) 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            res = max(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划 dp[i] 表示以 nums[i] 结尾的连续子数组的最大和</span></span><br><span class="line"><span class="comment">// 时间复杂度和空间复杂度均为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 dp[i] 只与上一个状态 dp[i - 1] 和 nums[i] 有关</span></span><br><span class="line"><span class="comment">// 通过一个变量记录上一个状态值将空间复杂度压缩到 O(1)</span></span><br><span class="line"><span class="comment">// 并且同时使用一个变量更新状态中的最大值</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(n) 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> preState = <span class="number">0</span>, curState = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        curState = nums[i];</span><br><span class="line">        <span class="keyword">if</span>(preState &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curState += preState;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, curState);</span><br><span class="line">        preState = curState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法 (还没搞懂)</span></span><br><span class="line"><span class="comment">// 时间复杂度 O(nlogn) 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binary_search(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = binary_search(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> rightMax = binary_search(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">int</span> midMax = nums[mid], t = midMax;</span><br><span class="line">    <span class="comment">// 开始计算左边的最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">        t += nums[i];</span><br><span class="line">        midMax = max(midMax, t);</span><br><span class="line">    &#125;</span><br><span class="line">    t = midMax;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        t += nums[i];</span><br><span class="line">        midMax = max(midMax, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(midMax, max(leftMax, rightMax));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. Maximum Product Subarray</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><ul><li>参考链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray/solution/dong-tai-gui-hua-li-jie-wu-hou-xiao-xing-by-liweiw/" target="_blank" rel="noopener">动态规划（理解无后效性） - 乘积最大子数组</a></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果还是定义 dp[i] 表示以 nums[i] 结尾的连续子数组的最大乘积</span></span><br><span class="line"><span class="comment">// 继续以 53 题的思路解决这道题是错误的做法</span></span><br><span class="line"><span class="comment">// 因为数组中负数的出现会使得正的最大值乘以负数而可能变成最小值</span></span><br><span class="line"><span class="comment">// 而负的最小值乘以一个负数而可能会变成最大值</span></span><br><span class="line"><span class="comment">// 也就是说乘积的最大值和最小值会由于当前的数的正负而发生转化</span></span><br><span class="line"><span class="comment">// 所以这题要根据 nums[i] 的正负来分别考虑以 nums[i] 结尾的子数组的最大值和最小值两种情况</span></span><br><span class="line"><span class="comment">// 定义 dp[0][i] 和 dp[1][i] 分别表示以 nums[i] 结尾的子数组的乘积的最小值和最大值</span></span><br><span class="line"><span class="comment">// 当 nums[i] &gt; 0 时</span></span><br><span class="line"><span class="comment">// dp[0][i] = min(nums[i] * dp[0][i - 1], nums[i])</span></span><br><span class="line"><span class="comment">// dp[1][i] = max(nums[i] * dp[1][i - 1], numa[i])</span></span><br><span class="line"><span class="comment">// 当 nums[i] &lt; 0 时</span></span><br><span class="line"><span class="comment">// dp[0][i] = min(nums[i] * dp[1][i - 1], nums[i])</span></span><br><span class="line"><span class="comment">// dp[1][i] = max(nums[i] * dp[0][i - 1], numa[i])</span></span><br><span class="line"><span class="comment">// 这题也可以问你连续子数组的最小乘积是多少</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>] * nums[i], nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>] * nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>] * nums[i], nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>] * nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, dp[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前状态只依赖前一个状态, 故可以使用滚动变量进行空间优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> dp_0_0 = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> dp_1_0 = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = dp_1_0;</span><br><span class="line">    <span class="comment">// 滚动变量</span></span><br><span class="line">    <span class="keyword">int</span> dp_0_1, dp_1_1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp_0_1 = min(nums[i] * dp_0_0, nums[i]);</span><br><span class="line">            dp_1_1 = max(nums[i] * dp_1_0, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp_0_1 = min(nums[i] * dp_1_0, nums[i]);</span><br><span class="line">            dp_1_1 = max(nums[i] * dp_0_0, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp_0_0 = dp_0_1;</span><br><span class="line">        dp_1_0 = dp_1_1;</span><br><span class="line">        res = max(res, dp_1_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1262-Greatest-Sum-Divisible-by-Three"><a href="#1262-Greatest-Sum-Divisible-by-Three" class="headerlink" title="1262. Greatest Sum Divisible by Three"></a><a href="https://leetcode.com/problems/greatest-sum-divisible-by-three/" target="_blank" rel="noopener">1262. Greatest Sum Divisible by Three</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>，请你找出并返回能被<code>3</code>整除的<strong>元素最大和</strong>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,6,5,1,8]</span><br><span class="line">Output: 18</span><br><span class="line">Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Since 4 is not divisible by 3, do not pick any number.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,4]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 4 * 10^4</code></li><li><code>1 &lt;= nums[i] &lt;= 10^4</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示对于前 i 个数, 选取的数字和对 3 取余为 j 的最大和 (j == 0, 1, 2)</span></span><br><span class="line"><span class="comment">// 我们的目标是要求 dp[n][0]</span></span><br><span class="line"><span class="comment">// 那么如果进行状态转移呢？</span></span><br><span class="line"><span class="comment">// 需要看第 i 个数 nums[i - 1] 对 3 取余的情况</span></span><br><span class="line"><span class="comment">// 1. 余数为 0</span></span><br><span class="line">    <span class="comment">// 加到哪一个最大和身上对 3 取余的结果不变</span></span><br><span class="line">    <span class="comment">// dp[i][0] = max(dp[i - 1][0], dp[i - 1][0] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][1] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// dp[i][2] = max(dp[i - 1][2], dp[i - 1][2] + nums[i - 1])</span></span><br><span class="line"><span class="comment">// 2. 余数为 1</span></span><br><span class="line">    <span class="comment">// 加到原来余 2 的最大和身上, 余数变成 0</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// 加到原来余 0 的最大和身上, 余数变成 1</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// 加到原来余 1 的最大和身上, 余数变成 2</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + nums[i - 1])</span></span><br><span class="line"><span class="comment">// 3. 余数为 2</span></span><br><span class="line">    <span class="comment">// 加到原来余 1 的最大和身上, 余数变成 0</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// 加到原来余 2 的最大和身上, 余数变成 1</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][1] = max(dp[i - 1][1], dp[i - 1][2] + nums[i - 1])</span></span><br><span class="line">    <span class="comment">// 加到原来余 0 的最大和身上, 余数变成 2</span></span><br><span class="line">    <span class="comment">// 所以 dp[i][2] = max(dp[i - 1][2], dp[i - 1][0] + nums[i - 1])</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// k 为任意数的一般情况</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k))</span></span>;</span><br><span class="line">    <span class="comment">// 这个初始化有点不太好想到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = nums[i - <span class="number">1</span>] % k;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][(k - mod + j) % k] + nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在理解了上一种解法的基础上, 下面这种思路更好</span></span><br><span class="line"><span class="comment">// dp[i] 表示选择的数字累加和模 3 == i 的数字和</span></span><br><span class="line"><span class="comment">// 对于 nums[i], 如果 nums[i] % 3 == 1, 那么将其加到之前模 3 == 2 的最大和上面</span></span><br><span class="line"><span class="comment">// 就变成了模 3 == 0 了, 所以 dp[0] = max(dp[0], dp[2] + nums[i])</span></span><br><span class="line"><span class="comment">// 依次类推, 对于每一个 nums[i] 都要更新 dp 数组的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// k 为任意数的一般情况</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 备份上一个状态</span></span><br><span class="line">        <span class="comment">// 因为要用上一个状态的值来更新当前状态</span></span><br><span class="line">        <span class="keyword">auto</span> temp = dp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> maxSum : temp) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = (maxSum + num) % k;</span><br><span class="line">            dp[mod] = max(dp[mod], maxSum + num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="486-Predict-the-Winner"><a href="#486-Predict-the-Winner" class="headerlink" title="486. Predict the Winner"></a><a href="https://leetcode.com/problems/predict-the-winner/" target="_blank" rel="noopener">486. Predict the Winner</a></h5><blockquote><p>  给定一个表示分数的非负整数数组。 玩家<code>A</code>从数组任意一端拿取一个分数，随后玩家<code>B</code>继续从剩余数组任意一端拿取分数，然后玩家<code>A</code>拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>  给定一个表示分数的数组，预测作为先手的玩家<code>A</code>是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><ul><li>如果最终两个玩家的分数相等，那么玩家<code>A</code>仍为赢家。</li></ul><p>  <strong>示例：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</span><br><span class="line">如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 dp[i][j][0] 表示先手在面对 nums[i..j] 的石头堆时能拿到的最大分数</span></span><br><span class="line"><span class="comment">// dp[i][j][1] 表示后手在面对 nums[i..j] 的石头堆时能拿到的最大分数</span></span><br><span class="line"><span class="comment">// 1. 对于石头堆 nums[i..j]</span></span><br><span class="line"><span class="comment">//    先手需要判断拿左边堆分数高还是拿右边堆分数高</span></span><br><span class="line"><span class="comment">//    如果先手拿了左边堆, 先手面对 nums[i+1..j] 时就变成了后手</span></span><br><span class="line"><span class="comment">//    此时的得分是 dp[i + 1][j][1] + nums[i]</span></span><br><span class="line"><span class="comment">//    如果先手拿了右边堆, 先手面对 nums[i..j-1] 时就变成了后手</span></span><br><span class="line"><span class="comment">//    此时的得分是 dp[i][j - 1][1] + nums[j]</span></span><br><span class="line"><span class="comment">//    肯定取较高的情况</span></span><br><span class="line"><span class="comment">//    dp[i][j][0] = max(dp[i + 1][j][1] + nums[i], dp[i][j - 1][1] + nums[j])</span></span><br><span class="line"><span class="comment">// 2. 先手的选择对后手会产生影响, 如果先手选择了左边堆</span></span><br><span class="line"><span class="comment">//    后手在面对 nums[i+1..j] 时就变成了先手</span></span><br><span class="line"><span class="comment">//    dp[i][j][1] = dp[i + 1][j][0]</span></span><br><span class="line"><span class="comment">//    如果先手选择了右边堆</span></span><br><span class="line"><span class="comment">//    后手在面对 nums[i..j-1] 时就变成了先手</span></span><br><span class="line"><span class="comment">//    dp[i][j][1] = dp[i][j - 1][0]</span></span><br><span class="line"><span class="comment">// 当 i &gt; j 时, 没有石头堆了 dp[i][j][0,1] = 0</span></span><br><span class="line"><span class="comment">// 当 i == j 时, dp[i][j][0] = nums[i], dp[i][j][1] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i][<span class="number">0</span>] = nums[i];</span><br><span class="line">        dp[i][i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 比较拿左边堆之后和拿右边堆之后的分数</span></span><br><span class="line">            <span class="keyword">int</span> left = dp[i + <span class="number">1</span>][j][<span class="number">1</span>] + nums[i];</span><br><span class="line">            <span class="keyword">int</span> right = dp[i][j - <span class="number">1</span>][<span class="number">1</span>] + nums[j];</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = left;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = dp[i + <span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = right;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不可以写成这样, 不能仅仅比较当前左右两堆石头的大小</span></span><br><span class="line">            <span class="comment">// 比如 [1, 5, 233, 7] 的情况</span></span><br><span class="line">            <span class="comment">// if(nums[i] &gt; nums[j])</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     dp[i][j][0] = dp[i + 1][j][1] + nums[i];</span></span><br><span class="line">            <span class="comment">//     dp[i][j][1] = dp[i + 1][j][0];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// else</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     dp[i][j][0] = dp[i][j - 1][1] + nums[j];</span></span><br><span class="line">            <span class="comment">//     dp[i][j][1] = dp[i][j - 1][0];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>][<span class="number">0</span>] &gt;= dp[<span class="number">0</span>][n - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划的另一种思路</span></span><br><span class="line"><span class="comment">// 甲乙比赛, 甲先手面对区间 [i...j] 时, dp[i][j] 表示甲对乙的净胜分</span></span><br><span class="line"><span class="comment">// 最终求的就是, 甲先手面对区间 [0...n-1] 时, 甲对乙的净胜分 dp[0][n-1] 是否 &gt;= 0</span></span><br><span class="line"><span class="comment">// 甲先手面对区间[i...j]时</span></span><br><span class="line"><span class="comment">// 1. 如果甲拿 nums[i], 那么变成乙先手面对区间 [i+1...j], 这段区间内乙对甲的净胜分为 dp[i+1][j]</span></span><br><span class="line"><span class="comment">// 那么甲对乙的净胜分就应该是 nums[i] - dp[i+1][j]</span></span><br><span class="line"><span class="comment">// 如果甲拿 nums[j], 同理可得甲对乙的净胜分为是 nums[j] - dp[i][j-1]</span></span><br><span class="line"><span class="comment">// 以上两种情况二者取大即可</span></span><br><span class="line"><span class="comment">// 状态转移方程 dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="comment">// 当 i == j 时先手对后手的净胜分就是 nums[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[i][i] = nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            dp[i][j] = max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="486_fig1.png" alt="fig1" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> totalScores(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回拿走 [i, j] 的石头堆后的的得分</span></span><br><span class="line"><span class="comment">// flag = 1 表示当前是先手, flag = -1 表示当前是后手</span></span><br><span class="line"><span class="comment">// flag 可用于控制先手的得分均为正值, 后手的得分均为负值</span></span><br><span class="line"><span class="comment">// 交替选择的过程中将他们的分数加起来</span></span><br><span class="line"><span class="comment">// 显然, 最后总得分为正时先后获胜, 为负时后手获胜</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalScores</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">        <span class="keyword">return</span> flag * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> key = to_string(i) + <span class="string">","</span> + to_string(j) + <span class="string">","</span> + to_string(flag);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> selectLeft = flag * nums[i] + totalScores(nums, i + <span class="number">1</span>, j, -flag);</span><br><span class="line">    <span class="keyword">int</span> selectRight = flag * nums[j] + totalScores(nums, i, j - <span class="number">1</span>, -flag);</span><br><span class="line">    <span class="comment">// 无论当前是先后还是后手, 其选择左或右后, 目前得分的总和可能为正也可能为负</span></span><br><span class="line">    <span class="comment">// 所以需要去掉正负号后再选出较大的值, 方法就是 得分*flag 就可以</span></span><br><span class="line">    <span class="comment">// 也就是说先手会尽量的把数变正变大</span></span><br><span class="line">    <span class="comment">// 后手会尽量把数变负变小</span></span><br><span class="line">    <span class="keyword">return</span> memo[key] = flag * max(flag * selectLeft, flag * selectRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="664-Strange-Printer"><a href="#664-Strange-Printer" class="headerlink" title="664. Strange Printer"></a><a href="https://leetcode.com/problems/strange-printer/" target="_blank" rel="noopener">664. Strange Printer</a></h5><blockquote><p>有台奇怪的打印机有以下两个特殊要求：</p><ul><li>打印机每次只能打印由 同一个字符 组成的序列。</li><li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li></ul><p>给你一个字符串<code>s</code>，你的任务是计算这个打印机打印它需要的最少打印次数。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: s &#x3D; &quot;aaabbb&quot;</span><br><span class="line">&gt;Output: 2</span><br><span class="line">&gt;Explanation: Print &quot;aaa&quot; first and then print &quot;bbb&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: s &#x3D; &quot;aba&quot;</span><br><span class="line">&gt;Output: 2</span><br><span class="line">&gt;Explanation: Print &quot;aaa&quot; first and then print &quot;b&quot; from the second place of the string, which will cover the existing character &#39;a&#39;.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 dp[i][j] 表示打印出字符串区间 s[i..j] 中的字符所需要的最少次数</span></span><br><span class="line"><span class="comment">// 对于 s[i] == s[j]</span></span><br><span class="line"><span class="comment">// 我们在第一次打印出 s[i] 的同时可以顺便打印出 s[j]</span></span><br><span class="line"><span class="comment">// 因此只需要关注如何更快的打印出 s[i..j-1] 中的字符即可</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i][j - 1]</span></span><br><span class="line"><span class="comment">// 对于 s[i] != s[j]</span></span><br><span class="line"><span class="comment">// 我们要分别完成以 s[i] 开头的左半部分字符和以 s[j] 结尾的右半部分字符的打印</span></span><br><span class="line"><span class="comment">// 具体的需要在 i 到 j 之间找一个分界点 k</span></span><br><span class="line"><span class="comment">// 找到最小的 dp[i][k] + dp[k + 1][j]</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(dp[i][k] + dp[k + 1][j]) for k in [i, j)</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[0][n - 1]</span></span><br><span class="line"><span class="comment">// 当 i == j 时 dp[i][j] = 1 只需要一次打印即可</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 可能想到的优化点</span></span><br><span class="line">    <span class="comment">// 注意到本题中连续的相同字符等价于单个字符</span></span><br><span class="line">    <span class="comment">// 所以可以先进行一个相邻元素去重处理</span></span><br><span class="line">    <span class="comment">// auto last = unique(s.begin(), s.end());</span></span><br><span class="line">    <span class="comment">// s.resize(distance(s.begin(), last));</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, INT_MAX))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 dp[i][j] 依赖于 dp[i + k][j]</span></span><br><span class="line">    <span class="comment">// 所以画出二维矩阵图之后知道我们要对 i 从下往上, j 从左往右遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="546-Remove-Boxes"><a href="#546-Remove-Boxes" class="headerlink" title="546. Remove Boxes"></a><a href="https://leetcode.com/problems/remove-boxes/" target="_blank" rel="noopener">546. Remove Boxes</a></h5><blockquote><p>  给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。</p><p>  你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续<code>k</code>个盒子（<code>k &gt;= 1</code>），这样一轮之后你将得到<code>k * k</code>个积分。</p><p>  当你将所有盒子都去掉之后，求你能获得的<strong>最大积分和</strong>。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: boxes &#x3D; [1,3,2,2,2,3,4,3,1]</span><br><span class="line">Output: 23</span><br><span class="line">Explanation:</span><br><span class="line">[1, 3, 2, 2, 2, 3, 4, 3, 1]</span><br><span class="line">----&gt; [1, 3, 3, 4, 3, 1] (3*3&#x3D;9 points)</span><br><span class="line">----&gt; [1, 3, 3, 3, 1] (1*1&#x3D;1 points)</span><br><span class="line">----&gt; [1, 1] (3*3&#x3D;9 points)</span><br><span class="line">----&gt; [] (2*2&#x3D;4 points)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 太特么难了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeBoxes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; boxes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a><a href="https://leetcode.com/problems/counting-bits/?um_chnnl=huawei?um_from_appkey=5fcda41c42348b56d6f8e8d5" target="_blank" rel="noopener">338. Counting Bits</a></h5><blockquote><p>  给定一个非负整数<code>num</code>。对于<code>0 ≤ i ≤ num</code>范围中的每个数字<code>i</code>，计算其二进制数中的<code>1</code>的数目并将它们作为数组返回。</p><p>  <strong>进阶</strong>：给出时间复杂度为<code>O(n*sizeof(integer))</code>的解答非常容易。但你可以在线性时间<code>O(n)</code>内用一趟扫描做到吗？</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: [0, 1, 1, 2, 1, 2]</span><br><span class="line">Explanation:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        bits[i] = countOnes(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">        ones++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算当前状态的值时通过最高位的 1 转移到之前的状态</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> highBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            highBit = i;</span><br><span class="line">        &#125;</span><br><span class="line">        bits[i] = bits[i - highBit] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算当前状态的值时通过最低位的 1 转移到之前的状态</span></span><br><span class="line"><span class="comment">// 实际上就是通过把值变小, 使当前值中的 1 的个数和更小的值中 1 的个数具有数量关系</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 方式一: 右移一位, 最右边的位可能为 0 或 1</span></span><br><span class="line">        bits[i] = bits[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 方式二: 去掉最低位 1</span></span><br><span class="line">        bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1866-Number-of-Ways-to-Rearrange-Sticks-With-K-Sticks-Visible"><a href="#1866-Number-of-Ways-to-Rearrange-Sticks-With-K-Sticks-Visible" class="headerlink" title="1866. Number of Ways to Rearrange Sticks With K Sticks Visible"></a><a href="https://leetcode.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/?um_chnnl=huawei?um_from_appkey=5fcda41c42348b56d6f8e8d5" target="_blank" rel="noopener">1866. Number of Ways to Rearrange Sticks With K Sticks Visible</a></h5><blockquote><p>  有<code>n</code>根长度互不相同的木棍，长度为从<code>1</code>到<code>n</code>的整数。请你将这些木棍排成一排，并满足从左侧可以看到恰好<code>k</code>根木棍。</p><p>  从左侧可以看到木棍的前提是这个木棍的左侧不存在比它更长的木棍。例如，如果木棍排列为<code>[1,3,2,5,4]</code>，那么从左侧可以看到的就是长度分别为<code>1、3 、5</code>的木棍。</p><p>  给你<code>n</code>和<code>k</code>，返回符合题目要求的排列数目 。由于答案可能很大，请返回对<code>10^9 + 7</code>取余的结果。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3, k &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible.</span><br><span class="line">The visible sticks are underlined.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5, k &#x3D; 5</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible.</span><br><span class="line">The visible sticks are underlined.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 20, k &#x3D; 11</span><br><span class="line">Output: 647427950</span><br><span class="line">Explanation: There are 647427950 (mod 10^9 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 dp[i][j] 表示对于高度为 [1..i] 的所有柱子进行排列, 从左侧能看到 j 根的排列数</span></span><br><span class="line"><span class="comment">// 我们考虑最后一根柱子能不能被看见</span></span><br><span class="line"><span class="comment">// 1. 如果最后一根柱子能被看见, 那么它的高度一定为 i</span></span><br><span class="line"><span class="comment">// 这样对于左侧 [1..i-1] 高度的柱子看到 j-1 根柱子的排列数就是之前的状态</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][ j - 1]</span></span><br><span class="line"><span class="comment">// 2. 如果最后一根柱子不能被看见, 那么它的高度可以为 [1..i-1] 中的任意一个</span></span><br><span class="line"><span class="comment">// 由于一根木棍能否被看到只与它和它左侧木棍的「相对高度关系」有关，而与「绝对高度关系」无关</span></span><br><span class="line"><span class="comment">// 因此, 此时最后一根柱子的高度有 [1..i-1] 中 i-1 种选择</span></span><br><span class="line"><span class="comment">// 固定每种选择后, 对于左侧的柱子看到 j 根柱子的排列数就是之前状态</span></span><br><span class="line"><span class="comment">// dp[i][j] = (i - 1) * dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 综合两种情况 dp[i][j] = dp[i - 1][ j - 1] + (i - 1) * dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 我们的目标是求 dp[n][k]</span></span><br><span class="line"><span class="comment">// 当 i == 0 &amp;&amp; j == 0 时 dp[0][0] = 1, 其它情况都初始化为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rearrangeSticks</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(k + <span class="number">1</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (i - <span class="number">1</span>) * dp[i - <span class="number">1</span>][j];</span><br><span class="line">            dp[i][j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="410-Split-Array-Largest-Sum"><a href="#410-Split-Array-Largest-Sum" class="headerlink" title="410. Split Array Largest Sum"></a><a href="https://leetcode.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. Split Array Largest Sum</a></h5><blockquote><p>  给定一个非负整数数组<code>nums</code>和一个整数<code>m</code>，你需要将这个数组分成<code>m</code>个非空的连续子数组。设计一个算法使得这<code>m</code>个子数组各自和的最大值最小。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,2,5,10,8], m &#x3D; 2</span><br><span class="line">Output: 18</span><br><span class="line">Explanation:</span><br><span class="line">There are four ways to split nums into two subarrays.</span><br><span class="line">The best way is to split it into [7,2,5] and [10,8],</span><br><span class="line">where the largest sum among the two subarrays is only 18.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 dp[i][j] 表示将前 i 个数划分成 j 个连续的子数组, 各自和的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="comment">// 枚举将前 k 个数划分为 j - 1 个子数组</span></span><br><span class="line">            <span class="comment">// 因为子数组非空, 所以 k in [j - 1, i - 1]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j - <span class="number">1</span>; k &lt; i; k++) &#123;</span><br><span class="line">                dp[i][j] = min(dp[i][j], max(dp[k][j - <span class="number">1</span>], prefix[i] - prefix[k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分 + 贪心 check</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> maxVal) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + num &lt;= maxVal) &#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        hi += num;</span><br><span class="line">        <span class="keyword">if</span>(lo &lt; num) &#123;</span><br><span class="line">            lo = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mi)) &#123;</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">1049. 最后一块石头的重量 II</a></h5><blockquote><p>  有一堆石头，用整数数组<code>stones</code>表示。其中<code>stones[i]</code>表示第<code>i</code>块石头的重量。</p><p>  每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为<code>x</code>和<code>y</code>，且<code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li><p>如果<code>x == y</code>，那么两块石头都会被完全粉碎；</p></li><li><p>如果<code>x != y</code>，那么重量为<code>x</code>的石头将会完全粉碎，而重量为<code>y</code>的石头新重量为<code>y - x</code>。</p><p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回<code>0</code>。</p></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,</span><br><span class="line">we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,</span><br><span class="line">we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,</span><br><span class="line">we can combine 1 and 1 to get 0, so the array converts to [1], then that&#39;s the optimal value.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones &#x3D; [31,26,33,21,40]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一回合的操作相当于在较大的数前面放置一个 '+' 号, 在较小的数前面放置一个 '-' 号</span></span><br><span class="line"><span class="comment">// 经过若干回合之后, 所有的数前面都被放置了相应的正负号</span></span><br><span class="line"><span class="comment">// 最后形成的表达式求值就是最终剩下的石头的重量</span></span><br><span class="line"><span class="comment">// 我们假设前面被放正号的数之和是 sumP, 前面放负号的数之和为 sumN</span></span><br><span class="line"><span class="comment">// 所有石头总和为 sum, 最后剩下的石头重量为 w</span></span><br><span class="line"><span class="comment">// 则 w = sumP - sumN = sum - sumN - sumN = sum - 2*sumN</span></span><br><span class="line"><span class="comment">// 为了保证 w 最小, 那么我们就是要保证 sum - 2*sumN 为非负值的情况下</span></span><br><span class="line"><span class="comment">// 也就是在 sumN &lt;= sum/2 时, 找到尽可能大的 sumN</span></span><br><span class="line"><span class="comment">// 此时问题就转换为了一个 01 背包问题</span></span><br><span class="line"><span class="comment">// 有一个容量为 sum/2 的背包和一堆重量已知的石头</span></span><br><span class="line"><span class="comment">// 问我们如何装能够装的石头总重量最大</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示对于前 i 堆石头, 背包容量为 j 时能装的最大重量</span></span><br><span class="line"><span class="comment">// 对于第 i 块石头有两个选择</span></span><br><span class="line"><span class="comment">// 1. 不装 dp[i][j] = dp[i - 1][j]</span></span><br><span class="line"><span class="comment">// 2. 装 dp[i][j] = dp[i - 1][j - stones[i - 1]] + stones[i - 1]</span></span><br><span class="line"><span class="comment">// 我们要求最大可能的重量, 所以两者取最大值即可</span></span><br><span class="line"><span class="comment">// 对于初始条件, 当 i == 0 时, 即没有石头可装, dp[i][j] = 0</span></span><br><span class="line"><span class="comment">// 当 j == 0, 即背包容量为 0, dp[i][j] = 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = stones.size();</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(stones.begin(), stones.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(sum/<span class="number">2</span> + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum/<span class="number">2</span>; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= stones[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i][j] , dp[i - <span class="number">1</span>][j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - <span class="number">2</span>*dp[n][sum/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 i 的当前状态只与前一个状态有关, 使用滚动数组优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = stones.size();</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(stones.begin(), stones.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(sum/<span class="number">2</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = sum/<span class="number">2</span>; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">            dp[j] = max(dp[j] , dp[j - stones[i]] + stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - <span class="number">2</span>*dp[sum/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="879-盈利计划"><a href="#879-盈利计划" class="headerlink" title="879. 盈利计划"></a><a href="https://leetcode-cn.com/problems/profitable-schemes/" target="_blank" rel="noopener">879. 盈利计划</a></h5><blockquote><p>  集团里有<code>n</code>名员工，他们可以完成各种各样的工作创造利润。第<code>i</code>种工作会产生<code>profit[i]</code>的利润，它要求<code>group[i]</code>名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p><p>  工作的任何至少产生<code>minProfit</code>利润的子集称为<strong>盈利计划</strong>。并且工作的成员总数最多为<code>n</code>。</p><p>  有多少种计划可以选择？因为答案可能很大，所以返回结果模<code>10^9 + 7</code>的值。</p><p>  <strong>示例 1</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, minProfit &#x3D; 3, group &#x3D; [2,2], profit &#x3D; [2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。</span><br><span class="line">总的来说，有两种计划。</span><br></pre></td></tr></table></figure><p>  <strong>示例 2</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10, minProfit &#x3D; 5, group &#x3D; [2,3,5], profit &#x3D; [6,7,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。</span><br><span class="line">有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</span><br></pre></td></tr></table></figure><p>  提示：</p><ul><li>1 &lt;= n &lt;= 100，0 &lt;= <code>minProfit</code> &lt;= 100，1 &lt;= <code>group.length</code> &lt;= 100</li><li>1 &lt;= group[i] &lt;= 100，<code>profit.length</code> == <code>group.length</code>，0 &lt;= profit[i] &lt;= 100</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态有工作, 员工数以及当前利润</span></span><br><span class="line"><span class="comment">// 我们定义 dp[i][j][k] 表示对于前 i 种工作, 参与的员工数为 j 时, 在利润 [至少] 为 k 的情况下的计划数</span></span><br><span class="line"><span class="comment">// 对于第 i 种工作我们有选择和不选两种选择</span></span><br><span class="line"><span class="comment">// 1. 不选 显然有</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j][k]</span></span><br><span class="line"><span class="comment">// 2. 选</span></span><br><span class="line"><span class="comment">// dp[i][j][k] = dp[i - 1][j - group[i - 1]][k - profit[i - 1]]</span></span><br><span class="line"><span class="comment">// 注意到对于状态 k 我们定义的是至少获得的利润</span></span><br><span class="line"><span class="comment">// 因此, 当 k - profit[i - 1] 为负时, 我们都取 0</span></span><br><span class="line"><span class="comment">// 也就是说所有大于 k 的利润都归为等于 k, 这就是至少的定义嘛</span></span><br><span class="line"><span class="comment">// 当 i == 0 时, 无论你用了多少个员工, 至少获得的利润 k 显然都为 0, 这属于 1 种计划</span></span><br><span class="line"><span class="comment">// dp[0][j][0] = 1 for j in [1..n]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> minProfit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; group, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = group.size();</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(minProfit + <span class="number">1</span>)))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= minProfit; k++) &#123;</span><br><span class="line">                dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= group[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j][k] += dp[i - <span class="number">1</span>][j - group[i - <span class="number">1</span>]][max(<span class="number">0</span>, k - profit[i - <span class="number">1</span>])];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j][k] = dp[i][j][k] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n][minProfit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组优化空间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">profitableSchemes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> minProfit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; group, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = group.size();</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(minProfit + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= group[i - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= minProfit; k++) &#123;</span><br><span class="line">                dp[j][k] += dp[j - group[i - <span class="number">1</span>]][max(<span class="number">0</span>, k - profit[i - <span class="number">1</span>])];</span><br><span class="line">                dp[j][k] = dp[j][k] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][minProfit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1155-掷骰子的N种方法"><a href="#1155-掷骰子的N种方法" class="headerlink" title="1155. 掷骰子的N种方法"></a><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/" target="_blank" rel="noopener">1155. 掷骰子的N种方法</a></h5><blockquote><p>  这里有<code>d</code>个一样的骰子，每个骰子上都有<code>f</code>个面，分别标号为<code>1, 2, ..., f</code>。</p><p>  我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。</p><p>  如果需要掷出的总点数为<code>target</code>，请你计算出有多少种不同的组合情况（所有的组合情况总共有<code>f^d</code>种），模<code>1e9+7</code>后返回。</p><p>  <strong>提示：</strong></p><ul><li><code>1 &lt;= d, f &lt;= 30</code></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01 背包问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(d + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(target + <span class="number">1</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k &lt;= j) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line">                    dp[i][j] = dp[i][j] % <span class="keyword">int</span>(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[d][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动数组优化空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 这个不太容易想到</span></span><br><span class="line">            <span class="comment">// 它表示降维前, dp[1..d][0] = 0 的情况</span></span><br><span class="line">            <span class="comment">// 即, 使用了多于一个骰子的话, 和为 0 的情况不可能出现</span></span><br><span class="line">            <span class="comment">// 因此, 每次迭代时要将这种情况的组合数设为 0</span></span><br><span class="line">            dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; k &lt;= j; k++) &#123;</span><br><span class="line">                dp[j] += dp[j - k];</span><br><span class="line">                dp[j] = dp[j] % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="801-使序列递增的最小交换次数"><a href="#801-使序列递增的最小交换次数" class="headerlink" title="801. 使序列递增的最小交换次数"></a><a href="https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing/" target="_blank" rel="noopener">801. 使序列递增的最小交换次数</a></h5><blockquote><p>  我们有两个长度相等且不为空的整型数组<code>A</code>和<code>B</code>。我们可以交换<code>A[i]</code>和<code>B[i]</code>的元素。注意这两个元素在各自的序列中应该处于相同的位置。在交换过一些元素之后，数组<code>A</code>和<code>B</code>都应该是严格递增的。</p><p>  给定数组<code>A</code>和<code>B</code>，请返回使得两个数组均保持严格递增状态的最小交换次数。<strong>假设给定的输入总是有效的</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于第 i 个元素, 有交换和不交换两种选择</span></span><br><span class="line"><span class="comment">// 定义 dp[i][0] 表示第 i 个元素交换时, 将前 i 个元素交换操作之后严格递增的最小操作次数</span></span><br><span class="line"><span class="comment">// 定义 dp[i][1] 表示第 i 个元素不交换时, 将前 i 个元素交换操作之后严格递增的最小操作次数</span></span><br><span class="line"><span class="comment">// 那么在考虑第 i 个元素时, 需要连同第 i - 1 个元素一起考虑</span></span><br><span class="line"><span class="comment">// 也就是 A[i - 1], A[i], B[i - 1] 和 B[i] 这四个元素</span></span><br><span class="line"><span class="comment">// 1. A[i - 1] &lt; A[i] &amp;&amp; B[i - 1] &lt; B[i]</span></span><br><span class="line"><span class="comment">// 此时若 A[i - 1] &lt; B[i] &amp;&amp; B[i - 1] &lt; A[i]</span></span><br><span class="line"><span class="comment">// 前一个元素可以交换也可以不交换</span></span><br><span class="line"><span class="comment">// 1.1 当前元素不交换 dp[i][0] = min(dp[i - 1][0], dp[i - 1][1])</span></span><br><span class="line"><span class="comment">// 1.2 当前元素交换 dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + 1</span></span><br><span class="line"><span class="comment">// 此时若 A[i - 1] &gt;= B[i] || B[i - 1] &gt;= A[i]</span></span><br><span class="line"><span class="comment">// 当前元素和前一个元素必须同时交换或不交换</span></span><br><span class="line"><span class="comment">// 1.3 当前元素不交换 dp[i][0] = dp[i - 1][0]</span></span><br><span class="line"><span class="comment">// 1.4 当前元素交换 dp[i][1] = dp[i - 1][1] + 1</span></span><br><span class="line"><span class="comment">// 2. A[i - 1] &gt;= A[i] || B[i - 1] &gt;= B[i]</span></span><br><span class="line"><span class="comment">// 当前元素若不交换则前一元素需要交换, 当前元素若交换则前一元素不能交换</span></span><br><span class="line"><span class="comment">// dp[i][0] = d[i - 1][1]</span></span><br><span class="line"><span class="comment">// dp[i][1] = d[i - 1][0] + 1</span></span><br><span class="line"><span class="comment">// 作为 base case, 第 0 个元素可以交换也可以不交换</span></span><br><span class="line"><span class="comment">// 若不交换 dp[0][0] = 0</span></span><br><span class="line"><span class="comment">// 若交换 dp[0][1] = 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i - <span class="number">1</span>] &lt; A[i] &amp;&amp; B[i - <span class="number">1</span>] &lt; B[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i - <span class="number">1</span>] &lt; B[i] &amp;&amp; B[i - <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/" target="_blank" rel="noopener">LCP 07. 传递信息</a></h5><blockquote><p>  小朋友<code>A</code>在和<code>ta</code>的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li><p>有<code>n</code>名玩家，所有玩家编号分别为<code>0～n-1</code>，其中小朋友<code>A</code>的编号为<code>0</code>；</p></li><li><p>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如<code>A</code>可以向<code>B</code>传信息，但<code>B</code>不能向<code>A</code>传信息）。</p></li><li><p>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</p><p>给定总玩家数<code>n</code>，以及按<code>[玩家编号，对应可传递玩家编号]</code>关系组成的二维数组<code>relation</code>。返回信息从小<code>A</code> (编号<code>0</code>) 经过<code>k</code>轮传递到编号为<code>n-1</code>的小伙伴处的方案数；若不能到达，返回<code>0</code>。</p></li></ol><p>  <strong>示例 1</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, relation &#x3D; [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p>  <strong>示例 2</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3, relation &#x3D; [[0,2],[2,1]], k &#x3D; 2</span><br><span class="line">输出：0</span><br><span class="line">解释：信息不能从小 A 处经过 2 轮传递到编号 2</span><br></pre></td></tr></table></figure><p>  限制：</p><ul><li>2 &lt;= n &lt;= 10</li><li>1 &lt;= k &lt;= 5</li><li>1 &lt;=<code>relation.length</code> &lt;= 90, 且 <code>relation[i].length</code> == 2</li><li>0 &lt;= <code>relation[i][0], relation[i][1]</code>&lt; n 且 <code>relation[i][0]</code> != <code>relation[i][1]</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较容易想到的是 dfs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; r : relation) &#123;</span><br><span class="line">        edges[r[<span class="number">0</span>]].push_back(r[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="keyword">int</span> idx, <span class="keyword">int</span> step) &#123;</span><br><span class="line">        <span class="keyword">if</span>(step == k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(idx == n - <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; to : edges[idx]) &#123;</span><br><span class="line">            dfs(dfs, to, step + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(dfs, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="comment">// 假设当前我们已经走了 i 步, 所在位置为 j, 那么剩余 k - j 步, 能否到达位置 n - 1</span></span><br><span class="line"><span class="comment">// 仅取决于 [剩余步数 k - i] 和 [边权关系 relation], 与如何到达位置 i 无关</span></span><br><span class="line"><span class="comment">// 对于方案数而言, 如果已经走了 i 步, 所在位置为 j, 到达位置 n - 1 的方案数仅取决于</span></span><br><span class="line"><span class="comment">// [剩余步数 k - i], [边权关系 relation] 和 [花费 i 步到达位置 j 的方案数]</span></span><br><span class="line"><span class="comment">// 以上分析归纳到边界 [走了 0 步, 所在位置 0] 同样成立</span></span><br><span class="line"><span class="comment">// 这就是动态规划中需要满足的 [无后效性]</span></span><br><span class="line"><span class="comment">// 定义 dp[i][j] 表示走了 i 步, 到达位置 j 的方案数</span></span><br><span class="line"><span class="comment">// 最终要求 dp[k][n - 1], 初始时 dp[0][0] = 1</span></span><br><span class="line"><span class="comment">// dp[i][j] = dp[i - 1][p] for [p, j] in relation</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; edge : relation) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = edge[<span class="number">0</span>], dst = edge[<span class="number">1</span>];</span><br><span class="line">            dp[i][dst] += dp[i - <span class="number">1</span>][src];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a><a href="https://leetcode-cn.com/problems/super-ugly-number/" target="_blank" rel="noopener">313. 超级丑数</a></h5><blockquote><p>  编写一段程序来查找第<code>n</code>个超级丑数。超级丑数是指其所有质因数都是长度为<code>k</code>的质数列表<code>primes</code>中的正整数。</p><p>  <strong>示例</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 12, primes &#x3D; [2,7,13,19]</span><br><span class="line">输出: 32 </span><br><span class="line">解释: 给定长度为 4 的质数列表 primes &#x3D; [2,7,13,19]，</span><br><span class="line">前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32]</span><br></pre></td></tr></table></figure><p>  <strong>说明</strong>：</p><ul><li><code>1</code>是任何给定<code>primes</code>的超级丑数；</li><li>给定<code>primes</code>中的数字以升序排列。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 set 的去重和有序特性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; uglys;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> prime : primes) &#123;</span><br><span class="line">            uglys.insert(prime * res);</span><br><span class="line">        &#125;</span><br><span class="line">        res = *uglys.begin();</span><br><span class="line">        uglys.erase(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划: 多指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = primes.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">su</span><span class="params">(n)</span></span>;</span><br><span class="line">    su[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        su[i] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            su[i] = min(su[i], primes[j] * su[p[j]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(su[i] == primes[j] * su[p[j]]) &#123;</span><br><span class="line">                p[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> su[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 263. 丑数</span></span><br><span class="line"><span class="comment">//https://leetcode-cn.com/problems/ugly-number/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> factor : &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;) &#123;</span><br><span class="line">        <span class="keyword">while</span>(n % factor == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 264. 丑数II</span></span><br><span class="line"><span class="comment">// https://leetcode-cn.com/problems/ugly-number-ii/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 set 的自动排序与降重功能</span></span><br><span class="line"><span class="comment">// 时间复杂度为外围的 n 次循环 O(n)</span></span><br><span class="line"><span class="comment">// 内部 set 的插入和删除操作都是 O(logn)</span></span><br><span class="line"><span class="comment">// 所以时间复杂度总共是 O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度总共为 set 使用的 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; setting;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(--n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        setting.insert(res * <span class="number">2</span>);</span><br><span class="line">        setting.insert(res * <span class="number">3</span>);</span><br><span class="line">        setting.insert(res * <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 每次取出最小的丑数用于下一次循环</span></span><br><span class="line">        res = *setting.begin();</span><br><span class="line">        <span class="comment">// 取出来之后它就没用了, 及时剔除</span></span><br><span class="line">        setting.erase(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态规划: 三指针</span></span><br><span class="line"><span class="comment">// p2 代表的是第几个数的 2 倍</span></span><br><span class="line"><span class="comment">// p3 代表的是第几个数的 3 倍</span></span><br><span class="line"><span class="comment">// p5 代表的是第几个数的 5 倍</span></span><br><span class="line"><span class="comment">// 时间复杂度就只有外层的 n 次循环 O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">u</span><span class="params">(n)</span></span>;</span><br><span class="line">    u[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        u[i] = min(&#123;<span class="number">2</span> * u[p2], <span class="number">3</span> * u[p3], <span class="number">5</span> * u[p5]&#125;);</span><br><span class="line">        <span class="keyword">if</span>(u[i] == <span class="number">2</span> * u[p2]) &#123;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u[i] == <span class="number">3</span> * u[p3]) &#123;</span><br><span class="line">            p3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u[i] == <span class="number">5</span> * u[p5]) &#123;</span><br><span class="line">            p5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 助你理解一:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段代码两个关键点.</span></span><br><span class="line"><span class="comment">1. 每次对计算出三个丑数并取最小，这里需要计算三个丑数，一定有两个丑数是在上一次中就已经被计算并比较过的, 因为较大所以被筛掉了两个（这两个进入下次比较中）, 留下较小的那个, 并自增一次最小值的下标 i, 使得参与下次计算时能稍微增大, 并同该次比较中淘汰的两个稍大数比较, 经过这样的不断比较 + 迭代, 能保证结果集是按从小到大的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 自增每次的最小丑数值的下标, 这么做一是可以迭代避免重复计算, 从而避免出现重复值, 二是避免遗漏. 因为按照最直接的理解与解法, 每个数都需分别 *2、*3、*5 加入数组, 历经n次，最后再排序，但通过设置三个从 0 开始的下标, 使其对应的值分别只与 2 或 3 或 5 相乘, 而每个下标都有机会迭代, 这样可以保证数组中的每个数实际都是分别与 2、3、5 乘一次, 数组中的前四个数是 1,2,3,5, 后面的数都是由前面的数分别与 2、3、5 相乘计算出来的, 这样也满足了丑数的定义, 并且每次计算的数都是先排序再加入的, 如此可以避免不漏且排序. 而不重是通过三个 if 判断解决的, 因为假如一个数既可通过 *2 得到又可以通过 *3 得到, 此时必然会重复计算并重复加入到数组, 因此此时需要既迭代 2 对应的下标 p2, 也迭代 3 对应的下标 p3, 所以 if 如果换成 if-else, 必然会有大量重复值出现.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 助你理解二:</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">动态规划方法对于三指针的解释令人费解, 实际上这三个指针是用于对三个子序列归并排序的.</span></span><br><span class="line"><span class="comment">1. 令 nums 为升序的全部丑数序列, nums[n - 1] 即为所求, 初始只有一个元素 1, 即 nums[0] 为 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 根据丑数的定义可知, 除 1 外其他丑数都可以通过更小的丑数乘以 2、3、5 得到, 因此由 nums 可生成三个有序丑数子序列 nums_j, j 为 2、3、5. nums_j 元素生成规则为 nums[p_j] * j, p_j 为指向 nums 元素的指针,</span></span><br><span class="line"><span class="comment">对这三个有序丑数子序列进行归并排序可以求得 nums 中的其他元素.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. nums 和三个子序列 nums_j 的元素都是动态生成的, 且生成 nums_j 的规则 nums[p_j] * j 中 j 是固定的, 不必预先创建出三个完整的子序列，只需维护三个指向 nums 的指针 p_j 用于归并排序即可.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 归并排序每生成一个最小丑数 min 时，将 min 追加到 nums 中, 然后生成 min 所在子序列 nums_j 的下一个元素, 即将 p_j 右移，pj++, 注意 min 可能同时存在于多个子序列，需要同时右移 p_j, 避免产生重复元素.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. nums 每追加一个丑数后, pj 只可能右移 1 个位置, 所以不会发生越界的情况.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客2021年4月15号模拟笔试题</title>
      <link href="/ZUdtS6UUmrVCKLed/"/>
      <url>/ZUdtS6UUmrVCKLed/</url>
      
        <content type="html"><![CDATA[<p>前两天在牛客网做了模拟笔试题，有两道感觉挺有意思的，这里总结一下。其中一道题稍微修改了点条件，进阶一下。</p><p>特么的我都不想说，其实这修改的条件是我笔试时没读清题，直接往难了去想的，就没做出来（呜呜呜，哭晕在厕所）。以后做题一定要审清题啊！！！</p><a id="more"></a><h5 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第<code>1</code>题</h5><blockquote><p>牛牛和牛妹最近迷上了新版消消看，该游戏规则如下：</p><p>在一个<code>01</code>串中，每一轮，玩家都可以选择一串连续相同字符进行消除，消除之后，左右两侧剩余的字符自动拼接，重新形成一个字符串。</p><p>例如，在<code>101001</code>中，牛牛选择了第四个和第五个字符，它们连续且都是<code>0</code>，满足消除条件，而当它们消除之后，左侧剩余的<code>101</code>和右侧剩余的<code>1</code>会拼接到一起，即，消除后剩余的<code>01</code>串为：<code>1011</code>。</p><p>计分规则如下：消除了几个<code>1</code>就计几分。<strong>允许消除单个字符</strong>，因此，直到消成空串时游戏结束。</p><p>对于给定的<code>01</code>串，由牛妹先手进行消除，两个人都以最优策略且以得分高为目标进行消除，请问最后，哪个人的得分会比较高？返回一个二元数组，分别是先手得分和后者得分。</p><p> <strong>进阶：如果不允许只消除单个字符，也就是说，直到消成没有连续的<code>1</code>或<code>0</code>后游戏就结束。</strong></p><p> <strong>例子<code>1</code>：</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;0110110101001111&quot;</span><br><span class="line">输出: [7, 3]</span><br><span class="line">解释: 先手得分为 4 + 2 + 1 &#x3D; 7, 后手得分为 2 + 1 &#x3D; 3</span><br></pre></td></tr></table></figure><p> <strong>进阶的例子<code>2</code>：</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;011011001001001111&quot;</span><br><span class="line">输出: [8, 2]</span><br><span class="line">解释: 先手得分为 4 + 2 + 2 &#x3D; 8, 后手得分为 2</span><br><span class="line">原始串     --&gt; 011011001001001111</span><br><span class="line">   消    1 --&gt; 000000001001000000 得分：6, 2</span><br><span class="line">后手消   0 --&gt; 1001000000 得分：6, 2</span><br><span class="line">先手消   0 --&gt; 1001 得分：6, 2</span><br><span class="line">后手消   0 --&gt; 11 得分：6, 2</span><br><span class="line">   消    1 --&gt; 00 得分：8, 2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于允许消除单个字符的情况</span></span><br><span class="line"><span class="comment">// 1. 先消除 1, 先手必定选择先消除最长的 1 串</span></span><br><span class="line"><span class="comment">// 2. 后手同样如此, 如此交替下去, 直到串中没有 1</span></span><br><span class="line"><span class="comment">// 3. 此时剩下的全为 0, 消除也不得分</span></span><br><span class="line"><span class="comment">// 因此, 只需要统计串中连续 1 的个数组成数组</span></span><br><span class="line"><span class="comment">// 对数组排序, 偶数索引的值累加为先手的得分</span></span><br><span class="line"><span class="comment">// 奇数索引的值累加为后手的得分</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">eliminate_01_series</span><span class="params">(<span class="built_in">string</span> series)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ones = countOnes(series);</span><br><span class="line">    sort(ones.begin(), ones.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ones.size(); i += <span class="number">2</span>)</span><br><span class="line">        scores[<span class="number">0</span>] += ones[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ones.size(); i += <span class="number">2</span>)</span><br><span class="line">        scores[<span class="number">1</span>] += ones[i];</span><br><span class="line">    <span class="keyword">return</span> scores;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countOnes</span><span class="params">(<span class="built_in">string</span> series)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ones;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; series.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(series[right] == <span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; series.size() &amp;&amp; series[right] != <span class="string">'0'</span>)</span><br><span class="line">                right++;</span><br><span class="line">            ones.push_back(right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (也可能是我想复杂了, 如果你有更简单的方法一定告诉我!)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不允许消除单个字符的话，情况就复杂的多了</span></span><br><span class="line"><span class="comment">1. 先按照上题的方案双方先消 1 (消连续 1 的时候有个小技巧, 不实际地把串中连续的 1 擦除,</span></span><br><span class="line"><span class="comment">  而把这些 1 反转为 0 即可), 消完 1 之后再开始消连续的 0</span></span><br><span class="line"><span class="comment">2. 这时候要根据上次消 1 时的 (1 的个数的数组) 的 (连续多个 1) 的个数奇偶性</span></span><br><span class="line"><span class="comment">  来判断谁先消 0 (奇数话就是原先的后手先消 0，偶数的话是原先的先手先消 0)</span></span><br><span class="line"><span class="comment">3. 因为消 0 又不得分. 消一次 0, 在串中实际地擦除 0, 得新串, 对新串递归调用回到第 1 步</span></span><br><span class="line"><span class="comment">4. 擦除 0 的时候还要注意, 对于这样的串 0001000101000 优先从最前面或最后面擦除</span></span><br><span class="line"><span class="comment">  可让对手不得分</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">下面是调试输出</span></span><br><span class="line"><span class="comment">原始串     --&gt; 00111010011100101001010010010000111011</span></span><br><span class="line"><span class="comment">    消   1 --&gt; 00000010000000101001010010010000000000 得分：6, 5</span></span><br><span class="line"><span class="comment">先手消   0 --&gt; 10000000101001010010010000000000 得分：6, 5</span></span><br><span class="line"><span class="comment">后手消   0 --&gt; 1000000010100101001001 得分：6, 5</span></span><br><span class="line"><span class="comment">先手消   0 --&gt; 110100101001001 得分：6, 5</span></span><br><span class="line"><span class="comment">    消   1 --&gt; 000100101001001 得分：6, 7</span></span><br><span class="line"><span class="comment">先手消   0 --&gt; 100101001001 得分：6, 7</span></span><br><span class="line"><span class="comment">后手消   0 --&gt; 1001010011 得分：6, 7</span></span><br><span class="line"><span class="comment">    消   1 --&gt; 1001010000 得分：8, 7</span></span><br><span class="line"><span class="comment">后手消   0 --&gt; 100101 得分：8, 7</span></span><br><span class="line"><span class="comment">先手消   0 --&gt; 1101 得分：8, 7</span></span><br><span class="line"><span class="comment">    消   1 --&gt; 0001 得分：8, 9</span></span><br><span class="line"><span class="comment">先手消   0 --&gt; 1 得分：8, 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">下面具体看代码注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">eliminate_01_series</span><span class="params">(<span class="built_in">string</span> series)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 得分数组, [先手得分, 后手得分]</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 调试代码</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"原始串 --&gt; "</span> &lt;&lt; series &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    helper(series, scores, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> scores;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// series 为当前串</span></span><br><span class="line"><span class="comment">// flag == 0 表示本次先手先消, flag == 1 表示本次后手先消</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> series, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;scores, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 首先计算串中 1 的个数数组, 注意返回的是一个 pair 数组</span></span><br><span class="line">    <span class="comment">// pair 中的元素为 &#123;连续 1 的个数, 对应在串中的起始索引&#125;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ones = countContinuousChar(series, <span class="string">'1'</span>);</span><br><span class="line">    <span class="comment">// 没有 1 就直接返回, 再消也不得分了</span></span><br><span class="line">    <span class="keyword">if</span>(ones.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 排序, 从大到小</span></span><br><span class="line">    sort(ones.begin(), ones.end(), greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;());</span><br><span class="line">    <span class="comment">// 如果有多个连续的 1 进入</span></span><br><span class="line">    <span class="comment">// 没有的话说明这时该消 0 了, 跳过下一步</span></span><br><span class="line">    <span class="keyword">if</span>(ones.front().first &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 偶数索引元素之和为先手得分</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; ones.size() &amp;&amp; ones[i].first &gt; <span class="number">1</span>; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scores[flag] += ones[i].first;</span><br><span class="line">            turnToZeros(series, ones[i].second, ones[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 奇数索引元素之和为先手得分</span></span><br><span class="line">        <span class="keyword">for</span> (; j &lt; ones.size() &amp;&amp; ones[j].first &gt; <span class="number">1</span>; j += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scores[<span class="number">1</span> - flag] += ones[j].first;</span><br><span class="line">            turnToZeros(series, ones[j].second, ones[j].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调试代码</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"    消   1 --&gt; "</span> &lt;&lt; series &lt;&lt; <span class="string">" 得分："</span> &lt;&lt; scores[<span class="number">0</span>] &lt;&lt; <span class="string">", "</span> &lt;&lt; scores[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 判断先后手是否转换</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">            flag = <span class="number">1</span> - flag;</span><br><span class="line">        helper(series, scores, flag);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明串中没有连续的 1 了</span></span><br><span class="line">    <span class="comment">// 计算 0 串的个数数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; zeros = countContinuousChar(series, <span class="string">'0'</span>);</span><br><span class="line">    <span class="comment">// 如果为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(zeros.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    sort(zeros.begin(), zeros.end(), greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;());</span><br><span class="line">    <span class="comment">// 如果有连续的 0</span></span><br><span class="line">    <span class="keyword">if</span>(zeros.front().first &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 优先擦除从 0 索引起始的或最后结尾的 0 串</span></span><br><span class="line">        <span class="comment">// 因为这样可以让下次对手不得分</span></span><br><span class="line">        <span class="comment">// 比如 0001001000 的情况</span></span><br><span class="line">        <span class="keyword">if</span>(series[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; series[<span class="number">1</span>] == <span class="string">'0'</span>)</span><br><span class="line">            series.erase(<span class="number">0</span>, series.find_first_of(<span class="string">'1'</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(series[series.size() - <span class="number">2</span>] == <span class="string">'0'</span> &amp;&amp; series[series.size() - <span class="number">1</span>] == <span class="string">'0'</span>)</span><br><span class="line">            series.erase(series.find_last_of(<span class="string">'1'</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则擦除中间任何 0 串都一样</span></span><br><span class="line">            series.erase(zeros.front().second, zeros.front().first);</span><br><span class="line">        <span class="comment">// 调试代码</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"先手消   0 --&gt; "</span> &lt;&lt; series &lt;&lt; <span class="string">" 得分："</span> &lt;&lt; scores[<span class="number">0</span>] &lt;&lt; <span class="string">", "</span> &lt;&lt; scores[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"后手消   0 --&gt; "</span> &lt;&lt; series &lt;&lt; <span class="string">" 得分："</span> &lt;&lt; scores[<span class="number">0</span>] &lt;&lt; <span class="string">", "</span> &lt;&lt; scores[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 注意这里始终要先后手转换</span></span><br><span class="line">        helper(series, scores, <span class="number">1</span> - flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果也没有连续的 0, 那就游戏结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;int, int&gt;&gt; countContinuousChar(string series, char c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ones;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; series.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(series[right] == c)</span><br><span class="line">        &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; series.size() &amp;&amp; series[right] != (<span class="string">'0'</span> + <span class="string">'1'</span> - c))</span><br><span class="line">                right++;</span><br><span class="line">            ones.push_back(&#123;right - left, left&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turnToZeros</span><span class="params">(<span class="built_in">string</span>&amp; series, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        series[pos + i] = <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第<code>2</code>题</h5><blockquote><p>  西部世界有<code>n</code>个赏金猎人，每个赏金猎人都有两个属性战斗里和所拥有金钱。<code>attack[i]</code>和<code>money[i]</code>分别表示第<code>i</code>个赏金猎人的战斗力和所拥有金钱，保证每个赏金猎人的战斗力不相同。每个赏金猎人都只有<code>k</code>发子弹，这意味着他最多可以击败<code>k</code>个战斗力比他小的赏金猎人并获取他们的金钱。输出每一个赏金猎人最多拥有多少金钱。</p><p>  <strong>Constraints:</strong></p><ul><li><p>1 &lt;= n &lt;= 10^5^, 0 &lt;= k &lt;= min(n - 1, 10).</p></li><li><p>1 &lt;= attack[i], money[i] &lt;= 10^9^.</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxMoney</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;attack, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;money, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录每个赏金猎人的战斗里和他所对应的索引</span></span><br><span class="line">    <span class="comment">// 并利用其自动排序的特性</span></span><br><span class="line">    <span class="comment">// 对赏金猎人的战斗力进行排序</span></span><br><span class="line">    <span class="comment">// 这样在遍历的时候就能保证之前遍历的都是比他战斗力小的</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attack.size(); i++)</span><br><span class="line">        mapping[attack[i]] = i;</span><br><span class="line">    <span class="comment">// 返回金钱数组里初始化为自身拥有的本金</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(money)</span></span>;</span><br><span class="line">    <span class="comment">// 维护一个最小堆, 堆固定大小为 k</span></span><br><span class="line">    <span class="comment">// 最多存储 k 个比当前赏金猎人的战斗力小的赏金猎人</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : mapping)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果堆不为空的话, 堆里的金钱数就是当前赏金猎人增加的金钱数</span></span><br><span class="line">        <span class="comment">// 因为排序后遍历的原因, 堆里的猎人的战斗力都比他小</span></span><br><span class="line">        <span class="keyword">if</span>(!heap.empty())</span><br><span class="line">            res[p.second] += accumulate(heap.begin(), heap.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 定制成最小堆</span></span><br><span class="line">        heap.push_back(money[p.second]);</span><br><span class="line">        push_heap(heap.begin(), heap.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">if</span>(heap.size() &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            pop_heap(heap.begin(), heap.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            heap.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用用优先级队列做为堆</span></span><br><span class="line"><span class="comment">// 使用一个整数变量 sum 时刻保持为堆内元素总和</span></span><br><span class="line"><span class="comment">// 这样代码更简单, 还不用每次求堆内元素和</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxMoney</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;attack, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;money, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录每个赏金猎人的战斗里和他所对应的索引</span></span><br><span class="line">    <span class="comment">// 并利用其自动排序的特性</span></span><br><span class="line">    <span class="comment">// 对赏金猎人的战斗力进行排序</span></span><br><span class="line">    <span class="comment">// 这样在遍历的时候就能保证之前遍历的都是比他战斗力小的</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attack.size(); i++)</span><br><span class="line">        mapping[attack[i]] = i;</span><br><span class="line">    <span class="comment">// 返回金钱数组里初始化为自身拥有的本金</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(money)</span></span>;</span><br><span class="line">    <span class="comment">// 维护一个最小堆, 堆固定大小为 k</span></span><br><span class="line">    <span class="comment">// 最多存储 k 个比当前赏金猎人的战斗力小的赏金猎人</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 堆内元素总和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p : mapping)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果堆不为空的话, 堆里的金钱数就是当前赏金猎人增加的金钱数</span></span><br><span class="line">        <span class="comment">// 因为排序后遍历的原因, 堆里的猎人的战斗力都比他小</span></span><br><span class="line">        <span class="keyword">if</span>(!heap.empty())</span><br><span class="line">            res[p.second] += sum;</span><br><span class="line">        <span class="comment">// 定制成最小堆</span></span><br><span class="line">        sum += money[p.second];</span><br><span class="line">        heap.push(money[p.second]);</span><br><span class="line">        <span class="keyword">if</span>(heap.size() &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            sum -= heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之数组</title>
      <link href="/qD0F57Dbj7HjnZou/"/>
      <url>/qD0F57Dbj7HjnZou/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>1</code>部分——数组。这里把有代表性的题目发出来，共计<code>82</code>道。主要涉及滑动窗口、哈希表、堆、二分搜索、扫描线、区间相关、拓扑排序、树状数组等算法。</p><p><code>leetcode</code>刷题系列其它文章组织如下：</p><p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p><p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p><p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p><a id="more"></a><h5 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h5><blockquote><p>给定一个<strong>有序整数数组</strong>和一个目标数，在数组中找到总和等于目标数的两个元素，返回它们的索引。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左右指针</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h5><blockquote><p>给定一个<strong>无序整数数组</strong>和一个目标数，在数组中找到总和等于目标数的两个元素，返回它们的索引。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助 hashtable 记录元素的存在情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;mapping[target - nums[i]], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mapping[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="560-Subarray-Sum-Equals-K"><a href="#560-Subarray-Sum-Equals-K" class="headerlink" title="560. Subarray Sum Equals K"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. Subarray Sum Equals K</a></h5><blockquote><p>给定一个整数数组和一个目标数，返回数组中其总和等于目标数的<strong>连续子数组的个数</strong>。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为这题数组中可以存在负数, 所有不能使用滑动窗口方法</span></span><br><span class="line"><span class="comment">// 暴力解法 超时</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">if</span>(sum == k) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助前缀和思想</span></span><br><span class="line"><span class="comment">// 使用 hashtable 记录所有的前缀和及其对应的数目</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须存在的 base case</span></span><br><span class="line">    <span class="comment">// 表示 sum 直接等于 k 的情况</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(sum - k)) &#123;</span><br><span class="line">            res += mapping[sum - k];</span><br><span class="line">        &#125;</span><br><span class="line">        mapping[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="724-Find-Pivot-Index"><a href="#724-Find-Pivot-Index" class="headerlink" title="724. Find Pivot Index"></a><a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. Find Pivot Index</a></h5><blockquote><p>给定一个整数数组，请计算该数组的枢轴索引。枢轴索引使得该索引左侧的所有数字的总和等于在该索引右侧的所有数字的总和。</p><p>如果索引在数组的左边缘，则左总和为<code>0</code>，因为左侧没有元素，这也适用于数组的右边缘。如果存在多个枢轴索引，返回最左边的。 如果不存在这样的索引，则返回<code>-1</code>。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,7,3,6,5,6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The pivot index is 3.</span><br><span class="line">Left sum &#x3D; nums[0] + nums[1] + nums[2] &#x3D; 1 + 7 + 3 &#x3D; 11</span><br><span class="line">Right sum &#x3D; nums[4] + nums[5] &#x3D; 5 + 6 &#x3D; 11</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">There is no index that satisfies the conditions in the problem statement.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,1,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">The pivot index is 0.</span><br><span class="line">Left sum &#x3D; 0 (no elements to the left of index 0)</span><br><span class="line">Right sum &#x3D; nums[1] + nums[2] &#x3D; 1 + -1 &#x3D; 0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(N), S: O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 计算前缀和数组</span></span><br><span class="line">    <span class="comment">// 子数组和 nums[i..j] = prefix[j + 1] - prefix[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((prefix[i] - prefix[<span class="number">0</span>]) == (prefix[n] - prefix[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(N), S: O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum - leftSum - nums[i] == leftSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="523-Continuous-Subarray-Sum"><a href="#523-Continuous-Subarray-Sum" class="headerlink" title="523. Continuous Subarray Sum"></a><a href="https://leetcode.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. Continuous Subarray Sum</a></h5><blockquote><p>给定一个非负整数数组和目标整数<code>k</code>，编写一个函数以检查该数组是否具有大小至少为<code>2</code>的连续子数组，该子数组的总和为<code>k</code>的倍数。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: [23, 2, 4, 6, 7],  k &#x3D; 6</span><br><span class="line">&gt;Output: True</span><br><span class="line">&gt;Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: [23, 2, 6, 4, 7],  k &#x3D; 6</span><br><span class="line">&gt;Output: True</span><br><span class="line">&gt;Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数学知识 (a - b) % c = 0 --&gt; a % c = b % c</span></span><br><span class="line"><span class="comment">// 借助前缀和思想</span></span><br><span class="line"><span class="comment">// 使用哈希表记录所有的 (前缀和对 k 的余数) 及其 (对应的索引)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须存在的 base case</span></span><br><span class="line">    <span class="comment">// 为了处理 sum 本身 对 k 取余为 0 的情况</span></span><br><span class="line">    <span class="comment">// 也就是说这时满足条件的数组是首元素打头的子数组</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">int</span> mod = sum % k;</span><br><span class="line">        <span class="comment">// 记住对于前缀和数组</span></span><br><span class="line">        <span class="comment">// 子数组和 nums[i..j] = prefixSum[j + 1] - prefixSum[i]</span></span><br><span class="line">        <span class="comment">// 就理解了为什么是 &gt; 1 而不是 &gt;= 1 了</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(mod)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - mapping[mod] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mapping[mod] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1089-复写零"><a href="#1089-复写零" class="headerlink" title="1089. 复写零"></a><a href="https://leetcode-cn.com/problems/duplicate-zeros/" target="_blank" rel="noopener">1089. 复写零</a></h5><blockquote><p>给定固定长度的整数数组<code>arr</code>，请复制每次出现的零，将其余元素向右移动。请注意，不会写入超出原始数组长度的元素。</p><p>对输入数组进行就地修改，不要从函数中返回任何内容。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2,3,0,4,5,0]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,2,3]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的解法, 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">     <span class="comment">// 提前计算出原始数组中 0 的个数</span></span><br><span class="line">    <span class="keyword">int</span> zerosCnt = count(arr.begin(), arr.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(zerosCnt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算非零元素的新索引</span></span><br><span class="line">            <span class="comment">// 在此处, 保证 zerosCnt 变量始终是大于 0 的</span></span><br><span class="line">            <span class="comment">// 且表示此非零元素前面的 0 的个数</span></span><br><span class="line">            <span class="keyword">int</span> newPos = i + zerosCnt;</span><br><span class="line">            <span class="comment">// 如果有效就搬过去</span></span><br><span class="line">            <span class="keyword">if</span>(newPos &lt; n) &#123;</span><br><span class="line">                arr[newPos] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原索引处赋 0</span></span><br><span class="line">            arr[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 每次遇到一个 0, 就减 1</span></span><br><span class="line">            zerosCnt--;</span><br><span class="line">            <span class="comment">// 前面没有 0 了, 就不需要搬移了</span></span><br><span class="line">            <span class="keyword">if</span>(zerosCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="941-Valid-Mountain-Array"><a href="#941-Valid-Mountain-Array" class="headerlink" title="941. Valid Mountain Array"></a><a href="https://leetcode.com/problems/valid-mountain-array/" target="_blank" rel="noopener">941. Valid Mountain Array</a></h5><blockquote><p>给定一个整数数组<code>arr</code>，当且仅当它是有效的山峰数组时，才返回<code>true</code>。当且仅当满足以下条件时，<code>arr</code>是一个山峰数组：</p><ul><li><code>arr.size() &gt;= 3</code></li><li>There exists some <code>i</code> with <code>0 &lt; i &lt; arr.size() - 1</code></li></ul><p>such that：</p><ul><li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li><li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.size() - 1]</code></li></ul><img src="hint_valid_mountain_array.png" alt="img" style="zoom: 50%;" /><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [3,5,5]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [0,3,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接模拟就行</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 递增扫描</span></span><br><span class="line">    <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最高点不能是数组的第一个位置或最后一个位置</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递减扫描</span></span><br><span class="line">    <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. Find All Numbers Disappeared in an Array</a></h5><blockquote><p>给定一个整数数组，其中<code>1 ≤ a[i] ≤ n (n = 数组大小)</code>，某些元素出现两次，而另一些元素出现一次。查找<code>[1，n]</code>包含的所有未出现在此数组中的元素。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 将所有出现过的值作为索引 (值减 1 ), 将该索引所在处的值映射为负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 最后没被映射为负数的值, 其对应的索引 +1 就是未出现的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="442-Find-All-Duplicates-in-an-Array"><a href="#442-Find-All-Duplicates-in-an-Array" class="headerlink" title="442. Find All Duplicates in an Array"></a><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">442. Find All Duplicates in an Array</a></h5><blockquote><p>给定一个整数数组，即<code>1 ≤ a[i] ≤ n (n = 数组大小)</code>，其中有些元素出现<strong>两次</strong>而其他元素出现<strong>一次</strong>。找到所有出现<strong>两次</strong>的元素。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 将所有出现过的值作为索引 (值减 1 ), 将该索引所在处的值映射为负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果已经被映射为负数, 说明之前这个数出现过一次了</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1744-Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day"><a href="#1744-Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day" class="headerlink" title="1744. Can You Eat Your Favorite Candy on Your Favorite Day?"></a><a href="https://leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/" target="_blank" rel="noopener">1744. Can You Eat Your Favorite Candy on Your Favorite Day?</a></h5><blockquote><p>  给你一个下标从<code>0</code>开始的正整数数组<code>candiesCount</code>，其中<code>candiesCount[i]</code>表示你拥有的第<code>i</code>类糖果的数目。同时给你一个二维数组<code>queries</code>，其中<code>queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]</code>。</p><p>  你按照如下规则进行一场游戏：</p><ul><li><p>你从第<code>0</code>天开始吃糖果。</p></li><li><p>你在吃完所有第<code>i - 1</code>类糖果之前，不能吃任何一颗第<code>i</code>类糖果。</p></li><li><p>在吃完所有糖果之前，你必须每天至少吃一颗糖果。</p><p>请你构建一个布尔型数组<code>answer</code>，满足<code>answer.length == queries.length</code>。<code>answer[i]</code>为<code>true</code>的条件是：在每天吃不超过<code>dailyCap_i</code>颗糖果的前提下，你可以在第<code>favoriteDay_i</code>天吃到第<code>favoriteType_i</code>类糖果；否则<code>answer[i]</code>为<code>false</code>。注意，只要满足上面<code>3</code>条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</p><p>请你返回得到的数组<code>answer</code>。</p></li></ul><p>  <strong>示例</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candiesCount &#x3D; [7,4,5,3,8], queries &#x3D; [[0,2,2],[4,2,4],[2,13,1000000000]]</span><br><span class="line">输出：[true,false,true]</span><br><span class="line">提示：</span><br><span class="line">1. 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果</span><br><span class="line">2. 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果</span><br><span class="line">3. 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀和 + 区间交集</span></span><br><span class="line"><span class="comment">// 对每一颗糖果依次进行编号</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">canEat</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candiesCount, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; queries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = candiesCount.size();</span><br><span class="line">    <span class="comment">// 用 long 防止后面的乘法和加法溢出</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; <span class="title">prefixSum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        prefixSum[i] = prefixSum[i - <span class="number">1</span>] + candiesCount[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">    res.reserve(queries.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;query : queries)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每天至少吃 1 颗, 至多吃 query[2] 颗</span></span><br><span class="line">        <span class="comment">// 因此在第 query[1] 天能吃到的糖果的编号范围是 [x1, y1]</span></span><br><span class="line">        <span class="keyword">long</span> x1 = query[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y1 = <span class="keyword">long</span>((query[<span class="number">1</span>] + <span class="number">1</span>)) * query[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 类型为 query[0] 的糖果的编号范围为 [x2, y2]</span></span><br><span class="line">        <span class="keyword">long</span> x2 = prefixSum[query[<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y2 = prefixSum[query[<span class="number">0</span>] + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果有交集就满足条件</span></span><br><span class="line">        res.push_back(x1 &lt;= y2 &amp;&amp; x2 &lt;= y1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="710-黑名单中的随机数"><a href="#710-黑名单中的随机数" class="headerlink" title="710. 黑名单中的随机数"></a><a href="https://leetcode-cn.com/problems/random-pick-with-blacklist/" target="_blank" rel="noopener">710. 黑名单中的随机数</a></h5><blockquote><p>给你输入一个正整数<code>N</code>，代表左闭右开区间<code>[0,N)</code>，再给你输入一个数组<code>blacklist</code>，其中包含一些「黑名单数字」，且<code>blacklist</code>中的数字都是区间<code>[0,N)</code>中的数字。</p><p>编写一个函数以随机返回<code>[0，N)</code>中的一个整数，该整数不在<code>blacklist</code>中。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本思路是记录下实际有效的数字的个数 actual</span></span><br><span class="line"><span class="comment">// 通过一个哈希表将黑名单中的在 [0, actual) 范围内的数字映射到 [actual N) 中不在黑名单中的数字身上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> actual;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; blacklist) &#123;</span><br><span class="line">        <span class="comment">// 先把黑名单中的所有数字放在哈希表中</span></span><br><span class="line">        <span class="comment">// 便于快速得到 [actual, N) 范围内的数字是否在黑名单中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : blacklist) &#123;</span><br><span class="line">            mapping[val] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        actual = N - blacklist.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : blacklist) &#123;</span><br><span class="line">            <span class="comment">// 黑名单中在 [0, actual) 范围内的数字才需要映射</span></span><br><span class="line">            <span class="keyword">if</span>(val &lt; actual) &#123;</span><br><span class="line">                N--;</span><br><span class="line">                <span class="comment">// 从后向前映射</span></span><br><span class="line">                <span class="comment">// 如果映射为的数字已经在黑名单中了</span></span><br><span class="line">                <span class="comment">// 就跳过</span></span><br><span class="line">                <span class="keyword">while</span>(mapping.count(N)) &#123;</span><br><span class="line">                    N--;</span><br><span class="line">                &#125;</span><br><span class="line">            mapping[val] = N;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % actual;</span><br><span class="line">        <span class="comment">// 如果这个数字在黑名单中, 需要返回其映射</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(i) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mapping[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="528-Random-Pick-with-Weight"><a href="#528-Random-Pick-with-Weight" class="headerlink" title="528. Random Pick with Weight"></a><a href="https://leetcode.com/problems/random-pick-with-weight/" target="_blank" rel="noopener">528. Random Pick with Weight</a></h5><blockquote><p>给定一个正整数数组<code>w</code>，其中<code>w[i]</code>描述第<code>i</code>个索引的权重。</p><p>我们需要调用函数<code>pickIndex()</code>，该函数随机返回范围为<code>[0，w.size())</code>的整数。 <code>pickIndex()</code>应该返回与其在<code>w</code>数组中的权重成比例的数。 例如，对于<code>w = [1，3]</code>，选择索引<code>0</code>的概率为<code>1 / (1 + 3) = 0.25</code>，而选择索引<code>1</code>的概率为<code>3 / (1 + 3)  = 0.75</code>。或者说，选择索引<code>i</code>的概率为<code>w[i] / sum(w)</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用前缀和数组</span></span><br><span class="line"><span class="comment">// 从 [0, sum(w)) 区间内随机产生一个数</span></span><br><span class="line"><span class="comment">// 看这个随机数落在前缀和数组的哪个区间内</span></span><br><span class="line"><span class="comment">// 比如 w = &#123;1, 4, 7, 2&#125;;</span></span><br><span class="line"><span class="comment">// prefixSum = &#123;0, 1, 5, 12, 14&#125;;</span></span><br><span class="line"><span class="comment">// 从 [0, 14) 区间内随机产生一个数</span></span><br><span class="line"><span class="comment">// 落在 [0, 1) 区间返回 0</span></span><br><span class="line"><span class="comment">// 落在 [1, 5) 区间返回 1</span></span><br><span class="line"><span class="comment">// 落在 [5, 12) 区间返回 2</span></span><br><span class="line"><span class="comment">// 落在 [12, 14) 区间返回 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefixSum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) : prefixSum(w.size() + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.size(); i++) &#123;</span><br><span class="line">            prefixSum[i + <span class="number">1</span>] = prefixSum[i] + w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> target = rand() % prefixSum.back();</span><br><span class="line">        <span class="comment">// 通过二分搜索加快搜索速度</span></span><br><span class="line">        <span class="comment">// 右边界搜索第一个大于目标值的索引</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = prefixSum.size();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = (hi + lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(prefixSum[mi] &lt;= target) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water</a></h5><blockquote><p>给你<code>n</code>个非负整数<code>a1, a2, ..., an</code>，每个数代表坐标中的一个点<code>(i, ai)</code> 。在坐标内画<code>n</code>条垂直线，垂直线<code>i</code>的两个端点分别为<code>(i, ai)</code>和<code>(i, 0)</code> 。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。</p><p>返回容纳的水量。</p><p><strong>Example:</strong></p><img src="question_11.jpg" alt="img" style="zoom: 67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = height.size();</span><br><span class="line">    <span class="comment">// 左右指针解法</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt;= height[right]) &#123;</span><br><span class="line">            res = max(res, (right - left) * height[left]);</span><br><span class="line">            <span class="comment">// 小的变化, 大的不变</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = max(res, (right - left) * height[right]);</span><br><span class="line">            <span class="comment">// 小的变化, 大的不变</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. Trapping Rain Water</a></h5><blockquote><p>给定<code>n</code>个表示海拔图的非负整数，其中每个条的宽度为<code>1</code>，计算下雨后它可以捕集多少水。</p><p><strong>Example:</strong></p><img src="rainwatertrap.png" alt="img"  /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每一个槽, 它所能接的水量取决于它左边最高的柱子和右边最高的柱子中的较低者</span></span><br><span class="line"><span class="comment">// 较低的值减去自身的高度就为该槽所能接的水量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了备忘录的方法</span></span><br><span class="line"><span class="comment">// 提前计算出每个槽左边最高的柱子和右边最高的柱子(包括它自己的高度)</span></span><br><span class="line"><span class="comment">// left_max[i] 表示第 i 个槽左边最高的柱子的高度</span></span><br><span class="line"><span class="comment">// right_max[i] 表示第 i 个槽右边最高的柱子的高度</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n), 但空间复杂度也为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = height.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left_max</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_max</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    left_max.front() = height.front();</span><br><span class="line">    right_max.back() = height.back();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        left_max[i] = max(height[i], left_max[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right_max[i] = max(height[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res += min(left_max[i], right_max[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用双指针解法</span></span><br><span class="line"><span class="comment">// 边走边记录左边柱子最高值和右边柱子最高值</span></span><br><span class="line"><span class="comment">// 优化后的时间复杂度为 O(n), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = height.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        left_max = max(left_max, height[left]);</span><br><span class="line">        right_max = max(right_max, height[right]);</span><br><span class="line">        <span class="keyword">if</span>(left_max &lt; right_max) &#123;</span><br><span class="line">            res += left_max - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += right_max - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1395-Count-Number-of-Teams"><a href="#1395-Count-Number-of-Teams" class="headerlink" title="1395. Count Number of Teams"></a><a href="https://leetcode.com/problems/count-number-of-teams/" target="_blank" rel="noopener">1395. Count Number of Teams</a></h5><blockquote><p><code>n</code>名士兵站成一排。每个士兵都有一个<strong>独一无二的评分</strong><code>rating</code>。每<code>3</code>个士兵可以组成一个作战单位，分组规则如下：</p><ol><li>从队伍中选出下标分别为<code>i、j、k</code>的<code>3</code>名士兵，他们的评分分别为<code>rating[i]、rating[j]、rating[k]</code>；</li><li>作战单位需满足：<code>rating[i] &lt; rating[j] &lt; rating[k]</code>或者<code>rating[i] &gt; rating[j] &gt; rating[k]</code>，其中<code>0 &lt;= i &lt; j &lt; k &lt; n</code>。</li></ol><p>你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。</p><p><strong>Example 1</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [2,5,3,4,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). </span><br></pre></td></tr></table></figure><p><strong>Example 2</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [2,1,3]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: We can&#39;t form any team given the conditions.</span><br></pre></td></tr></table></figure><p><strong>Example 3</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [1,2,3,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前求得每个元素右边的比它大的元素个数和比它小的元素个数</span></span><br><span class="line"><span class="comment">// 通过两次 O(n2) 的循环, 将时间复杂度减少到 O(n2), 但空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = rating.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_max</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_min</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rating[i] &lt; rating[j]) &#123;</span><br><span class="line">                right_max[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right_min[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rating[i] &lt; rating[j]) &#123;</span><br><span class="line">                res += right_max[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += right_min[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h5 id="480-Sliding-Window-Median"><a href="#480-Sliding-Window-Median" class="headerlink" title="480. Sliding Window Median"></a><a href="https://leetcode.com/problems/sliding-window-median/" target="_blank" rel="noopener">480. Sliding Window Median</a></h5><blockquote><p>中值是有序整数列表中的中间值。 如果列表的大小是偶数，则没有中间值，此时，中位数是两个中间值的平均值。</p><p>给定一个数组<code>num</code>，存在一个大小为<code>k</code>的滑动窗口，该窗口从数组的最左边移到最右边。 你只能在窗口中看到<code>k</code>个数字。 每次滑动窗口向右移动一个位置。 你的工作是输出原始数组中每个窗口的中值数组。</p><p>For example, Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window position               Median</span><br><span class="line">---------------               ------</span><br><span class="line">[1  3  -1] -3  5  3  6  7       1</span><br><span class="line">1  [3  -1  -3] 5  3  6  7      -1</span><br><span class="line">1  3  [-1  -3  5] 3  6  7      -1</span><br><span class="line">1  3  -1  [-3  5  3] 6  7       3</span><br><span class="line">1  3  -1  -3  [5  3  6] 7       5</span><br><span class="line">1  3  -1  -3  5  [3  6  7]      6</span><br></pre></td></tr></table></figure><p>Therefore, return the median sliding window as<code>[1,-1,-1,3,5,6]</code>.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; median;</span><br><span class="line">    <span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">window</span><span class="params">(nums.begin(), next(nums.begin(), k))</span></span>;</span><br><span class="line">    <span class="comment">// k 为奇数, mid 指向中间元素, k 为偶数, mid 指向中间两个元素的后一个元素</span></span><br><span class="line">    <span class="comment">// 之后每一次插入和删除元素都要维护 mid 正确性</span></span><br><span class="line">    <span class="keyword">auto</span> mid = next(window.begin(), k / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            median.push_back(*mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            median.push_back((<span class="keyword">double</span>(*prev(mid)) + <span class="keyword">double</span>(*mid)) * <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果插入相同的元素</span></span><br><span class="line">        <span class="comment">// multiset 的 insert 操作将其插入到范围上界</span></span><br><span class="line">        window.insert(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; *mid) &#123;</span><br><span class="line">            mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i - k] &lt;= *mid) &#123;</span><br><span class="line">            mid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除时从范围下界删除可保证 mid 不失效</span></span><br><span class="line">        window.erase(window.lower_bound(nums[i - k]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> medianSlidingWindowForOdd(nums, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> medianSlidingWindowForEven(nums, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只考虑 k 为奇数的情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindowForOdd</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; median;</span><br><span class="line">    <span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">window</span><span class="params">(nums.begin(), next(nums.begin(), k))</span></span>;</span><br><span class="line">    <span class="comment">// 窗口内有奇数个元素时, mid 指向中间元素</span></span><br><span class="line">    <span class="comment">// 窗口内有偶数个元素时, mid 指向中间两个元素的后一个元素</span></span><br><span class="line">    <span class="comment">// 之后每一次插入和删除元素都要维护 mid 正确性</span></span><br><span class="line">    <span class="keyword">auto</span> mid = next(window.begin(), k / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; ; i++) &#123;</span><br><span class="line">        median.push_back(*mid);</span><br><span class="line">        <span class="keyword">if</span>(i == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意, 插入前集合中的元素数为奇数个</span></span><br><span class="line">        <span class="comment">// 如果插入相同的元素, multiset 的 insert 操作将其插入到范围上界</span></span><br><span class="line">        window.insert(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果插入在 mid 右边</span></span><br><span class="line">            ++mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入后变为偶数个元素了</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i - k] &lt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果在 mid 左边删除</span></span><br><span class="line">            window.erase(window.find(nums[i - k]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i - k] &gt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果在 mid 右边删除</span></span><br><span class="line">            window.erase(window.find(nums[i - k]));</span><br><span class="line">            --mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果删除的就是 mid</span></span><br><span class="line">            mid = window.erase(mid); <span class="comment">// 注意 erase 会返回删除元素的后继元素迭代器</span></span><br><span class="line">            --mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只考虑 k 为偶数的情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindowForEven</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; median;</span><br><span class="line">    <span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">window</span><span class="params">(nums.begin(), next(nums.begin(), k))</span></span>;</span><br><span class="line">    <span class="comment">// 窗口内有偶数个元素时, mid 指向中间元素</span></span><br><span class="line">    <span class="comment">// 窗口内有奇数个元素时, mid 指向中间两个元素的后一个元素</span></span><br><span class="line">    <span class="comment">// 之后每一次插入和删除元素都要维护 mid 正确性</span></span><br><span class="line">    <span class="keyword">auto</span> mid = next(window.begin(), k / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; ; i++) &#123;</span><br><span class="line">        median.push_back((<span class="keyword">double</span>(*prev(mid)) + <span class="keyword">double</span>(*mid)) * <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意, 插入前集合中的元素数为偶数个</span></span><br><span class="line">        <span class="comment">// 如果插入相同的元素, multiset 的 insert 操作将其插入到范围上界</span></span><br><span class="line">        window.insert(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果插入在 mid 左边</span></span><br><span class="line">            --mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入后变为奇数个元素了</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i - k] &lt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果在 mid 左边删除</span></span><br><span class="line">            window.erase(window.find(nums[i - k]));</span><br><span class="line">            ++mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i - k] &gt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果在 mid 右边删除</span></span><br><span class="line">            window.erase(window.find(nums[i - k]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果删除的就是 mid</span></span><br><span class="line">            mid = window.erase(mid); <span class="comment">// 注意 erase 会返回删除元素的后继元素迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. Sliding Window Maximum</a></h5><blockquote><p>  给你一个整数数组<code>num</code>，有一个大小为<code>k</code>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的<code>k</code>个数字。滑动窗口每次只向右移动一位。</p><p>  返回滑动窗口中的最大值。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line">1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line">1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line">1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line">1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line">1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列保证从队头到队尾是递减的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonoQ</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; monoQ;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 如果入队的值比队尾的值大, 就把队尾元素 pop 掉, 这样保证是递减的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!monoQ.empty() &amp;&amp; monoQ.back() &lt; val) &#123;</span><br><span class="line">            monoQ.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        monoQ.push_back(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pop 的时候如果不是队头元素就什么也不做</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(monoQ.front() == val) &#123;</span><br><span class="line">            monoQ.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大值就是队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> monoQ.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 维护一个大小为 k 的递减队列</span></span><br><span class="line"><span class="comment">// 这个队列就相当于是题目中的滑动窗口</span></span><br><span class="line"><span class="comment">// 只是单调之后取其中的最大值很方便</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    MonoQ monoQ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        monoQ.push(nums[i]);</span><br><span class="line">        <span class="comment">// 如果窗口内的元素数等于 k</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 最大值就是队头元素</span></span><br><span class="line">            res.push_back(monoQ.maxVal());</span><br><span class="line">            <span class="comment">// pop 掉最左边的将要出窗口的元素</span></span><br><span class="line">            monoQ.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当然也可以不先写好一个单调队列类</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 用 deque 模拟队列</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; monoQ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!monoQ.empty() &amp;&amp; monoQ.back() &lt; nums[i]) &#123;</span><br><span class="line">            monoQ.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        monoQ.push_back(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            res.push_back(monoQ.front());</span><br><span class="line">            <span class="keyword">if</span>(monoQ.front() == nums[i - k + <span class="number">1</span>]) &#123;</span><br><span class="line">                monoQ.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1834-Single-Threaded-CPU"><a href="#1834-Single-Threaded-CPU" class="headerlink" title="1834. Single-Threaded CPU"></a><a href="https://leetcode.com/problems/single-threaded-cpu/" target="_blank" rel="noopener">1834. Single-Threaded CPU</a></h5><blockquote><p>给你一个二维数组<code>tasks</code>，用于表示<code>n</code>项从<code>0</code>到<code>n - 1</code>编号的任务。其中<code>tasks[i] = [enqueueTimei, processingTimei]</code>意味着第<code>i</code>项任务将会于<code>enqueueTimei</code>时进入任务队列，需要<code>processingTimei</code>的时长完成执行。</p><p>现有一个单线程<code>CPU</code>，同一时间只能执行最多一项任务，该<code>CPU</code>将会按照下述方式运行：</p><ul><li>如果<code>CPU</code>空闲，且任务队列中没有需要执行的任务，则<code>CPU</code>保持空闲状态。</li><li>如果<code>CPU</code>空闲，但任务队列中有需要执行的任务，则<code>CPU</code>将会选择执行时间最短的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li><li>一旦某项任务开始执行，<code>CPU</code>在执行完整个任务前都不会停止。</li><li><code>CPU</code>可以在完成一项任务后，立即开始执行一项新任务。</li></ul><p>返回<code>CPU</code>处理任务的顺序。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: tasks &#x3D; [[1,2],[2,4],[3,2],[4,1]]</span><br><span class="line">&gt;Output: [0,2,3,1]</span><br><span class="line">&gt;Explanation: The events go as follows: </span><br><span class="line">&gt;- At time &#x3D; 1, task 0 is available to process. Available tasks &#x3D; &#123;0&#125;.</span><br><span class="line">&gt;- Also at time &#x3D; 1, the idle CPU starts processing task 0. Available tasks &#x3D; &#123;&#125;.</span><br><span class="line">&gt;- At time &#x3D; 2, task 1 is available to process. Available tasks &#x3D; &#123;1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 3, task 2 is available to process. Available tasks &#x3D; &#123;1, 2&#125;.</span><br><span class="line">&gt;- Also at time &#x3D; 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks &#x3D; &#123;1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 4, task 3 is available to process. Available tasks &#x3D; &#123;1, 3&#125;.</span><br><span class="line">&gt;- At time &#x3D; 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks &#x3D; &#123;1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 6, the CPU finishes task 3 and starts processing task 1. Available tasks &#x3D; &#123;&#125;.</span><br><span class="line">&gt;- At time &#x3D; 10, the CPU finishes task 1 and becomes idle.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: tasks &#x3D; [[7,10],[7,12],[7,5],[7,4],[7,2]]</span><br><span class="line">&gt;Output: [4,3,2,0,1]</span><br><span class="line">&gt;Explanation: The events go as follows:</span><br><span class="line">&gt;- At time &#x3D; 7, all the tasks become available. Available tasks &#x3D; &#123;0,1,2,3,4&#125;.</span><br><span class="line">&gt;- Also at time &#x3D; 7, the idle CPU starts processing task 4. Available tasks &#x3D; &#123;0,1,2,3&#125;.</span><br><span class="line">&gt;- At time &#x3D; 9, the CPU finishes task 4 and starts processing task 3. Available tasks &#x3D; &#123;0,1,2&#125;.</span><br><span class="line">&gt;- At time &#x3D; 13, the CPU finishes task 3 and starts processing task 2. Available tasks &#x3D; &#123;0,1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 18, the CPU finishes task 2 and starts processing task 0. Available tasks &#x3D; &#123;1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 28, the CPU finishes task 0 and starts processing task 1. Available tasks &#x3D; &#123;&#125;.</span><br><span class="line">&gt;- At time &#x3D; 40, the CPU finishes task 1 and becomes idle.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Pair = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> taskCount = tasks.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> taskId = <span class="number">0</span>; taskId &lt; taskCount; taskId++) &#123;</span><br><span class="line">        tasks[taskId].push_back(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(tasks.begin(), tasks.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    priority_queue&lt;Pair, <span class="built_in">vector</span>&lt;Pair&gt;, greater&lt;Pair&gt;&gt; tasksQueue;</span><br><span class="line">    <span class="keyword">int</span> taskId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> timeStamp = <span class="number">0</span>; <span class="comment">// 时刻</span></span><br><span class="line">    <span class="keyword">while</span>(taskId &lt; taskCount || !tasksQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tasksQueue.empty()) &#123;</span><br><span class="line">            timeStamp = max(timeStamp, (<span class="keyword">long</span>)tasks[taskId][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(taskId &lt; taskCount &amp;&amp; tasks[taskId][<span class="number">0</span>] &lt;= timeStamp) &#123;</span><br><span class="line">            tasksQueue.push(&#123;tasks[taskId][<span class="number">1</span>], tasks[taskId][<span class="number">2</span>]&#125;);</span><br><span class="line">            taskId++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [duration, id] = tasksQueue.top();</span><br><span class="line">        tasksQueue.pop();</span><br><span class="line">        timeStamp += duration;</span><br><span class="line">        res.push_back(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>，请你将该数组升序排列。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下滤操作, 复杂度正比于完全二叉树的高度为 log(n)</span></span><br><span class="line">    <span class="comment">// 参数 n 代表 [有效堆] 数组的长度, 可用于验证待下滤元素 hole 的左右孩子节点的合法性</span></span><br><span class="line">    <span class="keyword">auto</span> down = [&amp;](<span class="keyword">int</span> hole, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 先保存待下滤的值, hole 代表洞号</span></span><br><span class="line">        <span class="keyword">int</span> holeVal = nums[hole];</span><br><span class="line">        <span class="comment">// 先找到待下滤元素的左孩子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lc = <span class="number">2</span> * hole + <span class="number">1</span>; lc &lt; n; lc = <span class="number">2</span> * hole + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果右子节点存在并且左子节点的值小于等于右子节点</span></span><br><span class="line">            <span class="keyword">if</span>(lc + <span class="number">1</span> &lt; n &amp;&amp; nums[lc] &lt;= nums[lc + <span class="number">1</span>]) &#123;</span><br><span class="line">                lc++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时, lc 指向孩子节点中较大的那一个</span></span><br><span class="line">            <span class="comment">// 如果待下滤的值比孩子中较大的还大, 就不需要下滤了</span></span><br><span class="line">            <span class="keyword">if</span>(nums[lc] &lt;= holeVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[hole] = nums[lc];</span><br><span class="line">            <span class="comment">// 产生新的洞号</span></span><br><span class="line">            hole = lc;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[hole] = holeVal;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 获取末元素的父亲, 也就是最后一个内部节点</span></span><br><span class="line">    <span class="keyword">int</span> lastInternal = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 建堆操作, 复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">while</span>(lastInternal &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        down(lastInternal--, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 此时最大元素是首元素</span></span><br><span class="line">        <span class="comment">// 首尾交换, 末元素就位</span></span><br><span class="line">        swap(nums[i], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 将新首元素下滤</span></span><br><span class="line">        down(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序, 自顶向下递归实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 排序 [0, n - 1] 之间的元素</span></span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单元素自动有序</span></span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, lo, mi);</span><br><span class="line">    mergeSort(nums, mi + <span class="number">1</span>, hi);</span><br><span class="line">    merge(nums, lo, mi, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="comment">// [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 辅助空间, 存储 [mi + 1, hi] 元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(next(nums.begin(), mi + <span class="number">1</span>), next(nums.begin(), hi + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 对两个数组中的元素, 依次从后向前比较</span></span><br><span class="line">    <span class="comment">// 从后向前放置元素, 先放较大者</span></span><br><span class="line">    <span class="keyword">int</span> i = mi;</span><br><span class="line">    <span class="keyword">int</span> j = hi - mi - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = hi;</span><br><span class="line">    <span class="comment">// 注意 i 的终止条件</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= lo &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意, 这里如果是 &gt;= 就不稳定了</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; helper[j]) &#123;</span><br><span class="line">            nums[k--] = nums[i--];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 归并排序, 自底向上迭代实现 */</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">    <span class="comment">// 中间节点相对于起点的位置是 1 个 step</span></span><br><span class="line">    <span class="comment">// 终点相对于起点是 2 个 step</span></span><br><span class="line">    <span class="comment">// step 从 1 开始直到等于数组的长度 sz </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= sz; step *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意, 这里 lo 从 0 开始直到等于 sz - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; sz; lo += <span class="number">2</span> * step) &#123;</span><br><span class="line">            <span class="comment">// 因为 merge 函数实现的原因, 都是闭区间, 而且 [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line">            <span class="comment">// 所以这里求出的 mi 和 hi 都需要减 1</span></span><br><span class="line">            merge(nums, lo, min(lo + step - <span class="number">1</span>, sz - <span class="number">1</span>), min(lo + <span class="number">2</span> * step - <span class="number">1</span>, sz - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quick sort</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机置乱闭区间 [lo, hi] 内的元素</span></span><br><span class="line">    <span class="keyword">auto</span> shuffle = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = rand() % (hi - i + <span class="number">1</span>) + i;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> partition = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        shuffle(lo, hi);</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = lo;</span><br><span class="line">        <span class="keyword">while</span>(++j &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= nums[lo]) &#123;</span><br><span class="line">                swap(nums[++i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[lo], nums[i]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(lo, hi);</span><br><span class="line">    quickSort(nums, lo, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, pivot + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. Find First and Last Position of Element in Sorted Array</a></h5><blockquote><p>给定一个以升序排列的整数<code>nums</code>数组，请找到给定目标值的开始和结束位置。如果在数组中未找到目标，则返回<code>[-1，-1]</code>。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = right_bound(nums, target - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> right = right_bound(nums, target);</span><br><span class="line">    <span class="keyword">if</span>(left &lt; <span class="number">0</span> || left &gt;= nums.size() || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;left, right - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边界搜索是返回第一个大于目标值的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[mi]) &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. Search a 2D Matrix II</a></h5><blockquote><p>  编写一个高效的算法来搜索<code>m x n</code>矩阵<code>matrix</code>中的一个目标值<code>target</code>。该矩阵具有以下特性：</p><ol><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ol><p>  <strong>Example 1:</strong></p>  <img src="searchgrid.jpg" alt="img" style="zoom:67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <img src="searchgrid2.jpg" alt="img" style="zoom:67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; n &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; matrix[r][c]) &#123;</span><br><span class="line">            c--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[r][c]) &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">162. Find Peak Element</a></h5><blockquote><p>  峰值元素是指其值严格大于左右相邻值的元素。给你一个输入数组<code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回<strong>任何一个峰值</strong>所在位置即可。</p><p>  你可以假设<code>nums[-1] = nums[n] = -∞</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mi] &gt; nums[mi + <span class="number">1</span>])</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="658-Find-K-Closest-Elements"><a href="#658-Find-K-Closest-Elements" class="headerlink" title="658. Find K Closest Elements"></a><a href="https://leetcode.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. Find K Closest Elements</a></h5><blockquote><p>  给定一个排序好的数组<code>arr</code>，两个整数<code>k</code>和<code>x</code>，从数组中找到最靠近<code>x</code>（两数之差最小）的<code>k</code>个数。返回的结果必须要是按升序排好的。</p><p>  整数<code>a</code>比整数<code>b</code>更接近<code>x</code>需要满足：</p><ul><li><code>|a - x| &lt; |b - x|</code>或者</li><li><code>|a - x| == |b - x|</code>且<code>a &lt; b</code>.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照与 x 差值的绝对值进行排序</span></span><br><span class="line"><span class="comment">// 返回排序后数组的前 k 个元素的原始顺序即可</span></span><br><span class="line"><span class="comment">// 时间复杂度为排序的复杂度 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(arr)</span></span>;</span><br><span class="line">    sort(res.begin(), res.end(),</span><br><span class="line">         [x](<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">abs</span>(a - x) == <span class="built_in">abs</span>(b - x) ? a &lt; b : <span class="built_in">abs</span>(a - x) &lt; <span class="built_in">abs</span>(b - x);</span><br><span class="line">         &#125;);</span><br><span class="line">    res.resize(k);</span><br><span class="line">    sort(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为数组已经是有序的, 先通过二分搜索找到 x 在数组中的位置</span></span><br><span class="line"><span class="comment">// 根据 x 的位置不同有几种情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; res(k);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 里面这段二分搜索是左边界搜索</span></span><br><span class="line">    <span class="comment">// lo 最后指向第一个大于等于 x 的元素</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = arr.size();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= arr[mi]) &#123;</span><br><span class="line">            hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 小于等于数组中的任何数, 那离 x 最近的就是前 k 个元素</span></span><br><span class="line">    <span class="keyword">if</span>(lo == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// copy_n(arr.begin(), k, res.begin());</span></span><br><span class="line">        copy(arr.begin(), arr.end(), back_inserter(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 大于等于数组中的任何数, 那离 x 最近的就是后 k 个元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(lo == arr.size()) &#123;</span><br><span class="line">        <span class="comment">// copy_n(arr.end() - k, k, res.begin());</span></span><br><span class="line">        copy(prev(arr.end(), k), arr.end(), back_inserter(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在中间, 就设置两个指针</span></span><br><span class="line">        <span class="comment">// 左右指针离 lo 的位置都为 k, 组成一个窗口</span></span><br><span class="line">        <span class="comment">// 在窗口中移动双指针使得窗口内元素数缩减为最接近 x 的 k 个数即可</span></span><br><span class="line">        <span class="keyword">int</span> left = max(lo - k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right = min(lo + k, <span class="keyword">int</span>(arr.size()) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(right - left &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[left] - x) &lt;= <span class="built_in">abs</span>(arr[right] - x)) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy_n(arr.begin() + left, k, res.begin());</span></span><br><span class="line">        copy(next(arr.begin(), left), next(arr.begin(), left + k), back_inserter(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="719-Find-K-th-Smallest-Pair-Distance"><a href="#719-Find-K-th-Smallest-Pair-Distance" class="headerlink" title="719. Find K-th Smallest Pair Distance"></a><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/" target="_blank" rel="noopener">719. Find K-th Smallest Pair Distance</a></h5><blockquote><p>  给定一个整数数组，返回所有数对之间的<strong>第<code>k</code>个最小距离</strong>。一对<code>(A, B)</code> 的距离被定义为<code>A</code>和<code>B</code>之间的绝对差值。</p><p>  <strong>Note:</strong></p><ol><li><code>2 &lt;= len(nums) &lt;= 10000</code>.</li><li><code>0 &lt;= nums[i] &lt; 1000000</code>.</li><li><code>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2</code>.</li></ol><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums &#x3D; [1,3,1]</span><br><span class="line">k &#x3D; 1</span><br><span class="line">Output: 0 </span><br><span class="line">Explanation:</span><br><span class="line">Here are all the pairs:</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">Then the 1st smallest distance pair is (1,1), and its distance is 0.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力解法</span></span><br><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distances;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</span><br><span class="line">            distances.push_back(<span class="built_in">abs</span>(nums[i] - nums[j]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = distances.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(distances, lo, hi);</span><br><span class="line">        <span class="keyword">if</span>(pivot == k - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> distances[pivot];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pivot &lt; k - <span class="number">1</span>)</span><br><span class="line">            lo = pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = pivot - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = lo;</span><br><span class="line">    <span class="keyword">while</span>(++j &lt;= hi)</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &lt; nums[lo])</span><br><span class="line">            swap(nums[++i], nums[j]);</span><br><span class="line">    swap(nums[lo], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用一个 multiset 实现起来更简单, 但还是 Time Limit Exceeded!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="comment">// 因为核心在这, 计算所有的 pair 复杂度为 O(n2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</span><br><span class="line">            setting.insert(<span class="built_in">abs</span>(nums[i] - nums[j]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = next(setting.begin(), k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binary search, a good idea.</span></span><br><span class="line"><span class="comment">// another problem, 373. Find K Pairs with Smallest Sums</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先把数组排序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// pairs 之间的差值最小无非就是 0</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最大就是尾元素减去首元素嘛</span></span><br><span class="line">    <span class="keyword">int</span> hi = nums.back() - nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 问题转化为在这个范围内找到一个差值</span></span><br><span class="line">    <span class="comment">// 使得有 k - 1 个 pair 的差值不比它大</span></span><br><span class="line">    <span class="comment">// 这种在有序的数值范围内搜索一个特定值就是典型的二分搜索的应用</span></span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取差值的中间</span></span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 下面应用一个滑动窗口算法计算有多少个比 mi 小的差值</span></span><br><span class="line">        <span class="comment">// 不要被两个 while 循环吓到了, 实际复杂度只有 O(n), 不清楚看最下面注释</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[right] - nums[left] &gt; mi)</span><br><span class="line">                left++;</span><br><span class="line">            count += right - left;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// count == number of pairs with distance &lt;= mi</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= count)</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. Time Complexity:O(NlogW + NlogN), where N is the length of nums, and W is equal to nums[nums.length - 1] - nums[0]. The logW factor comes from our binary search, and we do O(N) work inside our call to possible (or to calculate count). The final O(NlogN) factor comes from sorting.</span></span><br><span class="line"><span class="comment">2. Space Complexity: O(1). No additional space is used except for integer variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">It is O(N). the possible function is a classic sliding windowing solution, left and right would always increment in each outer loop iteration, that is 'left' and 'right' sweeps elements in the array only once. So time complexity is O(2N) = O(N).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/" target="_blank" rel="noopener">373. Find K Pairs with Smallest Sums</a></h5><blockquote><p>  给定两个以升序排列的整形数组<code>nums1</code>和<code>nums2</code>，以及一个整数<code>k</code>。</p><p>  定义一对值<code>(u,v)</code>，其中第一个元素来自<code>nums1</code>，第二个元素来自<code>nums2</code>。</p><p>  找到和最小的<code>k</code>对数字<code>(u1,v1),(u2,v2)...(uk,vk)</code>。</p><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 104</code></li><li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li><li><code>nums1</code> and <code>nums2</code> both are sorted in <strong>ascending order</strong>.</li><li><code>1 &lt;= k &lt;= 1000</code></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3</span><br><span class="line">Output: [[1,2],[1,4],[1,6]]</span><br><span class="line">Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,1,2], nums2 &#x3D; [1,2,3], k &#x3D; 2</span><br><span class="line">Output: [[1,1],[1,1]]</span><br><span class="line">Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [3], k &#x3D; 3</span><br><span class="line">Output: [[1,3],[2,3]]</span><br><span class="line">Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kSmallestPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123; <span class="keyword">return</span> a.first + a.second &lt; b.first + b.second; &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; pq(cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num1 : nums1) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num2 : nums2) &#123;</span><br><span class="line">            pq.push(&#123;num1, num2&#125;);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k) &#123;</span><br><span class="line">                pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        res.push_back(&#123;pq.top().first, pq.top().second&#125;);</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. Minimum Size Subarray Sum</a></h5><blockquote><p>  给定一个含有<code>n</code>个正整数的数组和一个正整数<code>target</code>。</p><p>  找出该数组中满足其和<code>≥ target</code>的长度最小的连续子数组<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回<code>0</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 4, nums &#x3D; [1,4,4]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(n), S: O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(nums.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(prefix[right] - prefix[left] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            res = min(res, right - left);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(n), S: O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            res = min(res, right - left);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(nlogn), S: O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefixSum</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++)</span><br><span class="line">        prefixSum[i] = prefixSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to_find = target + prefixSum[i];</span><br><span class="line">        <span class="comment">// auto it = lower_bound(prefixSum.begin(), prefixSum.end(), to_find);</span></span><br><span class="line">        <span class="comment">// if(it != prefixSum.end())</span></span><br><span class="line">        <span class="comment">//     res = min(res, int(distance(prefixSum.begin(), it)) - i);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> it = _lower_bound(prefixSum, to_find);</span><br><span class="line">        <span class="keyword">if</span>(it != prefixSum.size())</span><br><span class="line">            res = min(res, it - i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _lower_bound(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[mi])</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"></a><a href="https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</a></h5><blockquote><p>给你一个整数数组<code>nums</code>，和一个表示限制的整数<code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于<code>limit</code>。如果不存在满足条件的子数组，则返回<code>0</code>。</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li><li><code>0 &lt;= limit &lt;= 109</code></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">&gt;Output: 2 </span><br><span class="line">&gt;Explanation: All subarrays are: </span><br><span class="line">&gt;[8] with maximum absolute diff |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">&gt;[8,2] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">&gt;[8,2,4] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">&gt;[8,2,4,7] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">&gt;[2] with maximum absolute diff |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">&gt;[2,4] with maximum absolute diff |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">&gt;[2,4,7] with maximum absolute diff |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">&gt;[4] with maximum absolute diff |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">&gt;[4,7] with maximum absolute diff |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">&gt;[7] with maximum absolute diff |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">&gt;Therefore, the size of the longest subarray is 2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">&gt;Output: 4 </span><br><span class="line">&gt;Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| &#x3D; 5 &lt;&#x3D; 5.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">&gt;Output: 3</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题使用一个滑动窗口是毋庸置疑的</span></span><br><span class="line"><span class="comment">// 关键是我们希望实时的知道窗口内元素的最大值和最小值</span></span><br><span class="line"><span class="comment">// 那么我们要将窗口内的元素存储在哪种合适的数据结构中</span></span><br><span class="line"><span class="comment">// 满足我们要求的同时还能保证效率呢</span></span><br><span class="line"><span class="comment">// 1. 二叉搜索树, 我们可以方便的获得其中的最大值和最小值, 并且插入的效率为 o(logn)</span></span><br><span class="line"><span class="comment">//    最小值在树的最左边, 最大值在树的最右边</span></span><br><span class="line"><span class="comment">// 2. 单调队列, 使用两个单调队列, 一个是从队首到队尾递减的顺序, 一个是从队首到队尾递增的顺序</span></span><br><span class="line"><span class="comment">//    这样最大值和最小值分别都在它们的队首, 插入的效率为 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意窗口中可能存在的重复值的情况</span></span><br><span class="line"><span class="comment">// 这些重复值在搜索树或者在队列中都要同时存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口 + multiset</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        setting.insert(nums[right++]);</span><br><span class="line">        <span class="keyword">while</span>(*setting.rbegin() - *setting.begin() &gt; limit)</span><br><span class="line">            setting.erase(setting.find(nums[left++]));</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小技巧: 对于需要实时获取序列中最大值或最小值的问题, 单调队列是非常适合的数据结构!</span></span><br><span class="line"><span class="comment">// 滑动窗口 + 单调队列</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; minQ;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxQ;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!minQ.empty() &amp;&amp; minQ.back() &gt; nums[right])</span><br><span class="line">            minQ.pop_back();</span><br><span class="line">        <span class="keyword">while</span>(!maxQ.empty() &amp;&amp; maxQ.back() &lt; nums[right])</span><br><span class="line">            maxQ.pop_back();</span><br><span class="line"></span><br><span class="line">        minQ.push_back(nums[right]);</span><br><span class="line">        maxQ.push_back(nums[right]);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(!minQ.empty() &amp;&amp; !maxQ.empty() &amp;&amp; (maxQ.front() - minQ.front() &gt; limit))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(minQ.front() == nums[left])</span><br><span class="line">                minQ.pop_front();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(maxQ.front() == nums[left])</span><br><span class="line">                maxQ.pop_front();</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一个数组模拟两个单调队列是真的秀啊</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// minL 和 minR 是最小值区间的左右指针, maxL 和 maxR 是最大值区间的左右指针</span></span><br><span class="line">    <span class="keyword">int</span> minL = <span class="number">0</span>, minR = <span class="number">-1</span>, maxL = nums.size(), maxR = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// l, r 是 nums 的左右指针</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个数组用来记录最小值和最大值</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ascending</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="comment">// 开始遍历 nums</span></span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果遍历到的数字在最小值区间内, 就收缩最小值区间</span></span><br><span class="line">        <span class="keyword">while</span>(minR &gt;= minL &amp;&amp; nums[r] &lt; ascending[minR])</span><br><span class="line">            minR--;</span><br><span class="line">        <span class="comment">// 如果遍历到的数字在最大值区间内, 就收缩最大值区间</span></span><br><span class="line">        <span class="keyword">while</span>(maxR &gt;= maxL &amp;&amp; nums[r] &gt; ascending[maxL])</span><br><span class="line">            maxL++;</span><br><span class="line">        <span class="comment">// 拓展最小值和最大值区间</span></span><br><span class="line">        ascending[++minR] = nums[r];</span><br><span class="line">        ascending[--maxL] = nums[r];</span><br><span class="line">        r++;</span><br><span class="line">        <span class="comment">// 判断子集长度是否符合 limit 的要求, 如果不符合要求, 就收缩子集</span></span><br><span class="line">        <span class="keyword">while</span>(ascending[maxR] - ascending[minL] &gt; limit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 开始收缩子集, 使子集左指针右移</span></span><br><span class="line">            <span class="comment">// 如果子集左指针是最小值, 那么最小值将被移除, 所以更新存储最小值的区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == ascending[minL])</span><br><span class="line">                minL++;</span><br><span class="line">            <span class="comment">// 如果子集左指针是最大值, 那么最大值将被移除, 所以更新存储最大值的区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == ascending[maxR])</span><br><span class="line">                maxR--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, r - l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220. Contains Duplicate III"></a><a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. Contains Duplicate III</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>和两个整数<code>k</code>和<code>t</code>。请你判断是否存在两个不同下标<code>i</code>和<code>j</code>，使得<code>abs(nums[i] - nums[j]) &lt;= t</code>，同时又满足<code>abs(i - j) &lt;= k</code>。如果存在则返回<code>true</code>，不存在返回<code>false</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,0,1,1], k &#x3D; 1, t &#x3D; 2</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口 + 二叉搜索树</span></span><br><span class="line"><span class="comment">// 在 set 中维护一个元素数为 k 的滑动窗口</span></span><br><span class="line"><span class="comment">// 这可保证在 set 中的元素的索引满足 abs(i - j) &lt;= k</span></span><br><span class="line"><span class="comment">// 我们每迭代到数组中的下一个元素 [nums[i], 在更新 set 前</span></span><br><span class="line"><span class="comment">// 都要在其中找到一个在 [nums[i] - k, nums[i] + k] 范围内的值</span></span><br><span class="line"><span class="comment">// 如果存在, 那么就满足 abs(nums[i] - nums[j]) &lt;= t</span></span><br><span class="line"><span class="comment">// 为什么选择 multiset?</span></span><br><span class="line"><span class="comment">// 因为 set 具有自动排序的特性, 并且每次查找、删除和插入的复杂度都为</span></span><br><span class="line"><span class="comment">// 高效的 log(n). 因为我们要频繁地查找在范围 [nums[i] - k,</span></span><br><span class="line"><span class="comment">// nums[i] + k] 内的值, 还要频繁地删除和插入元素以维持固定地滑动窗口大小</span></span><br><span class="line"><span class="comment">// 注意一点, 在计算 nums[i] - k 和 nums[i] + k 的时候可能会出现数值溢出</span></span><br><span class="line"><span class="comment">// 所以要全部用 long</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; ms;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意此时 nums[i] 是不包含在窗口内的</span></span><br><span class="line">        <span class="comment">// 并且窗口内的元素数量 ? &lt;= k, 我们以第 ? + 1 个元素为对象</span></span><br><span class="line">        <span class="comment">// 寻找满足条件的另一个元素, 这样每一个元素都会 [被看作对象] 一次</span></span><br><span class="line">        <span class="keyword">long</span> valMin = (<span class="keyword">long</span>)nums[i] - (<span class="keyword">long</span>)t;</span><br><span class="line">        <span class="comment">// iter 指向首次进入 [nums[i] - k, ... 范围的数</span></span><br><span class="line">        <span class="comment">// 因此还要验证这个数是否也在 ..., nums[i] + k] 范围内</span></span><br><span class="line">        <span class="keyword">auto</span> iter = ms.lower_bound(valMin);</span><br><span class="line">        <span class="comment">// 如果存在这么一个数, 就找到满足条件的两个数了</span></span><br><span class="line">        <span class="keyword">if</span>(iter != ms.end() &amp;&amp; *iter &lt;= (<span class="keyword">long</span>)nums[i] + (<span class="keyword">long</span>)t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前对象已经处理过了, 将它放进窗口</span></span><br><span class="line">        <span class="comment">// 如果窗口大小超过 k 了, 还要将最左边的那个数剔出窗口</span></span><br><span class="line">        ms.insert(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(ms.size() &gt; k)</span><br><span class="line">            ms.erase(nums[i - k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口 + 分桶</span></span><br><span class="line"><span class="comment">// 将数组中的数值按照映射函数分配到相应桶中</span></span><br><span class="line"><span class="comment">// 映射函数为 桶号 id = value / (t + 1)</span></span><br><span class="line"><span class="comment">// 这样可保证</span></span><br><span class="line"><span class="comment">// 1. 映射到同一个桶的数值之差一定小于等于 t</span></span><br><span class="line"><span class="comment">// 2. 相邻桶中也有可能存在差值小于等于 t 的情况</span></span><br><span class="line"><span class="comment">// 3. 不相邻的桶中元素差值必定大于 t</span></span><br><span class="line"><span class="comment">// 如数组为 [1 5 9 1 3 7 8], k = 2, t = 3, 桶宽度为 t + 1 = 4</span></span><br><span class="line"><span class="comment">// 0 号桶: [1 1 3], 1 号桶: [5 7], 2 号桶: [9 8]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bucketsWidth = <span class="keyword">long</span>(t) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; buckets;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = getKey(nums[i], bucketsWidth);</span><br><span class="line">        <span class="comment">// 在一个桶中一定满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.count(id)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 在左边相邻桶中, 再判断差值是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.count(id - <span class="number">1</span>) &amp;&amp; nums[i] - buckets[id - <span class="number">1</span>] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 在右边相邻桶中, 再判断差值是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.count(id + <span class="number">1</span>) &amp;&amp; buckets[id + <span class="number">1</span>] - nums[i] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        buckets[id] = nums[i];</span><br><span class="line">        <span class="comment">// 保证所有桶中的元素小于等于 k 个</span></span><br><span class="line">        <span class="comment">// 如果大于 k, 就将窗口最左边的元素剔除</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.size() &gt; k)</span><br><span class="line">            buckets.erase(getKey(nums[i - k], bucketsWidth));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKey</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">long</span> bucketsWidth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = value / bucketsWidth;</span><br><span class="line">    <span class="comment">// 注意这里如果 value 为负数, 需要将桶号减 1</span></span><br><span class="line">    <span class="comment">// 保证 0 号桶的正确性</span></span><br><span class="line">    <span class="keyword">if</span>(value &lt; <span class="number">0</span>) id--;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="498-Diagonal-Traverse"><a href="#498-Diagonal-Traverse" class="headerlink" title="498. Diagonal Traverse"></a><a href="https://leetcode.com/problems/diagonal-traverse/" target="_blank" rel="noopener">498. Diagonal Traverse</a></h5><blockquote><p>  给定一个含有<code>m x n</code>个元素的矩阵（<code>m</code>行，<code>n</code>列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p><p>  <strong>Example 1:</strong></p>  <img src="diag1-grid.jpg" alt="img" style="zoom:67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[1,2],[3,4]]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">v</span><span class="params">(m + n - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            v[i + j].push_back(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            reverse(v[i].begin(), v[i].end());</span><br><span class="line">        res.insert(res.end(), v[i].begin(), v[i].end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].size(); j++)</span><br><span class="line">            mapping[i + j].push_back(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: mapping)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.first % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            res.insert(res.end(), p.second.rbegin(), p.second.rend());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.insert(res.end(), p.second.begin(), p.second.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1424-Diagonal-Traverse-II"><a href="#1424-Diagonal-Traverse-II" class="headerlink" title="1424. Diagonal Traverse II"></a><a href="https://leetcode.com/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">1424. Diagonal Traverse II</a></h5><blockquote><p>给你一个列表<code>num</code>，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回<code>num</code>中对角线上的整数。</p><p><strong>Example 1:</strong></p><p><img src="sample_1_1784.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">&gt;Output: [1,4,2,7,5,3,8,6,9]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="sample_2_1784.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">&gt;Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].size(); j++)</span><br><span class="line">            mapping[i + j].push_back(nums[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: mapping)</span><br><span class="line">        res.insert(res.end(), p.second.rbegin(), p.second.rend());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a><a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. Spiral Matrix</a></h5><blockquote><p>  给你一个<code>m</code>行<code>n</code>列的矩阵<code>matrix</code>，请按照<strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p><p>  <strong>Example 1:</strong></p>  <img src="spiral1.jpg" alt="img" style="zoom:67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <img src="spiral.jpg" alt="img" style="zoom:67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Traverse the matrix in the spiral order by keeping four variables</span></span><br><span class="line"><span class="comment">// u for the uppermost row, d for the downmost row</span></span><br><span class="line"><span class="comment">// l for the leftmost column, r for the rightmost column.</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>, d = m - <span class="number">1</span>, l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">order</span><span class="params">(m * n)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (u &lt;= d &amp;&amp; l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = l; col &lt;= r; col++)</span><br><span class="line">            order[p++] = matrix[u][col];</span><br><span class="line">        <span class="keyword">if</span>(++u &gt; d) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = u; row &lt;= d; row++)</span><br><span class="line">            order[p++] = matrix[row][r];</span><br><span class="line">        <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = r; col &gt;= l; col--)</span><br><span class="line">            order[p++] = matrix[d][col];</span><br><span class="line">        <span class="keyword">if</span>(--d &lt; u) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = d; row &gt;= u; row--)</span><br><span class="line">            order[p++] = matrix[row][l];</span><br><span class="line">        <span class="keyword">if</span>(l++ &gt; r) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1288-Remove-Covered-Intervals"><a href="#1288-Remove-Covered-Intervals" class="headerlink" title="1288. Remove Covered Intervals"></a><a href="https://leetcode.com/problems/remove-covered-intervals/" target="_blank" rel="noopener">1288. Remove Covered Intervals</a></h5><blockquote><p>  Given a list of <code>intervals</code>, remove all intervals that are covered by another interval in the list.</p><p>  Interval <code>[a,b)</code> is covered by interval <code>[c,d)</code> if and only if <code>c &lt;= a</code> and <code>b &lt;= d</code>.</p><p>  After doing so, return <em>the number of remaining intervals</em>.</p><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 1000</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= intervals[i][0] &lt; intervals[i][1] &lt;= 10^5</code></li><li>All the intervals are <strong>unique</strong>.</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[3,6],[2,8]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[2,3]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所谓区间问题, 就是线段问题, 让你合并所有线段、找出线段的交集等等.</span></span><br><span class="line"><span class="comment">// 主要有两个技巧:</span></span><br><span class="line"><span class="comment">// 1. 排序, 常见的排序方法就是按照区间起点或者终点排序. 一般都是先按照起点升序排序.</span></span><br><span class="line"><span class="comment">//    若起点相同，则按照终点降序排序</span></span><br><span class="line"><span class="comment">// 2. 画图, 就是说不要偷懒, 勤动手, 两个区间的相对位置到底有几种可能,</span></span><br><span class="line"><span class="comment">//    不同的相对位置我们的代码应该怎么去处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    res.reserve(intervals.size());</span><br><span class="line">    res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; interval = intervals[i];</span><br><span class="line">        <span class="comment">// 区间相交</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt;= interval[<span class="number">0</span>] &amp;&amp; right &lt; interval[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            right = interval[<span class="number">1</span>];</span><br><span class="line">            res.push_back(interval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 区间不相交</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right &lt;= interval[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            left = interval[<span class="number">0</span>];</span><br><span class="line">            right = interval[<span class="number">1</span>];</span><br><span class="line">            res.push_back(interval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 区间被覆盖的扔掉就行了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">56. Merge Intervals</a></h5><blockquote><p>  Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; interval = intervals[i];</span><br><span class="line">        <span class="comment">// 区间相交</span></span><br><span class="line">        <span class="comment">// 可能会有 [3, 3] 这样的区间, 判定和 [1, 3] 相交就行了</span></span><br><span class="line">        <span class="comment">// 不然的话会被当做不相交被加进去</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt;= interval[<span class="number">0</span>] &amp;&amp; right &lt;= interval[<span class="number">1</span>])</span><br><span class="line">            right = interval[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 区间不相交</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right &lt; interval[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(&#123;left, right&#125;);</span><br><span class="line">            left = interval[<span class="number">0</span>];</span><br><span class="line">            right = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 区间被覆盖的扔掉就行了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意最后一个区间可能没被加进去</span></span><br><span class="line">    <span class="keyword">if</span>(res.empty() || res.back() != <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left, right&#125;))</span><br><span class="line">        res.push_back(&#123;left, right&#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="noopener">57. Insert Interval</a></h5><blockquote><p>  给你一个<strong>无重叠的</strong>，按照区间起始端点排序的区间列表。</p><p>  在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [], newInterval &#x3D; [5,7]</span><br><span class="line">Output: [[5,7]]</span><br></pre></td></tr></table></figure><p>  <strong>Example 4:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,5]], newInterval &#x3D; [2,7]</span><br><span class="line">Output: [[1,7]]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a1 = newInterval[<span class="number">0</span>], b1 = newInterval[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a2 = intervals[i][<span class="number">0</span>], b2 = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 相交</span></span><br><span class="line">        <span class="keyword">if</span>(b2 &gt;= a1 &amp;&amp; b1 &gt;= a2)</span><br><span class="line">        &#123;</span><br><span class="line">            a1 = min(a1, a2);</span><br><span class="line">            b1 = max(b1, b2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不相交</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b1 &lt; a2 &amp;&amp; !found)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(&#123;a1, b1&#125;);</span><br><span class="line">            res.push_back(&#123;a2, b2&#125;);</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(&#123;a2, b2&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!found) res.push_back(&#123;a1, b1&#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="986-Interval-List-Intersections"><a href="#986-Interval-List-Intersections" class="headerlink" title="986. Interval List Intersections"></a><a href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener">986. Interval List Intersections</a></h5><blockquote><p>  给定两个由一些闭区间组成的列表，<code>firstList</code>和<code>secondList</code>，其中<code>firstList[i] = [start_i, end_i]</code>而<code>secondList[j] = [start_j, end_j]</code>。每个区间列表都是成对不相交的，并且已经排序。</p><p>  返回这两个区间列表的交集 。</p><p>  形式上，闭区间<code>[a, b]</code>（其中<code>a &lt;= b</code>）表示实数<code>x</code>的集合，而<code>a &lt;= x &lt;= b</code>。</p><p>  两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，<code>[1, 3]</code>和<code>[2, 4]</code>的交集为<code>[2, 3]</code>。</p><p>  <strong>Example 1:</strong></p>  <img src="interval1.png" alt="img" style="zoom: 33%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: firstList &#x3D; [[0,2],[5,10],[13,23],[24,25]], secondList &#x3D; [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: firstList &#x3D; [[1,3],[5,9]], secondList &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: firstList &#x3D; [], secondList &#x3D; [[4,8],[10,12]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>0 &lt;= firstList.length, secondList.length &lt;= 1000</code></li><li><code>firstList.length + secondList.length &gt;= 1</code></li><li><code>0 &lt;= start_i &lt; end_i &lt;= 109</code></li><li><code>endi &lt; start_(i + 1)</code></li><li><code>0 &lt;= start_j &lt; end_j &lt;= 109</code></li><li><code>endj &lt; start_(j + 1)</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">intervalIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; firstList, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; secondList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; firstList.size() &amp;&amp; j &lt; secondList.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a1 = firstList[i][<span class="number">0</span>], b1 = firstList[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> a2 = secondList[j][<span class="number">0</span>], b2 = secondList[j][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(b1 &gt;= a2 &amp;&amp; b2 &gt;= a1)</span><br><span class="line">            res.push_back(&#123;max(a1, a2), min(b1, b2)&#125;);</span><br><span class="line">        <span class="keyword">if</span>(b1 &lt;= b2) i++;</span><br><span class="line">        <span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a><a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. Non-overlapping Intervals</a></h5><blockquote><p>  给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>  注意:</p><ul><li>可以认为区间的终点总是大于它的起点。</li><li>区间<code>[1,2]</code>和<code>[2,3]</code>的边界相互“接触”，但没有相互重叠。</li></ul><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= intervals.size() &lt;= 2 * 10^4</code></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[1,2],[1,2]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[2,3]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题问的是至少删除多少个区间使得不再存在重叠区间</span></span><br><span class="line"><span class="comment">// 按照区间起点排序, 起点相同按终点排序</span></span><br><span class="line"><span class="comment">// 计数相交区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(intervals.begin(), intervals.end());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a1 = intervals[<span class="number">0</span>][<span class="number">0</span>], b1 = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a2 = intervals[i][<span class="number">0</span>], b2 = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果相交就移除后面那个区间</span></span><br><span class="line">        <span class="keyword">if</span>(b2 &gt; a1 &amp;&amp; b1 &gt; a2)</span><br><span class="line">        &#123;</span><br><span class="line">            a1 = min(a1, a2);</span><br><span class="line">            b1 = min(b1, b2);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a1 = a2;</span><br><span class="line">            b1 = b2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题问的是至少删除多少个区间使得不再存在重叠区间</span></span><br><span class="line"><span class="comment">// 换个思路</span></span><br><span class="line"><span class="comment">// 按照区间终点排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123; <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; &#125;;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">    <span class="keyword">int</span> pre_end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> start = intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 如果后一个区间的起点比前一个的终点小就重叠了</span></span><br><span class="line">        <span class="keyword">if</span>(start &lt; pre_end)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pre_end = intervals[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. Minimum Number of Arrows to Burst Balloons</a></h5><blockquote><p>  在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>  一支弓箭可以沿着<code>x</code>轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为<code>xstart</code>，<code>xend</code>， 且满足<code>xstart ≤ x ≤ xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>  给你一个数组<code>points</code>，其中<code>points [i] = [xstart, xend]</code>，返回引爆所有气球所必须射出的最小弓箭数。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: One way is to shoot one arrow for example at x &#x3D; 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x &#x3D; 11 (bursting the other two balloons).</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照区间终点排序</span></span><br><span class="line"><span class="comment">// 最多有多少个不重叠的区间 == n - 至少删除多少个区间使得不再存在重叠区间</span></span><br><span class="line"><span class="comment">// 最多有多少个不重叠的区间就是题目所问的至少需要的箭的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123; <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; &#125;;</span><br><span class="line">    sort(points.begin(), points.end(), cmp);</span><br><span class="line">    <span class="comment">// count 是最多有多少个不重叠的区间</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = points.size();</span><br><span class="line">    <span class="keyword">int</span> pre_end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> start = points[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 如果后一个区间的起点比前一个的终点小就重叠了</span></span><br><span class="line">        <span class="comment">// 因为这题边界触碰也能引爆气球, 所以属于重叠区间</span></span><br><span class="line">        <span class="comment">// 因此不是 &gt;= 号</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; pre_end)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            pre_end = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="436-Find-Right-Interval"><a href="#436-Find-Right-Interval" class="headerlink" title="436. Find Right Interval"></a><a href="https://leetcode.com/problems/find-right-interval/" target="_blank" rel="noopener">436. Find Right Interval</a></h5><blockquote><p>  给你一个区间数组<code>intervals</code>，其中<code>intervals[i] = [starti, endi]</code>，且每个<code>starti</code>都不同 。</p><p>  区间<code>i</code>的右侧区间可以记作区间<code>j</code>，并满足<code>startj &gt;= endi</code>，且<code>startj</code>最小化 。</p><p>  返回一个由每个区间<code>i</code>的右侧区间的最小起始位置组成的数组。如果某个区间<code>i</code>不存在对应的右侧区间，则下标<code>i</code>处的值设为<code>-1</code>。</p><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 2 * 10^4</code></li><li><code>intervals[i].length == 2</code></li><li><code>-10^6 &lt;= starti &lt;= endi &lt;= 10^6</code></li><li>The start point of each interval is <strong>unique</strong>.</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2]]</span><br><span class="line">Output: [-1]</span><br><span class="line">Explanation: There is only one interval in the collection, so it outputs -1.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[3,4],[2,3],[1,2]]</span><br><span class="line">Output: [-1,0,1]</span><br><span class="line">Explanation: There is no right interval for [3,4].</span><br><span class="line">The right interval for [2,3] is [3,4] since start0 &#x3D; 3 is the smallest start that is &gt;&#x3D; end1 &#x3D; 3.</span><br><span class="line">The right interval for [1,2] is [2,3] since start1 &#x3D; 2 is the smallest start that is &gt;&#x3D; end2 &#x3D; 2.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[2,3],[3,4]]</span><br><span class="line">Output: [-1,2,-1]</span><br><span class="line">Explanation: There is no right interval for [1,4] and [3,4].</span><br><span class="line">The right interval for [2,3] is [3,4] since start2 &#x3D; 3 is the smallest start that is &gt;&#x3D; end1 &#x3D; 3.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序后顺序搜索, 最差情况下时间复杂度为 O(n2)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        intervals[i].push_back(i);</span><br><span class="line">    sort(intervals.begin(), intervals.end());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &lt;= intervals[j][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                res[intervals[i][<span class="number">2</span>]] = intervals[j][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序后二分搜索, 时间复杂度降为 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        intervals[i].push_back(i);</span><br><span class="line">    sort(intervals.begin(), intervals.end());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = left_bound(intervals, i, n, intervals[i]);</span><br><span class="line">        <span class="keyword">if</span>(index &lt; n)</span><br><span class="line">            res[intervals[i][<span class="number">2</span>]] = intervals[index][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; interval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(interval[<span class="number">1</span>] &lt;= intervals[mi][<span class="number">0</span>])</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="713-Subarray-Product-Less-Than-K"><a href="#713-Subarray-Product-Less-Than-K" class="headerlink" title="713. Subarray Product Less Than K"></a><a href="https://leetcode.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">713. Subarray Product Less Than K</a></h5><blockquote><p>  给定一个正整数数组<code>nums</code>。找出该数组内乘积小于<code>k</code>的连续的子数组的个数。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [10, 5, 2, 6], k &#x3D; 100</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</span><br><span class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</span><br></pre></td></tr></table></figure><p>  <strong>Note:</strong></p><ul><li><code>0 &lt; nums.length &lt;= 50000</code>.</li><li><code>0 &lt; nums[i] &lt; 1000</code>.</li><li><code>0 &lt;= k &lt; 10^6</code>.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> product = <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        product *= nums[right++];</span><br><span class="line">        <span class="keyword">while</span>(product &gt;= k)</span><br><span class="line">            product /= nums[left++];</span><br><span class="line">        count += right - left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="525-Contiguous-Array"><a href="#525-Contiguous-Array" class="headerlink" title="525. Contiguous Array"></a><a href="https://leetcode.com/problems/contiguous-array/" target="_blank" rel="noopener">525. Contiguous Array</a></h5><blockquote><p>  Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><p>  解题方法说明图：</p><p>  The following figure illustrates the observation for the sequence <code>[0 0 1 0 0 0 1 1]</code>。</p>  <img src="535_Contiguous_Array.PNG" alt="Contiguous_Array" style="zoom: 67%;" /><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置一个计数器 counter, 遇 0 减 1, 遇 1 加 1</span></span><br><span class="line"><span class="comment">// 出现相等的 counter 时则说明从第 1 次出现时的索引开始到当前索引的子数组满足条件</span></span><br><span class="line"><span class="comment">// 并且是最长的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cnt += nums[i] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(cnt)) &#123;</span><br><span class="line">            res = max(res, i - mapping[cnt]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mapping[cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h5><blockquote><p>  给定一个包含<code>n</code>个整数的数组<code>nums</code>和一个目标值<code>target</code>，判断<code>nums</code>中是否存在四个元素<code>a</code>，<code>b</code>，<code>c</code>和<code>d</code>，使得<code>a + b + c + d</code>的值与<code>target</code>相等？找出所有满足条件且不重复的四元组。</p><p>  注意：答案中不可以包含重复的四元组。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nTargetSum(nums, target, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">nTargetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nSumResult;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curVals;</span><br><span class="line">    <span class="keyword">auto</span> twoSum = [&amp;](<span class="keyword">int</span> start, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> lo = start, hi = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">            <span class="keyword">int</span> loVal = nums[lo], hiVal = nums[hi];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 跳过重复数字，避免出现重复结果</span></span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == loVal) &#123;</span><br><span class="line">                    lo++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; sum) &#123;</span><br><span class="line">                <span class="comment">// 跳过重复数字，避免出现重复结果</span></span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == hiVal) &#123;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nSumResult.push_back(&#123;loVal, hiVal&#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> val : curVals) &#123;</span><br><span class="line">                    nSumResult.back().push_back(val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 跳过重复数字，避免出现重复结果</span></span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == loVal) &#123;</span><br><span class="line">                    lo++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == hiVal) &#123;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> nSum = [&amp;](<span class="keyword">auto</span>&amp;&amp; nSum, <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归基</span></span><br><span class="line">            twoSum(start, target);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">            curVals.push_back(nums[i]);</span><br><span class="line">            nSum(nSum, i + <span class="number">1</span>, target - nums[i], n - <span class="number">1</span>);</span><br><span class="line">            curVals.pop_back();</span><br><span class="line">            <span class="comment">// 跳过重复数字，避免出现重复结果</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; len - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    nSum(nSum, <span class="number">0</span>, target, n);</span><br><span class="line">    <span class="keyword">return</span> nSumResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="面试题-17-10-主要元素"><a href="#面试题-17-10-主要元素" class="headerlink" title="面试题 17.10. 主要元素"></a><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/" target="_blank" rel="noopener">面试题 17.10. 主要元素</a></h5><blockquote><p>  数组中占比超过一半的元素称之为主要元素。给你一个整数数组，找出其中的主要元素。若没有，返回<code>-1</code>。</p><p>  请设计时间复杂度为<code>O(n)</code>、空间复杂度为<code>O(1)</code>的解决方案。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速选择，使中间元素就位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    nth_element(nums.begin(), nums.begin() + n / <span class="number">2</span>, nums.end());</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[n / <span class="number">2</span>]) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[n / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摩尔投票</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            lastNum = num;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == lastNum) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == lastNum) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lastNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位运算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &amp; mask) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">            res |= mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == res) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253. Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="noopener">253. Meeting Rooms II</a></h5><blockquote><p>  给你一个会议时间安排的数组<code>intervals</code>，每个会议时间都会包括开始和结束的时间<code>intervals[i] = [start_i, end_i]</code>，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。</p><p>  <strong>示例 1：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[0,30],[5,10],[15,20]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>  <strong>示例 2：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[7,10],[2,4]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; times;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; interval : intervals) &#123;</span><br><span class="line">        times.emplace_back(interval[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">        times.emplace_back(interval[<span class="number">1</span>], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(times.begin(), times.end());</span><br><span class="line">    <span class="comment">// cnt 记录当前正在进行的会议数</span></span><br><span class="line">    <span class="comment">// res 记录最多的同时进行的会议数</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; [_, flag] : times) &#123;</span><br><span class="line">        cnt += flag;</span><br><span class="line">        res = max(res, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1094-Car-Pooling"><a href="#1094-Car-Pooling" class="headerlink" title="1094. Car Pooling"></a><a href="https://leetcode.com/problems/car-pooling/" target="_blank" rel="noopener">1094. Car Pooling</a></h5><blockquote><p>  假设你是一位顺风车司机，车上最初有<code>capacity</code>个空座位可以用来载客。由于道路的限制，车只能向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。</p><p>  这儿有一份乘客行程计划表<code>trips</code>[][]，其中<code>trips[i] = [num_passengers, start_location, end_location]</code>包含了第<code>i</code>组乘客的行程信息：</p><ul><li><p>必须接送的乘客数量；</p></li><li><p>乘客的上车地点；</p></li><li><p>以及乘客的下车地点。</p></li><li><p>这些给出的地点位置是从你的初始出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。</p><p>请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回<code>true</code>，否则请返回<code>false</code>）。</p></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[2,1,5],[3,5,7]], capacity &#x3D; 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>  <strong>Example 4:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[3,2,7],[3,7,9],[8,3,9]], capacity &#x3D; 11</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ol><li><code>trips.length &lt;= 1000</code></li><li><code>trips[i].length == 3</code></li><li><code>1 &lt;= trips[i][0] &lt;= 100</code></li><li><code>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000</code></li><li><code>1 &lt;= capacity &lt;= 100000</code></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将这 1000 个距离点看作一个数组, 数组中元素是那一距离点的乘客数</span></span><br><span class="line"><span class="comment">// 把路程中每一个位置的乘客数在数组中构造出来</span></span><br><span class="line"><span class="comment">// 时时比较乘客数是否超过客容量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 距离最远就 1000 个距离单位</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">passengers</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; trip : trips) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = trip[<span class="number">1</span>]; i &lt; trip[<span class="number">2</span>]; i++) &#123;</span><br><span class="line">            passengers[i] += trip[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(passengers[i] &gt; capacity) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组</span></span><br><span class="line"><span class="comment">// 将这 1000 个距离点看作一个数组, 数组中元素是那一距离点的乘客数, 初始数组元素都为 0</span></span><br><span class="line"><span class="comment">// 对每一个 trip 更新数组区间的值, 使用差分数组记录这些更新</span></span><br><span class="line"><span class="comment">// 最后还原数组的时候, 判断是否出现超载</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; trip : trips) &#123;</span><br><span class="line">        diff[trip[<span class="number">1</span>]] += trip[<span class="number">0</span>];</span><br><span class="line">        diff[trip[<span class="number">2</span>]] -= trip[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        diff[i] += diff[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(diff[i] &gt; capacity) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1840-Maximum-Building-Height"><a href="#1840-Maximum-Building-Height" class="headerlink" title="1840. Maximum Building Height"></a><a href="https://leetcode.com/problems/maximum-building-height/" target="_blank" rel="noopener">1840. Maximum Building Height</a></h5><blockquote><p>  在一座城市里，你需要建<code>n</code>栋新的建筑。这些新的建筑会从<code>1</code>到<code>n</code>编号排成一列。</p><p>  这座城市对这些新建筑有一些规定：</p><ul><li><p>每栋建筑的高度必须是一个非负整数。</p></li><li><p>第一栋建筑的高度必须是<code>0</code>。</p></li><li><p>任意两栋相邻建筑的高度差不能超过<code>1</code>。</p></li><li><p>除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组<code>restrictions</code>的形式给出，其中<code>restrictions[i] = [idi, maxHeighti]</code>，表示建筑<code>idi</code>的高度 不能超过<code>maxHeighti</code>。</p><p>题目保证每栋建筑在<code>restrictions</code>中至多出现一次 ，同时建筑<code>1</code>不会 出现在<code>restrictions</code>中。</p><p>请你返回最高建筑能达到的最高高度 。</p></li></ul><p>  <strong>示例 1：</strong></p>  <img src="ic236-q4-ex1-1.png" alt="img" style="zoom: 67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, restrictions &#x3D; [[2,1],[4,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [0,1,2,1,2] ，最高建筑的高度为 2 。</span><br></pre></td></tr></table></figure><p>  <strong>示例 2：</strong></p>  <img src="ic236-q4-ex2.png" alt="img" style="zoom: 67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 6, restrictions &#x3D; []</span><br><span class="line">输出：5</span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [0,1,2,3,4,5] ，最高建筑的高度为 5 。</span><br></pre></td></tr></table></figure><p>  <strong>示例 3：</strong></p>  <img src="ic236-q4-ex3.png" alt="img" style="zoom: 67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10, restrictions &#x3D; [[5,3],[2,5],[7,4],[10,3]]</span><br><span class="line">输出：5</span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [0,1,2,3,3,4,4,5,4,3] ，最高建筑的高度为 5 。</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>2 &lt;= n &lt;= 10^9</code></li><li><code>0 &lt;= restrictions.length &lt;= min(n - 1, 10^5)</code></li><li><code>2 &lt;= idi &lt;= n</code></li><li><code>idi</code> is <strong>unique</strong>.</li><li><code>0 &lt;= maxHeighti &lt;= 10^9</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxBuilding</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增加限制 (1, 0)</span></span><br><span class="line">    r.push_back(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    sort(r.begin(), r.end());</span><br><span class="line">    <span class="comment">// 增加限制 (n, n-1)</span></span><br><span class="line">    <span class="keyword">if</span>(r.back()[<span class="number">0</span>] != n) &#123;</span><br><span class="line">        r.push_back(&#123;n, n - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = r.size();</span><br><span class="line">    <span class="comment">// 从左向右传递限制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        r[i][<span class="number">1</span>] = min(r[i][<span class="number">1</span>], r[i - <span class="number">1</span>][<span class="number">1</span>] + (r[i][<span class="number">0</span>] - r[i - <span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右向左传递限制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        r[i][<span class="number">1</span>] = min(r[i][<span class="number">1</span>], r[i + <span class="number">1</span>][<span class="number">1</span>] + (r[i + <span class="number">1</span>][<span class="number">0</span>] - r[i][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 计算 r[i][0] 和 r[i + 1][0] 之间的建筑的最大高度</span></span><br><span class="line">        <span class="keyword">int</span> best = ((r[i + <span class="number">1</span>][<span class="number">0</span>] - r[i][<span class="number">0</span>]) + r[i][<span class="number">1</span>] + r[i + <span class="number">1</span>][<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        res = max(res, best);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1838-Frequency-of-the-Most-Frequent-Element"><a href="#1838-Frequency-of-the-Most-Frequent-Element" class="headerlink" title="1838. Frequency of the Most Frequent Element"></a><a href="https://leetcode.com/problems/frequency-of-the-most-frequent-element/" target="_blank" rel="noopener">1838. Frequency of the Most Frequent Element</a></h5><blockquote><p>  元素的频数是该元素在一个数组中出现的次数。</p><p>  给你一个整数数组<code>nums</code>和一个整数<code>k</code>。在一步操作中，你可以选择<code>nums</code>的一个下标，并将该下标对应元素的值增加<code>1</code>。</p><p>  执行最多<code>k</code>次操作后，返回数组中<strong>最高频元素的最大可能频数</strong>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,4], k &#x3D; 5</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Increment the first element three times and the second element two times to make nums &#x3D; [4,4,4].</span><br><span class="line">4 has a frequency of 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,4,8,13], k &#x3D; 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are multiple optimal solutions:</span><br><span class="line">- Increment the first element three times to make nums &#x3D; [4,4,8,13]. 4 has a frequency of 2.</span><br><span class="line">- Increment the second element four times to make nums &#x3D; [1,8,8,13]. 8 has a frequency of 2.</span><br><span class="line">- Increment the third element five times to make nums &#x3D; [1,4,13,13]. 13 has a frequency of 2.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,9,6], k &#x3D; 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降序排序后顺序模拟操作即可</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n2), 超时！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp_k = k;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[j] &lt;= temp_k) &#123;</span><br><span class="line">                temp_k -= nums[i] - nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = max(cnt, j - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降序排序后, 滑动窗口模拟操作</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size()) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>((right - left) * nums[right - <span class="number">1</span>] &gt; sum + k) &#123;</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1011-Capacity-To-Ship-Packages-Within-D-Days"><a href="#1011-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="1011. Capacity To Ship Packages Within D Days"></a><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011. Capacity To Ship Packages Within D Days</a></h5><blockquote><p>  传送带上的包裹必须在<code>days</code>天内从一个港口运送到另一个港口。</p><p>  传送带上的第<code>i</code>个包裹的重量为<code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>  返回能在<code>days</code>天内将传送带上的所有包裹送达的船的最低运载能力。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:</span><br><span class="line">1st day: 1, 2, 3, 4, 5</span><br><span class="line">2nd day: 6, 7</span><br><span class="line">3rd day: 8</span><br><span class="line">4th day: 9</span><br><span class="line">5th day: 10</span><br><span class="line"></span><br><span class="line">Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:</span><br><span class="line">1st day: 3, 2</span><br><span class="line">2nd day: 2, 4</span><br><span class="line">3rd day: 1, 4</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: weights &#x3D; [1,2,3,1,1], D &#x3D; 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">1st day: 1</span><br><span class="line">2nd day: 2</span><br><span class="line">3rd day: 3</span><br><span class="line">4th day: 1, 1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 船的最低运载能力至少为所有包裹的最大重量</span></span><br><span class="line"><span class="comment">// 最高运载能力充其量不过是一次把所有货物全部运完, 也就是所有货物重量之和</span></span><br><span class="line"><span class="comment">// 知道了最小值和最大值, 现在要我们求中间满足条件的一个最小值</span></span><br><span class="line"><span class="comment">// 如果说从最小值到最大值一个一个去试的话时间复杂度显然是线性的</span></span><br><span class="line"><span class="comment">// 其实这是二分搜索的一个典型应用场景</span></span><br><span class="line"><span class="comment">// 具体使用的是二分法的左边界搜索 (因为要求最低运载量嘛)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> computeDays = [&amp;](<span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> load = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> weight : weights) &#123;</span><br><span class="line">            <span class="keyword">if</span>(load + weight &gt; limit) &#123;</span><br><span class="line">                days++;</span><br><span class="line">                load = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            load += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> days;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> minLoad = *max_element(weights.begin(), weights.end());</span><br><span class="line">    <span class="keyword">int</span> maxLoad = accumulate(weights.begin(), weights.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(minLoad &lt; maxLoad) &#123;</span><br><span class="line">        <span class="keyword">int</span> midLoad = minLoad + ((maxLoad - minLoad) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(days &gt;= computeDays(midLoad)) &#123;</span><br><span class="line">            maxLoad = midLoad;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minLoad = midLoad + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLoad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="875-Koko-Eating-Bananas"><a href="#875-Koko-Eating-Bananas" class="headerlink" title="875. Koko Eating Bananas"></a><a href="https://leetcode.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. Koko Eating Bananas</a></h5><blockquote><p>珂珂喜欢吃香蕉。这里有<code>N</code>堆香蕉，第<code>i</code>堆中有<code>piles[i]</code>根香蕉。警卫已经离开了，将在<code>hours</code>小时后回来。</p><p>珂珂可以决定她吃香蕉的速度<code>K</code>（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉<code>K</code>根。如果这堆香蕉少于<code>K</code>根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在<code>hours</code>小时内吃掉所有香蕉的最小速度<code>K</code>（<code>K</code>为整数）。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: piles &#x3D; [3,6,7,11], h &#x3D; 8</span><br><span class="line">&gt;Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 5</span><br><span class="line">&gt;Output: 30</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 6</span><br><span class="line">&gt;Output: 23</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和上题一样, 吃香蕉的速度至少为 1 吧</span></span><br><span class="line"><span class="comment">// 最大速度充其量不过是一次把最大的一堆全部吃完, 也就是最大堆的香蕉个数</span></span><br><span class="line"><span class="comment">// 知道了最小值和最大值, 现在要我们求中间满足条件的一个最小值</span></span><br><span class="line"><span class="comment">// 如果说从最小值到最大值一个一个去试的话时间复杂度显然是线性的</span></span><br><span class="line"><span class="comment">// 其实这是二分搜索的一个典型应用场景</span></span><br><span class="line"><span class="comment">// 具体使用的是二分法的左边界搜索 (因为要求最小速度嘛)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> hours)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> computeHours = [&amp;](<span class="keyword">int</span> speed) &#123;</span><br><span class="line">        <span class="keyword">int</span> hours = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">            <span class="comment">// pile / speed 向上取整</span></span><br><span class="line">            hours += (pile + speed - <span class="number">1</span>) / speed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hours;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> minSpeed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSpeed = *max_element(piles.begin(), piles.end()) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(minSpeed &lt; maxSpeed) &#123;</span><br><span class="line">        <span class="keyword">int</span> midSpeed = minSpeed + ((maxSpeed - minSpeed) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(hours &gt;= computeHours(midSpeed)) &#123;</span><br><span class="line">            maxSpeed = midSpeed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minSpeed = midSpeed + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1760-Minimum-Limit-of-Balls-in-a-Bag"><a href="#1760-Minimum-Limit-of-Balls-in-a-Bag" class="headerlink" title="1760. Minimum Limit of Balls in a Bag"></a><a href="https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/" target="_blank" rel="noopener">1760. Minimum Limit of Balls in a Bag</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>，其中<code>nums[i]</code>表示第<code>i</code>个袋子里球的数目。同时给你一个整数<code>maxOperations</code>。你可以进行如下操作至多<code>maxOperations</code>次：</p><p>  选择任意一个袋子，并将袋子里的球分到<code>2</code>个新的袋子中，每个袋子里都有正整数个球。<br>  比方说，一个袋子里有<code>5</code>个球，你可以把它们分到两个新袋子里，分别有<code>1</code>个和<code>4</code>个球，或者分别有<code>2</code>个和<code>3</code>个球。</p><p>  你的开销是单个袋子里球数目的最大值 ，你想要最小化开销。请你返回进行上述操作后的最小开销。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [9], maxOperations &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">- Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -&gt; [6,3].</span><br><span class="line">- Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -&gt; [3,3,3].</span><br><span class="line">The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,4,8,2], maxOperations &#x3D; 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">- Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -&gt; [2,4,4,4,2].</span><br><span class="line">- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -&gt; [2,2,2,4,4,2].</span><br><span class="line">- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -&gt; [2,2,2,2,2,4,2].</span><br><span class="line">- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -&gt; [2,2,2,2,2,2,2,2].</span><br><span class="line">The bag with the most number of balls has 2 balls, so your penalty is 2 an you should return 2.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,17], maxOperations &#x3D; 2</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minCost = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCost = *max_element(nums.begin(), nums.end()) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(minCost &lt; maxCost) &#123;</span><br><span class="line">        <span class="keyword">int</span> midCost = minCost + (maxCost - minCost &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> need = operations(nums, midCost);</span><br><span class="line">        <span class="keyword">if</span>(need &lt;= maxOperations) &#123;</span><br><span class="line">            maxCost = midCost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minCost = midCost + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        op += (num - <span class="number">1</span>) / cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. Find Minimum in Rotated Sorted Array</a></h5><blockquote><p>  已知一个长度为<code>n</code>的数组，预先按照升序排列，经由<code>1</code>到<code>n</code>次旋转后，得到输入数组。例如，原数组<code>nums = [0,1,2,4,5,6,7]</code>在变化后可能得到：<br>  若旋转<code>4</code>次，则可以得到<code>[4,5,6,7,0,1,2]</code><br>  若旋转<code>7</code>次，则可以得到<code>[0,1,2,4,5,6,7]</code><br>  注意，数组<code>[a[0], a[1], a[2], ..., a[n-1]]</code>旋转一次的结果为数组<code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>。</p><p>  给你一个<strong>元素值互不相同</strong>的数组<code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素 。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,5,1,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The original array was [1,2,3,4,5] rotated 3 times.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [11,13,15,17]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: The original array was [11,13,15,17] and it was rotated 4 times. </span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li>All the integers of <code>nums</code> are <strong>unique</strong>.</li><li><code>nums</code> is sorted and rotated between <code>1</code> and <code>nums.length</code> times.</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mi] &lt;= nums[hi]) &#123;</span><br><span class="line">            hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[lo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="154. Find Minimum in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. Find Minimum in Rotated Sorted Array II</a></h5><blockquote><p>  已知一个长度为<code>n</code>的数组，预先按照升序排列，经由<code>1</code>到<code>n</code>次旋转后，得到输入数组。例如，原数组<code>nums = [0,1,2,4,5,6,7]</code>在变化后可能得到：<br>  若旋转<code>4</code>次，则可以得到<code>[4,5,6,7,0,1,2]</code><br>  若旋转<code>7</code>次，则可以得到<code>[0,1,2,4,5,6,7]</code><br>  注意，数组<code>[a[0], a[1], a[2], ..., a[n-1]]</code>旋转一次的结果为数组<code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>。</p><p>  给你一个可能<strong>存在重复元素值</strong>的数组<code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的<strong>最小元素</strong>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,5]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,2,0,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mi] &lt; nums[hi]) &#123;</span><br><span class="line">            hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mi] &gt; nums[hi]) &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[lo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. Search in Rotated Sorted Array</a></h5><blockquote><p>  整数数组<code>nums</code>按升序排列，数组中的值<strong>互不相同</strong>。给你<strong>旋转后</strong>的数组<code>nums</code>和一个整数<code>target</code>，如果<code>nums</code>中存在这个目标值<code>target</code>，则返回它的下标，否则返回<code>-1</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有重复值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target == nums[mi]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mi] &gt;= nums[lo]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mi] &amp;&amp; target &gt;= nums[lo]) &#123;</span><br><span class="line">                hi = mi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;             </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mi] &amp;&amp; target &lt;= nums[hi]) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="81. Search in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. Search in Rotated Sorted Array II</a></h5><blockquote><p>  已知存在一个按<strong>非降序排列</strong>的整数数组<code>nums</code>，数组中的值<strong>不必互不相同</strong>。</p><p>  给你旋转后的数组<code>nums</code>和一个整数<code>target</code>，请你编写一个函数来判断给定的目标值是否存在于数组中。如果<code>nums</code>中存在这个目标值<code>target</code>，则返回<code>true</code>，否则返回<code>false</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有重复值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target == nums[mi]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 和 I 题相比, 就添加这一个判断语句就行了</span></span><br><span class="line">        <span class="comment">// 跳过 nums[lo] == nums[mi] == nums[hi] 的情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums[lo] == nums[mi] &amp;&amp; nums[mi] == nums[hi]) &#123;</span><br><span class="line">            lo++;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mi] &gt;= nums[lo]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mi] &amp;&amp; target &gt;= nums[lo]) &#123;</span><br><span class="line">                hi = mi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mi] &amp;&amp; target &lt;= nums[hi]) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1004-Max-Consecutive-Ones-III"><a href="#1004-Max-Consecutive-Ones-III" class="headerlink" title="1004. Max Consecutive Ones III"></a><a href="https://leetcode.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener">1004. Max Consecutive Ones III</a></h5><blockquote><p>  Given a binary array <code>nums</code> and an integer <code>k</code>, return <em>the maximum number of consecutive</em> <code>1</code><em>‘s in the array if you can flip at most</em> <code>k</code> <code>0</code>‘s.</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,0,0,0,1,1,1,1,0], k &#x3D; 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [1,1,1,0,0,1,1,1,1,1,1]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k &#x3D; 3</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口, 关注窗口中 0 的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size()) &#123;</span><br><span class="line">        zeros += <span class="number">1</span> - nums[right++];</span><br><span class="line">        <span class="keyword">while</span>(zeros &gt; k) &#123;</span><br><span class="line">            zeros += nums[left++] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 魔改到让人看不懂为止</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        k += nums[r++] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">0</span>) k += <span class="number">1</span> - nums[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r - l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="391-数飞机"><a href="#391-数飞机" class="headerlink" title="391. 数飞机"></a><a href="https://www.lintcode.com/problem/number-of-airplanes-in-the-sky/?utm_source=sc-bky-sz-20dec" target="_blank" rel="noopener">391. 数飞机</a></h5><blockquote><p>给出飞机的起飞和降落时间，用<code>interval</code>序列表示，请计算出天上同时最多有多少架飞机？</p><ul><li>如果多架飞机降落和起飞在同一时刻，我们认为降落有优先权。</li></ul><p><strong>样例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [[1, 10], [2, 3], [5, 8], [4, 7]</span><br><span class="line">&gt;输出: 3</span><br><span class="line">&gt;解释: </span><br><span class="line">&gt;第一架飞机在 1 时刻起飞, 10 时刻降落.</span><br><span class="line">&gt;第二架飞机在 2 时刻起飞, 3 时刻降落.</span><br><span class="line">&gt;第三架飞机在 5 时刻起飞, 8 时刻降落.</span><br><span class="line">&gt;第四架飞机在 4 时刻起飞, 7 时刻降落.</span><br><span class="line">&gt;在 5 时刻到 6 时刻之间, 天空中有三架飞机.</span><br></pre></td></tr></table></figure><p><strong>样例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [[1, 2], [2, 3], [3, 4]]</span><br><span class="line">&gt;输出: 1</span><br><span class="line">&gt;解释: 降落优先于起飞.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描线算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOfAirplanes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;airplanes)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; timeSeries;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; interval : airplanes) &#123;</span><br><span class="line">        timeSeries.push_back(&#123;interval[<span class="number">0</span>], <span class="number">1</span>&#125;); <span class="comment">// 起飞是 1</span></span><br><span class="line">        timeSeries.push_back(&#123;interval[<span class="number">1</span>], <span class="number">-1</span>&#125;); <span class="comment">// 降落是 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序时就决定了降落在前, 起飞在后</span></span><br><span class="line">    <span class="comment">// 因为如果起飞时间和降落时间相等的话, 降落的第二个值是 -1, 小于起飞的 1</span></span><br><span class="line">    sort(timeSeries.begin(), timeSeries.end());</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; [_, p] : timeSeries) &#123;</span><br><span class="line">        count += p;</span><br><span class="line">        res = max(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="218-The-Skyline-Problem"><a href="#218-The-Skyline-Problem" class="headerlink" title="218. The Skyline Problem"></a><a href="https://leetcode.com/problems/the-skyline-problem/" target="_blank" rel="noopener">218. The Skyline Problem</a></h5><blockquote><p>  城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的<strong>天际线</strong> 。</p><p>  每个建筑物的几何信息由数组<code>buildings</code>表示，其中三元组<code>buildings[i] = [lefti, righti, heighti]</code>表示：</p><ul><li><p><code>lefti</code>是第<code>i</code>座建筑物左边缘的<code>x</code>坐标。</p></li><li><p><code>righti</code>是第<code>i</code>座建筑物右边缘的<code>x</code>坐标。</p></li><li><p><code>heighti</code>是第i座建筑物的高度。</p><p>天际线应该表示为由 “关键点” 组成的列表，格式<code>[[x1,y1],[x2,y2],...]</code>，并按<code>x</code>坐标进行排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，<code>y</code>坐标始终为<code>0</code>，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>注意：输出天际线中不得有连续的相同高度的水平线。例如<code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code>是不正确的答案；三条高度为<code>5</code>的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p></li></ul><p>  <strong>示例：</strong></p>  <img src="merged.jpg" alt="img" style="zoom: 33%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings &#x3D; [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</span><br><span class="line">输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</span><br><span class="line">解释：</span><br><span class="line">图 A 显示输入的所有建筑物的位置和高度，</span><br><span class="line">图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</span><br></pre></td></tr></table></figure>  <img src="Video_2021-04-27_200311.gif" alt="Video_2021-04-27_200311" style="zoom: 50%;" />  <img src="Video_2021-04-27_195717.gif" alt="Video_2021-04-27_195717" style="zoom: 50%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用扫描线算法求解的关键点就在于找出 [高度发生突变] 的位置</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getSkyline</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; geometrixPoints;</span><br><span class="line">    <span class="comment">// 将每一个建筑分成两个部分, 每部分都代表这栋建筑的几何点</span></span><br><span class="line">    <span class="comment">// 例如: [2, 9, 10] 可以转换成 [2, -10] [9, 10]</span></span><br><span class="line">    <span class="comment">// 我们用高度是否为负值来标志 左/右 边界点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; building : buildings) &#123;</span><br><span class="line">        geometrixPoints.emplace_back(building[<span class="number">0</span>], <span class="number">0</span> - building[<span class="number">2</span>]);</span><br><span class="line">        geometrixPoints.emplace_back(building[<span class="number">1</span>], building[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 x 值对这些关键点进行排序</span></span><br><span class="line">    <span class="comment">// 由于 pair 比较的特性, 排序完之后将保证扫描线从左往右走</span></span><br><span class="line">    <span class="comment">// 先出现的建筑先被扫描到, 后出现的建筑后被扫描到</span></span><br><span class="line">    sort(geometrixPoints.begin(), geometrixPoints.end());</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; heights;</span><br><span class="line">    <span class="comment">// 将 0 提前放入高度集中可以处理扫描线没有扫到任何建筑导致高度突变到 0 时的情况</span></span><br><span class="line">    heights.insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; keyPoints;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; [x_pos, height] : geometrixPoints) &#123;</span><br><span class="line">        <span class="keyword">if</span>(height &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 是左边界点, 将高度入堆</span></span><br><span class="line">            heights.insert(<span class="built_in">abs</span>(height));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 是右边界点, 将高度出堆</span></span><br><span class="line">            heights.erase(heights.find(height));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前最大高度</span></span><br><span class="line">        <span class="keyword">int</span> curMaxHeight = *heights.rbegin();</span><br><span class="line">        <span class="comment">// 看新加入/删除的建筑高度是否影响了建筑的最大高度</span></span><br><span class="line">        <span class="comment">// 当前最大高度不等于原先的最大高度就表示这是一个高度突变点</span></span><br><span class="line">        <span class="keyword">if</span>(curMaxHeight != maxHeight) &#123;</span><br><span class="line">            <span class="comment">// 添加坐标</span></span><br><span class="line">            keyPoints.emplace_back(<span class="built_in">vector</span>&#123;&#123;x_pos, curMaxHeight&#125;&#125;);</span><br><span class="line">            <span class="comment">// 更新最大高度</span></span><br><span class="line">            maxHeight = curMaxHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&lt;pair&lt;int, int&gt;&gt; 对 pair 排序默认的方式是，先比较 first，哪个小则排在前</span></span><br><span class="line"><span class="comment">first 相等则 second 小的排在前。而 first 这里表示横坐标，second 为负时，</span></span><br><span class="line"><span class="comment">表示建筑的左侧在这一位置；second 为正时，表示建筑的右侧在这一位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以对 geometrixPoints 遍历时，首先会取出横坐标小的点。如果 2 个点横坐标相等，</span></span><br><span class="line"><span class="comment">会先取出 second 小的点，对于负数来说，其实就是高度更高的建筑。也就是说，</span></span><br><span class="line"><span class="comment">两个点上有高度不同的建筑，会先取高的出来放入高度集合，集合中高度最大值和之前高度不同，</span></span><br><span class="line"><span class="comment">就直接以更高的高度作为关键点的高度。后面更低高度的建筑加入并不会改变最大高度，</span></span><br><span class="line"><span class="comment">因此不会错误的当作关键点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果 second 为正，表示建筑物在此处结束，需要把相应高度从高度集合中删除。</span></span><br><span class="line"><span class="comment">有相同建筑同时在此结束，则会先让较低的建筑离开，因为它们不会改变最大高度。</span></span><br><span class="line"><span class="comment">只有当最高的建筑物离开时，才进行改变。如果一个位置既有建筑物进来，又有建筑物离开，</span></span><br><span class="line"><span class="comment">会先以进来的建筑的高度来更新高度集，原因同理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这一系列正确的遍历顺序都取决于把高度的负值作为左边界点地标志, 高度的正值作为</span></span><br><span class="line"><span class="comment">右边界点的标志, 并将它们组合成一个 pair 这一巧妙的设计！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. Median of Two Sorted Arrays</a></h5><blockquote><p>  给定两个大小分别为<code>m</code>和<code>n</code>的<strong>有序</strong>（从小到大）数组<code>nums1</code>和<code>nums2</code>。请你找出并返回这两个正序数组的<strong>中位数</strong>。</p><p>  <strong>进阶：</strong>你能设计一个时间复杂度为<code>O(log(m+n))</code>的算法解决此问题吗？</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">Output: 2.00000</span><br><span class="line">Explanation: merged array &#x3D; [1,2,3] and median is 2.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">Output: 2.50000</span><br><span class="line">Explanation: merged array &#x3D; [1,2,3,4] and median is (2 + 3) &#x2F; 2 &#x3D; 2.5.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class="line">Output: 0.00000</span><br></pre></td></tr></table></figure><p>  <strong>Example 4:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class="line">Output: 1.00000</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一, 双指针归并两个有序数组</span></span><br><span class="line"><span class="comment">// 时间和空间复杂度都为 O(m + n)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merged</span><span class="params">(m + n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m || j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= n || (i &lt; m &amp;&amp; nums1[i] &lt; nums2[j])) &#123;</span><br><span class="line">            merged[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            merged[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">double</span>(merged[(m + n) / <span class="number">2</span>] + merged[(m + n - <span class="number">1</span>) / <span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二, [伪归并] 双指针寻找中位数的位置</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(m + n), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> preValue = <span class="number">0</span>, curValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((i &lt; m || j &lt; n) &amp;&amp; (i + j) &lt;= (m + n) / <span class="number">2</span>) &#123;</span><br><span class="line">        preValue = curValue;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= n || (i &lt; m &amp;&amp; nums1[i] &lt; nums2[j])) &#123;</span><br><span class="line">            curValue = nums2[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            curValue = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (m + n) &amp; <span class="number">1</span> ? curValue : <span class="keyword">double</span>(preValue + curValue) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法三, 划分数组 + 二分查找, 时间复杂度为 O(log(min(m, n))), 空间复杂度为 O(1)</span></span><br></pre></td></tr></table></figure><h5 id="457-Circular-Array-Loop"><a href="#457-Circular-Array-Loop" class="headerlink" title="457. Circular Array Loop"></a><a href="https://leetcode.com/problems/circular-array-loop/" target="_blank" rel="noopener">457. Circular Array Loop</a></h5><blockquote><p>  存在一个不含<code>0</code>的环形数组<code>nums</code>，每个<code>nums[i]</code>都表示位于下标<code>i</code>的角色应该向前或向后移动的下标个数：</p><ul><li><p>如果<code>nums[i]</code>是正数，向前移动<code>nums[i]</code>步</p></li><li><p>如果<code>nums[i]</code>是负数，向后移动<code>nums[i]</code>步</p></li><li><p>因为数组是环形的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p><p>数组中的循环由长度为k的下标序列<code>seq</code>：</p></li><li><p>遵循上述移动规则将导致重复下标序列<code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code>所有<code>nums[seq[j]]</code>应当不是全正就是全负</p></li><li><p><code>k &gt; 1</code></p><p>如果<code>nums</code>中存在循环，返回<code>true</code>；否则，返回<code>false</code>。</p></li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,-1,1,2,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">There is a cycle from index 0 -&gt; 2 -&gt; 3 -&gt; 0 -&gt; ...</span><br><span class="line">The cycle&#39;s length is 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The sequence from index 1 -&gt; 1 -&gt; 1 -&gt; ... is not a cycle because the sequence&#39;s length is 1.</span><br><span class="line">By definition the sequence&#39;s length must be strictly greater than 1 to be a cycle.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,1,-1,-2,-2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The sequence from index 1 -&gt; 2 -&gt; 1 -&gt; ... is not a cycle because nums[1] is positive, but nums[2] is negative.</span><br><span class="line">Every nums[seq[j]] must be either all positive or all negative.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度为 O(n), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">circularArrayLoop</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">auto</span> getnext = [&amp;](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> ((i + nums[i]) % n + n) % n; &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = i, fast = i;</span><br><span class="line">        <span class="comment">// 符号相同则乘积 &gt; 0</span></span><br><span class="line">        <span class="keyword">while</span>(nums[i] * nums[getnext(fast)] &gt; <span class="number">0</span> &amp;&amp; nums[i] * nums[getnext(getnext(fast))] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = getnext(slow);</span><br><span class="line">            fast = getnext(getnext(fast));</span><br><span class="line">            <span class="comment">// 出现环</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 排除长度为 1 的环</span></span><br><span class="line">                <span class="keyword">if</span>(slow == getnext(slow)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的 while 循环没有返回, 说明上面访问过的点的路径不会出现环</span></span><br><span class="line">        <span class="comment">// 把访问过的点置 0, 下次不会再次进入同样的无效路径</span></span><br><span class="line">        slow = i;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] * nums[slow] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = getnext(slow);</span><br><span class="line">            nums[slow] = <span class="number">0</span>;</span><br><span class="line">            slow = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. First Missing Positive</a></h5><blockquote><p>  给你一个未排序的整数数组<code>nums</code>，请你找出其中没有出现的最小的正整数。</p><p>  请你实现时间复杂度为<code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><p>  <strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/" target="_blank" rel="noopener">缺失的第一个正数 - 缺失的第一个正数</a></p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 300</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上, 对于一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 其中没有出现的最小正整数只能在 [1, n+1] 中</span></span><br><span class="line"><span class="comment">// 这是因为如果 [1, n] 都出现了, 那么答案是 n+1</span></span><br><span class="line"><span class="comment">// 否则答案是 [1, n] 中没有出现的最小正整数</span></span><br><span class="line"><span class="comment">// 哈希表, 时间和空间复杂度都为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        setting.insert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!setting.count(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于本题来说 O(n) 的空间复杂度是不符合要求的</span></span><br><span class="line"><span class="comment">// 由于我们已经得出了一个关键的结论:</span></span><br><span class="line"><span class="comment">// 没有出现的正整数只能在 [1, n+1] 中</span></span><br><span class="line"><span class="comment">// 这和数组的索引就存在着对应关系了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 由于我们只关注 [1, n+1] 内的正整数</span></span><br><span class="line">    <span class="comment">// 因此, 将数组中 &lt;= 0 的数都映射为 n+1 (足够大的正数)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] = n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数值对应的索引处的数值映射为负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= n &amp;&amp; nums[num - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[num - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有被映射为负数的第一个数的下标 +1</span></span><br><span class="line">    <span class="comment">// 就是缺失的第一个正整数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则</span></span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1482-Minimum-Number-of-Days-to-Make-m-Bouquets"><a href="#1482-Minimum-Number-of-Days-to-Make-m-Bouquets" class="headerlink" title="1482. Minimum Number of Days to Make m Bouquets"></a><a href="https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">1482. Minimum Number of Days to Make m Bouquets</a></h5><blockquote><p>  给你一个整数数组<code>bloomDay</code>，以及两个整数<code>m</code>和<code>k</code>。现需要制作<code>m</code>束花。制作花束时，需要使用花园中相邻的<code>k</code>朵花 。花园中有<code>n</code>朵花，第<code>i</code>朵花会在<code>bloomDay[i]</code>时盛开，恰好可以用于一束花中。请你返回从花园中摘<code>m</code>束花需要等待的最少的天数。如果不能摘到<code>m</code>束花则返回<code>-1</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Let&#39;s see what happened in the first three days. x means flower bloomed and _ means flower didn&#39;t bloom in the garden.</span><br><span class="line">We need 3 bouquets each should contain 1 flower.</span><br><span class="line">After day 1: [x, _, _, _, _]   &#x2F;&#x2F; we can only make one bouquet.</span><br><span class="line">After day 2: [x, _, _, _, x]   &#x2F;&#x2F; we can only make two bouquets.</span><br><span class="line">After day 3: [x, _, x, _, x]   &#x2F;&#x2F; we can make 3 bouquets. The answer is 3.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [7,7,7,7,12,7,7], m &#x3D; 2, k &#x3D; 3</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: We need 2 bouquets each should have 3 flowers.</span><br><span class="line">Here&#39;s the garden after the 7 and 12 days:</span><br><span class="line">After day 7: [x, x, x, x, _, x, x]</span><br><span class="line">We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.</span><br><span class="line">After day 12: [x, x, x, x, x, x, x]</span><br><span class="line">It is obvious that we can make two bouquets in different ways.</span><br></pre></td></tr></table></figure><p>  <strong>Example 4:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [1000000000,1000000000], m &#x3D; 1, k &#x3D; 1</span><br><span class="line">Output: 1000000000</span><br><span class="line">Explanation: You need to wait 1000000000 days to have a flower ready for a bouquet.</span><br></pre></td></tr></table></figure><p>  <strong>Example 5:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [1,10,2,9,3,8,4,7,5,6], m &#x3D; 4, k &#x3D; 2</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>bloomDay.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li><li><code>1 &lt;= m &lt;= 10^6</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; bloomDay.size() / k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">auto</span> [minVal, maxVal] = minmax_element(bloomDay.begin(), bloomDay.end());</span><br><span class="line">    <span class="keyword">int</span> lo = *minVal, hi = *maxVal;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(canMake(bloomDay, m, k, mi))</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canMake</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k, <span class="keyword">int</span> days)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flowers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bloomDay.size() &amp;&amp; m &gt; <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bloomDay[i] &gt; days)</span><br><span class="line">        &#123;</span><br><span class="line">            flowers = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flowers++;</span><br><span class="line">            <span class="keyword">if</span>(flowers == k)</span><br><span class="line">            &#123;</span><br><span class="line">                m--;</span><br><span class="line">                flowers = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1109-Corporate-Flight-Bookings"><a href="#1109-Corporate-Flight-Bookings" class="headerlink" title="1109. Corporate Flight Bookings"></a><a href="https://leetcode.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener">1109. Corporate Flight Bookings</a></h5><blockquote><p>  这里有<code>n</code>个航班，它们分别从<code>1</code>到<code>n</code>进行编号。</p><p>  有一份航班预订表<code>bookings</code>，表中第<code>i</code>条预订记录<code>bookings[i] = [first_i, last_i, seats_i]</code>意味着在从<code>first_i</code>到<code>last_i</code>（包含<code>first_i</code>和<code>last_i</code>）的每个航班上预订了<code>seats_i</code>个座位。</p><p>  请你返回一个长度为<code>n</code>的数组<code>answer</code>，其中<code>answer[i]</code>是航班<code>i</code>上预订的座位总数。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</span><br><span class="line">Output: [10,55,45,25,25]</span><br><span class="line">Explanation:</span><br><span class="line">Flight labels:        1   2   3   4   5</span><br><span class="line">Booking 1 reserved:  10  10</span><br><span class="line">Booking 2 reserved:      20  20</span><br><span class="line">Booking 3 reserved:      25  25  25  25</span><br><span class="line">Total seats:         10  55  45  25  25</span><br><span class="line">Hence, answer &#x3D; [10,55,45,25,25]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: bookings &#x3D; [[1,2,10],[2,2,15]], n &#x3D; 2</span><br><span class="line">Output: [10,25]</span><br><span class="line">Explanation:</span><br><span class="line">Flight labels:        1   2</span><br><span class="line">Booking 1 reserved:  10  10</span><br><span class="line">Booking 2 reserved:      15</span><br><span class="line">Total seats:         10  25</span><br><span class="line">Hence, answer &#x3D; [10,25]</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li><li><code>1 &lt;= bookings.length &lt;= 2 * 10^4</code></li><li><code>bookings[i].length == 3</code></li><li><code>1 &lt;= firsti &lt;= lasti &lt;= n</code></li><li><code>1 &lt;= seatsi &lt;= 10^4</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diff;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Difference(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        diff.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                diff[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将闭区间 [i, j] 元素加上 val</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.size()) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.size(); i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本题相当于原数组元素均为 0</span></span><br><span class="line">    <span class="comment">// 因此其差分数组的元素也都为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">Difference <span class="title">difference</span><span class="params">(diff)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; booking : bookings) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = booking[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = booking[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = booking[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 将数组 [i..j] 区间内元素加上 val</span></span><br><span class="line">        difference.add(i, j, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difference.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本题相当于原数组元素均为 0</span></span><br><span class="line">    <span class="comment">// 因此其差分数组的元素也都为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">difference</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; booking : bookings) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = booking[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = booking[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = booking[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 将数组 [i..j] 区间内元素加上 val</span></span><br><span class="line">        difference[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            difference[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据差分数组构造原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        difference[i] += difference[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-64-995-Minimum-Number-of-K-Consecutive-Bit-Flips"><a href="#1-64-995-Minimum-Number-of-K-Consecutive-Bit-Flips" class="headerlink" title="1.64 995. Minimum Number of K Consecutive Bit Flips"></a><code>1.64</code> <a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/" target="_blank" rel="noopener">995. Minimum Number of K Consecutive Bit Flips</a></h5><blockquote><p>  在仅包含<code>0</code>和<code>1</code>的数组<code>A</code>中，一次<code>K</code>位翻转包括选择一个长度为<code>K</code>的（连续）子数组，同时将子数组中的每个<code>0</code>更改为<code>1</code>，而每个<code>1</code>更改为<code>0</code>。</p><p>  返回所需的<code>k</code>位翻转的最小次数，以便数组没有值为<code>0</code>的元素。如果不可能，返回<code>-1</code>。</p><p>  <strong>xample 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [0,1,0], K &#x3D; 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Flip A[0], then flip A[2].</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,1,0], K &#x3D; 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: No matter how we flip subarrays of size 2, we can&#39;t make the array become [1,1,1].</span><br></pre></td></tr></table></figure><p>  <strong>Example 3:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [0,0,0,1,0,1,1,0], K &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]</span><br><span class="line">Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]</span><br><span class="line">Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]</span><br></pre></td></tr></table></figure><p>  <strong>Note:</strong></p><ol><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接模拟反转过程</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(nk), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="comment">// 超时 TLE!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到下一个 0 所在的位置</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; A[i] != <span class="number">0</span>) i++;</span><br><span class="line">        <span class="comment">// 如果没有 0 了, 就全部翻转成功</span></span><br><span class="line">        <span class="keyword">if</span>(i == n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果需要翻转的不够 K 位, 就不可能翻转成功</span></span><br><span class="line">        <span class="keyword">if</span>(i + K &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 实际地进行翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j++)</span><br><span class="line">            A[i + j] = <span class="number">1</span> - A[i + j];</span><br><span class="line">        <span class="comment">// 翻转次数加一</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组</span></span><br><span class="line"><span class="comment">// 自然而然, 我们会想到使用一个数组来记录每一位的翻转次数</span></span><br><span class="line"><span class="comment">// 但是我们又不希望是通过 [遍历数组的 K 位进行 +1 操作] 来完成记录</span></span><br><span class="line"><span class="comment">// 所以可以借助差分数组来记录每个区间元素被翻转的次数</span></span><br><span class="line"><span class="comment">// 当翻转的次数为奇数次时, 才真的要翻转, 为偶数次时并不需要实际地翻转</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n), 空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 多一个位置防止越位</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实时计算数组索引 i 处的翻转次数</span></span><br><span class="line">        <span class="comment">// 这时计算的是从索引 i 开始的 K 位被翻转之前的该位已经被翻转的次数</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) diff[i] += diff[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 判断索引 i 处开始的 K 位是否需要被翻转</span></span><br><span class="line">        <span class="keyword">if</span>((A[i] + diff[i]) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + K &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            diff[i] += <span class="number">1</span>;</span><br><span class="line">            diff[i + K] -= <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里的逻辑需要好好理一理, 这里相当于一边更新 diff 数组, 一边还原数组的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="307-Range-Sum-Query-Mutable"><a href="#307-Range-Sum-Query-Mutable" class="headerlink" title="307. Range Sum Query - Mutable"></a><a href="https://leetcode.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">307. Range Sum Query - Mutable</a></h5><blockquote><p>  给你一个数组<code>nums</code>，请你完成两类查询，其中一类查询要求更新数组下标对应的值，另一类查询要求返回数组中某个范围内元素的总和。</p><p>  实现<code>NumArray</code>类：</p><ul><li><code>NumArray(int[] nums)</code>：用整数数组<code>nums</code>初始化对象</li><li><code>void update(int index, int val)</code>：将<code>nums[index]</code>的值更新为<code>val</code></li><li><code>int sumRange(int left, int right)</code>：返回子数组<code>nums[left, right]</code>的总和（即，<code>nums[left] + nums[left + 1], ..., nums[right]</code>）</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状数组又称二叉索引树 (Binary Indexed Tree)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// O(nlogn) 的复杂度建立树状数组</span></span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) : _nums(nums), bit(_nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _nums.size(); i++)</span><br><span class="line">            add(i + <span class="number">1</span>, _nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">// O(n) 的复杂度建立树状数组</span></span><br><span class="line"><span class="comment">    NumArray(vector&lt;int&gt;&amp; nums)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 原有的值为 _nums[index], 要更新为 val, 需要加上 val - _nums[index]</span></span><br><span class="line">        add(index + <span class="number">1</span>, val - _nums[index]);</span><br><span class="line">        _nums[index] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getsum(right + <span class="number">1</span>) - getsum(left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _nums;</span><br><span class="line">    <span class="comment">// 注意 bit 数组的索引 [语义] 是从 1 开始</span></span><br><span class="line">    <span class="comment">// 长度和原数组相同</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将第 pos 个数加上 val</span></span><br><span class="line">    <span class="comment">// 时间复杂度为 O(logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt;= bit.size(); i += lowbit(i))</span><br><span class="line">            bit[i - <span class="number">1</span>] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回前 pos 个数的和</span></span><br><span class="line">    <span class="comment">// 时间复杂度为 O(logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &gt; <span class="number">0</span>; i -= lowbit(i))</span><br><span class="line">            res += bit[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="1310-XOR-Queries-of-a-Subarray"><a href="#1310-XOR-Queries-of-a-Subarray" class="headerlink" title="1310. XOR Queries of a Subarray"></a><a href="https://leetcode.com/problems/xor-queries-of-a-subarray/" target="_blank" rel="noopener">1310. XOR Queries of a Subarray</a></h5><blockquote><p>  有一个正整数数组<code>arr</code>，现给你一个对应的查询数组<code>queries</code>，其中<code>queries[i] = [Li, Ri]</code>。</p><p>  对于每个查询<code>i</code>，请你计算从<code>Li</code>到<code>Ri</code>的<code>XOR</code>值（即<code>arr[Li] xor arr[Li+1] xor ... xor arr[Ri]</code>）作为本次查询的结果。并返回一个包含给定查询<code>queries</code>所有结果的数组。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; pos &lt;= bit.size(); pos += lowbit(pos))</span><br><span class="line">        bit[pos - <span class="number">1</span>] ^= val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">for</span>(; pos &gt; <span class="number">0</span>; pos -= lowbit(pos))</span><br><span class="line">        res ^= bit[pos - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">xorQueries</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bit.resize(arr.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i++)</span><br><span class="line">        add(i + <span class="number">1</span>, arr[i]);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; query : queries)</span><br><span class="line">        res.push_back(getsum(query[<span class="number">1</span>] + <span class="number">1</span>) ^ getsum(query[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="315-Count-of-Smaller-Numbers-After-Self"><a href="#315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="315. Count of Smaller Numbers After Self"></a><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. Count of Smaller Numbers After Self</a></h5><blockquote><p>  给定一个整数数组<code>nums</code>，按要求返回一个新数组<code>counts</code>。数组<code>counts</code>有该性质：<code>counts[i]</code>的值是<code>nums[i]</code>右侧小于<code>nums[i]</code>的元素的数量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bit(<span class="keyword">int</span> _n) : n(_n), bit(n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 本题原数组相当于全 0 数组, 不需要创建 bit</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.size(); i++)</span></span><br><span class="line">        <span class="comment">//     add(i + 1, nums[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt;= n) &#123;</span><br><span class="line">            bit[pos] += val;</span><br><span class="line">            pos += lowbit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += bit[pos];</span><br><span class="line">            pos -= lowbit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 离散化树状数组</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums)</span></span>;</span><br><span class="line">    sort(temp.begin(), temp.end());</span><br><span class="line">    <span class="comment">// 离散化数组的方式, 将数组中的元素按照排名映射为 1 ...</span></span><br><span class="line">    <span class="comment">// 这种离散方式, 离散化前后并不需要保留元素的绝对大小, 只关心元素的相对大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = lower_bound(temp.begin(), temp.end(), nums[i]) - temp.begin() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res.push_back(bit.getsum(nums[i] - <span class="number">1</span>));</span><br><span class="line">        bit.add(nums[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对</a></h5><blockquote><p>  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个<strong>数组中的逆序对的总数</strong>。</p><p>  <strong>示例:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bit(<span class="keyword">int</span> _n) : n(_n), bit(n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 本题原数组相当于全 0 数组, 不需要创建 bit</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.size(); i++)</span></span><br><span class="line">        <span class="comment">//     add(i + 1, nums[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt;= n) &#123;</span><br><span class="line">            bit[pos] += val;</span><br><span class="line">            pos += lowbit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += bit[pos];</span><br><span class="line">            pos -= lowbit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化树状数组 (具体思想参考官方题解)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums)</span></span>;</span><br><span class="line">    sort(temp.begin(), temp.end());</span><br><span class="line">    <span class="comment">// 离散化数组的另一种方式, 通常需要保留原数组中元素大小时采用, 这里最然不需要</span></span><br><span class="line">    <span class="comment">// 将每个数按次序映射到数组中的对应的位置</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : temp) &#123;</span><br><span class="line">        mapping[num] = i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res += bit.getsum(mapping[nums[i]] - <span class="number">1</span>);</span><br><span class="line">        bit.add(mapping[nums[i]], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = data.size();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 提前分配空间优化构造析构函数效率</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(n/<span class="number">2</span>+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 合并闭区间 [lo, mi] 和 [mi + 1, hi] 的子数组</span></span><br><span class="line">    <span class="keyword">auto</span> merge = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mi + <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">            helper[i - mi - <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = mi;</span><br><span class="line">        <span class="keyword">int</span> j = hi - mi - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = hi;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= lo &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &gt; helper[j]) &#123;</span><br><span class="line">                data[k--] = data[i--];</span><br><span class="line">                <span class="comment">// 就增加这一行</span></span><br><span class="line">                cnt += j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                data[k--] = helper[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            data[k--] = helper[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; mergeSort = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(lo, mi);</span><br><span class="line">        mergeSort(mi + <span class="number">1</span>, hi);</span><br><span class="line">        merge(lo, mi, hi);</span><br><span class="line">    &#125;;</span><br><span class="line">    mergeSort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR"></a><a href="https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">1442. Count Triplets That Can Form Two Arrays of Equal XOR</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>。</p><p>  现需要从数组中取三个下标<code>i</code>、<code>j</code>和<code>k</code>，其中<code>(0 &lt;= i &lt; j &lt;= k &lt; nums.size())</code>。</p><p>  <code>a</code>和<code>b</code>定义如下：</p><ul><li><p><code>a = nums[i] ^ nums[i + 1] ^ ... ^ nums[j - 1]</code></p></li><li><p><code>b = nums[j] ^ nums[j + 1] ^ ... ^ nums[k]</code></p><p>请返回能够令<code>a == b</code>成立的三元组<code>(i, j , k)</code>的数目。</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀异或数组 + 三重循环枚举 i, j, k</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n3), 空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] ^ nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; n; k++)</span><br><span class="line">                <span class="keyword">if</span>(prefix[j] ^ prefix[i] == prefix[k + <span class="number">1</span>] ^ prefix[j])</span><br><span class="line">                    res++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意到如果 a == b</span></span><br><span class="line"><span class="comment">// 那么就有 nums[i] ^ ... ^ nums[j] ^ ... ^ nums[k] == 0</span></span><br><span class="line"><span class="comment">// 也就是说有 prefix[k + 1] == prefix[i]</span></span><br><span class="line"><span class="comment">// 此时对于 (i, k] 中的每一个 j 都是满足的</span></span><br><span class="line"><span class="comment">// 前缀异或数组 + 二重循环枚举 i, k</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n2), 空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] ^ nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">            <span class="keyword">if</span>(prefix[i] == prefix[k + <span class="number">1</span>])</span><br><span class="line">                res += k - i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表 + 一重循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] ^ nums[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt, total;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(prefix[k + <span class="number">1</span>]))</span><br><span class="line">            res += cnt[prefix[k + <span class="number">1</span>]] * k - total[prefix[k + <span class="number">1</span>]];</span><br><span class="line">        </span><br><span class="line">        cnt[prefix[k]]++;</span><br><span class="line">        total[prefix[k]] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="421-Maximum-XOR-of-Two-Numbers-in-an-Array"><a href="#421-Maximum-XOR-of-Two-Numbers-in-an-Array" class="headerlink" title="421. Maximum XOR of Two Numbers in an Array"></a><a href="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">421. Maximum XOR of Two Numbers in an Array</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>，返回<code>nums[i] ^ nums[j]</code>的最大运算结果，其中<code>0 ≤ i ≤ j &lt; n</code>。</p><p>  <strong>进阶</strong>：你可以在<code>O(n)</code>的时间解决这个问题吗？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Trie* child[<span class="number">2</span>] = &#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Trie* root = <span class="keyword">new</span> Trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie* cur = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;child[a])</span><br><span class="line">            cur-&gt;child[a] = <span class="keyword">new</span> Trie;</span><br><span class="line">        cur = cur-&gt;child[a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie* cur = root;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span> - a;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;child[b])</span><br><span class="line">        &#123;</span><br><span class="line">            res |= (b &lt;&lt; i);</span><br><span class="line">            cur = cur-&gt;child[b];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res |= (a &lt;&lt; i);</span><br><span class="line">            cur = cur-&gt;child[a];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(num);</span><br><span class="line">        res = max(res, num ^ check(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1707-Maximum-XOR-With-an-Element-From-Array"><a href="#1707-Maximum-XOR-With-an-Element-From-Array" class="headerlink" title="1707. Maximum XOR With an Element From Array"></a><a href="https://leetcode.com/problems/maximum-xor-with-an-element-from-array/" target="_blank" rel="noopener">1707. Maximum XOR With an Element From Array</a></h5><blockquote><p>  给你一个由非负整数组成的数组<code>nums</code>。另有一个查询数组<code>queries</code>，其中<code>queries[i] = [xi, mi]</code>。</p><p>  第<code>i</code>个查询的答案是<code>xi</code>和任何<code>nums</code>数组中不超过<code>mi</code>的元素按位异或得到的最大值。换句话说，答案是<code>max(nums[j] XOR xi)</code>，其中所有<code>j</code>均满足<code>nums[j] &lt;= mi</code>。如果<code>nums</code>中的所有元素都大于<code>mi</code>，最终答案就是<code>-1</code>。</p><p>  返回一个整数数组<code>answer</code>作为查询的答案，其中<code>answer.length == queries.length</code>且<code>answer[i]</code>是第<code>i</code>个查询的答案。</p><p>  <strong>题解</strong>：<a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/solution/yu-shu-zu-zhong-yuan-su-de-zui-da-yi-huo-7erc/" target="_blank" rel="noopener">与数组中元素的最大异或值 - 与数组中元素的最大异或值 - 力扣（LeetCode）</a></p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,2,3,4], queries &#x3D; [[3,1],[1,3],[5,6]]</span><br><span class="line">Output: [3,3,7]</span><br><span class="line">Explanation:</span><br><span class="line">1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 &#x3D; 3 and 1 XOR 3 &#x3D; 2. The larger of the two is 3.</span><br><span class="line">2) 1 XOR 2 &#x3D; 3.</span><br><span class="line">3) 5 XOR 2 &#x3D; 7.</span><br></pre></td></tr></table></figure><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length, queries.length &lt;= 10^5</code></li><li><code>queries[i].length == 2</code></li><li><code>0 &lt;= nums[j], xi, mi &lt;= 10^9</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maximizeXor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) insert(num);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.reserve(queries.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> query : queries)</span><br><span class="line">            res.push_back(getVal(query[<span class="number">0</span>], query[<span class="number">1</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> minVal = INT_MAX;</span><br><span class="line">        Trie* child[<span class="number">2</span>] = &#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Trie* root = <span class="keyword">new</span> Trie;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        root-&gt;minVal = min(root-&gt;minVal, num);</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;child[bit])</span><br><span class="line">                cur-&gt;child[bit] = <span class="keyword">new</span> Trie;</span><br><span class="line">            cur-&gt;child[bit]-&gt;minVal = min(cur-&gt;child[bit]-&gt;minVal, num);</span><br><span class="line">            cur = cur-&gt;child[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getVal</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; root-&gt;minVal)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[bit ^ <span class="number">1</span>] &amp;&amp; cur-&gt;child[bit ^ <span class="number">1</span>]-&gt;minVal &lt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                bit = bit ^ <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;child[bit];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="1074-Number-of-Submatrices-That-Sum-to-Target"><a href="#1074-Number-of-Submatrices-That-Sum-to-Target" class="headerlink" title="1074. Number of Submatrices That Sum to Target"></a><a href="https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/" target="_blank" rel="noopener">1074. Number of Submatrices That Sum to Target</a></h5><blockquote><p>  给出矩阵<code>matrix</code>和目标值<code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p><p>  如果<code>(x1, y1, x2, y2)</code>和<code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code>两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p><p>  <strong>题解</strong>：<a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-uttw/" target="_blank" rel="noopener">【宫水三叶】优化枚举的基本思路与进阶内容 - 元素和为目标值的子矩阵数量 - 力扣（LeetCode）</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀子矩阵和 + 暴力枚举</span></span><br><span class="line"><span class="comment">// 从「点」上来确定一个子矩阵, 在 n 和 m 同阶的情况下, 时间复杂度是 O(n^4)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">prefixsumOfSubMatrix</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            prefixsumOfSubMatrix[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + prefixsumOfSubMatrix[i - <span class="number">1</span>][j] + prefixsumOfSubMatrix[i][j - <span class="number">1</span>] - prefixsumOfSubMatrix[i - <span class="number">1</span>][ j - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> rl = <span class="number">1</span>; rl &lt;= m; rl++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cu = <span class="number">1</span>; cu &lt;= n; cu ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> rr = rl; rr &lt;= m; rr++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> cd = cu; cd &lt;= n; cd++)</span><br><span class="line">                    <span class="keyword">if</span>(prefixsumOfSubMatrix[rr][cd] - prefixsumOfSubMatrix[rr][cu - <span class="number">1</span>] - prefixsumOfSubMatrix[rl - <span class="number">1</span>][cd] + prefixsumOfSubMatrix[rl - <span class="number">1</span>][cu - <span class="number">1</span>] == target)</span><br><span class="line">                        res++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从「边」上来确定一个子矩阵, 通过枚举三条边</span></span><br><span class="line"><span class="comment">// 使用哈希表 + 前缀和来加速查找第四条边</span></span><br><span class="line"><span class="comment">// 在 n 和 m 同阶的情况下, 时间复杂度可降到 O(n3)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 枚举上边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 枚举下边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新每列的元素和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) sum[c] += matrix[j][c];</span><br><span class="line">            <span class="comment">// 遍历 sum 子数组的和</span></span><br><span class="line">            res += sumsOfSubArrayEqualTarget(sum, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算数组中和等于 target 的子数组个数</span></span><br><span class="line"><span class="comment">// 前缀和 + 哈希表优化 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumsOfSubArrayEqualTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="comment">// 表示以首元素开头的子数组的和等于 target</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, preSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        preSum += num;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(preSum - target))</span><br><span class="line">            res += mapping[preSum - target];</span><br><span class="line">        ++mapping[preSum];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1738-Find-Kth-Largest-XOR-Coordinate-Value"><a href="#1738-Find-Kth-Largest-XOR-Coordinate-Value" class="headerlink" title="1738. Find Kth Largest XOR Coordinate Value"></a><a href="https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/" target="_blank" rel="noopener">1738. Find Kth Largest XOR Coordinate Value</a></h5><blockquote><p>  给你一个二维矩阵<code>matrix</code>和一个整数<code>k</code>，矩阵大小为<code>m x n</code>由非负整数组成。矩阵中坐标<code>(a, b)</code>的值可由对所有满足<code>0 &lt;= i &lt;= a &lt; m</code>且<code>0 &lt;= j &lt;= b &lt; n</code>的元素<code>matrix[i][j]</code>（下标从<code>0</code>开始计数）执行异或运算得到。</p><p>  请你找出<code>matrix</code>的所有坐标中第<code>k</code>大的值（<code>k</code>的值从<code>1</code>开始计数）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀子矩阵异或 + 小顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subMatrixXors</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            subMatrixXors[i][j] = subMatrixXors[i - <span class="number">1</span>][j - <span class="number">1</span>] ^ subMatrixXors[i][j - <span class="number">1</span>] ^ subMatrixXors[i - <span class="number">1</span>][j] ^ matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            pq.push(subMatrixXors[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k)</span><br><span class="line">                pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀子矩阵异或 + 快速选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subMatrixXors</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    temp.reserve(m * n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            subMatrixXors[i][j] = subMatrixXors[i - <span class="number">1</span>][j - <span class="number">1</span>] ^ subMatrixXors[i][j - <span class="number">1</span>] ^ subMatrixXors[i - <span class="number">1</span>][j] ^ matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            temp.push_back(subMatrixXors[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nth_element(temp.begin(), prev(temp.end(), k), temp.end());</span><br><span class="line">    <span class="keyword">return</span> temp[m * n - k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="581-Shortest-Unsorted-Continuous-Subarray"><a href="#581-Shortest-Unsorted-Continuous-Subarray" class="headerlink" title="581. Shortest Unsorted Continuous Subarray"></a><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. Shortest Unsorted Continuous Subarray</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>，你需要找出一个连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的最短子数组，并输出它的长度。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,6,4,8,10,9,15]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先排序 + 再比较</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums)</span></span>;</span><br><span class="line">    sort(temp.begin(), temp.end());</span><br><span class="line">    <span class="comment">// 初始化为 -1 和 -2 方便处理数组已经是升序的情况</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>, right = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != temp[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="number">-1</span>) &#123;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">            right = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双层循环暴力法</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n2)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, left = INT_MAX, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                left = min(left, i);</span><br><span class="line">                right = max(right, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left == INT_MAX ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正序和逆序分别遍历</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 初始化为 -1 和 -2 方便处理数组已经是升序的情况</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>, right = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">int</span> maximun = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; maximun) &#123;</span><br><span class="line">            right = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            maximun = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minimum = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; minimum) &#123;</span><br><span class="line">            left = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minimum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">48. Rotate Image</a></h5><blockquote><p>  给定一个<code>n × n</code>的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转<code>90</code>度。你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>  <strong>示例 1：</strong></p>  <img src="mat2.jpg" alt="img" style="zoom:50%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用额外空间就比较容易了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(matrix)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = res[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用额外空间</span></span><br><span class="line"><span class="comment">// 用翻转实现旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">    <span class="comment">// 上下翻转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            swap(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5777-使数组元素相等的减少操作次数"><a href="#5777-使数组元素相等的减少操作次数" class="headerlink" title="5777. 使数组元素相等的减少操作次数"></a><a href="https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal/" target="_blank" rel="noopener">5777. 使数组元素相等的减少操作次数</a></h5><blockquote><p>  给你一个整数数组<code>nums</code>，你的目标是令<code>nums</code>中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p><ul><li><p>找出<code>nums</code>中的最大值。记这个值为<code>largest</code>并取其下标<code>i</code>（下标从<code>0</code>开始计数）。如果有多个元素都是最大值，则取最小的<code>i</code>。</p></li><li><p>找出<code>nums</code>中的下一个最大值，这个值严格小于<code>largest</code>，记为<code>nextLargest</code>。</p></li><li><p>将<code>nums[i]</code>减少到<code>nextLargest</code>。</p><p>返回使<code>nums</code>中的所有元素相等的操作次数。</p></li></ul><p>  <strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal/solution/shi-shu-zu-yuan-su-xiang-deng-de-jian-sh-lt55/" target="_blank" rel="noopener">使数组元素相等的减少操作次数 - 使数组元素相等的减少操作次数 - 力扣（LeetCode）</a></p><p>  <strong>示例 1：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,1,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：需要 3 次操作使 nums 中的所有元素相等：</span><br><span class="line"></span><br><span class="line">1. largest &#x3D; 5 下标为 0 。nextLargest &#x3D; 3 。将 nums[0] 减少到 3 。nums &#x3D; [3,1,3] 。</span><br><span class="line">2. largest &#x3D; 3 下标为 0 。nextLargest &#x3D; 1 。将 nums[0] 减少到 1 。nums &#x3D; [1,1,3] 。</span><br><span class="line">3. largest &#x3D; 3 下标为 2 。nextLargest &#x3D; 1 。将 nums[2] 减少到 1 。nums &#x3D; [1,1,1] 。</span><br></pre></td></tr></table></figure><p>  <strong>示例 3：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,2,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：需要 4 次操作使 nums 中的所有元素相等：</span><br><span class="line"></span><br><span class="line">1. largest &#x3D; 3 下标为 4 。nextLargest &#x3D; 2 。将 nums[4] 减少到 2 。nums &#x3D; [1,1,2,2,2] 。</span><br><span class="line">2. largest &#x3D; 2 下标为 2 。nextLargest &#x3D; 1 。将 nums[2] 减少到 1 。nums &#x3D; [1,1,1,2,2] 。 </span><br><span class="line">3. largest &#x3D; 2 下标为 3 。nextLargest &#x3D; 1 。将 nums[3] 减少到 1 。nums &#x3D; [1,1,1,1,2] 。 </span><br><span class="line">4. largest &#x3D; 2 下标为 4 。nextLargest &#x3D; 1 。将 nums[4] 减少到 1 。nums &#x3D; [1,1,1,1,1] 。</span><br></pre></td></tr></table></figure><p>  <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li><li><code>1 &lt;= nums[i] &lt;= 5 * 10^4</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序排序做法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reductionOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// 总操作次数</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 每个元素操作次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        res += cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降序排序做法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reductionOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = nums.size();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> max_value = nums[i];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; nums[i] == max_value) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        count.push_back(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    count.pop_back();</span><br><span class="line">    partial_sum(count.begin(), count.end(), count.begin());</span><br><span class="line">    <span class="keyword">return</span> accumulate(count.begin(), count.end(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a><a href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" rel="noopener">645. 错误的集合</a></h5><blockquote><p>  集合<code>s</code>包含从<code>1</code>到<code>n</code>的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制成了集合里面的另外一个数字的值，导致集合丢失了一个数字并且有一个数字重复。</p><p>  给定一个数组<code>nums</code>代表了集合<code>s</code>发生错误后的结果。请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p><p>  <strong>示例 1</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,2,4]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p>  <strong>提示</strong>：</p><ul><li>2 &lt;= nums.length &lt;= 1e4</li><li>1 &lt;= nums[i] &lt;= 1e4</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法一：哈希表</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; existed;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(existed.count(num)) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        existed.insert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(existed.count(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            res[<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法二：下标索引原地哈希</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(nums[num - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            a = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[num - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法三：数学</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum_1 = <span class="number">0</span>, sum_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">sets</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum_1 += num;</span><br><span class="line">        <span class="keyword">if</span>(!sets[num]) &#123;</span><br><span class="line">            sum_2 += num;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[num] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;sum_1 - sum_2, sum - sum_2&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法四：位运算</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> xors = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        xors = xors ^ (i + <span class="number">1</span>) ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lowbit = xors &amp; (-xors);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &amp; lowbit) &#123;</span><br><span class="line">            a = a ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            b = b ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((i + <span class="number">1</span>) &amp; lowbit) &#123;</span><br><span class="line">            a = a ^ (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            b = b ^ (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;b, a&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="462-最少移动次数使数组元素相等-II"><a href="#462-最少移动次数使数组元素相等-II" class="headerlink" title="462. 最少移动次数使数组元素相等 II"></a><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/" target="_blank" rel="noopener">462. 最少移动次数使数组元素相等 II</a></h5><blockquote><p>  给定一个非空整数数组，找到使所有数组元素相等所需的最小操作数，其中每次操作可将选定的一个元素加<code>1</code>或减<code>1</code>。</p><p>  <strong>参考题解</strong>：</p><p>  <a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/solution/czhong-wei-shu-jian-dan-zheng-ming-by-ke-a2v9/?um_chnnl=huawei?um_from_appkey=5fcda41c42348b56d6f8e8d5" target="_blank" rel="noopener">C++｜中位数｜简单证明 - 最少移动次数使数组元素相等 II</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使得操作数最小, 最终的值一定是中位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// nth_element(nums.begin(), next(nums.begin(), n/2), nums.end());</span></span><br><span class="line">    _nth_element(nums, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> midVal = nums[n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        res += <span class="built_in">abs</span>(num - midVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速选择算法，使得 k 索引处的元素就位</span></span><br><span class="line"><span class="keyword">void</span> _nth_element(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 对 [lo, hi] 区间内的元素进行洗牌算法</span></span><br><span class="line">    <span class="keyword">auto</span> shuffle = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = rand() % (hi - i + <span class="number">1</span>) + i;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 以首元素为轴点，对 [lo, hi] 区间内元素进行划分</span></span><br><span class="line">    <span class="keyword">auto</span> partition = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        shuffle(lo, hi);</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = lo;</span><br><span class="line">        <span class="keyword">while</span>(++j &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[lo]) &#123;</span><br><span class="line">                swap(nums[++i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[lo], nums[i]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="keyword">int</span>(nums.size()) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> p = partition(lo, hi);</span><br><span class="line">        <span class="keyword">if</span>(p == k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p &lt; k) &#123;</span><br><span class="line">            lo = p + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = p - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></h5><blockquote><p>  实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>  必须原地修改，只允许使用额外常数空间。</p><p>  <strong>参考链接</strong>：<a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/" target="_blank" rel="noopener">下一个排列算法详解：思路+推导+步骤，看不懂算我输</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_permutation(nums.begin(), nums.end());</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> left = n - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; nums[left] &gt;= nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; nums[right] &lt;= nums[left]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[left], nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(next(nums.begin(), left + <span class="number">1</span>), nums.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a></h5><blockquote><p>  给定一个未排序的整数数组<code>nums</code>，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>  请你设计并实现时间复杂度为<code>O(n)</code>的算法解决此问题。</p><p>  <strong>示例 1：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序 + 去重 + 计数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    unique(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = max(res, cnt);</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(res, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; existed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        existed.insert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : existed) &#123;</span><br><span class="line">        <span class="keyword">if</span>(existed.count(num - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxVal = num;</span><br><span class="line">            <span class="keyword">while</span>(existed.count(maxVal + <span class="number">1</span>)) &#123;</span><br><span class="line">                maxVal++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, maxVal - num + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h5><blockquote><p>  你这个学期必须选修<code>n</code>门课程，记为<code>0</code>到<code>n - 1</code>。在选修某些课程之前需要一些先修课程。 先修课程按数组<code>p</code>给出，其中<code>p[i] = [ai, bi]</code>，表示如果要学习课程<code>ai</code>则必须先学习课程<code>bi</code>。例如，先修课程对<code>[0, 1]</code>表示：想要学习课程<code>0</code>，你需要先完成课程<code>1</code>。</p><p>  请你判断是否可能完成所有课程的学习？如果可以，返回<code>true</code>；否则，返回<code>false</code>。</p><p>  <strong>示例：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 2, p &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">adj</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">in</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; v : p) &#123;</span><br><span class="line">        adj[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">        in[v[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        res.push_back(from);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> to : adj[from]) &#123;</span><br><span class="line">            in[to]--;</span><br><span class="line">            <span class="keyword">if</span>(in[to] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size() == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1462-课程表-IV"><a href="#1462-课程表-IV" class="headerlink" title="1462. 课程表 IV"></a><a href="https://leetcode-cn.com/problems/course-schedule-iv/" target="_blank" rel="noopener">1462. 课程表 IV</a></h5><blockquote><p>  你总共需要上<code>n</code>门课，课程编号依次为<code>0</code>到<code>n-1</code>。有的课会有直接的先修课程，比如如果想上课程<code>0</code>，你必须先上课程<code>1</code>，那么会以<code>[1, 0]</code>数对的形式给出先修课程数对。</p><p>  给你课程总数<code>n</code>和一个直接先修课程数对列表<code>p</code>和一个查询对列表<code>q</code>。</p><p>  对于每个查询对<code>q[i]</code>，请判断<code>q[i][0]</code>是否是<code>q[i][1]</code>的先修课程。请返回一个布尔值列表，列表中每个元素依次分别对应<code>q</code>每个查询对的判断结果。</p><p>  注意：如果课程<code>a</code>是课程<code>b</code>的先修课程且课程<code>b</code>是课程<code>c</code>的先修课程，那么课程<code>a</code>也是课程<code>c</code>的先修课程。</p><p>  <strong>参考链接</strong>：<a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd" target="_blank" rel="noopener">图最短路径算法之弗洛伊德算法（Floyd） | Echo Blog</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">adj</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; v : p) &#123;</span><br><span class="line">        adj[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                adj[i][j] = adj[i][j] || (adj[i][k] &amp;&amp; adj[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; v : q) &#123;</span><br><span class="line">        res.push_back(adj[v[<span class="number">0</span>]][v[<span class="number">1</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/submissions/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h5><blockquote><p>  给定一个<code>m x n</code>整数矩阵<code>matrix</code>，找出其中最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到 边界外（即不允许环绕）。</p><p>  <img src="grid1.jpg" alt="img"></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建图: 对于每一个点, 都有一个指向比其大的方向的路径</span></span><br><span class="line"><span class="comment">// 2. 从所有入度为 0 的点出发分别进行 dfs</span></span><br><span class="line"><span class="comment">// 3. 相当于是找到以各个出发节点为根的树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">adj</span><span class="params">(m * n)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">in</span><span class="params">(m * n)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> getId = [n](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">return</span> i * n + j;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(m * n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="keyword">int</span> from) &#123;</span><br><span class="line">        <span class="keyword">if</span>(adj[from].empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[from] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[from];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> to : adj[from]) &#123;</span><br><span class="line">            len = max(len, <span class="number">1</span> + dfs(dfs, to));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[from] = len;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m &amp;&amp; matrix[i][j] &lt; matrix[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                adj[getId(i, j)].push_back(getId(i + <span class="number">1</span>, j));</span><br><span class="line">                in[getId(i + <span class="number">1</span>, j)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; matrix[i][j] &lt; matrix[i][j + <span class="number">1</span>]) &#123;</span><br><span class="line">                adj[getId(i, j)].push_back(getId(i, j + <span class="number">1</span>));</span><br><span class="line">                in[getId(i, j + <span class="number">1</span>)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j] &lt; matrix[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                adj[getId(i, j)].push_back(getId(i - <span class="number">1</span>, j));</span><br><span class="line">                in[getId(i - <span class="number">1</span>, j)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j] &lt; matrix[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                adj[getId(i, j)].push_back(getId(i, j - <span class="number">1</span>));</span><br><span class="line">                in[getId(i, j - <span class="number">1</span>)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m * n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            res = max(res, dfs(dfs, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="444-序列重建"><a href="#444-序列重建" class="headerlink" title="444. 序列重建"></a><a href="https://leetcode-cn.com/problems/sequence-reconstruction/" target="_blank" rel="noopener">444. 序列重建</a></h5><blockquote><p>  验证原始的序列<code>org</code>是否可以从序列集<code>seqs</code>中唯一地重建。序列<code>org</code>是<code>1</code>到<code>n</code>整数的排列，其中<code>1 ≤ n ≤ 10^4</code>。重建是指在序列集<code>seqs</code>中构建最短的公共超序列。（即使得所有<code>seqs</code>中的序列都是该最短序列的子序列）。确定是否只可以从<code>seqs</code>重建唯一的序列，且该序列就是<code>org</code>。</p><p>  <strong>示例 1</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">org: [1,2,3], seqs: [[1,2],[1,3]]</span><br><span class="line">输出：false</span><br><span class="line">解释：[1,2,3] 不是可以被重建的唯一的序列，因为 [1,3,2] 也是一个合法的序列。</span><br></pre></td></tr></table></figure><p>  <strong>示例 2</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：org: [1,2,3], seqs: [[1,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：可以重建的序列只有 [1,2]。</span><br></pre></td></tr></table></figure><p>  <strong>示例 3</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：org: [1,2,3], seqs: [[1,2],[1,3],[2,3]]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列 [1,2], [1,3] 和 [2,3] 可以被唯一地重建为原始的序列 [1,2,3]。</span><br></pre></td></tr></table></figure><p>  <strong>示例 4</strong>：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：org: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; org, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; seqs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seqs.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = org.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">in</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">adj</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; all_set;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; seq : seqs) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = seq.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i] &lt;= <span class="number">0</span> || seq[i] &gt; n) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                all_set.insert(seq[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> from = seq[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = seq[i];</span><br><span class="line">            adj[from].push_back(to);</span><br><span class="line">            in[to]++;</span><br><span class="line">            all_set.insert(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> from = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        res.push_back(from);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> to : adj[from]) &#123;</span><br><span class="line">            in[to]--;</span><br><span class="line">            <span class="keyword">if</span>(in[to] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> org == res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之僵尸进程和孤儿进程</title>
      <link href="/rakjPpyIOCsd0MoJ/"/>
      <url>/rakjPpyIOCsd0MoJ/</url>
      
        <content type="html"><![CDATA[<h5 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h5><p>简单的说，僵尸进程就是子进程先于父进程退出，并且父进程并没有调用<code>wait</code>系统调用，即使其进程映像中占用的系统资源（比如内存，页表等）都会被释放回收，但这时子进程的进程描述符（<code>PCB</code>）结构仍然存在于系统中得不到释放，就称这样的进程为僵尸进程（<code>Zombie</code>）。</p><a id="more"></a><h5 id="为什么会产生僵尸进程？"><a href="#为什么会产生僵尸进程？" class="headerlink" title="为什么会产生僵尸进程？"></a>为什么会产生僵尸进程？</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* status)</span></span>;</span><br></pre></td></tr></table></figure><p>首先，如果一个进程不成为僵尸进程的话，就要请求内核来回收它最后遗留的<code>PCB</code>。而内核给出了<code>exit</code>和<code>wait</code>系统调用来提供回收进程<code>PCB</code>的途径。进程到最后或者是主动调用<code>exit</code>结束运行，或者是通过<code>return</code>语句使得编译器安插<code>exit</code>调用代码，目的都是向父进程传递一个“退出状态值”（这个状态值就是<code>exit</code>函数的那个参数，或者是<code>return</code>语句后面那个整数），我们就叫它临终遗言吧。这个遗言就保存在进程遗留的<code>PCB</code>中，等待着父进程调用<code>wait</code>系统调用去取它的遗言，也就是内核会把这个遗言放在<code>wait</code>函数的参数所指向的内存，取完之后，内核就会回收这块<code>PCB</code>资源。这些都是在执行系统调用期间发生的，也就是说调用了这两个系统调用，给了内核机会来回收遗留的<code>PCB</code>。</p><p>如果父进程在派生出子进程后并没有调用<code>wait</code>等待接收子进程的返回值，这时某个子进程调用<code>exit</code>退出了，自然没人来接收返回值了。因此其<code>PCB</code>所占的空间不能释放，没人为其“收尸”，自然就成了“僵 尸”。</p><h5 id="僵尸进程有什么危害以及如何处理？"><a href="#僵尸进程有什么危害以及如何处理？" class="headerlink" title="僵尸进程有什么危害以及如何处理？"></a>僵尸进程有什么危害以及如何处理？</h5><p>虽然进程的退出状态未被父进程取出前，除了<code>PCB</code>以外，其他所有资源都可以释放。但由于<code>PCB</code>不释放，它原本的<code>pid</code>也会继续被占用，当僵尸进程数量很大时，系统将无可用<code>pid</code>分配给新进程，从而加载进程失败。</p><p>既然产生了僵尸进程，就说明父进程违背了和内核的约定，不想回收子进程。那么，内核也提供了毫不客气的办法来处理，那就是直接<code>kill</code>掉父进程，在<code>Linux</code>中可以利用<code>ps –ef</code>查看所有任务的<code>pid</code>和<code>ppid</code>，找到状态为<code>Z</code>的进程，查看其<code>ppid</code>，跟着向<code>pid</code>为<code>ppid</code>的进程发送<code>kill -9</code>。</p><h5 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h5><p>在子进程提交给父进程返回值的时候，有这样一种情况，当父进程提前退出时，它所有的子进程还在运行，没有一个执行了<code>exit</code>，因为它们的生命周期尚未结束，还在运行中，个个都拥有“全尸”（完整的进程映像）， 这些进程就称为孤儿进程。这时候所有的子进程会被<code>pid</code>为<code>1</code>的<code>init</code>进程收养，<code>init</code>进程会成为这些子进程的新父亲，当子进程退出时会由<code>init</code>负责为其“收尸”。<code>init</code>进程是所有进程的祖先进程，所有进程最初都是通过它派生出来的。</p><p>对系统而言，有了<code>init</code>进程的“收养“，孤儿进程并没有什么危害，<code>init</code>会很好地为其善后，因此并不会额外占用资源，它和普通的进程一样，原理上对系统不会产生不良影响。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>exit</code>是由子进程调用的，表面上功能是使子进程结束运行并传递返回值给内核，本质上是内核在幕后会将进程除<code>PCB</code>以外的所有资源都回收。<code>wait</code>是父进程调用的，表面上功能是使父进程阻塞自己，直到子进程调用<code>exit</code>结束运行，然后获得子进程的返回值，本质上是内核在幕后将子进程的返回值传递给父进程并会唤醒父进程，然后将子进程的<code>PCB</code>回收。</p><h5 id="其它可参考链接"><a href="#其它可参考链接" class="headerlink" title="其它可参考链接"></a>其它可参考链接</h5><p><a href="https://blog.csdn.net/Eunice_fan1207/article/details/81387417" target="_blank" rel="noopener">孤儿进程与僵尸进程产生及其处理_Eunice_fan1207的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_44489823/article/details/103260332" target="_blank" rel="noopener">Linux下僵尸进程的处理回收详解_CSer-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之进程间通信（含内核实现）</title>
      <link href="/tRettVqCkfzWbulf/"/>
      <url>/tRettVqCkfzWbulf/</url>
      
        <content type="html"><![CDATA[<h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><ul><li><p><code>IPC</code>对象</p><p>内核中用于进程间通信的数据结构，全局可见，如消息队列的<code>msg_queue</code>结构体、信号量的<code>sem_array</code>结构体，共享内存的<code>shmid_kernel</code>结构体。类似于普通文件是通过文件名（文件描述符）进行读写操作，通过<code>IPC key</code>和<code>IPC</code>标识符进行<code>IPC</code>对象的读写操作。</p></li><li><p><code>IPC</code>标识符<code>ID</code></p><p>类似于文件描述符<code>fd</code>，可以用一个<code>IPC</code>标识符来引用一个<code>IPC</code>对象，是一个<code>32</code>位整数，是<code>IPC</code>对象的外部名字。返回给用户进程的。</p></li><li><p><code>IPC key</code>（魔数）<br><code>IPC</code>对象的内部名，是一个独一无二的整数，用来确保<code>IPC</code>对象的唯一性。该整数类型为<code>key_t</code>，在<code>sys/types.h</code>中被定义为长整型。<br>类似于普通文件通过文件名<code>open</code>一个文件，获得文件描述符；<code>IPC</code>对象是<code>get</code>函数根据给定的<code>key</code>去创建一个<code>IPC</code>对象，并返回<code>IPC</code>标识符<code>ID</code>。根据新资源是信号量、消息队列还是共享内存，分别调用<code>semget()</code>、<code>msgget()</code>或者<code>shmget()</code>函数创建<code>IPC</code>资源。</p><p>这三个函数的主要目的都是从<code>IPC key</code>（作为第一个参数传递）中导出相应的<code>IPC</code>标识符<code>ID</code>，进程以后就可以使用这个标识符对资源进行访问。如果还没有<code>IPC</code>资源和<code>IPC</code>关键字相关联，就创建一个新的资源。如果一切都顺利，那么函数就返回一个正的<code>IPC</code>标识符，否则，就返回一个错误码。</p></li></ul><a id="more"></a><p>在各个独立进程能够访问<strong><code>IPC</code>对象</strong>之前，<code>IPC</code>对象必须在系统内唯一标识。为此，每种<code>IPC</code>结构在创建时分配了一个<code>IPC key</code>（程序员自由分配）。凡知道这个<strong><code>IPC key</code></strong>的各个程序，都能够通过它得到一个标识符<code>ID</code>，进而访问对应的<code>IPC</code>对象。如果独立的应用程序需要彼此通信，则通常需要将该魔数永久地编译到程序中。</p><p>在访问<code>IPC</code>对象时，操作系统采用了基于文件访问权限的一个权限系统。每个<code>IPC</code>对象都有一个用户<code>ID</code>和一个组<code>ID</code>，依赖于产生<code>IPC</code>对象的程序在何种<code>UID/GID</code>之下运行。读写权限在初始化时分配。类似于普通的文件，这些控制了<code>3</code>种不同用户类别的访问：所有者、组、其他。</p><p><code>IPC</code>在内核中的默认命名空间通过<code>ipc_namespace</code>的静态实例<code>init_ipc_ns</code>实现，每个命名空间都包含如下信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span>* <span class="title">ids</span>[3];</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体中我们更感兴趣的是数组<code>ids</code>。每个数组元素对应于一种<code>IPC</code>机制：共享内存、信号量、消息队列。每个数组项指向一个<code>struct ipc_ids</code>实例，该结构用于跟踪各类别现存的<code>IPC</code>对象。比如，索引<code>0</code>对应的是信号量，其后是消息队列，最后是共享内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipc/util.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> in_use;</span><br><span class="line">    <span class="keyword">unsigned</span> short seq;</span><br><span class="line">    <span class="keyword">unsigned</span> short seq_max;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rw_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">ipcs_idr</span>;</span> <span class="comment">// 通过类似于基数树的方式管理 内核内部 ID 到指向 kern_ipc_perm 的指针的映射</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前几个成员保存了有关<code>IPC</code>对象状态的一般信息。</p><ul><li><code>in_use</code>保存了当前使用中<code>IPC</code>对象的数目。</li><li><code>seq</code>和<code>seq_max</code>用于连续产生用户空间<code>IPC</code>标识符<code>ID</code>。<del>计算方式为<code>ID = seq * M + id</code>。<code>M</code>是固定的宏，值为<code>32768</code>，<code>seq</code>被初始化为<code>0</code>，每次产生一个<code>ID</code>后加<code>1</code>，<code>id</code>为内核内部使用的一个数。</del></li><li><code>rw_mutex</code>是一个内核信号量。它用于实现信号量操作，避免用户空间中的竞态条件。该互斥量有效地保护了包含信号量值的数据结构。</li></ul><p>每个<code>IPC</code>对象都由<code>kern_ipc_perm</code>的一个实例表示，并且都有一个<code>IPC</code>标识符<code>ID</code>，<code>ipcs_idr</code>用于将<code>ID</code>关联到指向对应的<code>kern_ipc_perm</code>实例的指针。</p><p><code>kern_ipc_perm</code>的成员保存了有关<code>IPC</code>对象的所有者和访问权限等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*int id;*/</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">uid_t</span> uid;</span><br><span class="line">    <span class="keyword">gid_t</span> gid;</span><br><span class="line">    <span class="keyword">uid_t</span> cuid;</span><br><span class="line">    <span class="keyword">gid_t</span> cgid;</span><br><span class="line">    <span class="keyword">mode_t</span> mode;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>key</code>保存了用户程序用来标识<code>IPC</code>对象的<code>IPC key</code>，<del><code>id</code>就是前面用来计算标识符<code>ID</code>的公式中的<code>id</code></del>。</li><li><code>uid</code>和<code>gid</code>分别指定了所有者的用户<code>ID</code>和组<code>ID</code>。<code>cuid</code>和<code>cgid</code>保存了产生信号量的进程的用户<code>ID</code>和组<code>ID</code>。</li><li><code>seq</code>是一个序号，在分配<code>IPC</code>对象时使用，和<code>ipc_ids</code>结构中意思相同，为创建该资源是使用的<code>seq</code>。</li><li><code>mode</code>保存了位掩码，指定了所有者、组、其他用户的访问权限。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p><strong>数据传输</strong>：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</p></li><li><p><strong>共享数据</strong>：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</p></li><li><p><strong>通知事件</strong>：一个进程需要向另一个或一组进程发送消息，通知它发生了某种事件（如进程终止时要通知父进程）。</p></li><li><p><strong>资源共享</strong>：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</p></li><li><p><strong>进程控制</strong>：有些进程希望完全控制另一个进程的运行（如<code>Debug</code>进程）模式，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p></li></ul><p>每个进程的用户地址空间都是独立的，但是内核空间是共享的，所以，进程之间要想相互通信都要经过内核。<code>Linux</code>提供的几种进程间通信方式有管道、消息队列、信号量、信号、共享内存和本地套接字</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道只能单向传输数据，如果要想双向传输数据，需要创建两个管道。管道分为命名管道和匿名管道。</p><p><strong>命名管道</strong>的可通过<code>mkfifo</code>命令来创建，并且指定管道名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkfifo mypipe</span></span><br></pre></td></tr></table></figure><p>命名管道是以文件的方式存在于文件系统中，类型为<code>p</code>。进程之间可以通过这个文件进行通信。它是为了解决下面将要介绍的匿名管道只能用于具有亲缘关系的进程间通信的局限性的。</p><p><strong>匿名管道</strong>通过<code>pipe</code>系统调用创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>该函数通过传出参数返回两个文件描述符，<a href="https://mp.weixin.qq.com/s/hLq7Pp8CkJD9B-Xqym50dA" target="_blank" rel="noopener">如果不清楚文件描述符的概念，参考这篇文章</a>。一个是管道读取端描述符<code>fd[0]</code>，一个是管道的写入端描述符<code>fd[1]</code>。匿名管道是只存在内存中的特殊文件，实际上就是内核中的一块缓存。管道传输的数据是无格式的字节流且大小受限。</p><img src="641.jpg" alt="Image" style="zoom:50%;" /><p>通过<code>fork</code>系统调用创建子进程，创建的子进程会复制父进程的文件描述符，这样两个进程就可以通过各自的<code>fd</code>写入和读取同一个管道文件实现跨进程通信了。</p><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的<code>fd[0]</code>，只保留写入的<code>fd[1]</code>；</li><li>子进程关闭写入的<code>fd[1]</code>，只保留读取的<code>fd[0]</code>；</li></ul><img src="dfsgdfg.jpg" alt="dfsgdfg" style="zoom:50%;" /><p>在<code>shell</code>里面执行<code>A | B</code>命令的时候，<code>A</code>进程和<code>B</code>进程都是<code>shell</code>创建出来的子进程，<code>A</code>和<code>B</code>之间不存在父子关系，它俩的父进程都是<code>shell</code>。</p><img src="asdfsd.jpg" alt="asdfsd" style="zoom:50%;" /><p>当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p><p>在<code>Linux</code>中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的<code>file</code>结构和<code>VFS</code>的索引节点<code>inode</code>。通过将两个<code>file</code>结构指向同一个临时的<code>VFS</code>索引节点，而这个<code>VFS</code>索引节点又指向一个物理页面而实现的。</p><img src="image-20210412111846194.png" alt="image-20210412111846194" style="zoom: 50%;" /><p>管道是个环形缓冲区，对环形缓冲区的维护，主要是协调好数据读写的两个指针，以及生产者、消费者的休眠时机。环形缓冲区中一个指针用于读数据，另一个用于写数据。当缓冲区已满时，生产者要睡眠，并在睡眠前唤醒消费者，当缓冲区为空时，消费者要睡眠，并在睡眠前唤醒生产者。当缓冲区满或空时，使一方休眠，这是保证数据不丢失的方法。管道其实就是典型的生产者和消费者问题。</p><p>管道写函数通过将字节复制到<code>VFS</code>索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，内核必须利用一定的机制同步对管道的访问，为此，内核使用了锁、等待队列和信号。</p><p>当写进程向管道中写入时，它利用标准的库函数<code>write()</code>，系统根据库函数传递的文件描述符，可找到该文件的<code>file</code>结构。<code>file</code>结构中指定了用来进行管道专门写操作的函数<code>pipe_write</code>地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查<code>VFS</code>索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p><ul><li>内存中有足够的空间可容纳所有要写入的数据；</li><li>内存没有被读程序锁定。</li></ul><p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在<code>VFS</code>索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p><p>管道的读取过程和写入过程类似，通过read系统调用转调用管道专用读操作函数<code>pipe_read</code>。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。</p><p><strong>可以说管道适用于具有亲缘关系的进程间通信</strong>。无论是命名管道还是匿名管道，进程写入的数据都是缓存在内核的内存缓冲区中，读取的时候自然也是从内核的内存缓冲区中读取，因此需要在用户态和内核态之间转换。<strong>因此，管道的通信方式是低效率的，不适合进程间频繁地、大块地交换数据。</strong></p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p><strong>消息队列</strong>的通信模式比如说，<code>A</code>进程要给<code>B</code>进程发送消息，<code>A</code>进程把数据放在对应的消息队列后就可以正常返回了，<code>B</code>进程需要的时候再去读取数据就可以了。同理，<code>B</code>进程要给<code>A</code>进程发送消息也是如此。</p><p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期根随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。发送者和接收者通过消息队列通信时，无需同时运行，例如，发送进程可以打开一个队列，写入消息，然后结束工作，接收进程在发送者结束之后启动，仍然可以访问队列并（根据消息编号）获取消息。中间的一段时间内消息由内核维护。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，<strong>每个消息都至少分配一个内存页</strong>，同时所有队列所包含的全部消息体的总长度也是有上限。在<code>Linux</code>内核中，会有两个宏定义<code>MSGMAX</code>和<code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时或者另一进程读取内核中的消息数据时，会发生从内核缓冲区拷贝数据到用户缓冲区的过程。</p><p><strong>消息队列的实现</strong>：</p><p>消息队列使用名为<code>msg_queue</code>的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> q_stime; <span class="comment">// 上一次调用 sgsnd 送消息的时</span></span><br><span class="line">    <span class="keyword">time_t</span> q_rtime; <span class="comment">// 上一次调用 msgrcv 接收消息的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> q_ctime; <span class="comment">// 上一次修改的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes; <span class="comment">/*队列上当前字节数目*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum; <span class="comment">/*队列中的消息数目*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes; <span class="comment">/*队列上最大字节数目*/</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lspid; <span class="comment">/*上一次调用 msgsnd 的 pid */</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lrpid; <span class="comment">/*上一次接收消息的 pid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span> <span class="comment">// 消息体链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span> <span class="comment">// 睡眠的接收者链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span> <span class="comment">// 睡眠的发送者链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>q_messages</code>中的各个消息都封装在<code>msg_msg</code>结构体中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type; <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="keyword">int</span> m_ts; <span class="comment">/*消息正文长度*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span>* <span class="title">next</span>;</span><span class="comment">// 如果保存的消息超过一个内存页的长度</span></span><br><span class="line">    <span class="comment">/*接下来是实际的消息*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/*接下来是消息的下一部分*/</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><img src="image-20210412120217377.png" alt="image-20210412120217377" style="zoom: 50%;" /><p>消息正文紧接着该数据结构的实例之后存储。使用next，可以使消息分布到任意数目的页上。在通过消息队列通信时，发送进程和接收进程都可以进入睡眠：如果消息队列已经达到最大容量，则发送者在试图写入消息时会进入睡眠；如果队列中没有消息，那么接收者在试图获取消息时会进入睡眠。</p><p>睡眠的发送者放置在<code>msg_queue</code>的<code>q_senders</code>链表中，睡眠的接收者放置在<code>q_receivers</code>链表中，链表元素使用下列数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_sender</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">tsk</span>;</span> <span class="comment">// 指向休眠进程的进程描述符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_receiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">r_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">r_tsk</span>;</span> <span class="comment">// 指向休眠进程的进程描述符</span></span><br><span class="line">    <span class="keyword">int</span> r_mode;</span><br><span class="line">    <span class="keyword">long</span> r_msgtype;</span><br><span class="line">    <span class="keyword">long</span> r_maxsize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">volatile</span> <span class="title">r_msg</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="image-20210412120755697.png" alt="image-20210412120755697" style="zoom: 50%;" /><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>操作系统内存管理采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程<code>A</code>和进程<code>B</code>的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p>但是共享内存通信方式带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><img src="3333rtewrfg.jpg" alt="Image" style="zoom: 50%;" /><p><strong>共享内存的实现</strong>：</p><img src="image-20210412121016593.png" alt="image-20210412121016593" style="zoom:50%;" /><p>同样，在<code>smd_ids</code>全局变量的<code>entries</code>数组中保存了<code>kern_ipc_perm</code>和<code>shmid_kernel</code>的组合，以便管理<code>IPC</code>对象的访问权限。对每个共享内存对象都创建一个伪文件，通过<code>shm_file</code>连接到<code>shmid_kernel</code>的实例。内核使用<code>shm_file-&gt;f_mapping</code>指针访问地址空间对象（<code>struct address_space</code>），用于创建匿名映射。还需要设置所涉及各进程的页表，使得各个进程都能够访问与该<code>IPC</code>对象相关的内存区域。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，程序对其访问都是原子操作，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是<strong><code>P</code>操作</strong>，这个操作会把信号量减去<code>-1</code>，相减后如果信号量<code>&lt; 0</code>，则表明资源已被占用，进程需阻塞等待；相减后如果信号量<code>&gt;= 0</code>，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是<strong><code>V</code>操作</strong>，这个操作会把信号量加上<code>1</code>，相加后如果信号量<code>&lt;= 0</code>，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量<code>&gt; 0</code>，则表明当前没有阻塞中的进程；</li></ul><p><code>P</code>操作是用在进入共享资源之前，<code>V</code>操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p>信号量初始化为<code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。信号初始化为<code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程<code>A</code>应在进程<code>B</code>之前执行。</p><p><strong>信号量的实现</strong>：</p><p><code>sem_queue</code>是一个数据结构，用于将信号量与睡眠进程关联起来，该进程想要执行信号量操作，但目前不允许执行。换句话说，信号量的待决操作列表中，每一项都是该数据结构的实例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>* <span class="title">next</span>;</span> <span class="comment">/*队列中下一项*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>* <span class="title">prev</span>;</span> <span class="comment">/*队列中的前一项，对于第一项有 *(q-&gt;prev) == q*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">sleeper</span>;</span> <span class="comment">/*睡眠的进程*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span>* <span class="title">undo</span>;</span> <span class="comment">/*用于撤销的结构*/</span></span><br><span class="line">    <span class="keyword">int</span> pid; <span class="comment">/*请求信号量操作的进程 ID*/</span></span><br><span class="line">    <span class="keyword">int</span> status; <span class="comment">/*操作的完成状态*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span>* <span class="title">sma</span> ;</span><span class="comment">/*操作的信号量数组*/</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">/*内部信号量 ID*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>* <span class="title">sops</span>;</span> <span class="comment">/*待决操作数组*/</span></span><br><span class="line">    <span class="keyword">int</span> nsops; <span class="comment">/*操作数目*/</span></span><br><span class="line">    <span class="keyword">int</span> alter; <span class="comment">/*操作是否改变了数组?*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对每个信号量，都有一个队列管理与信号量相关的所有睡眠进程。该队列并未使用内核的标准设施实现（即<code>struct list_head</code>），而是通过<code>next</code>和<code>prev</code>指针手工实现的。</p><ul><li><code>sleeper</code>是一个指针，指向等待执行信号量操作进程的<code>task_struct</code>实例。</li><li><code>pid</code>指定了等待进程的<code>PID</code>。</li><li><code>id</code>保存了标识该信号量的<code>ID</code>。</li><li><code>sops</code>是一个指针，指向保存待决信号量操作的数组。操作数目（即，数组的长度）在<code>nsops</code>中定义。</li><li><code>alter</code>表明操作是否修改信号量的值（例如，状态查询不改变值）。</li><li><code>sma</code>保存了一个指针，指向用于管理信号量状态的数据结构的实例。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">/*权限，参见ipc.h*/</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_otime; <span class="comment">/*最后一次信号量操作的时间*/</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_ctime; <span class="comment">/*最后一次修改的时间*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span> <span class="comment">/*指向数组中第一个信号量的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span> <span class="comment">/*需要处理的待决操作*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>* <span class="title">sem_pending_last</span>;</span> <span class="comment">/*上一个待决操作*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span> <span class="comment">/*该数组上的撤销请求*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sem_nsems; <span class="comment">/*数组中信号量的数目*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>系统中的每个信号量集合，都对应于该数据结构的一个实例。该实例用于管理集合中的所有信号量（这个信号量集合指的是，每个进程操作信号量时，信号量都有一个值，将这些值组合在这个集合中，由下面要介绍的<code>sem_base</code>指向的数组表示）。</p><ul><li><p>信号量访问权限保存在我们熟悉的<code>kern_ipc_perm</code>类型的<code>sem_perm</code>成员中。</p></li><li><p><code>sem_nsems</code>指定了一个用户信号量集合中信号量的数目。</p></li><li><p><code>sem_base</code>是一个数组，每个数组项描述了集合中的一个信号量。其中保存了当前的信号量值和上一次访问它的进程的<code>PID</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> semval; <span class="comment">// 当前值</span></span><br><span class="line">    <span class="keyword">int</span> sempid; <span class="comment">// 上一次操作进程的 pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>sem_otime</code>指定了上一次访问信号量的时间。<code>sem_ctime</code>指定了上次修改信号量值的时间。</p></li><li><p><code>sem_pending</code>指向待决信号量操作的链表。该链表由<code>sem_queue</code>实例组成。<code>sem_pending_last</code>用于快速访问该链表的最后一个元素，而<code>sem_pending</code>指向链表的起始。</p></li></ul><img src="image-20210412170936487.png" alt="image-20210412170936487" style="zoom: 80%;" /><p>从当前命名空间获得<code>sem_ids</code>实例开始，内核通过<code>ipcs_idr</code>找到<code>ID</code>到指针的映射，在其中查找所需的<code>kern_ipc_perm</code>实例。<code>kern_ipc_perm</code>项可以转换为<code>sem_array</code>的实例。信号量的当前状态需要通过与另外两个结构的联系获取。</p><ul><li>待决操作通过<code>sem_queue</code>实例的链表管理。等待操作执行的睡眠进程，也可以通过该链表确定。</li><li><code>struct sem</code>实例的数组用于保存集合中各个信号量的值。</li></ul><p><code>kern_ipc_perm</code>是用来管理<code>IPC</code>对象的数据结构的第一个成员，不止对信号量是这样，消息队列和共享内存对象也是如此。这使得内核可以使用同样的代码检查所有<code>3</code>种对象的访问权限。放在第一个位置还方便转换为<code>sem_array</code>。</p><p>每个<code>sem_queue</code>成员包含了一个指针<code>sops</code>，指向<code>sembuf</code>实例的数组，<code>sembuf</code>详细描述了在信号量上将要执行的操作。使用<code>sembuf</code>实例的数组，可以使用一个<code>semctl</code>调用，用于在信号量集合的各个信号量上执行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sem_num; <span class="comment">// 信号量在数组中的索引</span></span><br><span class="line">    short sem_op; <span class="comment">// 信号量操作</span></span><br><span class="line">    short semflg; <span class="comment">// 操作标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它不仅保存了信号量在信号量集合<code>struct sem[]</code>中的索引（<code>sem_num</code>），还有所要进行的操作（<code>sem_op</code>）和一些操作标志（<code>sem_flg</code>）。</p><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong>在<code>Linux</code>操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过<code>kill -l</code>命令，查看所有的信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>运行在<code>shell</code>终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li><code>Ctrl + C</code>产生<code>SIGINT</code>信号，表示终止该进程；</li><li><code>Ctrl + Z</code>产生<code>SIGTSTP</code>信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过<code>kill</code>命令的方式给进程发送信号，但前提需要知道运行中的进程<code>PID</code>号，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kill <span class="number">-9</span> <span class="number">1050</span></span><br></pre></td></tr></table></figure><p>表示给<code>PID</code>为<code>1050</code>的进程发送<code>SIGKILL</code>信号，用来立即结束该进程。</p><p>所以，信号事件的来源主要有硬件来源（如键盘<code>Cltr + C</code>）和软件来源（如<code>kill</code>命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><ol><li><p><strong>执行默认操作</strong>。<code>Linux</code>对每种信号都规定了默认操作，例如，上面列表中的<code>SIGTERM</code>信号，就是终止进程的意思。<code>Core</code>的意思是<code>Core Dump</code>，也即终止进程后，通过<code>Core Dump</code>将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p></li><li><p><strong>捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p></li><li><p><strong>忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即<code>SIGKILL</code>和<code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p></li></ol><h4 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h4><p>我们先来看看创建<code>socket</code>的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocal)</span></span></span><br></pre></td></tr></table></figure><p>三个参数分别代表：</p><ul><li><code>domain</code>参数用来指定协议族，比如<code>AF_INET</code>用于<code>IPV4</code>、<code>AF_INET6</code>用于<code>IPV6</code>、<code>AF_LOCAL/AF_UNIX</code>用于本机；</li><li><code>type</code>参数用来指定通信特性，比如<code>SOCK_STREAM</code>表示的是字节流，对应<code>TCP</code>、<code>SOCK_DGRAM</code>表示的是数据报，对应<code>UDP</code>、<code>SOCK_RAW</code>表示的是原始套接字；</li><li><code>protocal</code>参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，<code>protocol</code>目前一般写成<code>0</code>即可；</li></ul><p>根据创建<code>socket</code>类型的不同，通信的方式也就不同：</p><ul><li>实现<code>TCP</code>字节流通信：<code>socket</code>类型是<code>AF_INET</code>和<code>SOCK_STREAM</code>；</li><li>实现<code>UDP</code>数据报通信：<code>socket</code>类型是<code>AF_INET</code>和<code>SOCK_DGRAM</code>；</li><li>实现<strong>本地进程间通信</strong>：「本地字节流<code>socket</code>」类型是<code>AF_LOCAL</code>和<code>SOCK_STREAM</code>，「本地数据报<code>socket</code>」类型是<code>AF_LOCAL</code>和<code>SOCK_DGRAM</code>。另外，<code>AF_UNIX</code>和<code>AF_LOCAL</code>是等价的。</li></ul><p>本地字节流<code>socket</code>和本地数据报<code>socket</code>在<code>bind</code>的时候，不像<code>TCP</code>和<code>UDP</code>要绑定<code>IP</code>地址和端口，而是<strong>绑定一个本地文件</strong>，这也是它们之间的最大区别。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之队列和栈</title>
      <link href="/fhQPnKWa9qDDelG3/"/>
      <url>/fhQPnKWa9qDDelG3/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>5</code>部分——队列和栈。这里把有代表性的题目发出来，共计<code>22</code>道。主要涉及<code>BFS</code>算法、<code>DFS</code>算法、单调栈以及单调队列技巧的应用。</p><p><code>leetcode</code>刷题系列其它文章组织如下：</p><p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p><p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p><p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p><a id="more"></a><h5 id="1660-Correct-a-Binary-Tree"><a href="#1660-Correct-a-Binary-Tree" class="headerlink" title="1660. Correct a Binary Tree"></a><a href="https://leetcode.com/problems/correct-a-binary-tree/" target="_blank" rel="noopener">1660. Correct a Binary Tree</a></h5><blockquote><p>你有一棵二叉树，这棵二叉树有个小问题，其中有且只有一个无效节点，它的右子节点错误地指向了与其在同一层且在其右侧的一个其他节点。</p><p>给定一棵这样的问题二叉树的根节点<code>root</code>，将该无效节点及其所有子节点移除（不移除被错误指向的节点），然后返回新二叉树的根结点。</p><p><strong>示例:</strong></p><img src="ex2v3.png" alt="img" style="zoom: 33%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode &#x3D; 7, toNode &#x3D; 4</span><br><span class="line">输出: [8,3,1,null,null,9,4,null,null,5,6]</span><br><span class="line">解释: 值为 7 的节点是无效的，所以移除这个节点及其子节点 2。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助层序遍历的思想</span></span><br><span class="line"><span class="comment">// 如果遍历到某一个节点, 发现其右孩子已经访问过了</span></span><br><span class="line"><span class="comment">// 就说明当前节点就是无效节点</span></span><br><span class="line"><span class="comment">// 但此时需要记录已经访问过的节点</span></span><br><span class="line"><span class="comment">// 如果要把此无效节点删除, 还要知道当前节点的父节点</span></span><br><span class="line"><span class="comment">// 因此, 使用一个哈希表记录所有访问过的节点以及这些节点的父节点</span></span><br><span class="line"><span class="comment">// 哈希表的映射有点特殊, 因为我们想达到这样的效果 mapping[node] == node's parent</span></span><br><span class="line"><span class="comment">// 因此, 每次访问一个节点 node 时</span></span><br><span class="line"><span class="comment">// 以 node 为值, 分别以其左右孩子(如果存在的话)为键加入哈希表</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">correctBinaryTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 队列仅仅用于完成层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="comment">// 当前节点和其父亲的映射的哈希表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt; mapping;</span><br><span class="line">    <span class="keyword">if</span>(root) q.push(root);</span><br><span class="line">    <span class="comment">// 标记是否找到了无效节点, 可用于提前结束遍历</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty() &amp;&amp; !flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 以上都是标准的层序遍历迭代实现的固定框架</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前节点的右孩子已经遍历过了</span></span><br><span class="line">            <span class="comment">// 说明找到无效节点</span></span><br><span class="line">            <span class="keyword">if</span>(mapping.count(node-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mapping[node]-&gt;left == node)</span><br><span class="line">                    <span class="comment">// 如果当前节点是其父节点的左孩子</span></span><br><span class="line">                    mapping[node]-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 否则是右孩子</span></span><br><span class="line">                    mapping[node]-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 否则继续遍历就是了</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) </span><br><span class="line">                &#123;</span><br><span class="line">                    mapping[node-&gt;left] = node;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    mapping[node-&gt;right] = node;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="394-Decode-String"><a href="#394-Decode-String" class="headerlink" title="394. Decode String"></a><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener">394. Decode String</a></h5><blockquote><p>  给定一个经过编码的字符串，返回它解码后的字符串。</p><p>  编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的<code>encoded_string</code>正好重复<code>k</code>次。注意<code>k</code>保证为正整数。</p><p>  你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>  此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数<code>k</code> ，例如不会出现像<code>3a</code>或<code>2[4]</code>的输入。</p><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.size() &lt;= 30</code></li><li><code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.</li><li><code>s</code> is guaranteed to be <strong>a valid</strong> input.</li><li>All the integers in <code>s</code> are in the range <code>[1, 300]</code>.</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">Output: &quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeatString</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = str;</span><br><span class="line">    <span class="keyword">while</span>(--count) str = s + str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; isdigits&#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">']'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> substr;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() != <span class="string">"["</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                substr = s.top() + substr;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.pop(); <span class="comment">// pop 掉相匹配的那个 '['</span></span><br><span class="line">            <span class="comment">// 获取 [] 前面的那个数字, 注意可能是多位数</span></span><br><span class="line">            <span class="built_in">string</span> numstr;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; isdigits.count(s.top()))</span><br><span class="line">            &#123;</span><br><span class="line">                numstr = s.top() + numstr;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 [] 中的字串重复指定次</span></span><br><span class="line">            repeatString(substr, stoi(numstr));</span><br><span class="line">            <span class="comment">// 新串再次入栈</span></span><br><span class="line">            s.push(substr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> s.push(<span class="built_in">string</span>(<span class="number">1</span>, c));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这时从栈底到栈顶的所有串连在一起其实就是答案了</span></span><br><span class="line">    <span class="comment">// 但是要转为 string 返回</span></span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        res = s.top() + res;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="752-Open-the-Lock"><a href="#752-Open-the-Lock" class="headerlink" title="752. Open the Lock"></a><a href="https://leetcode.com/problems/open-the-lock/" target="_blank" rel="noopener">752. Open the Lock</a></h5><blockquote><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有<code>10</code>个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code>。每个拨轮可以自由旋转：例如把<code>&#39;9&#39;</code>变为<code>&#39;0&#39;</code>，<code>&#39;0&#39;</code>变为<code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为<code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p><p>列表<code>deadends</code>包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串<code>target</code>代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回<code>-1</code>。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target &#x3D; &quot;0202&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.</span><br><span class="line">Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,</span><br><span class="line">because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;8888&quot;], target &#x3D; &quot;0009&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宽度优先遍历 BFS 通常用来解决最小(距离)、最短(路径)、最少(步数)等问题</span></span><br><span class="line"><span class="comment">// 先给出 BFS 算法框架</span></span><br><span class="line"><span class="comment">// 计算从 [开始状态] 到 [目标状态]的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(STATE startState, STATE targetState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;STATE&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;STATE&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.push(startState); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.insert(startState);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有状态分别向其所有相邻状态转换 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            STATE curState = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 下面代码是需要你根据实际问题的逻辑做调整的</span></span><br><span class="line">            <span class="comment">/***************************************/</span></span><br><span class="line">            <span class="comment">/* 划重点: 这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (curState is targetState) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的所有相邻状态加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (STATE state : all adjacent states of curState )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (state <span class="keyword">not</span> in visited)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(state);</span><br><span class="line">                    visited.insert(state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***************************************/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点: 更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于我们这题打开密码锁的问题</span></span><br><span class="line"><span class="comment">// 就是穷举所有的密码组合, 直到到达目标密码</span></span><br><span class="line"><span class="comment">// 密码锁初始值(开始状态)为 "0000", 一共四个位置, 每个位置可以向上或向下拨动, 也就是有 8 个相邻状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; deads;</span><br><span class="line">    <span class="comment">// 将死亡密码加入哈希集合</span></span><br><span class="line">    <span class="comment">// 其实这里是可以直接用 visited, 就是说直接把死亡密码看作已经被访问过了, 一样的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : deadends)</span><br><span class="line">        deads.insert(elem);</span><br><span class="line"></span><br><span class="line">    q.push(<span class="string">"0000"</span>);</span><br><span class="line">    visited.insert(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> qSize = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从队列中取出一个状态访问</span></span><br><span class="line">            <span class="built_in">string</span> curLock = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 如果当前状态在死亡状态里面</span></span><br><span class="line">            <span class="comment">// 说明我们不能够到达这个状态</span></span><br><span class="line">            <span class="comment">// 因此也就不可能从这个状态向其它相邻状态转换</span></span><br><span class="line">            <span class="comment">// 继续取出队列中的下一个状态</span></span><br><span class="line">            <span class="keyword">if</span>(deads.count(curLock)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果当前状态是目标状态了</span></span><br><span class="line">            <span class="keyword">if</span>(curLock == target) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 否则, 向相邻的 8 个状态转换</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将第 j 个字符向上拨动</span></span><br><span class="line">                <span class="built_in">string</span> upRotate = rotate(curLock, j, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!visited.count(upRotate))</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(upRotate);</span><br><span class="line">                    visited.insert(upRotate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将第 j 个字符向下拨动</span></span><br><span class="line">                <span class="built_in">string</span> downRotate = rotate(curLock, j, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(!visited.count(downRotate))</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(downRotate);</span><br><span class="line">                    visited.insert(downRotate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// direction 为 1 向上拨动, 为 0 则向下拨动</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">rotate</span><span class="params">(<span class="built_in">string</span> theLock, <span class="keyword">int</span> position, <span class="keyword">bool</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(direction)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(theLock[position] == <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            theLock[position] = <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">return</span> theLock;</span><br><span class="line">        &#125;</span><br><span class="line">        theLock[position]++;</span><br><span class="line">        <span class="keyword">return</span> theLock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(theLock[position] == <span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            theLock[position] = <span class="string">'9'</span>;</span><br><span class="line">            <span class="keyword">return</span> theLock;</span><br><span class="line">        &#125;</span><br><span class="line">        theLock[position]--;</span><br><span class="line">        <span class="keyword">return</span> theLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. Sudoku Solver</a></h5><blockquote><p>编写一个程序，通过填充空格来解决数独问题。</p><p>一个数独的解法需遵循如下规则：</p><ol><li>数字<code>1-9</code>在每一行只能出现一次。</li><li>数字<code>1-9</code>在每一列只能出现一次。</li><li>数字<code>1-9</code>在每一个以粗实线分隔的<code>3x3</code>宫内只能出现一次。空白格用<code>&#39;.&#39;</code>表示。</li></ol><table><thead><tr><th align="center">一个数独</th><th align="center">红色为答案</th></tr></thead><tbody><tr><td align="center"><img src="250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></td><td align="center"><img src="250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是深度优先搜索算法应用的典型题目</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前行填写完了, 就到下一行</span></span><br><span class="line">    <span class="keyword">if</span>(col == board.size()) <span class="keyword">return</span> dfs(board, row + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果最后一行也填完了, 就说明找到了数独的一个解</span></span><br><span class="line">    <span class="keyword">if</span>(row == board.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果当前格子中已经有数了就跳过这个格子</span></span><br><span class="line">    <span class="keyword">if</span>(board[row][col] != <span class="string">'.'</span>) <span class="keyword">return</span> dfs(board, row, col + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 针对当前格子</span></span><br><span class="line">    <span class="comment">// 从数字 1 到 9 依次尝试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前格子放置这个数字不符合那 3 条规则就跳过</span></span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, row, col, c)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = c;</span><br><span class="line">        <span class="comment">// 这里的 if 语句可以在找到一组解的时候立即返回</span></span><br><span class="line">        <span class="comment">// 不至于找到所有可能的解</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(board, row, col + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前行不能有数字重复</span></span><br><span class="line">        <span class="keyword">if</span>(board[row][i] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当前列不能有数字重复</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][col] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当前格子所在的九宫格不能有数字重复</span></span><br><span class="line">        <span class="comment">// 这特么还真不好写, 看不懂就背下吧</span></span><br><span class="line">        <span class="keyword">if</span>(board[(row / <span class="number">3</span>) * <span class="number">3</span> + i / <span class="number">3</span>][(col / <span class="number">3</span>) * <span class="number">3</span> + i % <span class="number">3</span>] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">279. Perfect Squares</a></h5><blockquote><p>给定正整数<code>n</code>，找到若干个完全平方数（比如<code>1, 4, 9, 16, ...</code>）使得它们的和等于<code>n</code>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数<code>n</code> ，返回和为<code>n</code>的完全平方数的最少数量。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 12</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DP 递推式: numSquares(n) = min(numSquares(n - k)) + 1</span></span><br><span class="line"><span class="comment">// 有点 找零钱 那题的那味儿</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; squares;</span><br><span class="line">    <span class="comment">// 先计算出所有符合条件的完全平方数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)</span><br><span class="line">        squares.push_back(i * i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> square : squares)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - square &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            dp[i] = min(dp[i], dp[i - square]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 穷举所有完全平方数相加的组合, 直到一组的和等于目标数</span></span><br><span class="line"><span class="comment">// 因为要找用到的 [最少的] 完全平方数, 所以使用 BFS</span></span><br><span class="line"><span class="comment">// 第 1 轮: 搜索所有 1 位数字判断是否满足</span></span><br><span class="line"><span class="comment">// 将 0 + (1, 2, 4, 9, ...) 的数字依次放进队列中</span></span><br><span class="line"><span class="comment">// 第 2 轮: 搜索所有 2 位数字的和并判断是否满足</span></span><br><span class="line"><span class="comment">// 将 1 + (1, 2, 4, 9, ...) 的数字依次放进队列中</span></span><br><span class="line"><span class="comment">// 将 2 + (1, 2, 4, 0, ...) 的数字依次放进队列中</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 第 3 轮: 搜索所有 3 位数字和并判断是否满足</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 你会发现我们穷举的时候遇到了大量同样的数字组合, 因此使用一个哈希集合来跳过它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur == n) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 直到完全平方数大于目标数</span></span><br><span class="line">            <span class="comment">// 这里的循环相当于是找当前值的所有可能的邻居</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = cur + j * j;</span><br><span class="line">                <span class="comment">// 如果完全平方数的和还小于目标数</span></span><br><span class="line">                <span class="comment">// 或者这个和没有被访问, 才加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(temp &lt;= n &amp;&amp; !visited.count(temp))</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp);</span><br><span class="line">                    visited.insert(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">155. Min Stack</a></h5><blockquote><p>  设计一个支持<code>push</code>，<code>pop</code>，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p><p>  <code>push(x)</code> —— 将元素<code>x</code>推入栈中。<br>  <code>pop()</code> —— 删除栈顶的元素。<br>  <code>top()</code> —— 获取栈顶元素。<br>  <code>getMin()</code> —— 检索栈中的最小元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() : _minVal(INT_MIN) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; _minVal || _data.empty()) _minVal = x;</span><br><span class="line">        _data.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(_data.back() == _minVal)</span><br><span class="line">            _minVal = *min_element(_data.begin(), _data.end() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        _data.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _minVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">    <span class="keyword">int</span> _minVal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a><a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. Daily Temperatures</a></h5><blockquote><p>  请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用<code>0</code>来代替。</p><p>  例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题本质上就是找到当前元素的下一个比它大的元素</span></span><br><span class="line"><span class="comment">// 然后两者的索引相减即可</span></span><br><span class="line"><span class="comment">// 像这样和下一个更大元素有关的问题都需要使用一种单调栈的技巧</span></span><br><span class="line"><span class="comment">// 就是说维护一个栈, 使其中的元素保持单调的次序</span></span><br><span class="line"><span class="comment">// 下面的代码就是单调栈的模板</span></span><br><span class="line"><span class="comment">// 这里维护着从栈底到栈顶递减的次序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 倒着遍历入栈, 因此也就是正着出栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = T.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素比栈首元素大</span></span><br><span class="line">        <span class="comment">// 那么栈的首元素出栈让出位子</span></span><br><span class="line">        <span class="comment">// 直到首元素比当前元素大了才把当前元素压入栈</span></span><br><span class="line">        <span class="comment">// 注意这里栈内放的是索引</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; T[s.top()] &lt;= T[i])</span><br><span class="line">            s.pop();</span><br><span class="line">        <span class="comment">// 更新数组中第 i 个元素的下一个更大的元素</span></span><br><span class="line">        <span class="comment">// 就在栈首</span></span><br><span class="line">        res[i] = s.empty() ? <span class="number">0</span> : (s.top() - i);</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="496-Next-Greater-Element-I"><a href="#496-Next-Greater-Element-I" class="headerlink" title="496. Next Greater Element I"></a><a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. Next Greater Element I</a></h5><blockquote><p>  给你两个没有重复元素的数组<code>nums1</code>和<code>nums2</code>，其中<code>nums1</code>是<code>nums2</code>的子集。</p><p>  请你找出<code>nums1</code>中每个元素在<code>nums2</code>中的下一个比其大的值。</p><p>  <code>nums1</code>中数字<code>x</code>的下一个更大元素是指<code>x</code>在<code>nums2</code>中对应位置的右边的第一个比<code>x</code>大的元素。如果不存在，对应位置输出<code>-1</code> 。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2]</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接套用单调栈的模板</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里用哈希表来存放答案</span></span><br><span class="line">    <span class="comment">// 记录着 nums2 数组中的每个元素与其下一个更大的元素之间的映射</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums2.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt;= nums2[i])</span><br><span class="line">            s.pop();</span><br><span class="line">        mapping[nums2[i]] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line">    <span class="comment">// 直接从哈希表中获取 nums1 数组中元素的下一个更大元素即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">        res[i] = mapping[nums1[i]];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="503-Next-Greater-Element-II"><a href="#503-Next-Greater-Element-II" class="headerlink" title="503. Next Greater Element II"></a><a href="https://leetcode.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. Next Greater Element II</a></h5><blockquote><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字<code>x</code>的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出<code>-1</code>。</p><img src="2-1616932759606.jpeg" alt="2" style="zoom: 33%;" /><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: [1,2,1]</span><br><span class="line">&gt;Output: [2,-1,2]</span><br><span class="line">&gt;Explanation: The first 1&#39;s next greater number is 2; The number 2 can&#39;t find next greater number; The second 1&#39;s next greater number needs to search circularly, which is also 2.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里和 I 题的区别是, 数组可以循环</span></span><br><span class="line"><span class="comment">// 也就是说从当前位置一直向后看去, 直到找到下一个更大元素为止</span></span><br><span class="line"><span class="comment">// 如果找到了尾元素则从首元素开始继续找</span></span><br><span class="line"><span class="comment">// 可以看作在原始数组后面又接了一段原始数组(见上图)</span></span><br><span class="line"><span class="comment">// 你当然可以申请一段两倍的数组空间来这放元素</span></span><br><span class="line"><span class="comment">// 但是, 下面来学习一个循环遍历数组的技巧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先直接套用单调栈的模板</span></span><br><span class="line"><span class="comment">// 其中改动的地方就是能够循环遍历数组的技巧</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])</span><br><span class="line">            s.pop();</span><br><span class="line">        res[i % n] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="556-Next-Greater-Element-III"><a href="#556-Next-Greater-Element-III" class="headerlink" title="556. Next Greater Element III"></a><a href="https://leetcode.com/problems/next-greater-element-iii/" target="_blank" rel="noopener">556. Next Greater Element III</a></h5><blockquote><p>  给你一个正整数<code>n</code>，请你找出符合条件的最小整数，其由重新排列<code>n</code>中存在的每位数字组成，并且其值大于<code>n</code>。如果不存在这样的正整数，则返回<code>-1</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 320241</span><br><span class="line">Output: 320412</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 321</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要想到的是先把数字转成字符串, 方便处理</span></span><br><span class="line"><span class="comment">// 然后再试想一下, 影响数值前后发生大小变化的决定因素什么</span></span><br><span class="line"><span class="comment">// 不知道你脑子里有没有蹦出 [逆序对] 三个字</span></span><br><span class="line"><span class="comment">// 注意我这里的 [逆序对] 是指, 原本降序排列的数, 其中相邻的一对数字是升序</span></span><br><span class="line"><span class="comment">// 如果你想到了这个, 那问题就很简单了</span></span><br><span class="line"><span class="comment">// 对于数字其中的一个逆序对</span></span><br><span class="line"><span class="comment">// 如果你把这两个数字交换, 值是不是就变大了？</span></span><br><span class="line"><span class="comment">// 但这题要找变大之后的数中最小的数</span></span><br><span class="line"><span class="comment">// 那就只需要对最后边的一个逆序对操作嘛</span></span><br><span class="line"><span class="comment">// 但是还是不能简单的将逆序对的数字交换</span></span><br><span class="line"><span class="comment">// 需要将逆序对的前一个元素和它后面的最后一个比它大的数交换才行</span></span><br><span class="line"><span class="comment">// 交换完之后还要将逆序对后面的所有元素进行一次反转</span></span><br><span class="line"><span class="comment">// 因为此时后面的那些元素必定是降序排列的, 反转之后值会进一步变小</span></span><br><span class="line"><span class="comment">// 说起来太抽象了, 下面直接看代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(to_string(n))</span></span>;</span><br><span class="line">    <span class="comment">// 从后往前走</span></span><br><span class="line">    <span class="comment">// 定位到第一个逆序对, pivot 指向逆序对的第一个元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = s.size() - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(; pivot &gt;= <span class="number">0</span>; pivot--)</span><br><span class="line">        <span class="keyword">if</span>(s[pivot] &lt; s[pivot + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 如果没有逆序对, 说明不可能组合成比原来大的数</span></span><br><span class="line">    <span class="keyword">if</span>(pivot == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 从后往前走, 定位到第一个比 pivot 指向元素大的元素</span></span><br><span class="line">    <span class="keyword">int</span> larger = s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; larger &gt; pivot; larger--)</span><br><span class="line">        <span class="keyword">if</span>(s[pivot] &lt; s[larger]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 交换二者</span></span><br><span class="line">    swap(s[pivot], s[larger]);</span><br><span class="line">    <span class="comment">// 这时候 pivot 之后的所有元素肯定是降序排列的</span></span><br><span class="line">    <span class="comment">// 反转它们, 以求数值最小</span></span><br><span class="line">    reverse(s.begin() + pivot + <span class="number">1</span>, s.end());</span><br><span class="line">    <span class="comment">// 如果这个数比 int 类型数值范围, 就不符合题目要求了</span></span><br><span class="line">    <span class="keyword">if</span>(stol(s) &gt; INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> stoi(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="133-Clone-Graph"><a href="#133-Clone-Graph" class="headerlink" title="133. Clone Graph"></a><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">133. Clone Graph</a></h5><blockquote><p>  给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。</p><p>  图中的每个节点都包含它的值<code>val</code>（<code>int</code>）和其邻居的列表<code>list[Node]</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   <span class="built_in">vector</span>&lt;Node *&gt; neighbors;</span><br><span class="line">   Node(<span class="keyword">int</span> _val)</span><br><span class="line">   &#123;</span><br><span class="line">       val = _val;</span><br><span class="line">       neighbors = <span class="built_in">vector</span>&lt;Node *&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  <strong>Example:</strong></p>  <img src="133_clone_graph_question.png" alt="img" style="zoom: 25%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Output: [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Explanation: There are 4 nodes in the graph.</span><br><span class="line">1st node (val &#x3D; 1)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">2nd node (val &#x3D; 2)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br><span class="line">3rd node (val &#x3D; 3)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">4th node (val &#x3D; 4)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接深度优先搜索即可</span></span><br><span class="line"><span class="comment">// 只是需要使用一个哈希表来记录已经 new 过的节点</span></span><br><span class="line"><span class="comment">// 哈希表中记录的是原节点和拷贝节点之间的映射</span></span><br><span class="line"><span class="comment">// 下次通过某节点的邻居遍历到相同的节点直接从哈希表中取就可以了</span></span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; visited;</span><br><span class="line">    <span class="keyword">return</span> dfs(node, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node, <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果这个节点已经 被克隆过了</span></span><br><span class="line">    <span class="comment">// 直接从哈希表中返回其映射</span></span><br><span class="line">    <span class="keyword">if</span>(visited.count(node)) <span class="keyword">return</span> visited[node];</span><br><span class="line">    <span class="comment">// 克隆当前节点</span></span><br><span class="line">    Node* res = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">    <span class="comment">// 记录映射</span></span><br><span class="line">    visited[node] = res;</span><br><span class="line">    <span class="comment">// 深度遍历其所有邻居</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; neighbors = node-&gt;neighbors;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; neighbors.size(); i++)</span><br><span class="line">        <span class="comment">// 将其一一添加进拷贝节点的邻居中</span></span><br><span class="line">        res-&gt;neighbors.push_back(dfs(neighbors[i], visited));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">494. Target Sum</a></h5><blockquote><p>  给定一个非负整数数组，<code>a1, a2, ..., an</code>和一个目标数<code>S</code>。现在你有两个符号<code>+</code>和<code>-</code>。对于数组中的任意一个整数，你都可以从<code>+</code>或<code>-</code>中选择一个符号添加在前面。</p><p>  返回可以使最终数组和为目标数<code>S</code>的所有添加符号的方法数。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先上暴力搜索 (dfs) 穷举所有添加方法的结果</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(2^n), n 为数组长度</span></span><br><span class="line"><span class="comment">// 空间复杂度为 O(n) 递归调用栈的空间</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs(nums, <span class="number">0</span>, S);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意这里用到的一个技巧是</span></span><br><span class="line"><span class="comment">// 等式左边的数相加或相减起来 = S, 等价于 S + 等式左边的那些数相加或相减 = 0</span></span><br><span class="line"><span class="comment">// 它们的个数肯定相等嘛</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos, <span class="keyword">long</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="number">0</span>) count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// S += nums[pos]; // 做选择</span></span><br><span class="line">    <span class="comment">// dfs(nums, pos + 1, S);</span></span><br><span class="line">    <span class="comment">// S -= nums[pos]; // 撤销选择</span></span><br><span class="line">    dfs(nums, pos + <span class="number">1</span>, S + nums[pos]); <span class="comment">// 函数进入自动做选择, 返回自动撤销选择</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// S -= nums[pos]; // 做选择</span></span><br><span class="line">    <span class="comment">// dfs(nums, pos + 1, S);</span></span><br><span class="line">    <span class="comment">// S += nums[pos]; // 撤销选择</span></span><br><span class="line">    dfs(nums, pos + <span class="number">1</span>, S - nums[pos]); <span class="comment">// 函数进入自动做选择, 返回自动撤销选择</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们从上面可以注意到递归过程中出现了许多的重复计算</span></span><br><span class="line"><span class="comment">// 比如, nums[pos] == 0 的时候, dfs(num, pos + 1, S) 要计算 2 次</span></span><br><span class="line"><span class="comment">// 除了这种特殊情况还有许多</span></span><br><span class="line"><span class="comment">// 这里我们就使用备忘录来消除重叠子问题</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, S);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要修改一下递归函数的定义</span></span><br><span class="line"><span class="comment">// int dfs(vector&lt;int&gt;&amp; nums, pos, int S)</span></span><br><span class="line"><span class="comment">// 表示在 pos 位置加正负号使其和等于 S 有多少种方法</span></span><br><span class="line"><span class="comment">// 这样递推式就是 dfs(.., pos, S) = </span></span><br><span class="line"><span class="comment">// dfs(.., pos + 1, S + nums[pos]) /* pos 位置加正号的话 */</span></span><br><span class="line"><span class="comment">//  + dfs(.., pos + 1, S - nums[pos]) /* pos 位置加负号的话 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos, <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要将这两个参数转为字符串作为哈希表的键</span></span><br><span class="line">    <span class="comment">// 把 [状态] 转化为字符串作为键是一种小技巧</span></span><br><span class="line">    <span class="built_in">string</span> key = to_string(pos) + <span class="string">","</span> + to_string(S);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line">    <span class="keyword">int</span> res = dfs(nums, pos + <span class="number">1</span>, S + nums[pos]) + dfs(nums, pos + <span class="number">1</span>, S - nums[pos]);</span><br><span class="line">    memo[key] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面使用的优化方法来看</span></span><br><span class="line"><span class="comment">// 似乎有 [动态规划] 的影子</span></span><br><span class="line"><span class="comment">// 现在让我们再转化一下思路</span></span><br></pre></td></tr></table></figure><h5 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. Implement Queue using Stacks</a></h5><blockquote><p>  请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作：</p><p>  实现<code>MyQueue</code>类：</p><p>  <code>void push(int x)</code>：将元素x推到队列的末尾；<br>  <code>int pop()</code>：从队列的开头移除并返回元素；<br>  <code>int peek()</code>：返回队列开头的元素；<br>  <code>bool empty()</code>：如果队列为空，返回<code>true</code>；否则，返回<code>false</code>。</p>  <img src="2.jpg" alt="img" style="zoom: 33%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如上图, 将两个栈这样放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 入栈的时候直接放进右边的栈即可</span></span><br><span class="line">        _back.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 出栈的时候从左边出</span></span><br><span class="line">        <span class="comment">// 如果为空, 需要把右边栈的元素搬过来</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) moveData();</span><br><span class="line">        <span class="comment">// 搬过来之后直接 pop 左边的栈即可</span></span><br><span class="line">        <span class="keyword">int</span> res = _front.top();</span><br><span class="line">        _front.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 取的时候和 pop 的情况一样</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) moveData();</span><br><span class="line">        <span class="comment">// 只是不出栈, 只取元素</span></span><br><span class="line">        <span class="keyword">return</span> _front.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _front.empty() &amp;&amp; _back.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _front;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _back;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 搬移数据就是简单的将右边栈出栈</span></span><br><span class="line">        <span class="comment">// 左边栈接收元素压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(!_back.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            _front.push(_back.top());</span><br><span class="line">            _back.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. Implement Stack using Queues</a></h5><blockquote><p>  请你仅使用两个队列实现一个后入先出的栈，并支持普通队列的全部四种操作。</p><p>  实现<code>MyStack</code>类：</p><p>  <code>void push(int x)</code>：将元素<code>x</code>压入栈顶；<br>  <code>int pop()</code>：移除并返回栈顶元素；<br>  <code>int top()</code>：返回栈顶元素；<br>  <code>bool empty()</code>：如果栈是空的，返回<code>true</code>；否则，返回<code>false</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列实现栈</span></span><br><span class="line"><span class="comment">// 入栈操作很简单, 调用队列的 push 即可</span></span><br><span class="line"><span class="comment">// 出栈麻烦点, 因为队列只能从对头出列, 对头相当于栈的栈底</span></span><br><span class="line"><span class="comment">// 但我们是想 pop 掉队尾元素</span></span><br><span class="line"><span class="comment">// 这时很暴力, 直接把队列中除了队尾之外的所有元素依次出队并依次入队即可</span></span><br><span class="line"><span class="comment">// 这时对头就是原队尾元素了, 再出队就行</span></span><br><span class="line"><span class="comment">// 获取栈顶元素的话, 为了实现 O(1) 复杂度</span></span><br><span class="line"><span class="comment">// 使用一个变量实时记录队尾 (栈顶) 元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 入队的时候要更新栈顶变量</span></span><br><span class="line">        _top = x;</span><br><span class="line">        _queue.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _queue.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _top = _queue.front();</span><br><span class="line">            _queue.pop();</span><br><span class="line">            _queue.push(_top);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = _queue.front();</span><br><span class="line">        _queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line">    <span class="keyword">int</span> _top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands</a></h5><blockquote><p>给定一个<code>m x n</code>字符栅格网格，该栅格网格表示<code>&#39;1&#39;</code>（土地）和<code>&#39;0&#39;</code>（水）的地图，请返回岛的数量。</p><p>一个岛屿被水包围，是通过水平或垂直连接相邻的土地而形成的。 您可以假设网格的所有四个边缘都被水包围。</p><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想是</span></span><br><span class="line"><span class="comment">// 1. 依次遍历网格中的每一个字符</span></span><br><span class="line"><span class="comment">// 2. 如果当前字符是 '1' 说明踏上了一座岛, 进行下一步, 如果为 '0'，回到步骤 1</span></span><br><span class="line"><span class="comment">// 3. 然后骚操作来了, 将当前字符赋值为 '0'</span></span><br><span class="line"><span class="comment">// 4. 然后遍历当前字符的上下左右四个邻居</span></span><br><span class="line"><span class="comment">// 5. 每到一个邻居重复对当前字符的操作</span></span><br><span class="line"><span class="comment">// 6. 直到某一个邻居 (可以是邻居的邻居) 的四个邻居都为'0'</span></span><br><span class="line"><span class="comment">// 7. 说明这座岛的每一个陆地都走过了, 此时岛数量 +1</span></span><br><span class="line"><span class="comment">// 8. 接下来再到下一个字符, 回到步骤 1</span></span><br><span class="line"><span class="comment">// 遍历邻居的时候有两种方法, dfs 和 bfs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs 借助队列的迭代实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中保存的是当前陆地的坐标</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                count++;</span><br><span class="line">                q.push(&#123;i, j&#125;);</span><br><span class="line">                <span class="comment">// while 循环的目的是把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                <span class="keyword">while</span>(!q.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = q.front().first;</span><br><span class="line">                    <span class="keyword">int</span> c = q.front().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size()</span><br><span class="line">                       || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 淹没陆地</span></span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="comment">// 判断左邻居</span></span><br><span class="line">                    q.push(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="comment">// 判断右邻居</span></span><br><span class="line">                    q.push(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="comment">// 判断上邻居</span></span><br><span class="line">                    q.push(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="comment">// 判断下邻居</span></span><br><span class="line">                    q.push(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="694-Number-of-Distinct-Islands"><a href="#694-Number-of-Distinct-Islands" class="headerlink" title="694. Number of Distinct Islands"></a><a href="https://leetcode.com/problems/number-of-distinct-islands/" target="_blank" rel="noopener">694. Number of Distinct Islands</a></h5><blockquote><p>  给定一个非空<code>01</code>二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的<code>1</code>组成，你可以认为网格的四周被海水包围。</p><p>  请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。</p><p>  <strong>示例 1：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00011</span><br><span class="line">00011</span><br><span class="line">给定上图，返回结果 1 。</span><br></pre></td></tr></table></figure><p>  <strong>示例 2：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11011</span><br><span class="line">10000</span><br><span class="line">00001</span><br><span class="line">11011</span><br><span class="line">给定上图，返回结果 3 。</span><br></pre></td></tr></table></figure><p>  注意：</p><p>  11<br>  1</p><p>  和</p><p>  1<br>  11<br>  是不同的岛屿，因为我们不考虑旋转、翻转操作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; setting;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                <span class="comment">// isLand 用于记录这座岛的所有陆地坐标</span></span><br><span class="line">                <span class="comment">// 实际记录的是相对陆地坐标, 即其他陆地相对于左上角的那块陆地</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; isLand;</span><br><span class="line">                <span class="comment">// 更新当前岛屿的相对坐标</span></span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, isLand, i, j);</span><br><span class="line">                <span class="comment">// set 有自动排序和去重的功能</span></span><br><span class="line">                setting.insert(isLand);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setting.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; isLand, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    isLand.push_back(&#123;r - x, c - y&#125;);</span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, isLand, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, isLand, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, isLand, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, isLand, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1254-Number-of-Closed-Islands"><a href="#1254-Number-of-Closed-Islands" class="headerlink" title="1254. Number of Closed Islands"></a><a href="https://leetcode.com/problems/number-of-closed-islands/" target="_blank" rel="noopener">1254. Number of Closed Islands</a></h5><blockquote><p>  有一个二维矩阵<code>grid</code>，每个位置要么是陆地（记号为<code>0</code>）要么是水域（记号为<code>1</code>）。</p><p>  我们从一块陆地出发，每次可以往上下左右<code>4</code>个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。</p><p>  如果一座岛屿完全由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。</p><p>  请返回封闭岛屿的数目。</p><p>  <strong>Example 1:</strong></p><p>  <img src="sample_3_1610.png" alt="img"></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Islands in gray are closed because they are completely surrounded by water (group of 1s).</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p><p>  <img src="sample_4_1610.png" alt="img"></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这题 1 代表水域而 0 代表陆地</span></span><br><span class="line"><span class="comment">// 和岛屿数量 I 题的区别在于边界上的岛屿不算岛屿</span></span><br><span class="line"><span class="comment">// 所以如果搜索出来的岛屿在边界上就不更新岛屿数</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">// 是否是封闭岛的标志</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowLength = grid.size();</span><br><span class="line">    <span class="keyword">int</span> colLength = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colLength; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                <span class="comment">// 看它是否是边界岛</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                <span class="keyword">if</span>(flag) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 能到达边界, 说明不是封闭岛</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(grid[r][c] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="695-Max-Area-of-Island"><a href="#695-Max-Area-of-Island" class="headerlink" title="695. Max Area of Island"></a><a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener">695. Max Area of Island</a></h5><blockquote><p>  给定一个包含了一些<code>0</code>和<code>1</code>的非 空二维数组<code>grid</code>。</p><p>  一个岛屿是由一些相邻的<code>1</code>(代表土地) 构成的组合，这里的「相邻」要求两个<code>1</code>必须在水平或者竖直方向上相邻。你可以假设<code>grid</code>的四个边缘都被<code>0</code>（代表水）包围着。</p><p>  找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为<code>0</code> )</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">[0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line">[0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line">[0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">Given the above grid, return &#96;6&#96;. Note the answer is not 11, because the island must be connected 4-directionally.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">Given the above grid, return &#96;0&#96;.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="keyword">int</span> area; <span class="comment">// 用于记录每个岛的面积</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛就把先前岛屿面积清零</span></span><br><span class="line">                area = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res = max(res, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    area++;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="733-Flood-Fill"><a href="#733-Flood-Fill" class="headerlink" title="733. Flood Fill"></a><a href="https://leetcode.com/problems/flood-fill/" target="_blank" rel="noopener">733. Flood Fill</a></h5><blockquote><p>  有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在<code>0</code>到<code>65535</code>之间。</p><p>  给你一个坐标<code>(sr, sc)</code>表示图像渲染开始的像素值（行 ，列）和一个新的颜色值<code>newColor</code>，让你重新上色这幅图像。</p><p>  为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>  最后返回经过上色渲染后的图像。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected </span><br><span class="line">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class="line">to the starting pixel.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和前面那个岛屿数量 I 的题思路差不多</span></span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(image[sr][sc] != newColor)</span><br><span class="line">        dfs(image, sr, sc, image[sr][sc], newColor);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> srcColor, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == image.size() || c == image[<span class="number">0</span>].size() || image[r][c] != srcColor)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    image[r][c] = newColor;</span><br><span class="line">    dfs(image, r + <span class="number">1</span>, c, srcColor, newColor);</span><br><span class="line">    dfs(image, r - <span class="number">1</span>, c, srcColor, newColor);</span><br><span class="line">    dfs(image, r, c + <span class="number">1</span>, srcColor, newColor);</span><br><span class="line">    dfs(image, r, c - <span class="number">1</span>, srcColor, newColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> srcColor = image[sr][sc];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(&#123;sr, sc&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> c = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == image.size() || c == image[<span class="number">0</span>].size() || image[r][c] != srcColor)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            image[r][c] = newColor;</span><br><span class="line">            q.push(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">            q.push(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">            q.push(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">            q.push(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="542-01-Matrix"><a href="#542-01-Matrix" class="headerlink" title="542. 01 Matrix"></a><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 Matrix</a></h5><blockquote><p>给定一个由<code>0</code>和<code>1</code>组成的矩阵，找出每个元素到最近的<code>0</code>的距离。</p><p>两个相邻元素间的距离为<code>1</code>。矩阵中的元素只在四个方向上相邻：上、下、左、右。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[0,0,0]]</span><br><span class="line"></span><br><span class="line">&gt;Output:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[0,0,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[1,1,1]]</span><br><span class="line"></span><br><span class="line">&gt;Output:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[1,2,1]]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为要寻找 [最近] 距离, 所以显然使用 BFS</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rSize = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> cSize = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(rSize, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cSize))</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为要对矩阵中的所有元素进行寻找最近的 0</span></span><br><span class="line">    <span class="comment">// 所以外面的两层循环实际上是处理这个问题的</span></span><br><span class="line">    <span class="comment">// 如果只需要对一个元素进行寻找就不需要这两层循环, 和传统的 BFS 模板一样</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            step = <span class="number">0</span>;</span><br><span class="line">            q.push(&#123;i, j&#125;);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sz = q.size();</span><br><span class="line">                <span class="keyword">while</span>(sz--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 从当前位置出发, 遍历其所有邻居</span></span><br><span class="line">                    <span class="keyword">int</span> r = q.front().first;</span><br><span class="line">                    <span class="keyword">int</span> c = q.front().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    <span class="comment">// 如果 走到了 0, 那么它离 0 的最近距离就是已经走的 step</span></span><br><span class="line">                    <span class="keyword">if</span>(matrix[r][c] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res[i][j] = step;</span><br><span class="line">                        <span class="comment">// 更新完 step 之后还要将队列清空方便对下一位置进行搜索时使用</span></span><br><span class="line">                        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将其上下左右四个邻居入栈等待搜索</span></span><br><span class="line">                    <span class="keyword">if</span>(r + <span class="number">1</span> &lt; rSize) q.push(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(r - <span class="number">1</span> &gt;= <span class="number">0</span>) q.push(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(c + <span class="number">1</span> &lt; cSize) mq.push(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(c - <span class="number">1</span> &gt;= <span class="number">0</span>) q.push(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="841-Keys-and-Rooms"><a href="#841-Keys-and-Rooms" class="headerlink" title="841. Keys and Rooms"></a><a href="https://leetcode.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. Keys and Rooms</a></h5><blockquote><p>  有<code>N</code>个房间，开始时你位于<code>0</code>号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p><p>  在形式上，对于每个房间<code>i</code>都有一个钥匙列表<code>rooms[i]</code>，每个钥匙<code>rooms[i][j]</code>由<code>[0,1，...，N-1]</code>中的一个整数表示，其中<code>N = rooms.length</code>。 钥匙<code>rooms[i][j] = v</code>可以打开编号为<code>v</code>的房间。</p><p>  最初，除<code>0</code>号房间外的其余所有房间都被锁住。</p><p>  你可以自由地在房间之间来回走动。</p><p>  如果能进入每个房间返回<code>true</code>，否则返回<code>false</code>。</p><p>  <strong>Note:</strong></p><ol><li><code>1 &lt;= rooms.length &lt;= 1000</code></li><li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li><li>The number of keys in all rooms combined is at most <code>3000</code>.</li></ol><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&#39;t enter the room with number 2.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为最多就 1000 个房间</span></span><br><span class="line"><span class="comment">// 需要对已经访问过的房间进行标记</span></span><br><span class="line"><span class="comment">// 所以这里我们使用一个 bitset</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 所有房间初始化全未被访问</span></span><br><span class="line">    <span class="built_in">bitset</span>&lt;1000&gt; bits;</span><br><span class="line">    <span class="comment">// 从 0 号房间开始</span></span><br><span class="line">    <span class="keyword">return</span> dfs(rooms, <span class="number">0</span>, bits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为我们是想要搜索到一种可能满足的访问次序就可以</span></span><br><span class="line"><span class="comment">// 所以这里的 dfs 函数有 bool 返回值来提前结束搜索</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms, <span class="keyword">int</span> room, <span class="built_in">bitset</span>&lt;<span class="number">1000</span>&gt;&amp; bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 访问当前房间, 标记为已访问</span></span><br><span class="line">    bits.<span class="built_in">set</span>(room);</span><br><span class="line">    <span class="comment">// 如果访问的房间总数等于所有房间数</span></span><br><span class="line">    <span class="keyword">if</span>(bits.count() == rooms.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 否则, 从当前房间获取其它房间钥匙, 依次进行访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curRoom = rooms[room];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> key : curRoom)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果这把钥匙对应的房间已经被访问过, 就不过去了</span></span><br><span class="line">        <span class="keyword">if</span>(bits.test(key)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 否则去访问</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(rooms, key, bits)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之malloc底层原理</title>
      <link href="/wF5qv4uNKgDG1SUa/"/>
      <url>/wF5qv4uNKgDG1SUa/</url>
      
        <content type="html"><![CDATA[<p>先来了解一些背景知识。</p><p><strong>进程地址空间的组成</strong>：</p><ol><li>内核空间：这块区域包含两种数据，一种是对每个进程都一样的数据，如共享的内核代码和全局数据结构。另一种是每个进程都不一样的数据，如页表、内核在进程上下文中执行代码时使用的栈，以及记录该进程虚拟地址空间当前组织状态的各种数据结构。</li><li><code>BSS</code>（<code>Block Started by Symbol</code>）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。是可读写的。在程序执行之前<code>BSS</code>段会自动清<code>0</code>。所以，未初始的全局变量在程序执行之前已经成<code>0</code>了）。 </li><li>数据段（<code>data segment</code>）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 </li><li>代码段（<code>code segment/text  segment</code>）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 </li><li>堆（<code>heap</code>）是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用<code>malloc</code>函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用<code>free</code>函数释放内存时，被释放的内存从堆中被释放（堆被缩减） 。</li><li>栈（<code>stack</code>）又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数块中定义的变量（但不包括<code>static</code>声明的变量，<code>static</code>意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存<code>/</code>恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li><li>内存映射区：这块虚拟内存区域被映射到任何需要的对象身上，如共享库文件、磁盘上的普通文件和将要介绍的通过<code>malloc</code>分配的大块内存区域（大于<code>128K</code>）。</li></ol><a id="more"></a><p>注意这些区域实际上存在于进程的虚拟地址空间上，一开始并没有被装载到物理内存上，比如说<code>bss</code>段，理论上是被初始化为零值，但并不是说在物理内存区域的对应段被填入零值，实际上，是将其映射到了零页，等到<code>CPU</code>向这块区域内写数据时，通过引发缺页故障的形式，才被装载到物理内存，分配到初始化为零的页（所谓的写时复制）。</p><p><img src="20032_0.png" alt="进程虚拟内存布局图"></p><p><strong>操作系统提供的两个系统调用函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p><code>sbrk</code>函数的作用是移动<code>brk</code>指针扩展<code>heap</code>的上界。函数的参数指示<code>brk</code>指针移动的大小，返回申请之前的<code>brk</code>地址。注意申请的内存地址中的值是随机的，即不要求为零。</p><p><code>mmap</code>函数第一种用法是映射磁盘文件到内存中；而<code>malloc</code>使用的<code>mmap</code>函数的第二种用法，即<strong>匿名映射</strong>，匿名映射不映射磁盘文件，而是向映射区申请一块全零页内存，相应的虚拟页面是被初始化为零的。</p><p>如上面的进程虚拟内存布局图所示，<code>mmap</code>对应<code>Memory Mapping Segment</code>，<code>brk</code>对应<code>Heap</code>。<code>start_brk</code>是堆段的开始位置，<code>brk(program break)</code>则是堆段的结束位置。</p><p>下面开始介绍<code>malloc</code>的实现原理。</p><p>那么，既然<code>brk/mmap</code>提供了内存分配的功能，直接使用<code>brk/mmap</code>进行内存管理不是更简单吗，为什么需要<code>malloc</code>呢？</p><blockquote><p>  我们知道，系统调用本身会产生软中断，导致程序从用户态陷入内核态，比较消耗资源。试想，如果频繁分配回收小块内存区，那么将有很大的性能耗费在系统调用中。因此，为了减少系统调用带来的性能损耗，<code>malloc</code>采用了内存池的设计，增加了一个代理层，每次内存分配，都优先从内存池中寻找，如果内存池中无法提供，再向操作系统申请。</p></blockquote><p>当申请小于<code>128K</code>内存时，<code>malloc</code>使用<code>sbrk</code>分配内存，当申请大于<code>128K</code>内存时，使用<code>mmap</code>函数申请内存。</p><p>下面主要讨论对于小块内存的申请<code>malloc</code>所采用的内存池设计方案。<strong>分配器不但要管理已分配的内存块，还需要管理空闲的内存块</strong>。<code>malloc</code>利用<code>chunk</code>结构体来管理这些内存块，内存池就是由许多不同大小的<code>chunk</code>链表组成的。</p><p><img src="10681867-9c09c94096413f83.png" alt="img"></p><p>内存池保存在<code>bins</code>这个长<code>128</code>的数组中，每个元素都是一个双向链表。其中：</p><ul><li><code>bins[0]</code>目前没有使用。</li><li><code>bins[1]</code>的链表称为<code>unsorted_list</code>，用于维护<code>free</code>释放的<code>chunk</code>。</li><li><code>bins[2, 63)</code>的区间称为<code>small_bins</code>，用于维护<code>＜512</code>字节的内存块，其中每个元素对应的链表中的<code>chunk</code>大小相同，均为<code>index*8</code>。</li><li><code>bins[64,127)</code>称为<code>large_bins</code>，用于维护<code>&gt;512</code>字节的内存块，每个元素对应的链表中的<code>chunk</code>大小不同，<code>index</code>越大，链表中<code>chunk</code>的内存大小相差越大，例如: 下标为<code>64</code>的<code>chunk</code>大小介于<code>[512, 512+64)</code>，下标为<code>95</code>的<code>chunk</code>大小介于<code>[2k+1, 2k+512)</code>。同一条链表上的<code>chunk</code>，按照从小到大的顺序排列。</li></ul><p>结构体<code>malloc_chunk</code>来描述这些块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free).  */</span>  </span><br><span class="line">    INTERNAL_SIZE_T <span class="built_in">size</span>; <span class="comment">/* Size in bytes, including overhead. */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="10681867-ce8d3eeabf100d45.png" alt="img"></p><p><code>glibc</code>在内存池中查找合适的<code>chunk</code>时，采用了<strong>最佳适应</strong>的伙伴算法。举例如下：</p><ol><li>如果分配内存<code>&lt; 512</code>字节，则通过内存大小定位到<code>smallbins</code>对应的<code>index</code>上。<ul><li>如果<code>smallbins[index]</code>为空，进入步骤<code>3</code></li><li>如果<code>smallbins[index]</code>非空，直接返回第一个<code>chunk</code></li></ul></li><li>如果分配内存<code>&gt; 512</code>字节，则定位到<code>largebins</code>对应的<code>index</code>上。<ul><li>如果<code>largebins[index]</code>为空，进入步骤<code>3</code></li><li>如果<code>largebins[index]</code>非空，扫描链表，找到第一个大小最合适的<code>chunk</code>，如<code>size=12.5K</code>，则使用<code>chunk B</code>，剩下的<code>0.5k</code>放入<code>unsorted_list</code>中</li></ul></li><li>遍历<code>unsorted_list</code>，查找合适<code>size</code>的<code>chunk</code>，如果找到则返回；否则，将这些<code>chunk</code>都归类放到<code>smallbins</code>和<code>largebins</code>里面。</li><li><code>index++</code>从更大的链表中查找，直到找到合适大小的<code>chunk</code>为止，找到后将<code>chunk</code>拆分，并将剩余的加入到<code>unsorted_list</code>中。</li><li>如果还没有找到，那么使用<code>top chunk</code>。</li></ol><p><strong><code>top chunk</code></strong><br> 如下图示: <code>top chunk</code>是堆顶的<code>chunk</code>，堆顶指针<code>brk</code>位于<code>top chunk</code>的顶部。移动<code>brk</code>指针，即可扩充<code>top chunk</code>的大小。</p><p><img src="10681867-4b414b22810c9e9d.png" alt="img"></p><p><code>free</code>释放内存时，有两种情况：</p><ol><li><code>chunk</code>和<code>top chunk</code>相邻，则和<code>top chunk</code>合并。</li><li><code>chunk</code>和<code>top chunk</code>不相邻，则直接插入到<code>unsorted_list</code>中。</li></ol><p><strong>参考链接：</strong></p><ol><li><p><a href="https://www.jianshu.com/p/2fedeacfa797" target="_blank" rel="noopener">glibc内存管理那些事儿 - 简书</a></p></li><li><p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" target="_blank" rel="noopener">Understanding glibc malloc – sploitF-U-N</a></p></li><li><p>自己实现一个简单的<code>malloc</code>可参考</p><ul><li><a href="https://github.com/danluu/malloc-tutorial/blob/master/malloc.c" target="_blank" rel="noopener">malloc-tutorial/malloc.c at master · danluu/malloc-tutorial</a></li><li><a href="https://www.pengrl.com/p/18873/" target="_blank" rel="noopener">[译] 写一个简单的内存分配器（替换glibc中的malloc函数） | yoko blog</a></li></ul></li><li><p><a href="https://www.pengrl.com/p/20032/" target="_blank" rel="noopener">[译] malloc中的系统调用brk和mmap | yoko blog</a>。</p></li><li><p>[malloc的底层实现（ptmalloc）_牛客博客</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之内存管理</title>
      <link href="/CB6w5vAiSmICT1OK/"/>
      <url>/CB6w5vAiSmICT1OK/</url>
      
        <content type="html"><![CDATA[<p>操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做<strong>内存管理</strong>。</p><a id="more"></a><h5 id="加载和链接"><a href="#加载和链接" class="headerlink" title="加载和链接"></a>加载和链接</h5><table><thead><tr><th>地址绑定时间</th><th>功能</th></tr></thead><tbody><tr><td>程序设计时</td><td>程序员直接在程序中确定所有实际的物理地址</td></tr><tr><td>编译或汇编时</td><td>程序包含符号地址访问，由编译器在加载程序时把它们转换为实际的绝对地址</td></tr><tr><td>加载时</td><td>编译器或汇编器产生相对地址，加载器在加载程序时把它们转换为实际的绝对地址</td></tr><tr><td>运行时</td><td>被加载的程序保持相对地址，处理器硬件在执行时把它们动态的转换为绝对地址</td></tr></tbody></table><table><thead><tr><th>链接时间</th><th>功能</th></tr></thead><tbody><tr><td>程序设计时</td><td>不允许外部程序或数据访问。程序员必须把所有引用到的子程序源代码放入程序中</td></tr><tr><td>编译或汇编时</td><td>汇编器必须取到每个引用的子程序的源代码，并把它们作为一个部件来进行汇编</td></tr><tr><td>加载模块产生时</td><td>所有目标模块都使用相对地址汇编。这些模块被链接在一起，所有访问都相对于最后加载的模块的地点重新声明</td></tr><tr><td>加载时</td><td>直到加载模块被加载到内存时才解析外部访问，此时被访问的动态链接模块附加到加载模块后，整个软件包被加载到内存或虚存</td></tr><tr><td>运行时</td><td>直到处理器执行外部调用时才解析外部访问，此时该进程被中断，需要的模块被链接到调用程序中</td></tr></tbody></table><h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><p>创建活动进程的第一步是把程序装入内存，并创建一个进程映像。应用程序由许多已编译过或汇编过的模块组成，这些模块以目标代码的形式存在，并被链接起来以解析模块间的任何访问和对库例程的访问。库例程可以合并到程序中，或作为操作系统在运行时提供的共享访问代码。</p><p><img src="image-20210325190827823.png" alt="image-20210325190827823"></p><p>加载器把加载的模块放置在内存中从<code>x</code>开始的位置。一般而言，可以采用三种方法:</p><ul><li><p>绝对加载</p><p>  绝对加载器要求给定加载模块总被加载到内存中的同一位置。因此，在提供给加载器的加载模块中，所有的地址访问必须是确定的，或者说是绝对的内存地址。给程序中的内存访问指定具体的地址值既可以由程序员完成，也可以在编译时或汇编时完成，</p><p>  这种方法存在许多缺点：首先，程序员必须知道在内存中放置模块时预定的分配策略；其次，如果在程序的模块体中进行了任何涉及插入或删除的修改，则所有地址都需要更改。</p><p>  因此，更可取的方法是允许用符号表示程序中的内存访问，然后在编译或汇编时解析这些符号引用。对指令或数据项的引用最初被表示成一个符号。在准备输入到一个绝对加载器的模块时，汇编器或编译器将把所有这些引用转换为具体地址。</p></li><li><p>可重定位加载</p><p>  在加载之前就把内存访问绑定到具体的地址的缺点是，会使得加载模块只能放置到内存中的一个区域。但是，当多个程序共享内存时，不可能事先确定哪块区域用于加载哪个特定的模块，最好是在加载时确定。因此，需要一个可分配到内存中任何地方的加载模块。</p><p>  为满足这个新需求，汇编器或编译器不产生实际的内存地址（绝对地址），而是使用相对于某些已知点的地址，如相对于程序的起点。加载模块中的所有其他内存访问都用与该模块起点的相对值来表示。</p><p>  既然所有内存访问都以相对形式表示，那么加载器就可以很容易地把模块放置在期望的位置。如果该模块要加载到从<code>x</code>位置开始的地方，则当加载器把该模块加载到内存中时，只需简单地给每个内存访问都加上<code>x</code>。为完成这一任务，加载模块必须包含一些需要告诉加载器的信息，如地址访问在哪里、如何解释它们（通常相对于程序的起点）。由编译器或汇编器准备这些信息，通常称这些信息为重定位地址库。</p>  <img src="image-20210325191522172.png" alt="image-20210325191522172" style="zoom: 67%;" /></li><li><p>动态运行时加载</p><p>  动态运行时加载可重定位加载器非常普遍，且相对于绝对加载器具有明显的优点。但是，在多道程序设计环境中，即使不依赖于虚存，可重定位的加载方案仍是不够的。由于需要把进程换入或换出内存来增大处理器的利用率，而为最大程度地利用内存，又希望能在不同的时刻把一个进程映像换回到不同的位置，因此，程序被加载后，可能被换出到磁盘，然后又被换回到内存中不同的位置。如果在开始加载时，内存访问就被绑足到绝对地址，那么前面提到的情况是不可能实现的。</p><p>  一种替代方案是在运行时真正在使用某个绝对地址时再计算它。为达到这一目的，加载模块被加载到内存中时，其所有内存访问都以相对形式表示，一条指令只有在真正被执行时才计算其绝对地址。为确保该功能不会降低性能，这些工作必须由特殊的处理器硬件完成，而不用软件实现。</p><p>  动态地址计算提供了很大的灵活性。一个程序可以加载到内存中的任何区域，程序的执行可以中断，程序还可换出内存，以后再换回到不同的位置。</p></li></ul><h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><p>链接器的功能是把一组目标模块作为输入，产生一个包含完整程序和数据模块的加载模块，并传递给加载器。在每个目标模块中，可能有到其他模块的地址访问，每个这样的访问可以在未链接的目标模块中用符号表示。链接器会创建一个单独的加载模块，它把所有目标模块逐个链接起来。每个模块内的引用必须从符号地址转换为对整个加载模块中的一个位置的引用。</p><img src="image-20210325192023851.png" alt="image-20210325192023851" style="zoom:67%;" /><p>产生可重定位加载模块的链接器通常称为<strong>链接编辑程序</strong>。地址链接的性质取决于链接发生时要创建的加载模块的类型。通常情况下需要可重定位的加载模块，然后链接按以下方式完成：同时创建每个已编译或汇编的目标模块及相对于该目标模块开始处的引用。所有这些模块，连同相对于该加载模块起点的所有引用，一起放进一个可重定位的加载模块中。该模块可以作为可重定位加载或动态运行时加载的输入。</p><p>像加载一样，可以推迟某些链接功能。<strong>动态链接</strong>是指把某些外部模块的链接推迟到创建加载模块之后。因此，加载模块包含到其他程序的未解析的引用，这些引用可以在加载时或运行时解析。</p><p>加载时的动态链接分为如下步骤：</p><ol><li>待加载的加载模块（应用模块）读入内存。</li><li>应用模块中到一个外部模块（目标模块）的任何引用都将导致加载程序查找目标模块，加载它，并把这些引用修改为相对于应用程序模块开始处的相对地址。</li></ol><p>该方法与静态加载相比，有以下优点：</p><ul><li>能更容易地并入已改变或已升级的目标模块，如操作系统工具，或某些其他的通用例程。而对于静态链接，这类支持模块的变化需要重新链接全部应用程序模块。</li><li>在动态链接文件中的目标代码可以很方便的进行共享。因为操作系统加载并链接了该代码，所以可以识别出有多个应用程序使用相同的目标代码。操作系统可以使用此信息，然后只加载目标代码的一个副本，并把这个被加载的目标副本链接到所有使用该目标代码的应用程序，而不是为每个应用程序都分别加载一个副本。</li></ul><p>使用运行时动态链接时，某些链接工作被推迟到执行时。这样一些对目标模块的外部引用保留在被加载的程序中，当调用的模块不存在时，操作系统定位该模块，加载它，并把它链接到调用模块中。这些模块一般是共享的。在 <code>Windows</code>环境下，这些模块称为动态链接库（<code>DLL</code>）。也就是说，如果一个进程已使用动态链接共享模块，该模块就位于内存中，新的进程就可以简单地链接上已加载好的模块。</p><h5 id="内存管理的需求"><a href="#内存管理的需求" class="headerlink" title="内存管理的需求"></a>内存管理的需求</h5><p>操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做<strong>内存管理</strong>。</p><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>页框</td><td>内存中固定长度的块</td></tr><tr><td>页</td><td>固定长度的数据块。一般和页框的长度相等，数据页可临时复制到内存的页框中</td></tr><tr><td>段</td><td>变长的数据块。整个段可以临时复制到内存中的一个可用区域中，或者将一个段划分为许多页，然后将每页单独复制到内存中（分段和分页相结合）</td></tr></tbody></table><p>内存管理的需求如下：</p><ol><li><p>重定位</p><p> 可用的有限内存空间通常被多个进程共享。程序换出到磁盘后，下次换入内存时并不一定被放回原来的区域。也就是说我们需要把进程重定位到不同的内存区域。同时，我们必须允许程序通过交换技术在内存中移动，所以处理器硬件和操作系统软件必须能够以某种方式将程序代码中写死的内存访问地址转换为实际的物理内存地址。</p><p> 首次加载一个进程时，重定位将代码中的相对内存访问被绝对内存地址代替，这个绝对地址由进程被加载到的基地址确定。</p><p> 一个进程在其生命周期中可能占据不同的分区。首次创建一个进程映像时，它被装入内存中的某个分区。以后，该进程可能被换出，当它再次被换入时，可能被指定到与上一次不同的分区中。</p><p> 进程被换入或在内存中移动时，指令和数据单元的位置会发生改变。为解决这个问题，需要区分几种地址类型。<strong>逻辑地址</strong>是指与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须把它转换为物理地址。<strong>相对地址</strong>是逻辑地址的一个特例，它是相对于某些已知点（通常是程序的开始处）的存储单元。物理地址或绝对地址是数据在内存中的实际位置。</p><p> 进程处于运行态时，有一个特殊处理器寄存器（称为基址寄存器），其内容是程序在内存中的起始地址。还有一个界限寄存器指明程序的终止位置。当程序被装入内存或当该进程的映像被换入时，必须设置这两个寄存器。在进程的执行过程中会遇到相对地址，包括指令寄存器的内容、跳转或调用指令中的指令地址，以及加载和存储指令中的数据地址。每个这样的相对地址都经过处理器的两步操作。首先，基址寄存器中的值加上相对地址产生一个绝对地址；然后，将得到的结果与界限寄存器的值进行比较，如果这个地址在界限范围内，则继续该指令的执行；否则，向操作系统发出一个中断信号，操作系统必须以某种方式对这个错误做出响应。</p></li><li><p>保护</p><p> 一个进程的内存空间不能被其它进程未经授权的访问，满足重定位的需求增大了满足保护需求的难度。由于程序在内存中的位置通常会变化，因此，不可能通过在编译时检查绝对地址来保护。必须在运行时检查进程的所有内存访问，以确保它们只访问分配给自己的内存空间。</p><p> 注意，内存保护必须由硬件（处理器）而非软件（操作系统）来满足。</p></li><li><p>共享</p><p> 例如，多个进程在执行同一个程序时，允许每个进程访问该程序的同一个副本，以节省内存空间。这意味着操作系统允许进程对共享内存区域的受控访问。</p></li><li><p>逻辑组织</p><p> 计算机系统中的内存总是被组织成线性(或一维）的地址空间，且地址空间由一系列字节或字组成。然而，大多数程序被组织成模块，某些模块是不可修改的（只读、只执行），某些模块包含可以修改的数据。若操作系统和计算机硬件能够有效地处理以某种模块形式组织的用户程序与数据，则会带来很多好处：</p><ul><li><p>可以独立地编写和编译模块，系统在运行时解析从一个模块到其他模块的所有引用。</p></li><li><p>通过适度的额外开销，可以为不同的模块提供不同的保护级别。</p></li><li><p>可以引入某种机制，使得模块可被多个进程共享。</p><p>最易于满足这些需求的工具是分段。</p></li></ul></li><li><p>物理组织</p><p> 计算机存储器至少要组织成两级，即内存和外存。内存提供快速的访问，成本也相对较高。此外，内存是易失性的，即它不能提供永久性存储。外存比内存慢而且便宜，且通常是非易失性的。因此，大容量的外存可用于长期存储程序和数据，而较小的内存则用于保存当前使用的程序和数据。</p><p> 在两级存储器间移动信息的任务应由系统负责。这一任务恰好是<strong>存储管理的本质</strong>。</p></li></ol><h5 id="固定分区和动态分区"><a href="#固定分区和动态分区" class="headerlink" title="固定分区和动态分区"></a>固定分区和动态分区</h5><p>内存管理的主要操作是处理器把程序装入内存中执行。虚存基于分页和分段两种技术。</p><table><thead><tr><th align="center">内存管理技术</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">固定分区</td><td align="left">在系统生成阶段，内存被划分成许多静态分区。进程可装入大于等于自身大小的分区中</td></tr><tr><td align="center">动态分区</td><td align="left">分区是动态创建的，因而每个进程可装入与自身大小正好相等的分区中</td></tr><tr><td align="center">简单分页</td><td align="left">内存被划分成许多大小相等的页框；每个进程被划分成许多大小与页框相等的页；要装入一个进程,需要把进程包含的所有页都装入内存内不一定连续的某些页框中</td></tr><tr><td align="center">简单分段</td><td align="left">每个进程被划分成许多段；要装入一个进程，需要把进程包含的所有段都装入内存内不一定连续的某些动态分区中</td></tr><tr><td align="center">虚存分页</td><td align="left">除了不需要装入一个进程的所有页外，与简单分页一样；非驻留页在以后需要时自动调入内存</td></tr><tr><td align="center">虚存分段</td><td align="left">除了不需要装入一个进程的所有段外，与简单分段一样；非驻留段在以后需要时自动调入内存</td></tr></tbody></table><p><strong>固定分区</strong></p><p>使用大小相等的分区：</p><ol><li>程序可能太大而不能放到一个分区中，此时必须使用覆盖技术。</li><li>内存的利用率很低。会产生大量内部碎片。</li></ol><p>使用大小不等的分区可缓解这两个问题。</p><p>对于大小相等的分区，<strong>放置算法</strong>将进程放入内存的哪个分区都没有关系。</p><p>对于大小不等的分区，放置算法将每个进程分配到能够容纳它的最小分区中。每个分区需要维护一个调度队列，用于保存从这个分区换出的进程。</p><p><strong>动态分区</strong></p><p>对于动态分区，分区长度和数量是可变的。进程装入内存时，系统会给它分配一块与其所需容量完全相等的内存空间。动态分区方法最初不错，但它最终在内存中形成了许多小空洞。随着时间的推移，内存中形成了越来越多的外部碎片，内存的利用率随之下降。</p><p><strong>放置算法</strong>把一个进程装入或换入内存时，如果内存中有多个足够大的空闲块，那么操作系统必须确定要为此进程分配哪个空闲块。可供考虑的放置算法有三种：最佳适配、首次适配和下次适配。<strong>首次适配算法</strong>是最简单，最好和最快的。</p><p><strong>置换算法</strong>使得操作系统将一个阻塞的进程换出内存，给新进程或处于就绪-挂起态的进程让出空间。因此,操作系统必须选择要替换哪个进程。</p><p><strong><em>伙伴系统</em></strong></p><img src="image-20210325152953062.png" alt="image-20210325152953062" style="zoom:67%;" /><h5 id="简单分页"><a href="#简单分页" class="headerlink" title="简单分页"></a>简单分页</h5><p>大小不等的固定分区和大小可变的分区技术在内存的使用上都是低效的，前者会产生内部碎片，后者会产生外部碎片。但是，如果内存被划分成大小固定、相等的块，且块相对比较小，每个进程也被分成同样大小的小块，那么进程中称为页的块可以分配到内存中称为页框的可用块。使用分页技术时，每个进程在内存中浪费的空间，仅是进程最后一页的一小部分形成的内部碎片，没有任何外部碎片。</p><p>在某个给定时刻，内存中的某些页框正被使用，某些页框是空闲的，操作系统维护空闲页框的列表。</p><p>这时仅有一个简单的基址寄存器是不够的，<strong>操作系统需要为每个进程维护一个页表</strong>。<strong>页表给出了该进程的每页所对应页框的位置。在程序中，每个逻辑地址包括一个页号和在该页中的偏移量</strong>。在简单分区的情况下，逻辑地址是一个字相对于程序开始处的位置，处理器把它转换为一个物理地址。在分页中，逻辑地址到物理地址的转换仍然由处理器硬件完成，且处理器必须知道如何访问当前进程的页表。给出逻辑地址（页号，偏移量）后，处理器使用页表产生物理地址（页框号，偏移量）。</p><img src="image-20210325154011859.png" alt="image-20210325154011859" style="zoom:67%;" /><img src="image-20210325154456738.png" alt="image-20210325154456738" style="zoom:67%;" /><p>进程的每页在页表中都有一项，因此页表很容易按页号对进程的所有页进行索引（从<code>0</code>页开始）。每个页表项包含内存中用于保存相应页的页框的页框号。此外，操作系统为当前内存中未被占用、可供使用的所有页框维护一个空闲页框列表。</p><p>总之，采用简单的分页技术，内存可分成许多大小相等且很小的页框，每个进程可划分成同样大小的页；较小的进程需要较少的页，较大的进程需要较多的页；装入一个进程时，其所有页都装入可用页框中，并建立一个页表。</p><h5 id="简单分段"><a href="#简单分段" class="headerlink" title="简单分段"></a>简单分段</h5><p>把程序和与其相关的数据划分到几个段中。并不要求所有程序的所有段的长度都相等。和分页一样，采用分段技术时的逻辑地址也由两部分组成：段号和偏移量。</p><p>一般情况下，程序员或编译器会把程序和数据指定到不同的段。为了实现模块化程序设计的目的，程序或数据可能会进一步分成多个段。</p><p>采用大小不等的段的另一个结果是，逻辑地址和物理地址间不再是简单的对应关系。类似于分页，在简单的分段方案中，每个进程都有一个段表，系统也会维护一个内存中的空闲块列表。每个段表项必须给出相应段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效地址。当进程进入运行状态时，系统会把其段表的地址装载到一个寄存器中，由内存管理硬件来使用这个寄存器。</p><img src="image-20210325154511633.png" alt="image-20210325154511633" style="zoom:67%;" /><p>总之，采用简单的分段技术，进程可划分为许多段，段的大小无须相等；调入一个进程时，其所有段都装入内存的可用区域，并建立一个段表。</p><h5 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h5><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>虚拟内存</td><td>被定义成一个连续完整的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换</td></tr><tr><td>虚拟地址</td><td>在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主内的一部分那样</td></tr><tr><td>虚拟地址空间</td><td>分配给进程的虚拟存储</td></tr><tr><td>地址空间</td><td>用于某进程的内存地址范围</td></tr><tr><td>实地址</td><td>内存中存储位置的地址</td></tr></tbody></table><p>分页和分段的两个特点：</p><ol><li>进程中的所有内存访问都是逻辑地址，这些逻辑地址会在运行时动态的转换为物理地址。这意味着一个进程可被换入和换出内存，进程可在执行过程中占据不同时刻内存中的不同区域。</li><li>一个进程可被划分为许多块（页和段），在执行过程中，这些快不需要连续的位于内存中。</li></ol><p>假设需要把一个新进程放入内存，此时操作系统仅读取包含程序开始处的一个或几个块。进程执行的任何时候都在内存的部分称为<strong>进程的常驻集</strong>。进程执行时，只要所有内存访问都是访问常驻集中的单元，执行就可以顺利进行；使用段表或页表，处理器总可以确定是否如此。</p><p>处理器需要访问一个不在内存中的逻辑地址时，会产生一个中断，这表明出现了内存访问故障（缺页故障）。操作系统会把被中断的进程置于阻塞态。要继续执行这个进程，操作系统必须把包含引发访问故障的逻辑地址的进程块（所在的页）读入内存。为此，操作系统产生一个磁盘<code>IO</code>读请求。产生<code>I/O</code>请求后，在执行磁盘<code>IO</code>期间，操作系统可以调度另一个进程运行。需要的块读入内存后，产生一个<code>I/O</code>中断，控制权交回给操作系统，而操作系统则把由于缺少该块而被阻塞的进程置为就绪态。</p><ol><li><p>在内存中保留多个进程。</p><p> 由于对任何特定的进程都仅装入它的某些块，因此有足够的空间来放置更多的进程。这样，在任何时刻这些进程中至少有一个处于就绪态，于是处理器得到了更有效的利用。</p></li><li><p>进程可以比内存的全部空间还大。</p><p> 操作系统在需要时会自动地把进程块装入内存。</p></li></ol><p>由于进程只能在内存中执行，因此这个存储器称为实存储器，简称实存。但程序员或用户感觉到的是一个更大的内存，且通常分配在磁盘上，这称为虚拟内存，简称虚存。虚存支持更有效的系统并发度，并能解除用户与内存之间没有必要的紧密约束。</p><p>考虑一个由很长的程序和多个数据数组组成的大进程。在任何一段很短的时间内，执行可能会局限在很小的一段程序中（如一个子程序），且可能仅会访问一个或两个数据数组。因此，若在程序被挂起或被换出前仅使用了一部分进程块，则为该进程给内存装入太多的块显然会带来巨大的浪费。仅装入这一小部分块可更好地使用内存。然后，若程序转移到或访问到不在内存中的某个块中的指令或数据，就会引发一个错误，告诉操作系统读取需要的块。</p><p>当操作系统读取一块时，它必须把另一块换出。如果一块正好在将要用到之前换出，操作系统就不得不很快地把它取回。这类操作通常被称为<strong>系统抖动</strong>。</p><p><strong>局部性原理</strong>表明虚拟内存方案是可行的。要使虚存比较实用并且有效，需要两方面的因素：</p><ul><li>首先，必须有对所采用分页或分段方案的硬件支持；</li><li>其次，操作系统必须有管理页或段在内存和辅助存储器之间移动的软件。</li></ul><h5 id="虚拟分页"><a href="#虚拟分页" class="headerlink" title="虚拟分页"></a>虚拟分页</h5><p>每个进程都有自己的页表，当它的所有页都装入内存时，将创建页表并装入内存。<strong>页表项（<code>Page Table Entry</code>，<code>PTE</code>）包含有与内存中的页框相对应的页框号</strong>。由于一个进程可能只有一些页在内存中，因而每个页表项需要有一位<code>P</code>来表示它所对应的页当前是否在内存中。若这一位表示该页在内存中，则这个页表项还包括该页的页框号。</p><p>页表项中所需要的另一个控制位是修改位<code>M</code>，它表示相应页的内容从上次装入内存到现在是否已改变。若未改变，则在需要把该页换出时，无须用页框中的内容更新该页。页表项还须提供其他一些控制位，例如，保护位和共享位。</p><img src="image-20210325214215830.png" alt="image-20210325214215830" style="zoom:67%;" /><h6 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h6><p>从内存中读取一个字的基本机制包括使用页表从虚拟地址到物理地址的转换。虚拟地址又称为逻辑地址，它由页号和偏移量组成，而物理地址由页框号和偏移量组成。由于页表的长度可基于进程的长度而变化，因而不能期望在寄存器中保存它，它须在内存中且可以访问。当某个特定的进程正运行时，一个寄存器保存该进程页表的起始地址。虚拟地址的页号用于检索页表、查找相应的页框号，并与虚拟地址的偏移量结合起来形成需要的实地址。一般来说，页号域长于页框号域（<code>n &gt; m</code>）。</p><img src="image-20210325214238480.png" alt="image-20210325214238480" style="zoom:67%;" /><p>每个进程可以占据大量的虚存空间，因而一个进程会有大量的页表项，这会导致保存页表的内存空间太大。大多数虚拟内存方案都在虚存而非实存中保存页表。这意味着页表和其他页一样都服从分页管理。一个进程正在运行时，它的页表至少有一部分须在内存中，这一部分包括正在运行的页的页表项。一些处理器使用<strong>两级方案</strong>来组织大型页表。在这类方案中有一个页目录，其中的每项指向一个页表。</p><img src="image-20210325214616001.png" alt="image-20210325214616001" style="zoom: 80%;" /><p>假设采用字节级的寻址，页尺寸为<code>4KB</code>(2^12^)，则<code>4GB</code>(2^32^)虚拟地址空间由2^20^页组成。若这些页中的每页都由一个<code>4</code>字节的页表项映射，则可创建由2^20^个页表项组成的一个页表，这时需要<code>4MB</code>(2^22^)的内存空间。这个由2^10^页组成的巨大用户页表可以保留在虚存中，并由一个包括2^10^个页表项的根页表映射，根页表占据的内存为<code>4KB</code>(2^12^)。</p><img src="image-20210325214950642.png" alt="image-20210325214950642" style="zoom:67%;" /><h6 id="转换检测缓冲区TLB"><a href="#转换检测缓冲区TLB" class="headerlink" title="转换检测缓冲区TLB"></a>转换检测缓冲区<code>TLB</code></h6><p>原则上，每次虚存访问都可能会引起两次物理内存访问：一次取相应的页表项，另一次取需要的数据（进程页）。因此，虚拟内存方案都为页表项使用了一个特殊的高速缓存，通常称为转换检测缓冲区（<code>Translation Lookaside Buffer</code>，<code>TLB</code>）。<code>TLB</code>中包含有最近用过的<strong>页号和完整的页表项</strong>。给定一个虚拟地址，处理器首先检查<code>TLB</code>，若需要的页表项在其中（<code>TLB</code>命中），则检索页框号并形成实地址。若未找到需要的页表项（<code>TLB</code>未命中）,则处理器用页号检索进程页表，并检查相应的页表项。若“存在位”已置位，则该页在内存中，处理器从页表项中检索页框号以形成实地址。处理器同时更新<code>TLB</code>，使其包含这个新页表项。最后，若“存在位”未置位，则表示需要的页不在内存中，这时会产生一次内存访问故障，称为缺页（<code>page fault</code>）故障。此时离开硬件作用范围，调用操作系统，由操作系统负责装入所需要的页，并更新页表。</p><img src="image-20210325215417101.png" alt="image-20210325215417101" style="zoom:67%;" /><p>页尺寸对缺页中断发生概率的影响使得这些问题变得更为复杂。一般而言，基于局部性原理，如果页尺寸非常小，那么每个进程在内存中就有较多数量的页。一段时间后，内存中的页都包含有最近访问的部分，因此缺页率较低。当页尺寸增加时，每页包含的单元和任何一个最近访问过的单元越来越远。因此局部性原理的影响被削弱，缺页率开始增长。</p><p>更为复杂的是，缺页率还取决于分配给一个进程的页框的数量。对固定的页尺寸，当内存中的页数量增加时，缺页率会下降。因此，软件策略（分配给每个进程的内存总量）影响着硬件设计决策（页尺寸)。</p><h5 id="虚拟分段和段页式"><a href="#虚拟分段和段页式" class="headerlink" title="虚拟分段和段页式"></a>虚拟分段和段页式</h5><p>分段允许程序员把内存视为由多个地址空间或段组成，段的大小不等，并且是动态的。内存访问以段号和偏移量的形式组成地址。其优点：</p><ol><li>允许程序独立地改变或重新编译，而不要求整个程序集重新链接和重新加载。同样，这也是使用多个段实现的。</li><li>有助于进程间的共享。程序员可以在段中放置一个实用工具程序或一个有用的数据表，供其他进程访问。</li><li>有助于保护。由于一个段可被构造成包含一个明确定义的程序或数据集，因而程序员或系统管理员可以更方便地指定访问权限。</li></ol><p>从内存中读一个字的基本机制，涉及使用段表来将段号和偏移量组成的虚拟地址（或逻辑地址）转换为物理地址。根据进程的大小，段表长度可变，无法在寄存器中保存，因此访问段表时它必须在内存中。当某个特定的进程正在运行时，有一个寄存器为该进程保存段表的起始地址。虚拟地址中的段号用于检索这个表，并查找该段起点的相应内存地址。这个地址加上虚拟地址中的偏移量部分，就形成了需要的实地址。</p><p><strong>段页式系统</strong></p><p>在段页式系统中，用户的地址空间被程序员划分为许多段。每段依次划分为许多固定大小的页，页的长度等于内存中的页框大小。若某段的长度小于一页，则该段只占据一页。从程序员的角度看，逻辑地址仍然由段号和段偏移量组成：从系统的角度看，段偏移量可视为指定段中的一个页号和页偏移量。</p><p>每个进程都使用一个段表和一些页表，且每个进程段使用一个页表。某个特定的进程运行时，使用一个寄存器记录该进程段表的起始地址。对每个虚拟地址，处理器使用段号部分来检索进程段表以寻找该段的页表。然后虚拟地址的页号部分用于检索页表并查找相应的页框号。这种方式结合虚拟地址的偏移部分，就形成了需要的实地址。</p><img src="image-20210325220947686.png" alt="image-20210325220947686" style="zoom:67%;" /><p><strong>分段有助于实现保护与共享机制</strong>。实际上，操作系统要求的保护和共享功能通常在段一级处理。由于每个段表项包括一个长度和一个基地址，因而程序不会不经意地访问超出该段的内存单元。为实现共享，一个段可能会在多个进程的段表中引用。</p><img src="image-20210325221118176.png" alt="image-20210325221118176" style="zoom:67%;" /><h5 id="操作系统软件的支持"><a href="#操作系统软件的支持" class="headerlink" title="操作系统软件的支持"></a>操作系统软件的支持</h5><p><strong>这里主要涉及的是操作系统为虚存方案提供的算法</strong>。在段页式虚存系统中，操作系统所面临的内存管理问题大多数都<strong>与分页有关</strong>。</p><p>在各种情况下，最重要的都是<strong>与性能相关</strong>的问题：由于缺页中断会带来巨大的软件开销，所以希望使缺页中断发生的频率最小。这类开销至少包括决定置换哪个或哪些驻留页，以及交换这些页所需要的<code>IO</code>操作。此外，在这个页<code>IO</code>操作的过程中，操作系统还须调度另一个进程运行，即导致一次进程切换。因此，希望能通过适当的安排，使得在一个进程正在执行时，访问一个未命中的页中的字的概率最小。</p><h6 id="读取策略和清除策略"><a href="#读取策略和清除策略" class="headerlink" title="读取策略和清除策略"></a>读取策略和清除策略</h6><p><strong>读取策略</strong></p><p>当一个进程首次启动时，会在一段时间出现大量的缺页故障；取入越来越多的页后，局部性原理表明大多数将来访问的页都是最近读取的页。因此，在一段时间后错误会逐渐减少，缺页率会降到很低。</p><p>读取策略决定某页何时取入内存，常用的两种方法是<strong>请求分页</strong>和<strong>预先分页</strong>。</p><p>对于请求分页，只有当访问到某页中的一个单元时才将该页取入内存。对于预先分页，读取的页并不是缺页中断请求的页。若一个进程的页连续存储在辅存中，则<strong>一次读取许多连续的页</strong>要比隔一段时间读取一页有效。</p><p>进程首先启动时或者发生缺页中断时，都可采用预先分配策略。</p><p>某个进程被换出内存并置于挂起态时，它的所有驻留页都会被换出。当该进程被唤醒时，所有以前在内存中的页都会被重新读回内存。</p><p><strong>清除策略</strong></p><p>与读取策略相反，清除策略用于确定何时将已修改的一页写回辅存。通常有两种选择：<strong>请求式清除和预约式清除</strong>。</p><p>对于请求式清除，只有当一页被选择用于置换时才被写回辅存；而预约式清除策略则将这些已修改的多页在需要使用它们所占据的页框之前成批写回辅存。</p><p>一种较好的方法是结合下一节介绍的<strong>页缓冲</strong>技术，这种技术允许采用下面的策略：只清除可用于置换的页。通过页缓冲，被置换页可放置在两个链表中：修改链表和未修改链表。修改链表中的页可以周期性地成批写出，并移到未修改链表中。未修改链表中的一页要么因为被访问到而被回收，要么在其页框分配给另一页时被淘汰。</p><h6 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h6><p>放置策略决定一个进程块驻留在实存中的什么位置。在段页式系统中，此策略无关紧要，<strong>因为地址转换硬件和内存访问硬件能以相同的效率为任何页框组合执行相应的功能</strong>。</p><h6 id="置换策略和页缓冲"><a href="#置换策略和页缓冲" class="headerlink" title="置换策略和页缓冲"></a>置换策略和页缓冲</h6><p>置换策略决定在必须读取一个新页时，应该置换内存中的哪一页。需要明确三个问题：</p><ol><li>给每个活动进程分配多少页框。</li><li>计划被置换的页集局限于那些产生缺页故障的进程，还是局限于所有页框都在内存中的进程。</li></ol><p>上面两个问题属于<strong>驻留集管理</strong>。置换策略专指第三个问题。</p><ol start="3"><li>在计划被置换的页集，选择换出哪一页。</li></ol><p><strong>所有置换策略的目标都是移出最近最不可能访问的页</strong>。根据局部性原理，最近的访问历史和最近将要访问的模式间有很大的相关性。因此，大多数策略都基于过去的行为来预测将来的行为。</p><p><strong>页框锁定</strong></p><p>内存中的某些页框可能是被锁定的。被锁定的页框中的页不能被置换。操作系统内核和重要的控制结构就需要保存在被锁定的页框中。锁定是通过给每个页框关联一个“锁定”位实现的，这一位可以包含在页框表和当前页表中。</p><p><strong>基本算法</strong></p><ul><li><p>最近最少使用（<code>LRU</code>，<code>Least Recently Used</code>）</p><p>  该策略选择置换内存中最长时间未被引用的页。根据局部性原理，这也是最近最不可能访问到的页。</p><p>  这种方法的问题是比较难以实现。一种实现方法是给每页添加一个最后一次访问的时间戳，并在每次访问内存时更新这个时间戳。另一种方法是维护一个关于访问页的栈，但开销同样很大。</p></li><li><p>先进先出（<code>FIFO</code>，<code>First In First Out</code>）</p><p>  FIFO 策略把分配给进程的页框视为一个循环缓冲区，并按循环方式移动页。它需要的只是一个指针，该指针在进程的页框中循环。</p><p>  这种方法所隐含的逻辑是置换驻留在内存中时间最长的页：很久以前取入内存的页，现在可能不会再用到。这一推断通常是错误的，因为经常会出现一部分程序或数据在整个程序的生命周期中使用频率都很高的情况，若使用 FIFO算法，则这些页需要被反复地换入和换出。</p></li><li><p>时钟（<code>Clock</code>）</p></li></ul><p><strong><em>页缓冲</em></strong>（<code>Page Cache</code>）</p><p>页缓冲能够提高分页的性能并允许使用较简单的页面置换策略。</p><p>使用页缓冲的置换算法不丢弃置换出的页。若该页未被修改，则将它分配到空闲页链表中；若已被修改，则分配到修改页链表中。<strong>注意，该页在内存中并不会物理性移动，移动的只是该页所对应的页表项，移动后的页表项放置在空闲页链表中或修改页链表中</strong>。</p><p>空闲页链表中包含有可被置换页的一系列页框，需要从磁盘中读取一页到内存中时，都将其放到空闲页链表头节点所指向的页框中，随后将头节点移除。注意，系统记录的被置换的页并不是链表头节点所指向的页。</p><p><strong>比如说，头节点当前指向内存中的页<code>a</code>，系统通过置换策略决定出要用磁盘中的页<code>b</code>置换内存中的页<code>c</code>。实际执行的操作是，将页<code>b</code>放置在页<code>a</code>中，如果页<code>c</code>未被修改，就将其加入到空闲页链表尾部，如果页<code>c</code>已被修改，就将其加入到修改页链表中</strong>。</p><p>这一骚操作的一个重要特点是，被置换的页仍然留在内存中。因此，若进程访问该页，则可迅速返回该进程的驻留集，且代价很小。实际上，空闲页链表和修改页链表充当着页的高速缓存的角色。</p><p>修改页链表还有另外―种很有用的功能：已修改的页按簇写回，而不是一次只写一页，因此大大减少了<code>I/O</code>操作的数量，进而减少了磁盘访问时间。</p><p><strong><em><code>Page Cache</code>和块缓冲（<code>Buffer Cache</code>）的区别</em></strong></p><p>首先要明确一点，<code>cache</code>是位于内存中的，是为了提高磁盘设备的<code>IO</code>性能。程序读磁盘设备中的数据时，首先把需要访问的数据页及其相邻页面统一读到内存（预读取策略），然后从内存中读取数据。程序向磁盘设备中的文件写数据时，先将数据写入内存，然后再将内存中的脏数据页定时统一的刷新到磁盘中。</p><p>这个用作磁盘数据缓存的内存就是所谓的<code>Buffer Cache</code>。主要是针对写数据场景的性能优化。也就是说<code>Buffer Cache</code>是作为磁盘数据读写而存在的。</p><p>然而，文件系统层为了提高文件读写的性能，也提供了文件系统级别的<code>Page Cache</code>。更多的是针对读数据场景的性能优化。也就是说<code>Page Cache</code>是作为文件读写而存在的。</p><p>其实针对的都是磁盘中的数据，有两个缓存显得没有必要了，因此，现有的<code>linux</code>系统版本已经将二者合并了，统称为<code>Page Cache</code>。其是通过<code>radix</code>树（基数树）数据结构实现的。</p><h6 id="驻留集管理"><a href="#驻留集管理" class="headerlink" title="驻留集管理"></a>驻留集管理</h6><p>驻留集是指一个进程被读取到内存中的页集。</p><ol><li>分配给一个进程的内存越少，在任何时候驻留在内存中的进程数就越多。这增加了操作系统至少找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间。</li><li>若一个进程在内存中的页数较少，尽管有局部性原理，缺页率仍相对较高。</li><li>然而，给进程分配的内存空间大到一定程度时，由于局部性原理，缺页率也不会有明显的降低。</li></ol><p><strong>固定分配策略</strong>为一个进程分配固定数量的页框，以供执行时使用。这个数量由进程创建时确定。对于这种策略，一旦在进程的执行过程中发生缺页中断，该进程的一页就必须被它所需要的页面置换。</p><p><strong>可变分配策略</strong>允许分配给一个进程的页框在该进程的生命周期中不断地发生变化。<strong>其大小可根据当前进程的缺页率大小来实时调整</strong>。理论上，若一个进程的缺页率一直比较高，则表明在该进程中局部性原理表现较弱，应给它多分配一些页框以减小缺页率；而若一个进程的缺页率特别低，则表明从局部性的角度看该进程的表现非常好，可在不明显增大缺页率的前提下减少分配给它的页框。</p><p><strong>置换范围</strong></p><p><strong>局部置换策略</strong>在产生这次缺页的进程的驻留页中选择，而<strong>全局置换策略</strong>则把内存中所有未被锁定的页都作为置换的候选页，而不管它们属于哪个进程。</p><h5 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a><code>Linux</code>内存管理</h5><p><img src="1356672578_8600.jpg" alt="1356672578_8600"></p><p><strong>虚存寻址</strong></p><p><img src="%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE.jpg" alt="虚拟地址访问"></p><p><code>Linux</code>使用三级页表结构（<strong>最新版本已经使用四级页表了</strong>），它由下面几种类型的表组成（每个表的大小都是一页）：</p><ul><li>顶级页表是页全局目录（<code>PGD</code>），它包含了一个<code>pgd_t</code>类型数组，多数体系结构中<code>pgd_t</code>类型等同于无符号长整型类型。<code>PGD</code>中的表项指向二级页目录中的表项：<code>PMD</code>。每个活动进程的页目录都必须在内存中。</li><li>二级页表是中间页目录（<code>PMD</code>），它是个<code>pmd_t</code>类型数组，其中的表项指向<code>PTE</code>中的表项。页中间目录可能跨越多个页。页中间目录中的每项指向页表中的一页。</li><li>最后一级的页表简称页表，其中包含了<code>pte_t</code>类型的页表项，该页表项指向物理页面。页表也可跨越多个页。每个页表项指向该进程的一个虚拟页。</li></ul><img src="image-20210326150018056.png" alt="image-20210326150018056" style="zoom:67%;" /><p><strong>页面分配</strong></p><p>页面分配为提升向内存中读入和从内存中写出页的效率，<code>Linux</code>定义了一种机制，用于把连续的页映射到连续的页框中。基于这一目的，它使用了<strong>伙伴系统</strong>。内核维护一系列大小固定的连续页框组，一组可以包含<code>1、2、4、8、16、32</code>个页框。当一页在内存中被分配或被解除分配时，可用的页框组使用伙伴算法来分裂或合并。</p><p><code>Linux</code>引入了一种新的分割<code>LRU</code>算法。</p><p>新算法给每个页表项添加了两个有效位：<code>PG_active</code>和<code>PG_referenced</code>。<code>Linux</code>的所有物理内存均基于它们的地址分配到两块“区域”，“激活”和“非激活”两个链表通过内存管理器来进行各区域的页面回收。内核驻留进程<code>kswapd</code>在后台周期性地执行各区域的页面回收，它扫描那些与系统页框对应的页表项。对于所有标记为访问过的页表项，启用<code>PG_referenced</code>有效位。处理器首次访问一个页面时，会启用这个标志位。<code>kswapd</code>每次迭代时，都会检查页表项中的页面访问过标志位是否被启用。<code>kswapd</code>在每次读取页面访问有效位后即将其清除。具体步骤如下：</p><ol><li>访问非激活链表中的一页时，<code>PG_referenced</code>有效位启用。</li><li>页面下次被访问时，<code>PG_active</code>被置位，并将其移动到激活链表。也就是说，页面经访问两次后被声明为激活。更准确地讲，两次不同扫描的访问才使得一个页面变为激活状态。</li><li>若第二次访问并未很快发生，则重置<code>PG_referenced</code>。</li><li>同样，激活的页面在两次超时之后也需要移动到非激活链表中。</li></ol><p>非激活链表中的页面然后可通过<code>LRU</code>算法被置换。</p><h6 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（<code>page</code>）</h6><p>内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字，但是，内存管理单元（<code>MMU</code>，管理内存并把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理。正因为如此，<code>MMU</code>以页大小为单位来管理系统中的页表。从虚拟内存的角度来看，页就是最小单位。</p><p>内核用<code>struct page</code>结构来表示系统中的每一个物理页，该结构位于<code>&lt;linux/mm_types.h&gt;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">atomic_t</span> _count;</span><br><span class="line">    <span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="keyword">pgoff_t</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">virtual</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flag</code>域用来存放页的状态。这些状态包括页是不是脏的，是不是被锁定在内存中等。这些标志被定义在<code>&lt;linux/page-flags.h&gt;</code>中。</p><p><code>count</code>域存放页的引用计数——也就是这一页被引用了多少次。当计数值变为<code>-1</code>时，就说明当前内核并没有引用这一页，于是，在新的分配中就可以使用它。内核代码不应当直接检查该域，而是调用<code>page_count()</code>函数进行检查，该函数唯一的参数就是<code>page</code>结构。当页空闲时，尽管该结构内部的<code>_count</code>值是负的，但是对<code>page_count()</code>函数而言，返回<code>0</code>表示页空闲，返回一个正整数表示页在使用。一个页可以由页缓存使用（这时，<code>mapping</code>域指向和这个页关联的<code>addresss_space</code>对象），或者作为私有数据（由<code>private</code>指向），或者作为进程页表中的映射。</p><p><code>virtual</code>域是页的虚拟地址。通常情况下，它就是页在虚拟内存中的地址。</p><p>必须要理解的一点是<code>page</code>结构与物理页相关，而并非与虚拟页相关。因此，该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，它们也可能并不再和同一个<code>page</code>结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关的物理页中存放的东西。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。</p><p>内核用这一结构来管理系统中所有的页，系统中的每个物理页都要分配一个这样的结构体。因为内核需要知道一个页是否空闲（也就是页有没有被分配）。如果页已经被分配，内核还需要知道谁拥有这个页。拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或页高速缓存（<code>Page Cache</code>）等。</p><h6 id="区（zone）"><a href="#区（zone）" class="headerlink" title="区（zone）"></a>区（<code>zone</code>）</h6><p>有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区。内核使用区对具有相似特性的页进行分组。</p><p><code>Linux</code>主要使用了三种区:</p><ul><li><code>ZONE_DMA</code>：这个区包含的页能用来执行<code>DMA</code>操作。</li><li><code>ZONE_NORMAL</code>：这个区包含的都是能正常映射的页。</li><li><code>ZONE_HIGHEM</code>：这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间。</li></ul><p>这些区在<code>&lt;linux/mmzone.h&gt;</code>中定义。</p><p><strong>区的实际使用和分布是与体系结构相关的</strong>。例如，某些体系结构在内存的任何地址上执行<code>DMA</code>都没有问题。在这些体系结构中，<code>ZONE_DMA</code>为空，<code>ZONE_NORMAL</code>就可以直接用于分配。与此相反，在<code>x86</code>体系结构上，<code>ISA</code>设备就不能在整个<code>32</code>位的地址空间中执行<code>DMA</code>，因为<code>ISA</code>设备只能访问物理内存的前<code>16MB</code>。因此，<code>ZONE_DMA</code>在<code>x86</code>上包含的页都在<code>0-16MB</code>的内存范围里。</p><p><code>Linux</code>把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。例如，<code>ZONE_DMA</code>内存池让内核有能力为<code>DMA</code>分配所需的内存。如果需要这样的内存，那么，内核就可以从<code>ZONE_DMA</code>中按照请求的数目取出页。</p><p>有些<code>64</code>位的体系结构，如<code>Intel</code>的<code>x86-64</code>体系结构可以映射和处理<code>64</code>位的内存空间，所以<code>x86-64</code>没有<code>ZONE_HIGHMEM</code>区，所有的物理内存都处于<code>ZONE_DMA</code>和<code>ZONE_NORMAL</code>区。</p><p>注意，区的划分没有任何物理意义，这只不过是内核为了管理页而采取的一种逻辑上的分组。</p><p>每个区都用<code>struct zone</code>表示，在<code>&lt;linux/mmzone.h&gt;</code>中定义。</p><p>这个结构体很大，但是，系统中只有三个区，因此，也只有三个这样的结构。</p><p><code>lock</code>域是一个自旋锁，它防止该结构被并发访问。注意，这个域只保护结构，而不保护驻留在这个区中的所有页。没有特定的锁来保护单个页。<code>watermark</code>数组持有该区的最小值、最低和最高水位值。内核使用水位为每个内存区设置合适的内存消耗基准。该水位随空闲内存的多少而变化。<code>name</code>域是一个以<code>NULL</code>结束的字符串表示这个区的名字。内核启动期间初始化这个值，其代码位于<code>mm/page_alloc.c</code>中。分别为“<code>DMA</code>“，“<code>Normal</code>”和“<code>HighMem</code>”。</p><h6 id="获得与释放页"><a href="#获得与释放页" class="headerlink" title="获得与释放页"></a>获得与释放页</h6><table><thead><tr><th align="left">内核接口</th><th>解释</th></tr></thead><tbody><tr><td align="left"><code>struct page* alloc_pages(gfp_t gfp_mask, unsigned int order)</code></td><td>该函数分配2^order^ (<code>1 &lt;&lt; order</code>）个连续的物理页，并返回一个指针，该指针指向第一个页的<code>page</code>结构体，如果出错，就返回<code>NULL</code>。</td></tr><tr><td align="left"><code>void free_pages(unsigned long addr, unsigned int order)</code></td><td>释放页，释放页时要谨慎，只能释放属于你的页。传递了错误的<code>struct page</code>或地址，用了错误的<code>order</code>值，这些都可能导致系统崩溃。</td></tr><tr><td align="left"><code>void kmalloc(size_t size, gfp_t flags)</code></td><td>这个函数返回一个指向以字节为单位内存块的指针。所分配的内存区在物理上是连续的。出错，返回<code>NULL</code>。它确保页在物理地址上是连续的。</td></tr><tr><td align="left"><code>void kfree(const void *ptr)</code></td><td>释放由<code>kmalloc()</code>分配出来的内存块。如果释放的内存不是由<code>kmalloc()</code>分配的，或者释放的内存早就被释放了，调用这个函数就会导致严重的后果。调用<code>kfree(NULL)</code>是安全的。</td></tr><tr><td align="left"><code>void* vmalloc(unsigned long size)</code></td><td>分配的内存虚拟地址是连续的，而物理地址则无须连续。它通过分配非连续的物理内存块，再“修正”页表，把内存映射到逻辑地址空间的连续区域中。</td></tr><tr><td align="left"><code>void vfree(const void* addr)</code></td><td>要释放通过<code>vmalloc()</code>获得的内存。</td></tr></tbody></table><p>大多数情况下，只有硬件设备需要得到物理地址连续的内存。在很多体系结构上，硬件设备存在于内存管理单元以外，它根本不理解什么是虚拟地址。因此，硬件设备用到的任何内存区都必须是物理上连续的块，而不仅仅是虚拟地址连续上的块。而仅供软件使用的内存块（例如与进程相关的缓冲区）就可以使用只有虚拟地址连续的内存块。对内核而言，所有内存看起来都是逻辑上连续的。</p><h5 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h5><p>内核除了管理本身的内存外，还必须管理用户空间中进程的内存。我们称这个内存为进程地址空间，也就是系统中每个用户空间进程所看到的内存。<code>Linux</code>系统中的所有进程之间以虚拟方式共享内存。对一个进程而言，它好像都可以访问整个系统的所有物理内存。即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。</p><p>进程地址空间由进程可寻址的虚拟内存组成，内核允许进程使用这种虚拟内存中的地址。每个进程都有一个<code>32</code>位或<code>64</code>位的平坦地址空间。术语“平坦”指的是地址空间范围是一个独立的连续区间。一个进程的地址空间与另一个进程的地址空间即使有相同的内存地址，实际上也彼此互不相干。这样的进程也就是<code>Linux</code>中所谓的线程。</p><p>内存地址是一个给定的值，它要在地址空间范围之内，比如<code>4021F000</code>。这个值表示的是进程32位地址空间中的一个特定的字节。尽管一个进程可以寻址<code>4GB</code>的虚拟内存（在32位的地址空间中)，但这并不代表它就有权访问所有的虚拟地址。在地址空间中，我们更为关心的是一些虚拟内存的地址区间，比如<code>08048000 - 0804C000</code>，它们可被进程访问。这些可被访问的合法地址空间称为内存区域。<strong>通过内核，进程可以给自己的地址空间动态地添加或减少内存区域</strong>。</p><p>进程只能访问有效内存区域内的内存地址。每个内存区域也具有相关权限如对相关进程有可读、可写、可执行属性。<strong>如果一个进程访问了不在有效范围中的内存区域，或以不正确的方式访向了有效地址</strong>，那么内核就会终止该进程，并返回“<strong>段错误</strong>”信息。</p><h6 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h6><p><code>Linux</code>内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由<code>mm_struct</code>结构体表示，下面给出内存描述符结构中各个域的描述，请大家结合前面的进程内存段布局图一起看：</p><p><img src="20170112101815302.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span> <span class="comment">/* 内存区域组织成链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span> <span class="comment">/* 内存区域组织成红黑树 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">/* 最近使用的内存区域 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_area_cache; <span class="comment">/* 地址空间第一个空洞 */</span></span><br><span class="line">    <span class="keyword">pgd_t</span> *pgd; <span class="comment">/* 页全局目录 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_users; <span class="comment">/* 使用地址空间的用户数 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_count; <span class="comment">/* 主使用计数器 */</span></span><br><span class="line">    <span class="keyword">int</span> map_count; <span class="comment">/* 内存区域的个数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span> <span class="comment">/* 内存区域的信号量 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> page_table_lock; <span class="comment">/* 页表锁 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span> <span class="comment">/* 所有 mm_struct 形成的链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rss; <span class="comment">/* 所分配的物理页 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm; <span class="comment">/* 全部页面数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm; <span class="comment">/* 上锁的页面数据 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pinned_vm; <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shared_vm; <span class="comment">/* 共享页面数目 Shared pages (files) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm; <span class="comment">/* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm; <span class="comment">/* 栈区页面数目 VM_GROWSUP/DOWN */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</span><br><span class="line">    <span class="comment">/* 代码段、数据段 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;<span class="comment">/* 堆区起始地址和结束地址, 进程栈区的起始地址 */</span></span><br><span class="line">    <span class="comment">/* 命令行参数 和 环境变量的 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="keyword">mm_context_t</span> context; <span class="comment">/* 体系结构特殊数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* 状态标志位 */</span></span><br><span class="line">    <span class="comment">/* Coredumping and NUMA and HugePage 相关结构体 */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mm_count</code>代表了对<code>mm_strcut</code>本身的引用，而<code>mm_users</code>代表对<code>mm_struct</code>相关资源的引用，分了两个层次。<code>mm_count</code>类似于以进程为单位。 <code>mm_users</code>类似于以线程为单位。内核线程在运行时会借用其他进程的<code>mm_struct</code>，这样的线程叫<code>anonymous users</code>，因为他们不关心<code>mm_struct</code>指向的用户空间，也不会去访问这个用户空间，他们只是临时借用（比如说当进程执行系统调用陷入到内核中，内核会借用该进程的地址空间）。<code>mm_count</code>记录这样的进程数。<code>mm_users</code>是对<code>mm_struct</code>所指向的用户空间进行共享的所有进程的计数。也就是说，会有多个进程共享同一个用户空间， 这些进程也就是所谓的线程。</p><p><code>mmap</code>和<code>mm_rb</code>这两个不同数据结构体描述的对象是相同的：该地址空间中的全部内存区域。但是前者以链表形式存放而后者以红黑树的形式存放。<code>mmap</code>结构体作为链表，利于简单、高效地遍历所有元素；而<code>mm_rb</code>结构体作为红黑树，更适合搜索定位指定元素。</p><p>所有的<code>mm_struct</code>结构体都通过自身的<code>mmlist</code>域连接在一个双向链表中，该链表的首元素是<code>init_mm</code>内存描述符，它代表<code>init</code>进程的地址空间。另外要注意，操作该链表的时候需要使用<code>mmlist_lock</code>锁来防止并发访问，该锁定义在文件<code>kernel/fork.c</code>中。</p><p>每个进程都有自己的页表（当然，线程会共享页表）。内存描述符的<code>pgd</code>域指向的就是进程的页全局目录。</p><h6 id="内存描述符的分配与撤销"><a href="#内存描述符的分配与撤销" class="headerlink" title="内存描述符的分配与撤销"></a>内存描述符的分配与撤销</h6><p>在进程的进程描述符（即<code>task_struct</code>结构体）中，<code>mm</code>域存放着该进程使用的内存描述符，所以<code>current-&gt;mm</code>便指向当前进程的内存描述符。<code>fork()</code>函数利用<code>copy_mm()</code>函数复制父进程的内存描述符，也就是<code>current-&gt;mm</code>域给其子进程，而子进程中的<code>mm_struct</code>结构体实际是通过文件<code>kernel/fork.c</code>中的<code>allocate_mm()</code>宏从<code>mm_cachep slab</code>缓存中分配得到的。通常，每个进程都有唯一的<code>mm_struct</code>结构体，即唯一的进程地址空间。</p><p>如果父进程希望和其子进程共享地址空间，可以在调用<code>clone()</code>时，设置<code>CLONE_VM</code>标志。我们把这样的进程称作线程。当<code>CLONE_VM</code>被指定后，内核就不再需要调用<code>allocate_mm()</code>函数了，而仅仅需要调用<code>copy_mm()</code>函数中将<code>mm</code>域指向其父进程的内存描述符就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(clone_flags &amp; CLONE_vM)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// current 是父进程而 tsk 在 fork(）执行期间是子进程</span></span><br><span class="line">    atomic_inc(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">    tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进程退出时，内核会调用定义在<code>kernel/exit.c</code>中的<code>exit_mm()</code>函数，该函数执行一些常规的撤销工作，同时更新一些统计量。其中，该函数会调用<code>mmput()</code>函数减少内存描述符中的<code>mm_users</code>用户计数，如果用户计数降到零，将调用<code>mmdrop()</code>函数，减少<code>mm_count</code>使用计数。如果<code>mm_count</code>也等于零了，说明该内存描述符不再有任何使用者了，那么调用<code>free_mm()</code>宏通过<code>kmem_cache_free()</code>函数将<code>mm_struct</code>结构体归还到<code>mm_cachep slab</code>缓存中。</p><p>内核线程没有进程地址空间，也没有相关的内存描述符。所以内核线程对应的进程描述符中<code>mm</code>域为空。事实上，这也正是内核线程的真实含义——它们没有用户上下文。当一个进程被调度时，该进程的<code>mm</code>域指向的地址空间被装载到内存，进程描述符中的<code>active_mm</code>域会被更新，指向新的地址空间。内核线程没有地址空间，所以<code>mm</code>域为<code>NULL</code>。于是，当一个内核线程被调度时，内核发现它的<code>mm</code>域为<code>NULL</code>，就会保留前一个进程的地址空间，随后内核更新内核线程对应的进程描述符中的<code>active_mm</code>域，使其指向前一个进程的内存描述符。</p><p>所以在需要时，内核线程便可以使用前一个进程的页表。因为内核线程不访问用户空间的内存，所以它们仅仅使用地址空间中和内核内存相关的信息，这些信息的含义和普通进程完全相同（要知道用户进程的地址空间是包含分配给内核的那<code>1G</code>的空间的，只不过是不允许访问而已，所以内核线程借用前一个进程的地址空间是用来访问属于内核的那<code>1G</code>空间的）。</p><h6 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h6><p>每个和进程相关的内存区域都对应于一个<code>vm_area_struct</code>结构体。<code>vm_area_struct</code>结构体描述了指定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都拥有一致的属性，比如访问权限等，另外，相应的操作也都一致。按照这样的方式，每一个<code>VMA</code>就可以代表不同类型的内存区域（比如内存映射文件或者进程用户空间栈），下面给出该结构定义和各个域的描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>        <span class="comment">// 相关的 mm_struct 结构体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;         <span class="comment">// 区间的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;           <span class="comment">// 区间的尾地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span> <span class="comment">// VMA 链表</span></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;          <span class="comment">// 访问控制权限</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags; <span class="comment">//标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span> <span class="comment">//树上该 VMA 的节点</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 或者是关联于 address_space-&gt;i_mmap 字段</span></span><br><span class="line">        <span class="comment">// 或者是关联于 address_space-&gt;i_mmap_nonlinear 字段</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="keyword">void</span> *parent;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_truct</span> <span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span>      <span class="comment">// anon_vma 项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>           <span class="comment">//匿名VMA对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">vin_ops</span>;</span> <span class="comment">// 相关的操作表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="number">1</span>ong vm_pgoff;              <span class="comment">// 文件中的偏移量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">vm_file</span>;</span>                <span class="comment">// 被映射的文件（如果存在)</span></span><br><span class="line">    <span class="keyword">void</span> *vm_private_data;               <span class="comment">// 私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个内存描述符都对应于进程地址空间中的唯一区间。<code>vm_start</code>域指向区间的首地址（最低地址），<code>vm_end</code>域指向区间的尾地址（最高地址）之后的第一个字节。注意，在同一个地址空间内的不同内存区间不能重叠。</p><p><code>vm_mm</code>域指向和<code>VMA</code>相关的<code>mm_struct</code>结构体，注意，每个<code>VMA</code>对其相关的<code>mm_struct</code>结构体来说都是唯一的，所以即使两个独立的进程将同一个文件映射到各自的地址空间，它们分别都会有一个<code>vm_area_struct</code>结构体来标志自己的内存区域；反过来，如果两个线程共享一个地址空间，那么它们也同时共享其中的所有<code>vm_area_struct</code>结构体。</p><p>上文讨论过，可以通过内存描述符中的<code>mmap</code>和<code>mm_rb</code>域之一访问内存区域。<code>mmap</code>域使用单独链表连接所有的内存区域对象。每一个<code>vm_area_struet</code>结构体通过自身的<code>vm_next</code>域被连入链表，所有的区域按地址增长的方向排序，<code>mmap</code>域指向链表中第一个内存区域，链中最后一个结构体指针指向空。<code>mm_rb</code>域使用红黑树连接所有的内存区域对象。<code>mm_rb</code>域指向红黑树的根节点，地址空间中每一个<code>vm_area_struct</code>结构体通过自身的<code>vm_rb</code>域连接到树中。</p><h6 id="创建和删除地址空间"><a href="#创建和删除地址空间" class="headerlink" title="创建和删除地址空间"></a>创建和删除地址空间</h6><p>内核使用<code>do_mmap()</code>函数创建一个新的线性地址区间。如果创建的地址区间和一个已存在的地址区间相邻，并且它们具有相同的访问权限的话，两个区间将合并为一个。映射时，从<code>vm_area_cachep</code>长字节（<code>slab</code>）缓存中分配一个<code>vm_area_struct</code>结构体，并且使用<code>vma_link()</code>函数将新分配的内存区域添加到地址空间的内存区域链表和红黑树中，随后还要更新内存描述符中的<code>total_vm</code>域，然后才返回新分配的地址区间的初始地址。</p><p><code>do_mmap()</code>函数定义在文件<code>&lt;linux/mm.h&gt;</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数映射由<code>file</code>指定的文件，具体映射的是文件中从偏移<code>offset</code>处开始，长度为<code>len</code>字节的范围内的数据。如果<code>file</code>参数是<code>NULL</code>并且<code>offset</code>参数也是<code>0</code>，那么就代表这次映射没有和文件相关，该情况称作匿名映射（<code>anonymous mapping</code>）。如果指定了文件名和偏移量，那么该映射称为文件映射（<code>file-backed mapping</code>）。</p><p><code>addr</code>是可选参数，它指定搜索空闲区域的起始位置。<code>prot</code>参数指定内存区域中页面的访问权限。访问权限标志定义在文件<code>&lt;asm/mman.h&gt;</code>中。</p><p>在用户空间可以通过<code>mmap()</code>系统调用获取内核函数<code>do_mmap()</code>的功能。<code>mmap()</code>系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap2</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> pgoff)</span></span>;</span><br></pre></td></tr></table></figure><p>由于该系统调用是<code>mmap()</code>调用的第二种变种，所以起名为<code>mmap2()</code>。最原始的<code>mmap()</code>调用中最后一个参数是字节偏移量，而目前这个<code>mmap2()</code>使用页面偏移作最后一个参数。使用页面偏移量可以映射更大的文件和更大的偏移位置。原始的<code>mmap()</code>调用由<code>POSIX</code>定义，仍然在<code>C</code>库中作为<code>mmap()</code>方法使用，但是内核中已经没有对应的实现了，而实现的是新方法<code>mmap2()</code>。虽然<code>C</code>库仍然可以使用原始版本的映射方法，但是它其实还是基于函数<code>mmap2</code>进行的，对原始<code>mmap()</code>方法的调用是通过将字节偏移转化为页面偏移，从而转化为对<code>mmap2()</code>函数的调用来实现的。</p><p><code>do_mummap()</code>函数从特定的进程地址空间中删除指定地址区间，该函数定义在文件<code>&lt;linux/mm.h&gt;</code>中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_mummap</span><span class="params">(struct mm_struct *mm , <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数指定要删除区域所在的地址空间，删除从地址<code>start</code>开始，长度为<code>len</code>字节的地址区间。如果成功，返回零。否则，返回负的错误码。</p><p>系统调用<code>munmap</code>()给用户空间程序提供了一种从自身地址空间中删除指定地址区间的方法，它和系统调用<code>mmap()</code>的作用相反，该系统调用定义在文件<code>mm/mmap.c</code>中，它是对<code>do_mummap()</code>函数的一个简单的封装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="进程用户栈、线程栈、进程内核栈、中断栈"><a href="#进程用户栈、线程栈、进程内核栈、中断栈" class="headerlink" title="进程用户栈、线程栈、进程内核栈、中断栈"></a>进程用户栈、线程栈、进程内核栈、中断栈</h5><p><strong>进程用户栈</strong></p><p>进程栈是属于用户态栈，和进程虚拟地址空间 (<code>Virtual Address Space</code>) 密切相关。那我们先了解下什么是虚拟地址空间：在<code>32</code>位机器下，虚拟地址空间大小为<code>4G</code>。这些虚拟地址通过页表 (<code>Page Table</code>) 映射到物理内存，页表由操作系统维护，并被处理器的内存管理单元 (<code>MMU</code>) 硬件引用。每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。</p><p><code>Linux</code>内核将这<code>4G</code>字节的空间分为两部分，将最高的<code>1G</code>字节（<code>0xC0000000</code>- <code>0xFFFFFFFF</code>）供内核使用，称为内核空间。而将较低的<code>3G</code>字节（<code>0x00000000</code> - <code>0xBFFFFFFF</code>）供各个进程使用，称为用户空间。每个进程可以通过系统调用陷入内核态，因此内核空间是由所有进程共享的。虽然说内核和用户态进程占用了这么大地址空间，但是并不意味它们使用了这么多物理内存，仅表示它可以支配这么大的地址空间。它们是根据需要，将物理内存映射到虚拟地址空间中使用。</p><img src="20160901214930068.jpg" alt="Linux虚拟地址空间" style="zoom:150%;" /><p><code>Linux</code>对进程地址空间有个标准布局，地址空间中由各个不同的内存段组成 (<code>Memory Segment</code>)，主要的内存段如下：</p><ul><li>程序段 (<code>Text Segment</code>)：可执行文件代码的内存映射。</li><li>数据段 (<code>Data Segment</code>)：可执行文件的已初始化全局变量的内存映射。</li><li><code>BSS</code>段 (<code>BSS Segment</code>)：未初始化的全局变量或者静态变量（<strong><u>映射到零页</u></strong>）。</li><li>堆区 (<code>Heap</code>) : 存储动态内存分配，匿名的内存映射（<code>malloc</code>分配的内存区域）。</li><li>栈区 (<code>Stack</code>) : 进程用户空间栈，由编译器自动分配释放，存放函数的参数值、局部变量的值等。</li><li>映射段（<code>Memory Mapping Segment</code>）：任何内存映射文件，如每一个诸如C库或动态连接程序等共享库的代码段、数据段和<code>BSS</code>也会被载入进程的地址空间。</li></ul><p><u><strong>可执行文件的<code>BSS</code>段未存储在磁盘上，内核将零页面映射到<code>BSS</code>范围</strong></u>。</p><p>因为在创建新进程时预期<code>BSS</code>段将被初始化为零，并且仅在可执行文件中存储一堆零浪费了空间，所以可执行文件仅指示<code>BSS</code>段应从何处开始以及应该从多大。</p><p>当内核从可执行文件构建新进程时，它将为<code>BSS</code>范围创建到零页面的映射，该页面是全零的静态（虚拟）页面。该映射设置有<strong>写时复制</strong>功能，因此，新进程首次向其中一个<code>BSS</code>页进行写入时，在允许写入完成之前，静态零页的实际副本将分配到另一个内存页中。 这样做有如下几点好处：</p><ol><li>节省了可执行文件中的空间。</li><li>避免了实际分配可能永远不会被该进程触及的<code>BSS</code>页面，从而节省了内存使用量。</li><li>同时仍然提供了确保每个进程中的<code>BSS</code>段看起来都是零初始化的保证。</li></ol><p><img src="20160901214948512.jpg" alt="20160901214948512"></p><p>而上面进程虚拟地址空间中的栈区，正指的是我们所说的进程栈。进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，<code>Linux</code>内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制<code>RLIMIT_STACK</code>（一般为<code>8M</code>），我们可以通过<code>ulimit</code>来查看或更改<code>RLIMIT_STACK</code>的值。</p><p><strong>如何确认进程栈的大小</strong></p><p>我们要知道栈的大小，那必须得知道栈的起始地址和结束地址。栈起始地址获取很简单，只需要嵌入汇编指令获取栈指针<code>esp</code>寄存器的值即可。栈结束地址的获取有点麻烦，我们需要先利用递归函数把栈搞溢出了，然后再<code>GDB</code>中把栈溢出的时候把栈指针<code>esp</code>寄存器的值打印出来即可。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file name: stacksize.c */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *orig_stack_pointer;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blow_stack</span><span class="params">()</span> </span>&#123; blow_stack(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">"movl %esp, orig_stack_pointer"</span>);</span><br><span class="line"></span><br><span class="line">    blow_stack();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ g++ -g stacksize.c -o ./stacksize</span><br><span class="line">$ gdb ./stacksize</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/home/misc-code/setrlimit</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">blow_stack () at setrlimit.c:<span class="number">4</span></span><br><span class="line"><span class="number">4</span>       blow_stack();</span><br><span class="line">(gdb) print (<span class="keyword">void</span> *)$esp</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0xffffffffff7ff000</span></span><br><span class="line">(gdb) print (<span class="keyword">void</span> *)orig_stack_pointer</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">void</span> *) <span class="number">0xffffc800</span></span><br><span class="line">(gdb) print <span class="number">0xffffc800</span><span class="number">-0xff7ff000</span></span><br><span class="line">$<span class="number">3</span> = <span class="number">8378368</span><span class="comment">// Current Process Stack Size is 8M</span></span><br></pre></td></tr></table></figure><p><strong>进程栈的动态增长实现</strong></p><p>进程在运行的过程中，通过不断向栈区压入数据，当超出栈区容量时，就会耗尽栈所对应的内存区域，这将触发一个 缺页异常 (<code>page fault</code>）。通过异常陷入内核态后，异常会被内核的<code>expand_stack()</code>函数处理，进而调用 <code>acct_stack_growth()</code>来检查是否还有合适的地方用于栈的增长。</p><p>如果栈的大小低于<code>RLIMIT_STACK</code>（通常为<code>8MB</code>），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情，这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会发生栈溢出（<code>stack overflow</code>），进程将会收到内核发出的段错误（<code>segmentation fault</code>）信号。</p><p>动态栈增长是唯一一种访问未映射内存区域而被允许的情形，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。</p><p><strong>线程栈</strong></p><p>从<code>Linux</code>内核的角度来说，其实它并没有线程的概念。<code>Linux</code>把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了<code>task_struct</code>中。线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和<code>Linux</code>中所谓线程的唯一区别。线程创建的时候，加上了<code>CLONE_VM</code>标记，这样 线程的内存描述符 将直接指向父进程的内存描述符。</p><p>虽然线程的地址空间和进程一样，但是对待其地址空间的栈<code>stack</code>还是有些区别的。对于<code>Linux</code>进程或者说主线程，其<code>stack</code>是在<code>fork</code>的时候生成的，实际上就是复制了父亲的<code>stack</code>空间地址，然后写时拷贝 (<code>cow</code>) 以及动态增长。然而对于主线程生成的子线程而言，其<code>stack</code>将不再是这样的了，而是事先固定下来的，使用<code>mmap</code>系统调用，它不带有<code>VM_STACK_FLAGS</code>标记。</p><p>这个可以从<code>glibc</code>的<code>nptl/allocatestack.c</code>中的<code>allocate_stack()</code>函数中看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem = mmap (<span class="literal">NULL</span>, size, prot, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>由于线程的<code>mm-&gt;start_stack</code>栈地址和所属进程相同，所以线程栈的起始地址并没有存放在<code>task_struct</code>中，应该是使用<code>pthread_attr_t</code>中的<code>stackaddr</code>来初始化<code>task_struct-&gt;thread-&gt;sp</code>（<code>sp</code>指向<code>struct pt_regs</code>对象，该结构体用于保存用户进程或者线程的寄存器现场）。这些都不重要，重要的是，线程栈不能动态增长，一旦用尽就没了，这是和生成进程的<code>fork</code>不同的地方。由于线程栈是从进程的地址空间中<code>map</code>出来的一块内存区域，原则上是线程私有的。</p><p><strong>进程内核栈</strong></p><p>在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作进程内核栈。进程内核栈在进程创建的时候，通过<code>slab</code>分配器从<code>thread_info_cache</code>缓存池中分配出来，其大小为<code>THREAD_SIZE</code>，一般来说是一个页大小<code>4K</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>thread_union</code>进程内核栈和<code>task_struct</code>进程描述符有着紧密的联系。由于内核经常要访问<code>task_struct</code>，高效获取当前进程的描述符是一件非常重要的事情。因此内核将进程内核栈的头部一段空间，用于存放<code>thread_info</code>结构体，而此结构体中则记录了对应进程的描述符，两者关系如下图：</p><img src="20160901215111055.jpg" alt="img" style="zoom:150%;" /><p>有了上述关联结构后，内核可以先获取到栈顶指针<code>esp</code>，然后通过<code>esp</code>来获取<code>thread_info</code>。这里有一个小技巧，直接将<code>esp</code>的地址与上<code>~(THREAD_SIZE - 1)</code>后即可直接获得<code>thread_info</code>的地址。由于<code>thread_union</code>结构体是从<code>thread_info_cache</code>的<code>Slab</code>缓存池中申请出来的，而<code>thread_info_cache</code>在<code>kmem_cache_create</code>创建的时候，保证了地址是<code>THREAD_SIZE</code>对齐的。因此只需要对栈指针进行<code>THREAD_SIZE</code>对齐，即可获得<code>thread_union</code>的地址。成功获取到<code>thread_info</code>后，直接取出它的<code>task</code>成员就成功得到了<code>task_struct</code>。其实上面这段描述，也就是<code>current</code>宏的实现方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> current_stack_pointer <span class="title">asm</span> <span class="params">(<span class="string">"sp"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_current() (current_thread_info()-&gt;task)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> current get_current()</span></span><br></pre></td></tr></table></figure><p><strong>中断栈</strong></p><p>进程陷入内核态的时候，需要内核栈来支持内核函数调用。中断也是如此，当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关。</p><p><code>x86</code>上中断栈就是独立于内核栈的；独立的中断栈所在内存空间的分配发生在<code>arch/x86/kernel/irq_32.c</code>的<code>irq_ctx_init()</code>函数中（如果是多处理器系统，那么每个处理器都会有一个独立的中断栈），函数使用<code>__alloc_pages</code>在低端内存区分配<code>2</code>个物理页面，也就是<code>8KB</code>大小的空间。有趣的是，这个函数还会为<code>softirq</code>分配一个同样大小的独立堆栈。如此说来，<code>softirq</code>将不会在<code>hardirq</code>的中断栈上执行，而是在自己的上下文中执行。</p><p><strong>为什么需要单独的进程内核栈？</strong></p><p>（<strong>为什么需要单独的线程栈？进程和线程是否共享一个内核栈？</strong>）</p><p>所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程<code>A</code>陷入内核态执行的时候，需要等待读取网卡的数据，主动调用<code>schedule()</code>让出<code>CPU</code>；此时调度器唤醒了另一个进程<code>B</code>，碰巧进程<code>B</code>也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程<code>B</code>进入内核态的时候产生的压栈操作，必然会破坏掉进程<code>A</code>已有的内核栈数据；一但进程<code>A</code>的内核栈数据被破坏，很可能导致进程<code>A</code>的内核态无法正确返回到对应的用户态了。</p><p>**这三个问题很好理解，只要可被调度执行的对象之间共用一个栈（无论进程栈，内核栈还是线程栈），那必然会有出错的机会，所以不能共用。进程和同一个进程的线程都是可被调度执行的对象！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之并发与同步</title>
      <link href="/29s2fW7i8PsxWCiK/"/>
      <url>/29s2fW7i8PsxWCiK/</url>
      
        <content type="html"><![CDATA[<h5 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h5><p>在单处理器多道程序设计系统中，进程会被交替地执行，因而表现出一种并发执行的外部特征。支持并发进程的基本需求是加强互斥的能力。也就是说，当一个进程被授予互斥能力时，那么在其活动期间，它具有排斥所有其他进程的能力。</p><p>并发包括很多设计问题，其中有进程间通信、资源共享与竞争（如内存、文件、<code>I/O</code>访问)、多个进程活动的同步以及给进程分配处理器时间等。并发问题源于多道程序设计系统的一个基本特性：进程的相对执行速度不可预测，它取决于其他进程的活动、操作系统处理中断的方式以及操作系统的调度策略。</p><a id="more"></a><table><thead><tr><th align="center">术语</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">临界区</td><td align="center">一段代码，在这段代码中进程将访问共享资源，当另外一个进程已在这段代码中运行时，这个进程就不能在这段代码中执行</td></tr><tr><td align="center">死锁</td><td align="center">两个或两个以上的进程因每个进程都在等待其他进程做完某些事情而不能继续执行的情形</td></tr><tr><td align="center">互斥</td><td align="center">当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源的情形</td></tr><tr><td align="center">竞争条件</td><td align="center">多个线程或进程在读写一个共享数据时，结果依赖于它们执行的相对时间的情形</td></tr><tr><td align="center">饥饿</td><td align="center">一个可运行进程尽管能继续执行，但被调度程序无限期地忽视，而不能被调度执行的情形</td></tr><tr><td align="center">原子操作</td><td align="center">保证指令序列要么作为一个组来执行，要么都不执行</td></tr></tbody></table><p>如果需要保护共享的全局变量（以及其他共享的全局资源），唯一的办法是控制访问该变量的代码。</p><p><strong><em>原子性和顺序性</em></strong></p><p>原子性确保指令执行期间不被打断，要么全部执行完，要么根本不执行。另一方面，顺序性确保即使两条或多条指令出现在独立的执行线程中，甚至独立的处理器上，它们本该的执行顺序却依然要保持。顺序性通过屏障（<code>barrier</code>）指令来实施。</p><h5 id="进程交互的分类"><a href="#进程交互的分类" class="headerlink" title="进程交互的分类"></a>进程交互的分类</h5><ul><li>进程之间互相不知道对方的存在，它们表现出<strong>竞争</strong>关系</li><li>进程间接知道对方的存在，但它们共享某些对象，表现出通过<strong>共享合作</strong>的关系</li><li>进程直接知道对方的存在，可以通过进程ID互相传递消息进行通信，表现出通过<strong>通信合作</strong>的关系</li></ul><p><strong>竞争进程</strong>面临三个控制问题：</p><ol><li><p>互斥</p><p> 假设两个或更多的进程需要访问一个不可共享的资源，如打印机。在执行过程中，每个进程都给该<code>IO</code>设备发命令，接收状态信息，发送数据和接收数据。我们把这类资源称为临界资源，使用临界资源的那部分程序称为程序的临界区。一次只允许有一个程序在临界区中，这一点非常重要。</p></li></ol><p>为了实现互斥则产生了下面两个问题：</p><ol start="2"><li><p>死锁</p><p> 考虑两个进程<code>P1</code>和<code>P2</code>，以及两个资源<code>R1</code>和<code>R2</code>，假设每个进程为执行部分功能都需要访问这两个资源，那么就有可能出现下列情况：操作系统把<code>R1</code>分配给<code>P2</code>，把<code>R2</code>分配给<code>P1</code>，每个进程都在等待另一个资源，且在获得其他资源并完成功能前，谁都不会释放自己已拥有的资源，此时这两个进程就会发生死锁。</p></li><li><p>饥饿</p><p> 假设有三个进程（<code>P1</code>、<code>P2</code>和<code>P3</code>），每个进程都周期性地访问资源<code>R</code>。假设操作系统把访问权轮流授予<code>P1</code>和<code>P3</code>，那么即使没有死锁，<code>P2</code>也可能被无限地拒绝访间资源。</p></li></ol><p><strong>合作进程</strong>和竞争进程的唯一区别是可以按两种不同的模式（读和写）访问数据项，并且<strong>只有写操作必须保证互斥</strong>。除了面临上面三个问题外，还有一个新的要求：<strong>数据一致性</strong>。</p><p>若使用临界区来保护数据的一致性，则没有确定的资源或变量可作为参数。此时，可以把参数视为一个在并发进程间共享的标识符，用于标识必须互斥的临界区。</p><h5 id="互斥的要求以及实现"><a href="#互斥的要求以及实现" class="headerlink" title="互斥的要求以及实现"></a>互斥的要求以及实现</h5><ol><li>必须强制实施互斥：在与相同资源或共享对象的临界区有关的所有进程中，一次只允许一个进程进入临界区。</li><li>没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入。</li><li>一个进程驻留在临界区中的时间必须是有限的。</li></ol><p><strong><em>硬件支持的实现</em></strong></p><ol><li><p>禁用中断</p><p> 为保证互斥，只需保证一个进程不被中断即可，这种能力可通过系统内核为启用和禁用中断定义的原语来提供。但代价非常高。</p></li><li><p>专用机器指令</p><p> 在硬件级别上，对存储单元的访问排斥对相同单元的其他访问。因此，处理器的设计者人员提出了一些机器指令，用于保证两个动作的原子性。</p></li></ol><p><strong><em>软件支持的实现</em></strong></p><table><thead><tr><th>并发机制</th><th align="left">解释</th></tr></thead><tbody><tr><td>信号量</td><td align="left">用于进程间传递信号的一个整数值。在信号量上只可进行三种操作，即初始化、递减和递增，它们都是原子操作。递减操作用于阻塞一个进程，递增操作用于解除一个进程的阻塞</td></tr><tr><td>二元信号量</td><td align="left">只取<code>0</code>值和<code>1</code>值的信号量</td></tr><tr><td>互斥量</td><td align="left">类似于二元信号量。关键区别在于为其加锁（设定值为<code>0</code>）的进程和为其解锁（设定值为<code>1</code>）的进程必须为同一个进程，一般被用在构造临界区上</td></tr><tr><td>条件变量</td><td align="left">一种数据类型，用于阻塞进程或线程，直到特定的条件为真</td></tr><tr><td>自旋锁</td><td align="left">一种互斥机制，进程在一个无条件循环中执行，等待锁变量的值可用</td></tr></tbody></table><h6 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h6><p><code>Linux</code>中的信号量是一种<strong>睡眠</strong>锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放）后，处于等待队列中的那个任务将被唤醒。</p><p>我们可以从信号量的睡眠特性得出一些有意思的结论：</p><ul><li>由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况。</li><li>相反，锁被短时间持有时，使用信号量就不太适宜了。因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁被占用的全部时间还要长。</li><li>面于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下文中是不能进行调度的。</li><li>你可以在持有信号量时去睡眠，因为当其他进程试图获得同一信号量时不会因此而死锁（因为该进程也只是去睡眠而已，而你最终会继续执行的）。</li></ul><p>为达到预期效果，可把信号量视为一个值为整数的变量，整数值上定义了三个操作：</p><ol><li>一个信号量可以初始化成非负数。</li><li><code>semWait</code>操作使信号量减<code>1</code>。若值变成负数，则阻塞执行<code>semWait</code>的进程，否则进程继续执行。</li><li><code>semSignal</code>操作使信号量加<code>1</code>。被<code>semWait</code>操作阻塞的进程之一（可能没有被阻塞的）解除阻塞。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 比较和交换指令 实现的信号量原语</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semwait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 把当前进程插入队列 */</span>;</span><br><span class="line">        <span class="comment">/* 阻塞当前进程 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= O)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 把进程 P 从队列中移除 */</span>;</span><br><span class="line">        <span class="comment">/* 把进程卫插入就绪队列 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>s.count ≥ 0</code>：<code>s.count</code>是可执行<code>semwait(s)</code>而不被阻塞的进程数。这种情形允许信号量支持同步与互斥。</li><li><code>s.count &lt; 0</code>：<code>s.count</code>的大小是阻塞在<code>s.queue</code>队列中的进程数。</li></ul><h6 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h6><ol><li>二元信号量可以初始化为<code>0</code>或<code>1</code>。</li><li><code>semWaitB</code>操作检查信号的值。若值为<code>0</code>，则进程执行<code>semwaitB</code>就会受阻。若值为<code>1</code>，则将值改为<code>0</code>，并继续执行该进程。</li><li><code>semSignalB</code>操作检查是否有任何进程在该信号上受阻。若有进程受阻，则通过<code>semWaitB</code>操作受阻的进程会被唤醒：若没有进程受阻，则值设置为<code>1</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;zero, one&#125; value;</span><br><span class="line">    qrueueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semwaitB</span><span class="params">(binary semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.value = one)</span><br><span class="line">        s.value = zero;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 把当前进程插入队列 */</span>;</span><br><span class="line">        <span class="comment">/* 阻塞当前进程 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignalB</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty())</span><br><span class="line">        s.value =one;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 把进程 P 从等待队列中移除 */</span>;</span><br><span class="line">        <span class="comment">/* 把进程卫插入就绪队列 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论是计数信号量还是二元信号量，都需要使用队列来保存于信号量上等待的进程。这就产生了一个问题，进程按什么顺序从队列中移出？最公平的策略是先进先出，被阻塞时间最久的进程最先从队列释放。采用这一策略定义的信号量称为强信号量，而没有规定进程从队列中移出顺序的信号量称为弱信号量。</p><p>强信号量保证不会饥饿，而弱信号量则无法保证。</p><h6 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h6><p>自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个被已经持有（即所谓的争用）的自旋锁，那么该线程就会一直进行忙循环一旋转，等待锁重新可用。要是锁未被争用，请求锁的执行线程便能立刻得到它，继续执行。在任意时间，自旋锁都可以防止多于一个的执行线程同时进入临界区。</p><p>自旋锁是不可递归的（不可重入的）。</p><p>自旋锁可以使用在中断处理程序中（此处不能使用信号量，因为它们会导致睡眠）。在中断处理程序中使用自旋锁时，一定要在获取锁之前，首先禁止本地中断（在当前处理器上的中断请求），否则，中断处理程序就会打断正持有锁的内核代码，有可能会试图去争用这个已经被持有的自旋锁。这样一来，中断处理程序就会自旋，等待该锁重新可用，但是锁的持有者在这个中断处理程序执行完毕前不可能运行。这正是我们在前面的内容中提到的双重请求死锁。注意，需要关闭的只是当前处理器上的中断。如果中断发生在不同的处理器上，即使中断处理程序在同一锁上自旋，也不会妨碍锁的持有者（在不同处理器上）最终释放锁。</p><h6 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量<code>mutex</code></h6><ul><li>任何时刻中只有一个任务可以持有<code>mutex</code>，也就是说，<code>mutex</code>的使用计数永远是<code>1</code>。</li><li>给<code>mutex</code>上锁者必须负责给其再解锁——你不能在一个上下文中锁定一个<code>mutex</code>，而在另一个上下文中给它解锁。这个限制使得<code>mutex</code>不适合内核同用户空间复杂的同步场景。最常使用的方式是：在同一上下文中上锁和解锁。</li><li>递归地上锁和解锁是不允许的。也就是说，你不能递归地持有同一个锁，同样你也不能再去解锁一个已经被解开的<code>mutex</code>。</li><li>当持有一个<code>mutex</code>时，进程不可以退出。</li><li><code>mutex</code>只能通过官方<code>API</code>管理，不可被拷贝、赋值、重复初始化。</li></ul><p><strong>除非<code>mutex</code>的某个约束妨碍你使用，否则相比信号量要优先使用<code>mutex</code>。在中断上下文中只能使用自旋锁，而在任务睡眠时只能使用<code>mutex</code></strong>。</p><h5 id="死锁原理"><a href="#死锁原理" class="headerlink" title="死锁原理"></a>死锁原理</h5><p>死锁定义为一组相互竞争系统资源或进行通信的进程间的“永久”阻塞。当一组进程中的每个进程都在等待某个事件（典型情况下是等待释放所请求的资源），而仅有这组进程中被阻塞的其他进程才可触发该事件时，就称这组进程发生了死锁。</p><p>资源通常分为两类：可重用资源和可消耗资源。<strong>可重用资源</strong>是指一次仅供一个进程安全使用且不因使用而耗尽的资源。可重用资源的例子包括处理器、<code>I/O</code>通道、内存和外存、设备，以及诸如文件、数据库和信号量之类的数据结构。<strong>可消耗资源</strong>是指可被创建（生产）和销毁（消耗）的资源。存在。可消耗资源的例子有中断、信号、消息和<code>I/O</code>缓冲区中的信息。</p><p>产生死锁有三个必要条件：</p><ol><li>互斥。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。</li><li>占有且等待。当一个进程等待其他进程时，继续占有已分配的资源。</li><li>不可抢占。不能强行抢占进程已占有的资源。</li></ol><p>要产生死锁，还需要第四个条件：</p><ol start="4"><li>循环等待。存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。</li></ol><p>第四个条件实际上是前三个条件的潜在结果，即假设前三个条件存在，那么可能发生的系列事件会导致不可解的循环等待。这个不可解的循环等待实际上就是死锁的定义。循环等待之所以不可解，是因为有前面三个条件的存在。因此，这四个条件一起构成 了死锁的充分必要条件。</p><h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><p>死锁预防方法分为两类。一类是间接死锁预防方法，即防止前面列出的三个必要条件中的任何一个条件的发生；另一类是直接死锁预防方法，即防止循环等待的发生。</p><ol><li><p>互斥</p><p> 不可能禁止。如果需要对资源进行互斥访问，那么操作系统就必须支持互斥。</p></li><li><p>占有且等待</p><p> 为预防占有且等待的条件，可以要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足。</p></li><li><p>不可抢占</p><p> 预防不可抢占的方法有几种。首先，占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放其最初占有的资源，必要时可再次申请这些资源和其他资源。其次，一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不同的条件下，后一种方案才能预防死锁。</p><p> 此外，只有在资源状态可以很容易地保存和恢复的情况下（如<code>CPU</code>上下文），这种方法才是实用的。</p></li><li><p>循环等待</p><p> 循环等待条件可通过定义资源类型的线性顺序来预防。若一个进程已分配了<code>R</code>类型的资源，则其接下来请求的资源只能是那些排在<code>R</code>类型之后的资源。</p></li></ol><h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><p>在死锁避免中，是否允许当前的资源分配请求是通过判断该请求是否可能导致死锁来决定的。因此，死锁避免需要知道未来进程资源请求的情况。</p><ol><li>进程启动拒绝。若一个进程的请求会导致死锁，则不启动该进程。</li><li>资源分配拒绝，又称<strong>银行家算法</strong>。若一个进程增加的资源请求会导致死锁，则不允许这一资源分配。</li></ol><p>死锁避免的优点是，无须死锁预防中的抢占和回滚进程，</p><h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><p>对于死锁检测来说，只要有可能，就会给进程分配其所请求的资源。操作系统周期性地执行一个算法来检测前面的循环等待条件。算法的策略是查找一个进程，使得可用资源能满足该进程的资源请求，然后假设同意这些资源，让该进程运行直到结束，再释放它的所有资源。然后，算法再寻找另一个可以满足资源请求的进程。</p><p><img src="image-20210410143441173.png" alt="image-20210410143441173"></p><p><strong>死锁恢复</strong>：</p><ol><li>取消所有的死锁进程。这是操作系统中最常采用的方法。</li><li>连续取消死锁进程直到不再存在死锁。所选取消进程的顺序应基于某种最小代价原则。每次取消后，必须重新调用检测算法，以测试是否仍存在死锁。</li><li>连续抢占资源直到不再存在死锁。</li></ol><p><strong>对于内存资源来说，基于抢占的死锁预防是最适合的策略</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之进程与线程管理</title>
      <link href="/DRLdCV5y4mc6kSqv/"/>
      <url>/DRLdCV5y4mc6kSqv/</url>
      
        <content type="html"><![CDATA[<p><strong>任务、线程、进程三者关系</strong></p><p>任务是一个抽象的概念，即指软件完成的一个活动；而线程则是完成任务所需的动作；进程则指的是完成此动作所需资源的统称；关于三者的关系，有一个形象的比喻：</p><ul><li>任务 = 送货</li><li>线程 = 开送货车</li><li>系统调度 = 决定合适开哪部送货车</li><li>进程 = 道路 + 加油站 + 送货车 + 修车厂</li></ul><a id="more"></a><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><h6 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h6><p>操作系统为进程提供两种虚拟机制。虚拟处理器让进程觉得自己在独享<code>CPU</code>。虚拟内存让进程在分配和管理内存的时候觉得自己拥有全部内存资源。</p><p>进程就是处于执行期的程序和一组相关的系统资源的总称。这些资源包括，打开的文件描述符、挂起的信号、内核内部数据、处理器状态、映射了的内存地址空间、所有执行的线程以及存放全局变量的数据段。它的两个基本元素就是程序代码（可能被执行相同程序的其他进程共享）和与代码相关联的数据集。</p><p>进程最少必须包括一个或一组被执行的程序，而与这些程序相关联的是局部变量、全局变量和任何已定义常量的数据单元。因此，一个进程至少应有足够的内存空间来保存其<strong>程序和数据</strong>；此外，程序的执行通常涉及用于跟踪过程调用和过程间参数传递的<strong>栈帧</strong>。最后，还有与每个进程相关的许多属性，以便操作系统控制该进程。通常，属性集称为<strong>进程描述符</strong>。<strong>程序、数据、栈帧和属性的集合称为进程映像</strong>。下图表示了进程映像在虚存中的结构。</p><p><img src="image-20210319113140920.png" alt="image-20210319113140920"></p><h6 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h6><p>从<code>linux</code>内核的观点看，进程又被称为任务，<strong>内核将所有进程组织在叫做任务队列的一个双向循环链表中</strong>。链表中的每一项是类型为<code>task_struct</code>的结构体（定义在<code>&lt;linux/sched.h&gt;</code>文件中），称为<strong>进程描述符或进程控制块</strong>，它被用来定义和描述一个完整的进程。</p><p>进程描述符包含有一个具体进程的所有信息，主要包括：</p><ul><li>进程标识信息<ul><li>标识符：与进程相关的唯一标识符，用来区分其他进程。每个进程都有唯一的一个进程标识符<code>PID</code>，以及用户标识符<code>UID</code>和组标识符<code>GID</code>。组标识符用于给一组进程指定资源访问特权。</li></ul></li><li>进程状态信息<ul><li>程序计数器：程序中即将执行的下一条指令的地址。</li><li>栈指针：用于指向保存参数和过程调用或系统调用的地址的栈帧的栈顶指针。</li><li>上下文数据：进程执行时处理器的<strong>寄存器组</strong>中的数据。包括控制，状态寄存器等。</li></ul></li><li>进程控制信息<ul><li>状态：表示进程的执行状态，有执行态、就绪态、停止态、阻塞态和僵死态。</li><li>调度信息：<code>Linux</code>调度进程所需要的信息。一个进程可能是普通的或实时的，并具有优先级。实时进程在普通进程前调度，且在每类中使用相关的优先级。一个计数器会记录允许进程执行的时间量。</li><li>等待事件信息：进程继续执行前等待的事件标识。</li><li>地址空间信息：包括程序代码和进程相关数据的指针，以及与其他进程共享内存块的指针。</li><li>时间和计时器：包括进程创建的时刻和进程所消耗的处理器时间总量。一个进程可能还有一个或多个间隔计时器，进程通过系统调用来定义间隔计时器，计时器期满时，会给进程发送一个信号。计时器可以只用一次或周期性地使用。</li><li>链接：每个进程都有一个到其父进程的链接及到其兄弟进程（与它有相同的父进程）的链接，以及到其所有子进程的链接。</li><li>文件系统：包括指向被该进程打开的任何文件的指针和指向该进程当前目录与根目录的指针。</li></ul></li></ul><p><code>Linux</code>通过<code>slab</code>分配器动态地给<code>task_struct</code>的结构体分配内存空间，这样能达到对象复用（通过预先分配和重复使用<code>task_struct</code>，可以避免动态分配和释放带来的资源消耗）和缓存着色的目的。除此之外，还需要在内核栈的栈底创建一个类型为<code>thread_info</code>的结构体（定义在<code>&lt;asm/thread_info.h&gt;</code>文件中），结构中的<code>task</code>域存放有指向该任务的<code>task_struct</code>的指针。</p><p>对于<code>Linux</code>系统，进程描述符中的<code>state</code>域描述了当前进程的状态，也就是其行为特征，共分为<code>5</code>种：</p><ol><li><p><code>TASK_RUNNING</code></p><p> 表示进程是可执行的；要么是在运行队列中等待被调度执行（就绪态），要么是正在执行（运行态）。</p></li><li><p><code>TASK_INIERRUPTIBLE</code></p><p> 进程正在被阻塞（阻塞态），等待某些条件的满足。一旦条件满足或者接收到信号而提前被唤醒，会从当前状态转为<code>TASK_RUNNING</code>状态（就绪态）。</p></li><li><p><code>TASK_UNINIERRUPTIBLE</code></p><p> 和<code>TASK_INIERRUPTIBLE</code>状态相同，除了<strong>不响应任何信号</strong>。也就是执行<code>ps</code>命令后看到进程被标记为<code>D</code>状态的进程，不能通过发送<code>SIGKILL</code>信号杀死处于此状态的进程。比如内核态进程在等待某项资源，这时候是不允许被打断的，否则可能导致系统进入未知状态，或者引发严重的系统异常，所以对于这种操作，定义<code>D</code>状态进行保护。使其在完成本次操作之前，不可以被任何异步状态打断。</p></li><li><p><code>_TASK_TRACED</code></p><p> 表示此进程正在被其它进程跟踪，例如通过<code>ptrace</code>对调试程序进行跟踪。</p></li><li><p><code>_TASK_STOPPED</code></p><p> 进程处于终止状态（停止态）。并且只能由来自另一个进程的主动动作恢复，例如，在调试期间收到任何信号都会使进程进入此状态。</p></li><li><p>僵死态</p><p> 进程已被终止，但由于某些原因，在进程表中仍然有其<code>task_struct</code>。</p></li></ol><p><img src="image-20210319201039276.png" alt="image-20210319201039276"></p><p>可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行（用户态）。当一个程序调执行了系统调用或者触发了某个异常，它就陷入了内核空间（内核态）。此时，我们称内核“代表进程执行”并处于<strong>进程上下文</strong>中。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复到用户空间继续执行。</p><p>系统调用，异常处理程序和中断处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行——对内核的所有访问都必须通过这些接口。</p><p>在<code>Linux</code>系统中，所有的进程都是<code>PID</code>为<code>1</code>的<code>init</code>进程的后代。内核在系统启动的最后阶段启动<code>init</code>进程。该进程读取系统的初始化脚本并执行其他的相关程序，最终完成系统启动的整个过程。</p><h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><p>进程的创建将一个新进程添加到正被管理的进程集时，操作系统需要建立用于管理该进程的数据结构，并在内存中给它分配地址空间，这些行为构成了一个新进程的创建过程， 操作系统会按照如下步骤操作：</p><ol><li>为新进程分配一个唯一的进程描述符。此时，主进程表中会添加一个新表项，每个进程一个表项。</li><li>为进程分配空间。包括进程映像中的所有元素。</li><li>初始化进程控制块（进程描述符）。</li><li>设置正确的链接。即将其放入适当的任务队列中。</li><li>创建或扩充其它数据结构。例如，操作系统可因编制账单和/或评估性能，为每个进程维护一个记账文件。</li></ol><p><code>Linux</code>中的进程创建分为两步，首先，<code>fork()</code>通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于<code>PID</code>、<code>PPID</code>（子进程将其设置为被拷贝进程的<code>PID</code>）和某些资源和统计量（例如，挂起的信号，它没有必要被继承）。然后，在需要时，通过<code>exec()</code>函数族读取可执行文件并将其载入地址空间开始作为一个全新的进程运行。</p><p><code>fork()</code>使用写时拷贝（<code>copy-on-write</code>）页实现。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。</p><p><code>fork()</code>的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。如果进程创建后马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据。</p><p><code>fork()</code>通过<code>clone()</code>系统调用实现。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。<code>fork()</code>和<code>_clone()</code>库函数都根据各自需要的参数标志去调用<code>clone()</code>，然后由<code>clone()</code>去调用<code>do_fork()</code>。</p><p><code>do_fork</code>完成了创建中的大部分工作，它的定义在<code>kernel/fork.c</code>文件中。该函数调用<code>copy_process()</code>函数，然后让进程开始运行。<code>copy _process()</code>函数完成如下工作：</p><ol><li>调用<code>dup_task_struct()</code>为新进程创建一个内核栈、<code>thread_info</code>结构和<code>task_struct</code>，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同的。</li><li>检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制。</li><li>子进程着手使自己与父进程区别开来。进程描述符内的许多成员都要被清零或设为初始值。那些不是继承而来的进程描述符成员，主要是统计信息（文件引用计数等）。<code>task_struct</code>中的大多数数据都依然未被修改。</li><li>子进程的状态被设置为<code>TASK_UNINTERRUPTIBLE</code>，以保证它不会投入运行。</li><li><code>copy_process()</code>调用<code>copy_flags()</code>以更新<code>task_struct</code>的<code>flags</code>成员。表明进程是否拥有超级用户权限的<code>PF_SUPERPRIV</code>标志被清<code>0</code>。表明进程还没有调用<code>exec()</code>函数的<code>PF_FORKNOEXEC</code>标志被设置。</li><li>调用<code>alloc_pid()</code>为新进程分配一个有效的<code>PID</code>。</li><li>根据传递给<code>clone()</code>的参数标志，<code>copy_process()</code>拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。在一般情况下，这些资源会被给定进程的所有线程共享。</li><li>最后，<code>copy_process()</code>做扫尾工作并返回一个指向子进程的指针。</li></ol><p>再回到<code>do_fork()</code>函数，如果<code>copy_process()</code>函数成功返回，新创建的子进程被唤醒并让其投入运行。内核有意选择子进程首先执行。因为一般子进程都会马上调用<code>exec()</code>函数族，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。</p><h5 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h5><table><thead><tr><th align="center">原因</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">正常完成</td><td align="center">进程自行执行一个操作系统服务调用，表示它已经结束运行</td></tr><tr><td align="center">超出时限</td><td align="center">进程运行时间超过规定的时限</td></tr><tr><td align="center">无可用内存</td><td align="center">系统无法满足进程需要的内存空间</td></tr><tr><td align="center">保护错误</td><td align="center">进程试图使用不允许使用的资源或文件，如往只读文件中写或试图访问不允许访问的内存单元</td></tr><tr><td align="center"><code>I/O</code>失败</td><td align="center">在输入或输出期间发生错误，如找不到文件或某些无效操作</td></tr><tr><td align="center">父进程终止</td><td align="center">当一个父进程终止时，操作系统可能会自动终止该进程的所有子进程</td></tr><tr><td align="center">父进程请求</td><td align="center">父进程通常具有终止其任何子进程的权力</td></tr></tbody></table><p>进程的终结发生在调用<code>exit()</code>系统调用时，<code>exit()</code>又调用了<code>do_exit()</code>（定义在<code>&lt;kernel/exit.c&gt;</code>文件中）：</p><ol><li><p>将<code>tast_struct</code>中的标志成员设置为<code>PF_EXITING</code>。</p></li><li><p>调用<code>del_timer_sync()</code>删除任一内核定时器。根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。</p></li><li><p>然后调用<code>exit_mm()</code>函数释放进程占用的<code>mm_struct</code>，如果没有别的进程使用它们（也就是说，这个地址空间没有被共享)，就彻底释放它们。</p></li><li><p>接下来调用<code>sem__exit()</code>函数。如果进程排队等候<code>IPC</code>信号，它则离开队列。</p></li><li><p>调用<code>exit_files()</code>和<code>exit_fs()</code>，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为零，那么就代表没有进程在使用相应的资源，此时可以释放。</p></li><li><p>接着把存放在<code>task_struct</code>的<code>exit_code</code>成员中的任务退出代码置为由<code>exit()</code>提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。退出代码存放在这里供父进程随时检索。</p></li><li><p>调用<code>exit_notify()</code>向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为<code>init</code>进程，并把进程状态（存放在<code>task_struct</code>结构的<code>exit_state</code>中）设成<code>EXIT_ZOMBIE</code>。</p><p> 如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白地耗费内存。一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。<code>init</code>进程会例行调用<code>wait()</code>来检查其子进程，清除所有与其相关的僵死进程。</p></li><li><p><code>do_exit()</code>调用<code>schedule()</code>切换到新的进程。因为处于<code>EXIT_ZOMBIE</code>状态的进程不会再被调度，所以这是进程所执行的最后一段代码。<code>do_exit()</code>永不返回。</p></li></ol><p>至此，与进程相关联的所有资源都被释放掉了，还占用的所有内存就是内核栈、<code>thread_info</code>结构和<code>tast_struct</code>结构。此时进程存在的唯一目的就是向它的父进程提供信息。</p><p>这意味着，进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得已终结的子进程的信息后，通知内核它并不关注那些信息后，子进程的<code>task_struct</code>结构才被释放。</p><p><code>wait()</code>这一族函数都是通过唯一（但是很复杂）的一个系统调用<code>wait4()</code>来实现的。它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的<code>PID</code>。此外，调用该函数时提供的指针会包含子函数退出时的退出代码。</p><p>当最终需要释放进程描述符时，<code>release_task()</code>会被调用，用以完成以下工作：</p><ol><li>它调用<code>__exit_signal()</code>，该函数调用<code>_unhash process()</code>，后者又调用<code>detach_pid()</code>从<code>pidhash</code>上删除该进程，同时也要从任务列表中删除该进程。</li><li><code>_exit_signal()</code>释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。</li><li>如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么<code>release_task()</code>就要通知僵死的领头进程的父进程。</li><li><code>release_task()</code>调用<code>put_task_struct()</code>释放进程内核栈和<code>thread_info</code>结构所占的页，并释放<code>tast_struct</code>所占的<code>slab</code>高速缓存。</li></ol><p>至此，进程描述符和所有进程独享的资源就全部释放掉了。</p><h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><h6 id="进程间切换"><a href="#进程间切换" class="headerlink" title="进程间切换"></a>进程间切换</h6><p>进程切换可在操作系统从当前正在运行进程中获得控制权的任何时刻（即，当执行进程从用户态转移到内核态之后）发生。</p><table><thead><tr><th>机制</th><th>原因</th><th>用途</th></tr></thead><tbody><tr><td>中断</td><td>来自当前执行指令的外部</td><td>对异步外部事件的反应，如完成一次<code>I/O</code>操作</td></tr><tr><td>异常（陷阱）</td><td>与当前执行指令有关</td><td>处理一个错误或异常事件，如非法的内存或文件访问</td></tr><tr><td>系统调用</td><td>显示请求</td><td>调用系统函数，使用系统调用会将用户进程设为阻塞态</td></tr></tbody></table><p>涉及状态变化的完整的进程切换步骤如下：</p><ol><li>保存处理器的上下文，包括程序计数器和其他寄存器。</li><li>更新当前处于运行态进程的进程控制块，包括把进程的状态改变为另一状态（就绪态、阻塞态、退出态）。还须更新其他相关的字段，包括退出运行态的原因和记账信息。</li><li>把该进程的进程控制块移到相应的任务队列（就绪、阻塞）</li><li>选择另一个进程执行，详见进程调度。</li><li>更新所选进程的进程控制块，包括把进程的状态改为运行态。</li><li>更新内存管理数据结构。是否需要更新取决于管理地址转换的方式，详见内存管理。</li><li>载入程序计数器和其他寄存器先前的值，将处理器的上下文恢复为所选进程上次退出运行态时的上下文。</li></ol><p>与<strong>模式切换</strong>（指用户态和内核态间切换）的区别在于，模式切换可在不改变当前运行态进程的状态下出现（即不涉及状态变化），此时保存上下文并之后恢复上下文仅需很少的开销。</p><h6 id="线程间切换"><a href="#线程间切换" class="headerlink" title="线程间切换"></a>线程间切换</h6><p><strong>在<code>Linux</code>系统中</strong>，当<code>Linux</code>内核执行从一个进程到另一个进程的切换时，会检查当前进程的页目录地址是否与将被调度的进程的相同。若相同，则它们共享同一个地址空间（即同一个进程中的不同线程），所以此时上下文切换仅是从代码的处跳转到代码的另一处。</p><p>进程切换分两步：</p><ol><li>切换页目录以使用新的地址空间。</li><li>切换内核栈和硬件上下文。</li></ol><p>对于<code>Linux</code>来说，线程和进程的最大区别就在于地址空间。对于线程切换，第<code>1</code>步是不需要做的，第<code>2</code>步是进程和线程切换都要做的。 所以明显是进程切换代价大。</p><p>另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理器的页表缓冲（<code>TLB</code>）会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。</p><h5 id="线程和线程在Linux中的实现"><a href="#线程和线程在Linux中的实现" class="headerlink" title="线程和线程在Linux中的实现"></a>线程和线程在<code>Linux</code>中的实现</h5><p><strong>进程是资源分配的最小单元，享有资源所有权，线程是调度执行的具体对象，享有被调度执行权。</strong></p><p>线程是在进程中活动的可被内核调度的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。同一个进程中的所有线程可以共享虚拟内存，但拥有独立的虚拟处理器。<strong>进程中的所有线程共享该进程的状态和资源，所有线程都驻留在同一块地址空间中，并可访问相同的数据</strong>。</p><p><code>Linux</code>实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的<code>task_struct</code>，所以在内核中，它看起来就像是一个普通的进程，只是线程和其他一些进程共享某些资源，如地址空间。</p><p>也就是说，组成一个用户级进程的多个用户级线程被映射到<strong>共享同一个组<code>ID</code></strong>的多个<code>Linux</code>内核级进程上。因此，<strong>这些进程可以共享文件和内存等资源</strong>，使得同一个组中的进程调度切换时不需要切换上下文。</p><p>线程的创建和普通进程的创建类似，只不过在调用<code>clone()</code>的时候需要传递一些参数标志来指明需要共享的资源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>上面的代码产生的结果和调用<code>fork()</code>差不多，只是父子俩共享地址空间<code>CLONE_VM</code>、文件系统资源<code>CLONE_FS</code>、文件描述符<code>CLONE_FILES</code>和信号处理程序<code>CLONE_SIGHAND</code>。新建的进程和它的父进程就是所谓的线程，但它们都具有各自的用户栈，因为<code>clone()</code>系统调用会为每个进程创建独立的栈空间。</p><p>对比一下，一个普通的<code>fork()</code>的实现是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这些<code>clone()</code>用到的参数标志以及它们的作用，这些是在<code>&lt;linux/sched.h&gt;</code>中定义的。</p><h6 id="内核线程（进程）"><a href="#内核线程（进程）" class="headerlink" title="内核线程（进程）"></a><strong>内核线程（进程）</strong></h6><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程（独立运行在内核空间的标准进程，内核线程也只能由其他内核线程创建）完成。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的<code>mm</code>指针被设置为<code>NULL</code>）。它们只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。</p><h6 id="守护线程（进程）"><a href="#守护线程（进程）" class="headerlink" title="守护线程（进程）"></a><strong>守护线程（进程）</strong></h6><p><code>Linux Daemon</code>（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。<code>Linux</code>系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程<code>syslogd</code>、 <code>web</code>服务器<code>httpd</code>等。</p><p>守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（<code>root</code>）权限运行，因为它们要使用特殊的端口（<code>1-1024</code>）或访问某些特殊的资源。</p><p>一个守护进程的父进程是<code>init</code>进程，因为它真正的父进程在<code>fork</code>出子进程后就先于子进程<code>exit</code>退出了，所以它是一个由<code>init</code>继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备<code>stdout</code>还是标准出错设备<code>stderr</code>的输出都需要特殊处理。</p><p>首先我们要了解一些基本概念：</p><p>进程组 ：</p><ul><li>每个进程也属于一个进程组</li><li>每个进程主都有一个进程组号，该号等于该进程组组长的<code>PID</code>号 .</li><li>一个进程只能为它自己或子进程设置进程组<code>ID</code>号</li></ul><p>会话：会话（<code>session</code>）是一个或多个进程组的集合。</p><p><code>setsid()</code>函数可以建立一个会话：</p><p> 如果，调用<code>setsid</code>的进程不是一个进程组的组长，此函数创建一个新的会话期。</p><ol><li>此进程变成该对话期的首进程；</li><li>此进程变成一个新进程组的组长进程；</li><li>此进程没有控制终端，如果在调用<code>setsid</code>前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误；</li><li>为了保证这一点，我们先调用<code>fork()</code>然后父进程<code>exit()</code>，此时只有子进程在运行。</li></ol><p>现在我们来给出创建守护进程所需步骤：</p><p>编写守护进程的一般步骤步骤：</p><ol><li>在父进程中执行<code>fork</code>并让父进程<code>exit</code>退出；</li><li>在子进程中调用<code>setsid</code>函数创建新的会话；</li><li>在子进程中调用<code>chdir</code>函数，让根目录<code>/</code>成为子进程的工作目录；</li><li>在子进程中调用<code>umask</code>函数，设置进程的<code>umask</code>为<code>0</code>；</li><li>在子进程中关闭任何不需要的文件描述符。</li></ol><p>一些说明：</p><ol><li><p>在后台运行<br> 为避免挂起控制终端将<code>Daemon</code>放入后台执行。方法是在进程中调用<code>fork</code>使父进程终止，让<code>Daemon</code>在子进程中后台执行。</p></li><li><p>脱离控制终端，登录会话和进程组<br> 有必要先介绍一下<code>Linux</code>中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（<code>GID</code>）就是进程组长的进程号（<code>PID</code>）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。</p><p> 控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第<code>1</code>点的基础上，调用<code>setsid()</code>使进程成为会话组长，当进程是会话组长时<code>setsid()</code>调用失败。</p><p> 但第一点已经保证进程不是会话组长。<code>setsid()</code>调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。</p></li><li><p>禁止进程重新打开控制终端<br> 现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过再次<code>fork()</code>使进程不再成为会话组长来禁止进程重新打开控制终端。</p></li><li><p>关闭打开的文件描述符<br> 进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。</p></li><li><p>改变当前工作目录<br> 进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录。</p></li><li><p>重设文件创建掩码<br> 进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：<code>umask(0);</code>。</p></li><li><p>处理<code>SIGCHLD</code>信号<br> 处理<code>SIGCHLD</code>信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在<code>Linux</code>下可以简单地将<code>SIGCHLD</code>信号的操作设为<code>SIG_IGN</code>：<code>signal(SIGCHLD, SIG_IGN);</code>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之memcpy、memset、strcpy、strcmp、strlen、string的实现</title>
      <link href="/fKh6HJGjVNfldP4P/"/>
      <url>/fKh6HJGjVNfldP4P/</url>
      
        <content type="html"><![CDATA[<ol><li><code>memcpy</code></li><li><code>memset</code></li><li><code>strcpy</code></li><li><code>strcmp</code></li><li><code>strlen</code></li><li>自己动手实现一个<code>string</code>类</li></ol><a id="more"></a><h4 id="memcpy、memset实现"><a href="#memcpy、memset实现" class="headerlink" title="memcpy、memset实现"></a><code>memcpy</code>、<code>memset</code>实现</h4><h5 id="memcpy实现"><a href="#memcpy实现" class="headerlink" title="memcpy实现"></a><code>memcpy</code>实现</h5><ul><li>此实现并没有考虑<code>dst</code>和<code>src</code>的内存重叠问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 const 修饰 src</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 验证 dst 和 src 的合法性</span></span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">void</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">char</span>*)dst = *(<span class="keyword">char</span>*)src;</span><br><span class="line">        dst = (<span class="keyword">char</span>*)dst + <span class="number">1</span>;</span><br><span class="line">        src = (<span class="keyword">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="memset实现"><a href="#memset实现" class="headerlink" title="memset实现"></a><code>memset</code>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memset</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">void</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">char</span>*)dst = (<span class="keyword">char</span>)ch;</span><br><span class="line">        dst = (<span class="keyword">char</span>*)dst + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回原 dst 指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="strcpy、strcmp、strlen实现"><a href="#strcpy、strcmp、strlen实现" class="headerlink" title="strcpy、strcmp、strlen实现"></a><code>strcpy</code>、<code>strcmp</code>、<code>strlen</code>实现</h4><h5 id="strcpy实现"><a href="#strcpy实现" class="headerlink" title="strcpy实现"></a><code>strcpy</code>实现</h5><ul><li>此实现并没有考虑<code>dst</code>和<code>src</code>的内存重叠问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 const 修饰 src</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 验证 dst 和 src 的合法性</span></span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回原 dst 指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="strcmp实现"><a href="#strcmp实现" class="headerlink" title="strcmp实现"></a><code>strcmp</code>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意将两个指针都用 const 修饰</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* rhs, <span class="keyword">const</span> <span class="keyword">char</span>* lhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判空测试</span></span><br><span class="line">    assert(rhs != <span class="literal">NULL</span>);</span><br><span class="line">    assert(lhs != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里必须是 unsigned char</span></span><br><span class="line">    <span class="comment">// 表示的范围为 0 ~ 255</span></span><br><span class="line">    <span class="comment">// 如果是 char 的话, 范围是 -128 ~ 127, 这个范围用来比较字符串是不对的</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = *rhs++;</span><br><span class="line">        c2 = *lhs++;</span><br><span class="line">        <span class="keyword">if</span>(c1 != c2)</span><br><span class="line">            <span class="keyword">return</span> c1 &lt; c2 ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="number">0</span>)</span><br><span class="line">            bresk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="strlen实现"><a href="#strlen实现" class="headerlink" title="strlen实现"></a><code>strlen</code>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pc = str;</span><br><span class="line">    <span class="keyword">while</span>(*pc++ != <span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> pc - str - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于标准库中的实现</strong>：通过减少数据从内存存取到寄存器的次数来提高效率，使用的手段是先字节对齐，然后每次读取一个<code>4/8</code>字节的多字节数据，对多字节数据遍历是否存在<code>\0</code>。</p><h4 id="自己动手实现一个string类"><a href="#自己动手实现一个string类" class="headerlink" title="自己动手实现一个string类"></a>自己动手实现一个<code>string</code>类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_data;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *c_str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="keyword">char</span>[_size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_data, c_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String() : _data(<span class="literal">nullptr</span>), _size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span> *c_str) : _size(<span class="built_in">strlen</span>(c_str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c_str)</span><br><span class="line">            init(c_str);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String(<span class="keyword">const</span> String &amp;str) : _size(str._size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str._data)</span><br><span class="line">            init(str._data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String(String &amp;&amp;str) <span class="keyword">noexcept</span> : _data(str._data), _size(str._size)</span><br><span class="line">    &#123;</span><br><span class="line">        str._data = <span class="literal">nullptr</span>;</span><br><span class="line">        str._size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_data)</span><br><span class="line">            <span class="keyword">delete</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> *c_str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 copy and swap 技术, 可以处理自我赋值情况</span></span><br><span class="line">        String temp(c_str);</span><br><span class="line">        swap(temp);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> = str._data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(String &amp;&amp;str) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测自我赋值情况</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (_data)</span><br><span class="line">            <span class="keyword">delete</span> _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">        swap(str);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(String &amp;str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(_data, str._data);</span><br><span class="line">        swap(_size, str._size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span> *c_str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(_data, c_str) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> == str._data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> i) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> String str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; str.c_str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之const关键字的实现</title>
      <link href="/cZUstnNRSXkgncRt/"/>
      <url>/cZUstnNRSXkgncRt/</url>
      
        <content type="html"><![CDATA[<h4 id="编译器是如何实现const关键字功能的"><a href="#编译器是如何实现const关键字功能的" class="headerlink" title="编译器是如何实现const关键字功能的"></a>编译器是如何实现<code>const</code>关键字功能的</h4><h5 id="const用于声明变量"><a href="#const用于声明变量" class="headerlink" title="const用于声明变量"></a><code>const</code>用于声明变量</h5><p><code>const</code>定义的变量只有类型为<strong>整数或枚举</strong>，且<strong>以常量表达式初始化</strong>时，在其它地方使用该变量的地方才会被以常量替换。其他情况下它只是一个<code>const</code>限定的变量。但它们都分配了内存地址，把它们统称为常量。</p><a id="more"></a><ul><li><p>修饰全局变量</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局</span></span><br><span class="line"><span class="keyword">const</span> Point p&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point *pp = (Point *)&amp;p;</span><br><span class="line">    pp-&gt;x = <span class="number">3</span>; <span class="comment">// error!</span></span><br><span class="line">    <span class="comment">// Exception has occurred. Segmentation fault</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  未被<code>const</code>修饰的全局变量默认为<code>extern</code>，不需要<code>extern</code>显式声明即可以在其它文件中访问！而全局<code>const</code>常量需要显式声明<code>extern</code>，并且需要做初始化，才能在其它文件中访问！<strong>因为常量在定义后就不能被修改，所以定义时必须初始化</strong>。</p><p>  虽然可以编译通过（骗过了编译器）。<strong>但上述全局<code>const</code>修饰的变量<code>p</code>会被编译器存放在<code>ELF</code>文件的<code>.rodata</code>分区（只读），程序默认不拥有写权限，故运行时不可更改</strong>。</p><p>  接下来，控制变量<code>p</code>的<code>const</code>功能就交给操作系统中内存分页机制了。操作系统会将<code>.rodata</code>所在的内存页的权限标记为只读。每当程序访问内存时，<code>CPU</code>都会检查内存地址对应的权限。如果权限不符，那么<code>CPU</code>就会产生中断并调用操作系统所设置的中断处理例程。在这个例子中，当<code>CPU</code>发现程序想要写一块只读内存时，就会产生中断。而<code>Linux</code>设置的默认动作是终止程序，并打印 “<code>Segmentation fault (core dumped)</code>”。</p></li><li><p>修饰局部变量</p><p>  这时只是编译器负责检查你有没有显式的通过<code>p</code>来修改<code>const</code>修饰的变量<code>p</code>的值。但是你可以通过其它技巧骗过编译器来修改。比如：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Point p&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    p.x = <span class="number">3</span>; <span class="comment">// error!</span></span><br><span class="line">    Point *pp = (Point *)&amp;p;</span><br><span class="line">    pp-&gt;x = <span class="number">3</span>; <span class="comment">// correct!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>编译器的实现为，函数内变量放在函数的栈帧里的，程序拥有对这个存储区自由读写的权限</strong>。</p></li><li><p>修饰类的成员变量</p><p>  编译器的实现和前面说的修饰函数内局部变量一样。但类中的<code>const</code>成员变量必须通过初始化列表进行初始化。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Point(<span class="keyword">int</span> x_, <span class="keyword">int</span> y_) : x(x_), y(y_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// p 对象中 x = 1, y = 2</span></span><br><span class="line">    <span class="keyword">int</span> *pi = (<span class="keyword">int</span> *)&amp;p;</span><br><span class="line">    *pi = <span class="number">3</span>; <span class="comment">// // p 对象中 x = 3, y = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过指针竟然可以修改类对象内声明为<code>const</code>的对象。细思极恐,，这其实就是指针的被广为诟病的地方了。</p></li><li><p>修饰函数形参</p><ul><li><p><code>value with const</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> val)</span></span>; <span class="comment">// 传递过来的参数不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> p)</span></span>; <span class="comment">// 指针本身不可变</span></span><br></pre></td></tr></table></figure><p>  编译器的实现跟前面讨论的修饰函数内局部变量一样。</p></li><li><p><code>reference or pointer with const</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>; <span class="comment">// 参数指针所指内容为常量不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> A &amp;a)</span> <span class="comment">// 参数为引用, 为了增加效率同时防止修改</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>修饰函数返回类型</p><ul><li><p><code>value with const</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point <span class="title">func1</span><span class="params">()</span></span>; <span class="comment">// 无意义, 因为参数返回本身就是赋值给其他的变量！</span></span><br></pre></td></tr></table></figure></li><li><p><code>reference or pointer with const</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point* <span class="title">func2</span><span class="params">()</span></span>; <span class="comment">// 指针指向内容不可变</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Point&amp; <span class="title">func2</span><span class="params">()</span></span>; <span class="comment">// 引用的内容不可变</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="const用于声明函数"><a href="#const用于声明函数" class="headerlink" title="const用于声明函数"></a><code>const</code>用于声明函数</h5><ul><li><p>修饰类的成员函数</p><p>  被<code>const</code>修饰的类对象，只能访问类中<code>const</code>成员函数。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Point(<span class="keyword">int</span> x_, <span class="keyword">int</span> y_) : x(x_), y(y_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  编译器会将被<code>const</code>修饰的成员函数<code>getX()</code>转化为：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化为下面这样</span></span><br><span class="line"><span class="comment">// 前面的那个 const_ 才是 const 修饰起到的作用, 后面的本身就有</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">(const_ Point* <span class="keyword">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样的调用</span></span><br><span class="line"><span class="function">Point <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">p.getX();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为下面这样</span></span><br><span class="line">getX(&amp;p);</span><br></pre></td></tr></table></figure><p>  也就是说，<code>const</code>修饰类成员函数时，修饰的只是传进来的<code>this</code>指针而已。</p></li></ul><h5 id="const-char-str、char-str、char-str-、const-char-str-的区别"><a href="#const-char-str、char-str、char-str-、const-char-str-的区别" class="headerlink" title="const char* str、char* str、char str[]、const char str[]的区别"></a><code>const char* str</code>、<code>char* str</code>、<code>char str[]</code>、<code>const char str[]</code>的区别</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注意, 下面的讨论都是把此定义放在 全局 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器都会将常量 "hello" 存放在只读数据段</span></span><br><span class="line"><span class="comment">// 而且这和前面是否使用 const 修饰没关系</span></span><br><span class="line"><span class="comment">// 程序持有的只是一个指针变量而已</span></span><br><span class="line"><span class="comment">// 所以, 通过指针修改这个串 "hello", 都会报错的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但如果这样定义</span></span><br><span class="line"><span class="comment">// 此时定义的是数组变量, 有 const 的话会放在只读数据段</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 const 的话就会放在可写段</span></span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *s2 = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">char</span> s3[] = <span class="string">"dfasd"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> s4[] = <span class="string">"asdfasdf"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s1 = <span class="string">'e'</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">char</span> *ps1 = (<span class="keyword">char</span> *)s1;</span><br><span class="line">    *ps1 = <span class="string">'d'</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    *s2 = <span class="string">'e'</span>; <span class="comment">// error</span></span><br><span class="line">    *s3 = <span class="string">'e'</span>; <span class="comment">// correct</span></span><br><span class="line"></span><br><span class="line">    *s4 = <span class="string">'r'</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">char</span> *ps4 = (<span class="keyword">char</span> *)s4;</span><br><span class="line">    *ps4 = <span class="string">'d'</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意, 下面的讨论都是把此定义放在 局部 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和定义在全局相同</span></span><br><span class="line"><span class="comment">// 编译器都会将常量 "hello" 存放在只读数据段</span></span><br><span class="line"><span class="comment">// 而且这和前面是否使用 const 修饰没关系</span></span><br><span class="line"><span class="comment">// 程序持有的只是一个指针变量而已</span></span><br><span class="line"><span class="comment">// 所以, 通过指针修改这个串 "hello", 都会报错的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但如果这样定义</span></span><br><span class="line"><span class="comment">// 此时定义的是数组变量, 有 const 的话 只会放在函数的栈帧上</span></span><br><span class="line"><span class="comment">// 编译器会负责检查, 不允许你显示修改 str 数组</span></span><br><span class="line"><span class="comment">// 可以通过前面介绍的 trick 骗过编译器来修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 const 的话, 放在函数的栈帧上, 访问就随意啦</span></span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *s2 = <span class="string">"world"</span>;</span><br><span class="line">    <span class="keyword">char</span> s3[] = <span class="string">"dfasd"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> s4[] = <span class="string">"asdfasdf"</span>;</span><br><span class="line"></span><br><span class="line">    *s1 = <span class="string">'e'</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">char</span> *ps1 = (<span class="keyword">char</span> *)s1;</span><br><span class="line">    *ps1 = <span class="string">'d'</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    *s2 = <span class="string">'e'</span>; <span class="comment">// error</span></span><br><span class="line">    *s3 = <span class="string">'e'</span>; <span class="comment">// correct</span></span><br><span class="line"></span><br><span class="line">    *s4 = <span class="string">'r'</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">char</span> *ps4 = (<span class="keyword">char</span> *)s4;</span><br><span class="line">    *ps4 = <span class="string">'d'</span>; <span class="comment">// correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译器是如何实现强制类型转换的"><a href="#编译器是如何实现强制类型转换的" class="headerlink" title="编译器是如何实现强制类型转换的"></a>编译器是如何实现强制类型转换的</h4><p>关于强制类型转换的分类和使用参考《<code>Effective C++</code>》条款<code>27</code>。</p><p>进行强制类型转换后，内存空间里面<strong>原变量的内容是不会发生改变的</strong>，改变的是运算时产生的<strong>临时数据对象</strong>的类型，是你去读取这个内存空间时的解析方法。</p><p>从编译原理的角度去看，<code>C++</code>编译器会维护一份程序中所有变量的名称和其类型之间的一个映射表。通过变量名称去操作内存空间时，会查看这个映射表，获取变量所属的类型之后再决定操作的内存范围。当使用强制类型转换时，会首先改变这个<strong>临时数据对象</strong>的类型，再去操作内存。</p>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之智能指针</title>
      <link href="/DVejmy5owOXx5WKk/"/>
      <url>/DVejmy5owOXx5WKk/</url>
      
        <content type="html"><![CDATA[<p>关于智能指针的<code>demo</code>，参见<code>C++ primer 12.1</code>。</p><h5 id="什么是智能指针"><a href="#什么是智能指针" class="headerlink" title="什么是智能指针"></a>什么是智能指针</h5><p>智能指针是使用<code>RAII</code>手法对裸指针进行的一个面向对象封装，即在构造函数中初始化资源地址，在析构函数中释放资源。智能指针保证当资源<strong>应当被释放的时候</strong>一定会释放它，这是利用了<strong>栈上的对象出作用域时自动析构</strong>这个特点。</p><a id="more"></a><h5 id="为什么引入智能指针"><a href="#为什么引入智能指针" class="headerlink" title="为什么引入智能指针"></a>为什么引入智能指针</h5><p>用以弥补裸指针的不足：</p><p>​        1）使用裸指针分配内存后，没有对指针释放资源会导致内存泄漏；</p><p>​        2）多个裸指针指向同一资源时，多次释放资源时，对空悬指针进行释放会导致不可预知的错误。</p><h5 id="如何知道是否存在内存泄漏"><a href="#如何知道是否存在内存泄漏" class="headerlink" title="如何知道是否存在内存泄漏"></a>如何知道是否存在内存泄漏</h5><p>在不借助其他检测工具的情况下，可以通过观察，即程序长时间运行后内存占用率一直不断的缓慢的上升，而实际上在你的逻辑中并没有这么多的内存需求。</p><h5 id="如何定位到内存泄漏点"><a href="#如何定位到内存泄漏点" class="headerlink" title="如何定位到内存泄漏点"></a>如何定位到内存泄漏点</h5><ul><li><code>review</code>代码，找到<code>new</code>和<code>delete</code>关键字的位置，先看看内存的申请和释放是否是成对的来进行初步的判断；</li><li>对于函数中申请的临时空间，认真检查是否存在提前跳出函数的地方而导致没有释放内存。</li></ul><h5 id="智能指针有哪些"><a href="#智能指针有哪些" class="headerlink" title="智能指针有哪些"></a>智能指针有哪些</h5><p>智能指针分为不带引用计数的<code>scoped_ptr</code>和<code>unique_ptr</code>，带引用计数的<code>shared_ptr</code>和<code>weak_ptr</code>。</p><h5 id="这些智能指针分别是如何实现的"><a href="#这些智能指针分别是如何实现的" class="headerlink" title="这些智能指针分别是如何实现的"></a>这些智能指针分别是如何实现的</h5><p><code>scoped_ptr</code>私有化了拷贝构造函数和赋值操作运算符，资源的所有权无法进行转移，也无法在容器中使用，这种方式杜绝了浅拷贝的发生。</p><p><code>unique_ptr</code>删除了拷贝构造函数和赋值函数，因此不支持普通的拷贝或赋值操作。但引入了移动构造函数和移动赋值运算符。所以它们保证了有唯一的智能指针持有此资源。<code>unique_ptr</code>还提供了<code>reset</code>重置资源，<code>swap</code>交换资源等函数，也经常会使用到。</p><p><code>shared_ptr</code>称为强智能指针，<strong>它的资源引用计数器在内存的<code>heap</code>堆上</strong>（这保证了，每个智能指针的引用计数变量会动态的变化）。通常用于管理对象的<strong>生命周期</strong>。只要有一个指向对象的<code>shared_ptr</code>存在，该对象就不会被析构。</p><p><code>weak_ptr</code>被称为弱智能指针，其对资源的引用<strong>不会引起资源的引用计数的变化</strong>，通常作为观察者，用于判断资源是否存在，并根据不同情况做出相应的操作。比如使用<code>weak_ptr</code>对资源进行弱引用，当调用<code>weak_ptr</code>的<code>lock()</code>方法时，若返回<code>nullptr</code>，则说明资源已经不存在，放弃对资源继续操作。否则，将返回一个<code>shared_ptr</code>对象，可以继续操作资源。另外，一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放。即使有<code>weak_ptr</code>指向对象，对象也还是会被释放。</p><p>当需要<strong>多个智能指针</strong>指向同一个资源时，使用带引用计数的智能指针。每增加一个智能指针指向同一资源，资源引用计数加<code>1</code>，反之减<code>1</code>。当引用计数为<code>0</code>时，由最后一个指向资源的智能指针将资源进行释放。</p><h5 id="如何避免循环引用"><a href="#如何避免循环引用" class="headerlink" title="如何避免循环引用"></a>如何避免循环引用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">// 前置声明类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; _ptrb; <span class="comment">// 指向B对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; _ptra; <span class="comment">// 指向A对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">// ptra指向A对象，A的引用计数为1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">// ptrb指向B对象，B的引用计数为1</span></span><br><span class="line">    ptra-&gt;_ptrb = ptrb;          <span class="comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为2</span></span><br><span class="line">    ptrb-&gt;_ptra = ptra;          <span class="comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印A的引用计数结果:2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印B的引用计数结果:2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span></span><br><span class="line"><span class="comment">B对象的引用计数从2减到1，达不到释放A和B的条件（释放的条件是</span></span><br><span class="line"><span class="comment">A和B的引用计数为0），因此造成两个new出来的A和B对象无法释放，</span></span><br><span class="line"><span class="comment">导致内存泄露，这个问题就是“强智能指针的交叉引用(循环引用)问题”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法，这也是强弱智能指针的一个重要应用规则：<strong>定义对象时，用强智能指针<code>shared_ptr</code>，在其它地方引用对象时，使用弱智能指针<code>weak_ptr</code></strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">// 前置声明类 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;B&gt; _ptrb; <span class="comment">// 指向 B 对象的弱智能指针。引用对象时，用弱智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;A&gt; _ptra; <span class="comment">// 指向 A 对象的弱智能指针。引用对象时，用弱智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义对象时，用强智能指针</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">// ptra 指向 A 对象，A 的引用计数为 1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">// ptrb 指向B 对象，B 的引用计数为 1</span></span><br><span class="line">    <span class="comment">// A 对象的成员变量 ptrb 也指向 B 对象，B 的引用计数为 1，因为是弱智能指针，引用计数没有改变</span></span><br><span class="line">    ptra-&gt;_ptrb = ptrb;</span><br><span class="line">    <span class="comment">// B 对象的成员变量 ptra 也指向 A 对象，A 的引用计数为 1，因为是弱智能指针，引用计数没有改变</span></span><br><span class="line">    ptrb-&gt;_ptra = ptra;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果: 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果: 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">出 main 函数作用域，ptra 和 ptrb 两个局部对象析构，分别给 A 对象和</span></span><br><span class="line"><span class="comment">B 对象的引用计数从 1 减到 0，达到释放 A 和 B 的条件，因此 new 出来的 A 和 B 对象</span></span><br><span class="line"><span class="comment">被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="什么情况下需要自定义deleter"><a href="#什么情况下需要自定义deleter" class="headerlink" title="什么情况下需要自定义deleter"></a>什么情况下需要自定义<code>deleter</code></h5><p>在管理的裸指针<strong>不是<code>new</code>出来的裸指针时</strong>需要自定义删除器，比如管理的指针为<strong>文件指针</strong>或<strong>由<code>malloc</code>获得的指针</strong>等。</p><h5 id="enable-shared-from-this机制"><a href="#enable-shared-from-this机制" class="headerlink" title="enable_shared_from_this机制"></a><code>enable_shared_from_this</code>机制</h5><p>当<code>class Widget</code>被<code>share_ptr</code>管理，且在<code>Widget</code>的成员函数里需要把当前类对象的智能指针作为参数传给其他函数时，就需要传递一个指向自身的<code>share_ptr</code>。</p><p>而当使用<code>shared_ptr</code>管理同一资源，调用<code>shared_ptr</code>的构造函数和拷贝构造函数是不一样的（构造函数新创建一份堆上的引用计数资源，拷贝构造函数修改原来堆上的引用计数资源），它们虽然使得不同<code>shared_ptr</code>指向同一资源，但<strong>管理引用计数资源的方式却不一样</strong>。这就造成了不能直接传递<code>shared_ptr&lt;Widget&gt;(this)</code>。因为这样会造成<code>2</code>个非共享的<code>share_ptr</code>指向同一个对象，引用计数资源相互独立导致对象被析构<code>2</code>次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">getptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Widget() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget::~Widget() called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 错误的示例, 每个 shared_ptr 都认为自己是对象仅有的所有者</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Widget;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; p2 = p1-&gt;getptr();</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 打印 p1 和 p2 的引用计数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count() = "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出为 1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2.use_count() = "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出为 1</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;  <span class="comment">// Widget 对象将会被删除两次</span></span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Widget&gt; <span class="comment">// 注意：继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">getptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">    ~Widget() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget::~Widget() called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Widget;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; p2 = p1-&gt;getptr();</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 打印 p1 和 p2 的引用计数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count() = "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出为 2</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2.use_count() = "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出为 2</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;  <span class="comment">// // Widget 对象只会被删除一次</span></span></span></span><br></pre></td></tr></table></figure><p>实际使用场景：在异步调用中，存在一个保活机制，异步函数执行的时间点我们是无法确定的，然而异步函数可能会使用到异步调用之前就存在的变量。为了保证该变量在异步函数执期间一直有效，我们可以传递一个指向自身的<code>share_ptr</code>给异步函数，这样在异步函数执行期间<code>share_ptr</code>所管理的对象就不会析构，所使用的变量也会一直有效了（保活）。</p><h5 id="enable-shared-from-this是如何实现的"><a href="#enable-shared-from-this是如何实现的" class="headerlink" title="enable_shared_from_this是如何实现的"></a><code>enable_shared_from_this</code>是如何实现的</h5><p><code>enable_shared_from_this</code>类中包含一个作为观察者的成员变量，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">enable_shared_from_this</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    SetSharedPtr(<span class="built_in">shared_ptr</span>&lt;T&gt;* sp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(weak_this_.expired())</span><br><span class="line">        wp = sp; <span class="comment">// 标准库中并没有把 sp 直接赋值给 wp，而是使用了 shared_ptr 的别名构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __shared_ptr&lt;_Tp, _Lp&gt; shared_from_this()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_ptr&lt;_Tp, _Lp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __shared_ptr&lt;const _Tp, _Lp&gt; shared_from_this() const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_ptr&lt;<span class="keyword">const</span> _Tp, _Lp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt; _M_weak_this; <span class="comment">// 使用 weak_ptr 的目的正是为了避免循环引用!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当一个类继承了<code>enable_shared_from_this</code>类，就继承了<code>_M_weak_this</code>这个成员变量。</p><p>使用<code>shared_ptr&lt;Widget&gt;(new Widget())</code>第一次构造智能指针对象时，就会初始化一个作为观察者的弱智能指针<code>_M_weak_this</code>指向<code>Widget</code>对象资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>&lt;T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(T* w)</span><br><span class="line">    &#123;</span><br><span class="line">        SetSharedPtr(<span class="keyword">this</span>, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSharedPtr</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;T&gt;* sp, enable_shared_from_this&lt;T&gt;* w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        w-&gt;SetSharedPtr(sp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此重载函数的作用是为了处理 Widget 并没有继承 enable_shared_from_this 的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSharedPtr</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<code>shared_from_this()</code>方法代替<code>shared_ptr</code>的普通构造函数来返回一个<code>shared_ptr</code>对象，从而避免产生额外的引用计数资源对象。在<code>shared_from_this()</code>函数中，是通过<code>_M_weak_this</code>来构造并返回一个<code>shared_ptr</code>对象的。</p><h5 id="智能指针源码分析"><a href="#智能指针源码分析" class="headerlink" title="智能指针源码分析"></a>智能指针源码分析</h5><p><code>unique_ptr</code>的声明包含两个模板参数，第一个参数<code>_Tp</code>显然就是原生指针的类型。第二个模板参数<code>_Dp</code>是一个<code>deleter</code>，默认值为<code>default_delete&lt;_Tp&gt;</code>。<code>default_delete</code>是一个针对<code>delete operator</code>的函数对象。</p><p><code>unique_ptr</code>内部用<code>tuple&lt;pointer, _Dp&gt; _M_t;</code>变量保存数据，相当于原生指针和<code>deleter</code>对象组成的一个<code>pair</code>。</p><p>定义了构造函数和移动构造函数和移动赋值运算符，但是删除了拷贝构造函数和拷贝赋值运算符。</p><p><code>unqiue_ptr</code>还定义了两个很重要的函数：<code>reset(pointer)</code>和<code>release()</code>。<code>reset(pointer)</code>的功能是用一个新指针替换原来的指针，而<code>release()</code>则是是放弃原生指针的所有权。</p><p>到目前为止，<code>unique_ptr</code>还不像个指针，因为还缺少两个方法：<code>operator*</code>和<code>operator-&gt;</code>。</p><p>下面是<code>unique_ptr</code>的源码，有删减，但大体上不变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/// Default constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp *__ptr)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> __ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">uniq_ptr_impl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">    struct _Ptr</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> type = _Up *;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Ptr</span>&lt;_Up, _Ep, __void_t&lt;typename remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">using</span> type = <span class="keyword">typename</span> remove_reference&lt;_Ep&gt;::type::pointer;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> _Ptr&lt;_Tp, _Dp&gt;::type;</span><br><span class="line"></span><br><span class="line">    __uniq_ptr_impl() = <span class="keyword">default</span>;</span><br><span class="line">    __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del&gt;</span><br><span class="line">    __uniq_ptr_impl(pointer __p, _Del &amp;&amp;__d) : _M_t(__p, <span class="built_in">std</span>::forward&lt;_Del&gt;(__d)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    pointer &amp;_M_ptr() &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">    pointer _M_ptr() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">    _Dp &amp;_M_deleter() &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line">    <span class="keyword">const</span> _Dp &amp;_M_deleter() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    tuple&lt;pointer, _Dp&gt; _M_t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">unique_ptr</span></span><br><span class="line">&#123;</span><br><span class="line">    __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</span><br><span class="line">    <span class="keyword">using</span> element_type = _Tp;</span><br><span class="line">    <span class="keyword">using</span> deleter_type = _Dp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Default constructor, creates a unique_ptr that owns nothing.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> : _M_t()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) <span class="keyword">noexcept</span> : _M_t(__p)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_ptr</span>(pointer __p, <span class="keyword">typename</span> remove_reference&lt;deleter_type&gt;::type &amp;&amp;__d) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_t(<span class="built_in">std</span>::move(__p), <span class="built_in">std</span>::move(__d))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move constructors.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Move constructor.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span> &amp;&amp;__u) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_t(__u.release(), <span class="built_in">std</span>::forward&lt;deleter_type&gt;(__u.get_deleter())) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Destructor, invokes the deleter if the stored pointer is not null.</span></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;__ptr = _M_t._M_ptr();</span><br><span class="line">        <span class="keyword">if</span> (__ptr != <span class="literal">nullptr</span>)</span><br><span class="line">            get_deleter()(__ptr);</span><br><span class="line">        __ptr = pointer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assignment.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span> &amp;<span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span> &amp;&amp;__u) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        reset(__u.release());</span><br><span class="line">        get_deleter() = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(__u.get_deleter());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Reset the %unique_ptr to empty, invoking the deleter if necessary.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span> &amp;<span class="keyword">operator</span>=(<span class="keyword">nullptr_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        reset();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Observers.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Dereference the stored pointer.</span></span><br><span class="line">    <span class="keyword">typename</span> add_lvalue_reference&lt;element_type&gt;::type</span><br><span class="line">    <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the stored pointer.</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the stored pointer.</span></span><br><span class="line">    <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_t._M_ptr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return a reference to the stored deleter.</span></span><br><span class="line">    <span class="function">deleter_type &amp;<span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_t._M_deleter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return a reference to the stored deleter.</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> deleter_type &amp;<span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_t._M_deleter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return @c true if the stored pointer is not null.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get() == pointer() ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Release ownership of any stored pointer.</span></span><br><span class="line">    <span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pointer __p = get();</span><br><span class="line">        _M_t._M_ptr() = pointer();</span><br><span class="line">        <span class="keyword">return</span> __p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(_M_t._M_ptr(), __p);</span><br><span class="line">        <span class="keyword">if</span> (__p != pointer())</span><br><span class="line">            get_deleter()(__p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Exchange the pointer and deleter with another object.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">unique_ptr</span> &amp;__u)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(_M_t, __u._M_t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable copy from lvalue.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> <span class="built_in">unique_ptr</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span> &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">unique_ptr</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是<code>shared_ptr</code>的类图。</p><p><img src="3725930-bdd744c1b57e7bea.jpg" alt="img"></p><p>如图，<code>shared_ptr</code>类几乎什么都没有做，它是继承了<code>__shared_ptr</code>，<code>__shared_ptr</code>内部有一个类型为<code>__shared_count</code>类型的成员，<code>__shared_count</code>内部有类型为<code>_Sp_counted_base*</code>的成员。</p><p><code>_Sp_counted_base</code>才是整个<code>shared_ptr</code>功能的核心，通过<code>_Sp_counted_base</code>控制引用计数来管理指向的内存，由图可见<code>_Sp_counted_base</code>内部不持有指向内存的指针，这里<code>__shared_count</code>内部的<code>_Sp_counted_base*</code>成员其实指向的是一个继承自<code>_Sp_counted_base</code>的<code>_Sp_counted_ptr</code>类型的派生类对象，<code>_Sp_counted_ptr</code>类型内部持有指向内存的指针<code>M_ptr</code>，这样<code>__shared_count</code>内部就既可以控制引用计数，又可以在最后根据指向对象的指针释放托管内存。</p><p>注意的是：为什么<code>_Sp_counted_ptr</code>和<code>__shared_ptr</code>内部都有指向对象的指针。实际上它们可以是不同的类型（只要它们之间存在隐式转换），这是<code>shared_ptr</code>的一大功能：</p><ol><li><p>无需虚析构。假设<code>Bar</code>是<code>Foo</code>的基类，但是<code>Bar</code>和<code>Foo</code>都没有虚析构。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Sp_counted_ptr._M_ptr 和 __shared_ptr._M_ptr 的类型都是 Foo*</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以赋值, __shared_ptr._M_ptr 自动向上转型 up-cast</span></span><br><span class="line"><span class="comment">// _Sp_counted_ptr._M_ptr 类型不变</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Bar&gt; sp2 = sp1;</span><br><span class="line"></span><br><span class="line">sp1.reset(); <span class="comment">// 这时 Foo 对象的引用计数降为 1</span></span><br></pre></td></tr></table></figure><p> 此后<code>sp2</code>仍然能安全地管理<code>Foo</code>对象的生命期，并安全完整地释放<code>Foo</code>，因为其<code>_Sp_counted_ptr._M_ptr</code>记住了<code>Foo</code>的实际类型。</p></li><li><p><code>shared_ptr&lt;void&gt;</code>可以指向并安全地管理（析构或防止析构）任何对象。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Sp_counted_ptr._M_ptr 和 __shared_ptr._M_ptr 的类型都是 Foo*</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以赋值, __shared_ptr._M_ptr 中的 Foo* 类型向 void* 自动转型</span></span><br><span class="line"><span class="comment">// _Sp_counted_ptr._M_ptr 类型不变</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; sp2 = sp1;</span><br><span class="line"></span><br><span class="line">sp1.reset(); <span class="comment">// 这时 Foo 对象的引用计数降为 1</span></span><br></pre></td></tr></table></figure><p> 此后<code>sp2</code>仍然能安全地管理<code>Foo</code>对象的生命期，并安全完整地释放<code>Foo</code>，不会出现<code>delete void*</code>的情况，因为<code>delete</code>的是<code>_Sp_counted_ptr._M_ptr</code>而不是<code>__shared_ptr._M_ptr</code>。</p></li><li><p>多继承。假设<code>Bar</code>是<code>Foo</code>的多个基类之一，那么：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时 sp1._M_ptr 和 sp2._M_ptr 可能指向不同的地址</span></span><br><span class="line"><span class="comment">// 因为 Bar subobject 在 Foo object 中的 offset 可能不为 0</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Bar&gt; sp2 = sp1;</span><br><span class="line"></span><br><span class="line">sp1.reset(); <span class="comment">// 此时 Foo 对象的引用计数降为 1</span></span><br></pre></td></tr></table></figure><p> 但是<code>sp2</code>仍然能安全地管理<code>Foo</code>对象的生命期，并安全完整地释放<code>Foo</code>，因为<code>delete</code>的不是<code>Bar*</code>，而是原来的 <code>Foo*</code>。换句话说，<code>sp1._M_ptr</code>和<code>sp2._M_ptr</code>可能具有不同的值（当然它们的类型也不同）。</p></li></ol><p><strong>这里称<code>_M_pi</code>为管理对象，它内部的<code>_M_ptr</code>为托管对象</strong>，管理同一块托管对象的多个<code>shared_ptr</code>内部共用一个管理对象,，这里的多个<code>shared_ptr</code>可能是通过第一个<code>shared_ptr</code>拷贝或者移动而来，管理对象内部有两个成员变量<code>_M_use_count</code>和<code>_M_weak_count</code>。</p><p><code>_M_use_count</code>表示托管对象的引用计数，控制托管对象什么时候析构和释放，当引用计数为<code>0</code>时调用托管对象的析构函数且释放内存。</p><p><code>_M_weak_count</code>表示管理对象的引用计数，它的初始值比<code>_M_use_count</code>大<code>1</code>，管理对象也是一个内存指针，<strong>这块指针是初始化第一个<code>shared_ptr</code>时<code>new</code>出来的</strong>，到最后也需要<code>delete</code>，所以使用<code>_M_weak_count</code>来控制管理对象什么时候析构，当<code>weak_ptr</code>析构时时，管理对象的引用计数<code>_M_weak_count</code>就会减<code>1</code>，当<code>_M_weak_count</code>为<code>0</code>时，管理对象<code>_M_pi</code>就会析构且释放内存。</p><p><strong><em><code>_M_use_count</code>是如何加减的</em></strong></p><p><em>M</em>use_count表示托管对象的引用计数，即当<code>shared_ptr</code>拷贝时会增加，当<code>shared_ptr</code>析构时会减少，看精简代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Yp&gt;</span><br><span class="line">__shared_ptr(<span class="keyword">const</span> __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r, element_type* __p) <span class="keyword">noexcept</span></span><br><span class="line">    : _M_ptr(__p), _M_refcount(__r._M_refcount)  <span class="comment">// never throws</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__shared_count(<span class="keyword">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span> : _M_pi(__r._M_pi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>) _M_pi-&gt;_M_add_ref_copy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy()</span><br><span class="line">&#123;</span><br><span class="line">    ++_M_use_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>拷贝时，内部<code>__shared_count</code>类型的<code>_M_refcount</code>会进行拷贝，<code>__shared_count</code>的拷贝构造函数会调用<code>_M_add_ref_copy()</code>方法，<code>_M_add_ref_copy()</code>方法中会将<code>_M_use_count</code>加<code>1</code>。</p><p>这里再看下<code>shared_ptr</code>的赋值构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Yp&gt;</span><br><span class="line">_Assignable&lt;<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;_Yp&gt;&amp;&gt; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;_Yp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__shared_ptr&lt;_Tp&gt;::<span class="keyword">operator</span>=(__r);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Yp&gt;</span><br><span class="line">_Assignable&lt;_Yp&gt; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _M_ptr = __r._M_ptr;</span><br><span class="line">    _M_refcount = __r._M_refcount;  <span class="comment">// __shared_count::op= doesn't throw</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__shared_count&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != _M_pi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != <span class="number">0</span>) __tmp-&gt;_M_add_ref_copy();</span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="number">0</span>) _M_pi-&gt;_M_release();</span><br><span class="line">        _M_pi = __tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可见，<code>shared_ptr</code>的<code>operator=</code>会调用<code>__shared_ptr</code>的<code>operator=</code>进而调用<code>__shared_count</code>的<code>operator=</code>，从这里可以看出管理同一块托管对象的<code>shared_ptr</code>共用的同一个管理对象的指针。</p><p><code>_M_use_count</code>是如何减为<code>0</code>的，可以猜想到<code>shared_ptr</code>析构时会调用<code>__shared_count</code>的析构函数，看精简代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~__shared_count() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>) _M_pi-&gt;_M_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--_M_use_count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _M_dispose();</span><br><span class="line">        <span class="keyword">if</span> (--_M_weak_count == <span class="number">0</span>) _M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span> &#123; <span class="keyword">delete</span> _M_ptr; &#125;</span><br></pre></td></tr></table></figure><p>在<code>shared_ptr</code>生命周期结束析构时会将引用计数减1，如果引用引用计数为<code>0</code>，会调用<code>_M_dispose()</code>函数进而释放托管对象内存。</p><p><strong><em><code>_M_weak_count</code>是如何加减的</em></strong></p><p>上面的代码中可以看见<code>_M_weak_count</code>为<code>0</code>时，会调用<code>_M_destroy()</code>函数，这里看看<code>_M_weak_count</code>是如何加减的。管理对象初始化时<code>_M_weak_count</code>的初始值为<code>1</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Sp_counted_base() <span class="keyword">noexcept</span> : _M_use_count(<span class="number">1</span>), _M_weak_count(<span class="number">1</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>注意当<code>shared_ptr</code>拷贝或者移动时<code>_M_weak_count</code>是不会增加的，它表示的是管理对象的计数，只有当<code>__M_use_count</code>为0时<code>_M_weak_count</code>才会减<code>1</code>，除此之外<code>_M_weak_count</code>的数值是由<code>weak_ptr</code>控制的。</p><p>由上面类图可以看见<code>weak_ptr</code>内部其实和<code>shared_ptr</code>内部持有的是同一个管理对象指针，即<code>_Sp_counted_base</code>的指针，当<code>weak_ptr</code>拷贝析构时候，<code>_Sp_counted_base</code>内部的<code>_M_weak_count</code>会相应加减。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__weak_count(<span class="keyword">const</span> __weak_count&amp; __r) <span class="keyword">noexcept</span> : _M_pi(__r._M_pi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>) _M_pi-&gt;_M_weak_add_ref();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_weak_add_ref() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    ++_M_weak_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~__weak_count() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>) _M_pi-&gt;_M_weak_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--_M_weak_count == <span class="number">0</span>) _M_destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> _M_destroy() <span class="keyword">noexcept</span> &#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，<code>weak_ptr</code>拷贝时<code>_M_weak_count</code>加<code>1</code>，析构时<code>_M_weak_count</code>减<code>1</code>，当<code>_M_weak_count</code>为<code>0</code>时，表示不再需要管理对象来控制托管对象，调用<code>_M_destroy()</code>的<code>delete this</code>来释放管理对象内存。</p><p><strong><em><code>weak_ptr</code>的<code>expired()</code>和<code>lock()</code>做了什么</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_refcount._M_get_use_count() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>weak_ptr</code>的<code>expired()</code>函数只是看了托管对象的引用计数是否为<code>0</code>，为<code>0</code>返回<code>true</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__shared_ptr&lt;_Tp, _Lp&gt; lock() const noexcept</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __shared_ptr&lt;element_type, _Lp&gt;(*<span class="keyword">this</span>, <span class="built_in">std</span>::nothrow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__shared_ptr(<span class="keyword">const</span> __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>)</span><br><span class="line">    : _M_refcount(__r._M_refcount, <span class="built_in">std</span>::nothrow)</span><br><span class="line">&#123;</span><br><span class="line">    _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>weak_ptr</code>的<code>lock()</code>函数是打算返回一个<code>shared_ptr</code>对象来延长托管对象的生命周期，这里返回后需要判断返回值是否为<code>nullptr</code>。</p><p><strong><em><code>shared_from_this()</code></em></strong>是如何实现的</p><p>精简代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __shared_ptr&lt;_Tp, _Lp&gt; shared_from_this()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_ptr&lt;_Tp, _Lp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __shared_ptr&lt;const _Tp, _Lp&gt; shared_from_this() const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_ptr&lt;<span class="keyword">const</span> _Tp, _Lp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt; _M_weak_this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>shared_from_this()</code>的类需要继承<code>enable_shared_from_this</code>类，<code>enable_shared_from_this</code>类中持有一个类型为<code>weak_ptr</code>的成员<code>_M_weak_this</code>，调用<code>shared_from_this()</code>就是将内部持有的<code>weak_ptr</code>转成了<code>shared_ptr</code>。</p><h5 id="为什么建议使用make-shared-函数"><a href="#为什么建议使用make-shared-函数" class="headerlink" title="为什么建议使用make_shared()函数"></a>为什么建议使用<code>make_shared()</code>函数</h5><p>我们已经看到了，<code>shared_ptr</code>内部维护了两个指针，如果你直接调用构造函数，就想这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>;</span></span><br><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Foo());</span><br></pre></td></tr></table></figure><p>这里实际分配了两次内存，第一次是调用<code>new Foo()</code>的时候，第二次则是在<code>shared_ptr</code>构造函数的内部构造<code>_Sp_counted_base</code>的时候。分配内存是很昂贵的操作，所以标准库提供了<code>make_shared()</code>函数，让你一次分配全部所需的内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> __shared_ptr&lt;_Tp, _Lp&gt;</span><br><span class="line">__make_shared(_Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_const&lt;_Tp&gt;::type _Tp_nc;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::__allocate_shared&lt;_Tp, _Lp&gt;</span><br><span class="line">        (<span class="built_in">std</span>::allocator&lt;_Tp_nc&gt;(), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在用<code>make_shared()</code>的话，可以一次分配一块足够大的内存，供<code>Foo</code>和<code>_Sp_counted_base</code>对象容身。</p><h5 id="智能指针的线程安全性分析"><a href="#智能指针的线程安全性分析" class="headerlink" title="智能指针的线程安全性分析"></a>智能指针的线程安全性分析</h5><ol><li><p>同一个的<code>shared_ptr</code>对象可以被多个线程同时读取（只读）</p><p> 对同一个对象的并发读，显然是线程安全的。</p></li><li><p>不同的<code>shared_ptr</code>对象可以被多个线程同时读写</p><p> 如果这不同的<code>shared_ptr</code>对象管理的是不同的对象资源，显然并发读写是线程安全的。</p><p> 若它们指向的是同一个对象，这需要它们共同维护一份在堆上的引用计数资源。而<code>shared_ptr</code>对象对于这份引用计数资源的读写使用了原子性操作，因此，也是线程安全的。</p><p> 容易出现问题的是，从<code>shared_ptr</code>构造<code>weak_ptr</code>或者从<code>weak_ptr</code>构造<code>shared_ptr</code>的情况。</p><ul><li><p>从<code>shared_ptr</code>构造<code>weak_ptr</code></p><p>  由于<code>weak_ptr</code>的构造过程中并不涉及引用计数资源的改变（实际上不改变的是<code>shared_ptr</code>对象计数变量<code>_M_use_count_</code>，只是改变了<code>weak_ptr</code>对象计数变量<code>_M_weak_count</code>），和前面的分析一样，使用了原子操作，也是线程安全的。</p></li><li><p>从<code>weak_ptr</code>构造<code>shared_ptr</code></p><p>  而这一过程，会改变引用计数资源（增加<code>shared_ptr</code>对象计数变量<code>_M_use_count</code>），但是实际上也实现了线程安全的修改。可以去参考源码的实现。</p></li></ul></li><li><p>同一个<code>shared_ptr</code>对象不可以被多个线程同时读写（有写）</p><p> <code>shared_ptr&lt;Foo&gt;</code>包含两个成员，一个是指向<code>Foo</code>的指针<code>_M_ptr</code>，另一个是<code>_Sp_counted_base*</code>指针，指向<strong>堆上的</strong><code>_Sp_counted_base</code>对象。因为这两个数据成员读写操作不是原子化，所以使用多个线程读写同一个<code>shared_ptr</code>对象需要加锁，也就是说不是线程安全的。</p></li></ol><h5 id="自己动手实现一个基本的shared-ptr"><a href="#自己动手实现一个基本的shared-ptr" class="headerlink" title="自己动手实现一个基本的shared_ptr"></a>自己动手实现一个基本的<code>shared_ptr</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Deleter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DefaultFunc = <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(T *)&gt;;</span><br><span class="line">    Deleter() : func_(<span class="built_in">std</span>::bind(&amp;Deleter::defaultFunc, <span class="keyword">this</span>, <span class="built_in">std</span>::placeholders::_1))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleter::Deleter()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">Deleter</span>(<span class="title">D</span> <span class="title">func</span>) :</span> func_(func)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleter::Deleter(D func)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        func_(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DefaultFunc func_;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFunc</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleter::defaultFunc"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Ref_count_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    <span class="keyword">int</span> count_;</span><br><span class="line">    Deleter&lt;T&gt; deleter_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Ref_count_base(T *p) : ptr_(p), count_(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ref_count_base::Ref_count_base(T *p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">Ref_count_base</span>(<span class="title">T</span> *<span class="title">p</span>, <span class="title">D</span> <span class="title">deleter</span>) :</span> ptr_(p), count_(<span class="number">1</span>), deleter_(deleter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ref_count_base::Ref_count_base(T *p, D deleter)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Ref_count_base()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ref_count_base::~Ref_count_base()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        deleter_(ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reduce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> --count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    Ref_count_base&lt;T&gt; *ref_count_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shared_ptr() : ptr_(<span class="literal">nullptr</span>), ref_count_(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Shared_ptr</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr(std::nullptr_t)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        Shared_ptr&lt;T&gt; temp;</span><br><span class="line">        swap(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    explicit Shared_ptr(T *p) : ptr_(p), ref_count_(new Ref_count_base&lt;T&gt;(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr(T *p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">explicit</span> <span class="title">Shared_ptr</span>(<span class="title">T</span> *<span class="title">p</span>, <span class="title">D</span> <span class="title">deleter</span>) :</span> ptr_(p), ref_count_(<span class="keyword">new</span> Ref_count_base&lt;T&gt;(p, deleter))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr(T *p, D deleter)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Shared_ptr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::~Shared_ptr()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (ref_count_ &amp;&amp; ref_count_-&gt;reduce() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">delete</span> ref_count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Shared_ptr(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp) : ptr_(sp.ptr_), ref_count_(sp.ref_count_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (ref_count_)</span><br><span class="line">            ref_count_-&gt;increase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Shared_ptr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::operator=(const Shared_ptr&lt;T&gt; &amp;sp)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="function">Shared_ptr&lt;T&gt; <span class="title">temp</span><span class="params">(sp)</span></span>;</span><br><span class="line">        swap(temp);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Shared_ptr &amp;<span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::operator=(std::nullptr_t)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        Shared_ptr&lt;T&gt; temp;</span><br><span class="line">        swap(temp);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_)</span><br><span class="line">            <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_)</span><br><span class="line">            <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">ptrdiff_t</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Shared_ptr&lt;T&gt; &amp;rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_ == rhs.ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_ != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ref_count_)</span><br><span class="line">            <span class="keyword">return</span> ref_count_-&gt;getCount();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Shared_ptr&lt;T&gt; &amp;sp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(ptr_, sp.ptr_);</span><br><span class="line">        swap(ref_count_, sp.ref_count_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">Shared_ptr</span>&lt;T&gt; &amp;<span class="title">lhs</span>, <span class="title">Shared_ptr</span>&lt;T&gt; &amp;<span class="title">rhs</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    lhs.swap(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下是测试代码 */</span></span><br><span class="line"><span class="comment">/* 以下是测试代码 */</span></span><br><span class="line"><span class="comment">/* 以下是测试代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span> : <span class="title">val</span><span class="params">(i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point(int i = 0)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Point()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Point()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point &amp;<span class="keyword">operator</span>=(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point::operator=(int i)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        val = i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDeleter1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Point *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDeleter2</span><span class="params">(Point *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myDeleter2(Point *p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myDeleter3 = [](Point *p) &#123; <span class="keyword">delete</span>[] p; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Shared_ptr&lt;Point&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Point[<span class="number">2</span>], myDeleter3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1[<span class="number">0</span>].getVal() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1[<span class="number">0</span>].getVal() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Shared_ptr&lt;Point&gt; p2 = p1;</span><br><span class="line">    Shared_ptr&lt;Point&gt; p3;</span><br><span class="line">    p3 = p2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2.use_count: "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3.use_count: "</span> &lt;&lt; p3.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 == p2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 != p2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 为真"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p1)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 为假"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2.use_count: "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3.use_count: "</span> &lt;&lt; p3.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果为</span></span><br><span class="line"></span><br><span class="line">Point::Point(<span class="keyword">int</span> i = <span class="number">0</span>)</span><br><span class="line">Point::Point(<span class="keyword">int</span> i = <span class="number">0</span>)</span><br><span class="line">Deleter::Deleter(D func)</span><br><span class="line">Ref_count_base::Ref_count_base(T *p, D deleter)</span><br><span class="line">Shared_ptr::Shared_ptr(T *p, D deleter)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">Point::<span class="keyword">operator</span>=(<span class="keyword">int</span> i)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">p1.use_count: <span class="number">1</span></span><br><span class="line">Shared_ptr::Shared_ptr(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::Shared_ptr()</span><br><span class="line">Shared_ptr::<span class="keyword">operator</span>=(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::Shared_ptr(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br><span class="line">p1.use_count: <span class="number">3</span></span><br><span class="line">p2.use_count: <span class="number">3</span></span><br><span class="line">p3.use_count: <span class="number">3</span></span><br><span class="line">p1 == p2</span><br><span class="line">p1 为真</span><br><span class="line">Shared_ptr::<span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>)</span><br><span class="line">Shared_ptr::Shared_ptr()</span><br><span class="line">Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br><span class="line">p1 为假</span><br><span class="line">p1.use_count: <span class="number">0</span></span><br><span class="line">p2.use_count: <span class="number">2</span></span><br><span class="line">p3.use_count: <span class="number">2</span></span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br><span class="line">Ref_count_base::~Ref_count_base()</span><br><span class="line">Point::~Point()</span><br><span class="line">Point::~Point()</span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br></pre></td></tr></table></figure><h5 id="智能指针使用注意事项"><a href="#智能指针使用注意事项" class="headerlink" title="智能指针使用注意事项"></a>智能指针使用注意事项</h5><ol><li><p>尽量用<code>make_shared/make_unique</code></p><p> <code>std::shared_ptr</code>在实现的时候使用的<code>ref count</code>技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行<code>std::shared_ptr&lt;Widget&gt; p2(new Widget)</code>的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而<code>std::make_shared&lt;Widget&gt;()</code>则是只执行一次内存申请，将数据和控制块的申请放到一起。</p></li><li><p>不要使用相同的内置指针来初始化（或者<code>reset</code>）多个智能指针</p></li><li><p>不要<code>delete get()</code>返回的指针</p></li><li><p>不要用<code>get()</code>初始化或<code>reset</code>另一个智能指针</p></li><li><p>智能指针管理的资源它只会默认删除<code>new</code>分配的内存，如果不是<code>new</code>分配的则要传递给其一个删除器</p><p> 以下代码试图将<code>malloc</code>产生的动态内存交给<code>shared_ptr</code>管理，显然是有问题的，所以我们需要自定义删除器传递给<code>shared_ptr</code>。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>* pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(pi)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>* pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(pi， [](<span class="keyword">int</span>* p)&#123; <span class="built_in">free</span>(p); &#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要把一个原生指针给多个<code>shared_ptr</code>或者多个<code>unique_ptr</code>管理</p><p> 在使用原生指针对智能指针初始化的时候，智能指针对象都视原生指针为自己管理的资源。换句话意思就说：初始化多个智能指针之后，这些智能指针都担负起释放内存的作用。那么就会导致该原生指针会被释放多次！！</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1, p2 析构的时候都会释放 ptr, 同一内存被释放多次!</span></span><br><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重要知识点 </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之排序算法实现及效率分析</title>
      <link href="/cuQpjpPOQ0qnpSE2/"/>
      <url>/cuQpjpPOQ0qnpSE2/</url>
      
        <content type="html"><![CDATA[<ol><li>快速排序</li><li>归并排序</li><li>计数排序</li><li>堆排序</li></ol><a id="more"></a><h4 id="排序算法实现及效率分析"><a href="#排序算法实现及效率分析" class="headerlink" title="排序算法实现及效率分析"></a>排序算法实现及效率分析</h4><p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png" alt="排序算法总结"></p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 洗牌算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = rand() % ((n - <span class="number">1</span>) - i + <span class="number">1</span>) + i; <span class="comment">// 返回 [i, n - 1] 内的随机数</span></span><br><span class="line">        swap(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左闭右闭区间, 以首元素作为轴点 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本一, 数据结构视频 9.1.5 节</span></span><br><span class="line"><span class="comment">// int partition(std::vector&lt;int&gt; &amp;nums, int lo, int hi)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     // 随机置乱数组</span></span><br><span class="line"><span class="comment">//     shuffle(nums.begin(), nums.end(), default_random_engine(time(nullptr)));</span></span><br><span class="line"><span class="comment">//     int pivot = nums[lo];</span></span><br><span class="line"><span class="comment">//     while (lo &lt; hi)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         while (lo &lt; hi &amp;&amp; (pivot &lt;= nums[hi])) hi--;</span></span><br><span class="line"><span class="comment">//         nums[lo] = nums[hi];</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         while (lo &lt; hi &amp;&amp; (nums[lo] &lt;= pivot)) lo++;</span></span><br><span class="line"><span class="comment">//         nums[hi] = nums[lo];</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     nums[lo] = pivot;</span></span><br><span class="line"><span class="comment">//     return lo;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本二, 算法 4 书籍</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 随机置乱数组</span></span><br><span class="line">    shuffle(nums.begin(), nums.end(), default_random_engine(time(<span class="literal">nullptr</span>)));</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[++i] &lt; nums[lo]) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[lo] &lt; nums[--j]) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= i) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::swap(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::swap(nums[lo], nums[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本三, 数据结构视频 9.3.4 节</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 随机置乱数组</span></span><br><span class="line">    shuffle(nums.begin(), nums.end(), default_random_engine(time(<span class="literal">nullptr</span>)));</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = lo;</span><br><span class="line">    <span class="keyword">while</span> (++j &lt;= hi)</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[lo])</span><br><span class="line">            <span class="built_in">std</span>::swap(nums[++i], nums[j]);</span><br><span class="line">    <span class="built_in">std</span>::swap(nums[lo], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(nums, lo, hi);</span><br><span class="line">    quickSort(nums, lo, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, pivot + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序（Top-down-Approach）"><a href="#归并排序（Top-down-Approach）" class="headerlink" title="归并排序（Top-down Approach）"></a>归并排序（<code>Top-down Approach</code>）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意以下的 vector 参数传的都是引用</span></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="comment">// [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 辅助空间, 存储 [mi + 1, hi] 元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(nums.begin() + mi + <span class="number">1</span>, nums.begin() + hi + <span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对两个数组中的元素, 依次从后向前比较</span></span><br><span class="line">    <span class="comment">// 从后向前放置元素, 先放较大者</span></span><br><span class="line">    <span class="keyword">int</span> i = mi;</span><br><span class="line">    <span class="keyword">int</span> j = helper.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = hi;</span><br><span class="line">    <span class="comment">// 注意 i 的终止条件</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= lo &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 注意, 这里如果是 &gt;= 就不稳定了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; helper[j])</span><br><span class="line">            nums[k--] = nums[i--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[k--] = helper[j--];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 单元素自动有序</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, lo, mi);</span><br><span class="line">    mergeSort(nums, mi + <span class="number">1</span>, hi);</span><br><span class="line">    merge(nums, lo, mi, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 排序 [0, nums.size()) 之间的元素</span></span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序（Bottom-up-Approach）"><a href="#归并排序（Bottom-up-Approach）" class="headerlink" title="归并排序（Bottom-up Approach）"></a>归并排序（<code>Bottom-up Approach</code>）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="comment">// [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 辅助空间, 存储 [mi + 1, hi] 元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(nums.begin() + mi + <span class="number">1</span>, nums.begin() + hi + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对两个数组中的元素, 依次从后向前比较</span></span><br><span class="line">    <span class="comment">// 从后向前放置元素, 先放较大者</span></span><br><span class="line">    <span class="keyword">int</span> i = mi;</span><br><span class="line">    <span class="keyword">int</span> j = helper.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = hi;</span><br><span class="line">    <span class="comment">// 注意 i 的终止条件</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= lo &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; helper[j])</span><br><span class="line">            nums[k--] = nums[i--];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">    <span class="comment">// 中间节点相对于起点的位置是 1 个 step</span></span><br><span class="line">    <span class="comment">// 终点相对于起点是 2 个 step</span></span><br><span class="line">    <span class="comment">// step 从 1 开始直到等于数组的长度 sz </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= sz; step *= <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 注意, 这里 lo 从 0 开始直到等于 sz - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; sz; lo += <span class="number">2</span> * step)</span><br><span class="line">            <span class="comment">// 因为 merge 函数实现的原因, 都是闭区间, 而且 [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line">            <span class="comment">// 所以这里求出的 mi 和 hi 都需要减 1</span></span><br><span class="line">            merge(nums, lo, min(lo + step - <span class="number">1</span>, sz - <span class="number">1</span>), min(lo + <span class="number">2</span> * step - <span class="number">1</span>, sz - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ol><li>计数排序要求待排序的<code>n</code>个元素的大小在<code>[0, k]</code>之间，并且<code>k</code>与<code>n</code>在一个数量级上，即<code>k = O(n)</code>，此时使用计数排序可以把时间复杂度降到<code>O(n)</code>上；</li><li>计数排序不是基于比较的排序算法，它基于计数策略；</li><li>写计数排序算法时，应该把它写成稳定排序的；</li><li>计数排序还是原址排序，但需要借助额外的内存空间；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出待排序的数组中最大的元素 maxVal 和最小元素 minVal</span></span><br><span class="line"><span class="comment">// 统计数组中每个值为 val 的元素出现的次数, 存入数组 count 的第 val - minVal 项</span></span><br><span class="line"><span class="comment">// 对所有的计数累加, 从 count 中的第一个元素开始, 每一项和前一项相加</span></span><br><span class="line"><span class="comment">// 反向填充目标数组: 将每个元素 val 放在新数组的第 count(val - minVal) 项</span></span><br><span class="line"><span class="comment">// 每放一个元素就将 count(val - minVal) 减去 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minVal = *min_element(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> valRange = maxVal - minVal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意: 这个数组的大小为 valRange + 1, 用于统计 [0, valRange]范围内的元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(valRange + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计待排序数组中每一个元素的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        count[x - minVal]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处计算待排序数组中小于等于第i个元素的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= valRange; ++i)</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把待排序的数组放到输出数组中, 为了保持排序的稳定性, 从后向前添加元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">backup</span><span class="params">(nums)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = count[backup[i] - minVal] - <span class="number">1</span>;</span><br><span class="line">        nums[index] = backup[i];</span><br><span class="line">        <span class="comment">// 因为可能有重复的元素, 所以要减 1, 为下一个重复的元素计算正确的下标</span></span><br><span class="line">        count[backup[i] - minVal]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>秩为<code>i</code>的元素，其父节点若存在，其秩必为<code>(i - 1) / 2</code>；其左孩子若存在，其秩必为<code>2 * i + 1</code>；其右孩子若存在，其秩必为左孩子秩加<code>1</code>。</p><p><strong>下滤</strong>：将首元素依次和其孩子中较大者交换。<strong>上滤</strong>：将末元素依次和其父亲交换。时间复杂度均为<code>O(logn)</code>。</p><p><strong>批量建堆</strong>：可以是所有的<strong>内部节点</strong>，自右往左依次<strong>下滤</strong>（复杂度正比于所有下滤节点的高度），或者是末元素依次上滤（复杂度是正比于所有上滤节点的深度），相比之下，前者的时间复杂度为<code>O(n)</code>，后者时间复杂度为<code>O(nlogn)</code>。第一个内部节点其实就是末元素的父亲，之后的内部节点依次递减即可。</p><p><strong>堆排序</strong>：先执行<strong>批量建堆</strong>操作，时间复杂度为<code>O(n)</code>，然后进行<code>n</code>次取最大值操作，时间复杂度为<code>O(nlogn)</code>。具体实现可以是建完堆后，反复进行<strong>将首元素和未排序的末元素交换，然后对首元素进行下滤</strong>的操作。总体时间复杂度为<code>O(n) + O(nlogn) = O(nlogn)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(i) ((i - 1) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(i) ((2 * i) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(i) (LC(i) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下滤操作, 复杂度正比于完全二叉树的高度为 log(n)</span></span><br><span class="line"><span class="comment">// 参数 len 代表 [有效堆] 数组的长度, 可用于验证待下滤元素 i 的左右孩子节点的合法性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downFilter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = nums[i]; <span class="comment">// 先保存待下滤的值, i 就可代表洞号</span></span><br><span class="line">    <span class="keyword">int</span> rc = RC(i);    <span class="comment">// 待下滤元素的右孩子</span></span><br><span class="line">    <span class="comment">// 如果右孩子存在</span></span><br><span class="line">    <span class="keyword">while</span> (rc &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果右子节点的值小于左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (nums[rc] &lt;= nums[rc - <span class="number">1</span>])</span><br><span class="line">            rc--;</span><br><span class="line">        <span class="comment">// 此时, rc 指向孩子节点中较大的那一个</span></span><br><span class="line">        <span class="comment">// 如果待下滤的值比孩子中较大的还大, 就不需要下滤了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[rc] &lt;= val)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[i] = nums[rc];</span><br><span class="line">        i = rc;     <span class="comment">// 产生新的洞号</span></span><br><span class="line">        rc = RC(i); <span class="comment">// 获得新洞号的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右孩子不存在, 但如果左孩子存在且其值大于待下滤的值</span></span><br><span class="line">    <span class="keyword">if</span> (rc - <span class="number">1</span> &lt; len &amp;&amp; nums[rc - <span class="number">1</span>] &gt; val)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = nums[rc - <span class="number">1</span>];</span><br><span class="line">        i = rc - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右孩子都不存在了</span></span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">    <span class="keyword">int</span> i = P(sz - <span class="number">1</span>); <span class="comment">// 获取末元素的父亲, 也就是最后一个内部节点</span></span><br><span class="line">    <span class="comment">// 建堆操作, 复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">        downFilter(nums, i--, sz); <span class="comment">// 从最后一个内部节点自后向前 依次下滤</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外层循环 n 加内层的 log(n) 下滤, 因此堆排序复杂度为 nlog(n)</span></span><br><span class="line">    <span class="comment">// 此时最大元素是首元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(nums[<span class="number">0</span>], nums[i]); <span class="comment">// 首尾交换, 末元素就位</span></span><br><span class="line">        downFilter(nums, <span class="number">0</span>, i);      <span class="comment">// 将新首元素下滤</span></span><br><span class="line">        <span class="comment">// 依次缩短未排序数组的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之右值与移动语义</title>
      <link href="/63ixVU2ANYIUKUrm/"/>
      <url>/63ixVU2ANYIUKUrm/</url>
      
        <content type="html"><![CDATA[<ol><li>解释<strong>右值引用</strong>和左值引用的区别</li><li>移动构造函数和移动赋值运算符</li><li>理解<code>std::move</code>和<code>std::forward</code></li></ol><a id="more"></a><h4 id="解释右值引用和左值引用的区别"><a href="#解释右值引用和左值引用的区别" class="headerlink" title="解释右值引用和左值引用的区别"></a>解释<strong>右值引用</strong>和左值引用的区别</h4><p>所谓<strong>右值引用</strong>就是必须绑定到右值的引用，通过<code>&amp;&amp;</code>获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。<strong>左值引用</strong>，不能绑定到要转换的表达式、字面常量或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。</p><p><strong>返回左值的表达式</strong>包括返回左值引用的函数及赋值、下标、解引用和前置递增<code>/</code>递减运算符，<strong>返回右值的表达式</strong>包括返回非引用类型的函数及算术、关系、位和后置递增<code>/</code>递减运算符。可以看到，左值的特点是有持久的状态，而右值则是短暂的。</p><p><strong>变量是左值</strong>，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p><p>函数参数和其它任何变量一样，都是左值表达式。</p><h4 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h4><p>参见<code>C++ primer 13.6</code>。</p><p>与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为<code>noexcept</code>。</p><p>在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的<strong>每个非<code>static</code>数据成员</strong>都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。</p><p>移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。</p><p>如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。</p><p>类似拷贝构造函数和拷贝赋值运算符，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。如果有类成员是<code>const</code>的或是引用，则类的移动赋值运算符被定义为删除的。</p><p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。</p><p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数：移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝（即，通过拷贝构造函数来“移动”）。</p><p><strong><em>拷贝并交换赋值运算符和移动操作</em></strong><br><code>HasPtr</code>类定义了一个拷贝并交换赋值运算符，如果为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加的移动构造函数</span></span><br><span class="line">    HasPtr(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> : ps(p.ps), i(p.i)</span><br><span class="line">    &#123;</span><br><span class="line">        p.ps = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值运算符既是移动赋值运算符, 也是拷贝赋值运算符</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(HasPtr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        HasPtr temp(rhs); <span class="comment">// copy and</span></span><br><span class="line">        swap(*<span class="keyword">this</span>, temp); <span class="comment">// swap</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他成员的定义</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个版本中，我们为类添加了一个移动构造函数，它接管了给定实参的值。构造函数体将给定的<code>HasPtr</code>的指针置为<code>0</code>，从而确保销毁移后源对象是安全的。此函数不会抛出异常，因此我们将其标记为<code>noexcept</code>。<br>现在让我们观察赋值运算符。<strong>此运算符有一个非引用参数</strong>，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。<br>假定<code>hp</code>和<code>hp2</code>都是<code>HasPtr</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hp = hp2;<span class="comment">// hp2 是一个左值; hp2 通过拷贝构造函数来拷贝</span></span><br><span class="line">hp = <span class="built_in">std</span>::move(hp2); <span class="comment">// 移动构造函数移动 hp2</span></span><br></pre></td></tr></table></figure><p>在第一个赋值中，右侧运算对象是一个左值，因此移动构造函数是不可行的。<code>rhs</code>将使用拷贝构造函数来初始化。拷贝构造函数将分配一个新<code>string</code>，并拷贝<code>hp2</code>指向的<code>string</code>。<br>在第二个赋值中，我们调用<code>std::move</code>将一个右值引用绑定到<code>hp2</code>上。在此情况下，拷贝构造函数和移动构造函数都是可行的。但是，由于实参是一个右值引用，移动构造函数是精确匹配的。移动构造函数从<code>hp2</code>拷贝指针，而不会分配任何内存。<br>不管使用的是拷贝构造函数还是移动构造函数，赋值运算符的函数体都<code>swap</code>两个运算对象的状态。交换<code>HasPtr</code>会交换两个对象的指针成员。在<code>swap</code>之后，<code>rhs</code>中的指针将指向原来左侧运算对象所拥有的<code>string</code>。当<code>rhs</code>离开其作用域时，这个<code>string</code>将被销毁。</p><h4 id="理解std-move和std-forward"><a href="#理解std-move和std-forward" class="headerlink" title="理解std::move和std::forward"></a>理解<code>std::move</code>和<code>std::forward</code></h4><p>参见<code>C++ primer 16.2.6 &amp; 16.2.7</code>。</p><p><strong>调用<code>std::move</code>就意味着承诺：除了对移后源赋值或销毁外，我们将不再使用它。</strong></p><h5 id="标准库中std-move的实现"><a href="#标准库中std-move的实现" class="headerlink" title="标准库中std::move的实现"></a>标准库中<code>std::move</code>的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从一个左值 static_cast 到一个右值引用是允许的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>remove_reference</code>模板有一个模板类型参数和一个名为<code>type</code>的（<code>public</code>）类型成员。如果我们用一个引用类型实例化<code>remove_reference</code>，则<code>type</code>将表示被引用的类型。例如，如果我们实例化<code>remove_reference&lt;string&amp;&gt;</code>，则<code>type</code>成员将是<code>string</code>。更一般的，给定一个迭代器<code>beg</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br></pre></td></tr></table></figure><p>将获得<code>beg</code>引用的元素的类型：<code>decltype(*beg)</code>返回元素类型的引用类型。<code>remove_reference::type</code>脱去引用，剩下元素类型本身。</p><h5 id="std-move是如何工作的"><a href="#std-move是如何工作的" class="headerlink" title="std::move是如何工作的"></a><code>std::move</code>是如何工作的</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("hi!"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"bye!"</span>));<span class="comment">// 正确: 从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1);<span class="comment">// 正确: 但在赋值之后, s1的值是不确定的</span></span><br></pre></td></tr></table></figure><p>在第一个赋值中，传递给<code>move</code>的实参是<code>string</code>的构造函数的右值结果——<code>string(&quot;bye!&quot;)</code>。因此，在<code>std::move(string(&quot;bye!&quot;))</code>中：</p><ul><li>推断出的<code>T</code>的类型为<code>string</code>；</li><li>因此，<code>remove_reference</code>用<code>string</code>进行实例化；</li><li><code>remove_reference&lt;string&gt;</code>的<code>type</code>成员是<code>string</code>；</li><li><code>move</code>的返回类型是<code>string&amp;&amp;</code>；</li><li><code>move</code>的函数参数<code>t</code>的类型为<code>string&amp;&amp;</code>。</li></ul><p>因此，这个调用实例化<code>move&lt;string&gt;</code>，即函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp;&amp; <span class="title">move</span><span class="params">(<span class="built_in">string</span>&amp;&amp; t)</span></span></span><br></pre></td></tr></table></figure><p>函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。<code>t</code>的类型已经是<code>string&amp;&amp;</code>，于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用。</p><p>现在考虑第二个赋值，它调用了<code>std::move</code>。在此调用中，传递给<code>move</code>的实参是一个左值。这样：</p><ul><li>推断出的<code>T</code>的类型为<code>string&amp;</code>；</li><li>因此，<code>remove_reference</code>用<code>string&amp;</code>进行实例化；</li><li><code>remove_reference&lt;string&amp;&gt;</code>的<code>type</code>成员是<code>string</code>；</li><li><code>move</code>的返回类型仍是<code>string&amp;&amp;</code>；</li><li><code>move</code>的函数参数<code>t</code>实例化为<code>string&amp;&amp; &amp;</code>，会折叠为<code>string&amp;</code>。</li></ul><p>因此，这个调用实例化<code>move&lt;string&amp;&gt;</code>，即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp;&amp; <span class="title">move</span><span class="params">(<span class="built_in">string</span>&amp; t)</span></span></span><br></pre></td></tr></table></figure><p>这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。在此情况下，<code>t</code>的类型为<code>string&amp;</code>，<code>static_cast</code>将其转换为<code>string&amp;&amp;</code>。</p><h5 id="标准库中std-forward的实现"><a href="#标准库中std-forward的实现" class="headerlink" title="标准库中std::forward的实现"></a>标准库中<code>std::forward</code>的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp;&amp; <span class="title">forward</span>(<span class="title">typename</span> <span class="title">std</span>:</span>:remove_reference&lt;T&gt;::type&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp;&amp; <span class="title">forward</span>(<span class="title">typename</span> <span class="title">std</span>:</span>:remove_reference&lt;T&gt;::type&amp;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。通常情况下，使用<code>forward</code>传递那些<strong>定义为模板类型参数的右值引用的函数参数</strong>。通过其返回类型上的引用折叠，<code>forward</code>可以保持给定实参的左值<code>/</code>右值以及<code>const</code>属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在这里使用 std::forward&lt;T&gt;(t)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实参<code>t</code>是一个右值，则<code>T</code>被推断为一个普通（非引用）类型，<code>std::forward&lt;T&gt;</code>将返回<code>T&amp;&amp;</code>。如果实参是一个左值，则通过引用折叠，<code>T</code>被推断为一个左值引用类型。在此情况下，<code>std::forward&lt;T&gt;</code>返回类型是一个指向左值引用类型的右值引用<code>T&amp;&amp; &amp;</code>，再次引用折叠，将返回一个左值引用类型<code>T&amp;</code>。</p><p>注意：<strong>不能使用一个左值实例化一个右值引用类型的函数参数</strong>。函数参数和其它任何变量一样，在函数体内都是左值表达式。</p>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之二叉树</title>
      <link href="/B90hHtDrYEYJD3xv/"/>
      <url>/B90hHtDrYEYJD3xv/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>4</code>部分——二叉树。这里把有代表性的题目发出来，共计<code>36</code>道。</p><p><code>leetcode</code>刷题系列其它文章组织如下：</p><p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p><p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p><p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p><a id="more"></a><h5 id="114-Binary-Tree-Preorder-Traversal"><a href="#114-Binary-Tree-Preorder-Traversal" class="headerlink" title="114. Binary Tree Preorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">114. Binary Tree Preorder Traversal</a></h5><blockquote><p>二叉树的前序遍历。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) &#123;</span><br><span class="line">        TreeNode* node = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="keyword">while</span>(node) &#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">                nodes.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal</a></h5><blockquote><p>二叉树的中序遍历。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正中序遍历, 即左-中-右</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;        </span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodes.empty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逆中序遍历, 即右-中-左</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;        </span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            <span class="comment">// 右子树依次入栈</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodes.empty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">// 这里去左子树</span></span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. Binary Tree Postorder Traversal</a></h5><blockquote><p>二叉树的后序遍历。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此解法借鉴中序遍历的思路</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    TreeNode* preVisited = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodes.empty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        root = nodes.top();</span><br><span class="line">        <span class="comment">// 如果待访问节点没有右孩子或者右孩子刚才访问过</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == preVisited) &#123;</span><br><span class="line">            <span class="comment">// 就访问</span></span><br><span class="line">            preVisited = root;</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="comment">// 这是为了跳过下次的 while(root) 循环</span></span><br><span class="line">            root = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// 下一个待访问节点一定是刚刚访问节点的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果待访问节点有右孩子并且右孩子上次没有访问过</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 就去访问右孩子</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此解法借鉴前序遍历的思路</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) &#123;</span><br><span class="line">        TreeNode* node = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="keyword">while</span>(node) &#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="comment">// 和前序遍历相反的顺序访问左右子树</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">                nodes.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后, 逆序输出就和后序遍历一样</span></span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a></h5><blockquote><p>二叉树的层序遍历。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用队列迭代实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nodes.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subVector</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            root = nodes.front();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            subVector[i] = root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) &#123;</span><br><span class="line">                nodes.push(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">                nodes.push(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(subVector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助前序遍历的思想, 递归实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 每次递归的时候提供被遍历节点的层级信息</span></span><br><span class="line">    <span class="keyword">auto</span> preOrder = [&amp;](<span class="keyword">auto</span>&amp;&amp; preOrder, TreeNode* root, <span class="keyword">size_t</span> level) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level) &#123;</span><br><span class="line">            res.resize(level);</span><br><span class="line">        &#125;</span><br><span class="line">        res[level - <span class="number">1</span>].push_back(root-&gt;val);</span><br><span class="line">        preOrder(preOrder, root-&gt;left, level);</span><br><span class="line">        preOrder(preOrder, root-&gt;right, level);</span><br><span class="line">    &#125;;</span><br><span class="line">    preOrder(preOrder, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree</a></h5><blockquote><p>给定二叉树的根，返回其最大深度。二叉树的最大深度是指沿着从根节点到最远的叶节点的最长路径的节点数。</p><p><strong>Example:</strong></p><img src="tmp-tree.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自底向上递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自上到下递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每次递归时传递被访问节点的深度信息</span></span><br><span class="line">    function&lt;<span class="keyword">void</span>(TreeNode*, <span class="keyword">int</span>)&gt; helper = [&amp;](TreeNode* root, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, depth);</span><br><span class="line">        helper(root-&gt;left, <span class="number">1</span> + depth);</span><br><span class="line">        helper(root-&gt;right, <span class="number">1</span> + depth);</span><br><span class="line">    &#125;;</span><br><span class="line">    helper(root, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree</a></h5><blockquote><p>  给定二叉树的根，返回其最小深度。二叉树的最小深度是指沿着从根节点到最近的叶节点的最短路径的节点数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftMinDepth = minDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> rightMinDepth = minDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(leftMinDepth == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + rightMinDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rightMinDepth == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + leftMinDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + min(leftMinDepth, rightMinDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS 迭代解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        q.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a></h5><blockquote><p>给定二叉树的根和一个整数<code>targetSum</code>，如果树具有从根到叶的路径，则沿路径的所有值加起来等于<code>targetSum</code>，则返回<code>true</code>。</p><p><strong>Example:</strong></p><img src="pathsum1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下递归</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hasPathSum(root-&gt;left, sum - root-&gt;val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hasPathSum(root-&gt;right, sum - root-&gt;val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II</a></h5><blockquote><p>给定二叉树的根和一个整数<code>targetSum</code>，返回所有从根到叶的路径，其中每个路径的和等于<code>targetSum</code>。</p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range<code>[0, 5000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><p><strong>Example:</strong></p><img src="pathsumii1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; target;</span><br><span class="line">    function&lt;<span class="keyword">void</span>((TreeNode*, <span class="keyword">int</span>))&gt; dfs = [&amp;](TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        target.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">// 如果是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(target);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, sum);</span><br><span class="line">        <span class="comment">// target.pop_back();</span></span><br><span class="line">        <span class="comment">// target.push_back(root-&gt;val);</span></span><br><span class="line">        dfs(root-&gt;right, sum);</span><br><span class="line">        target.pop_back();</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(root, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III</a></h5><blockquote><p>你将获得一棵二叉树，其中每个节点都包含一个整数值。查找路径中节点值总和为给定值的路径数。</p><p>该路径无需在根或叶处开始或结束，但必须向下（仅从父节点到子节点移动）。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">       10</span><br><span class="line">      &#x2F;  \</span><br><span class="line">     5   -3</span><br><span class="line">    &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line">&#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等于以从 root 开始的子路径 + ...</span></span><br><span class="line">    <span class="keyword">return</span> rootPathSum(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dfs 求解以从 root 开始的子路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rootPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(TreeNode*, <span class="keyword">int</span>)&gt; dfs = [&amp;](TreeNode* root, <span class="keyword">int</span> curSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root) &#123;</span><br><span class="line">            curSum += root-&gt;val;</span><br><span class="line">            <span class="comment">// 和上一题 II 不同了</span></span><br><span class="line">            <span class="comment">// 不必等到是叶子节点</span></span><br><span class="line">            <span class="comment">// 只要中间有满足的, 直接增加计数</span></span><br><span class="line">            <span class="keyword">if</span>(targetSum == curSum) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(root-&gt;left, curSum);</span><br><span class="line">            dfs(root-&gt;right, curSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面纯递归的方法相当于暴力搜索, 时间复杂度为 O(n2)</span></span><br><span class="line"><span class="comment">// 不仅数组中可以用到前缀和, 这里也可以用到, 时间复杂度可以优化到 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping; <span class="comment">// &lt;前缀和, 出现的次数&gt;</span></span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(TreeNode*, <span class="keyword">int</span>)&gt; dfs = [&amp;](TreeNode* root, <span class="keyword">int</span> curSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root) &#123;</span><br><span class="line">            curSum += root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(mapping.count(curSum - sum)) &#123;</span><br><span class="line">                count += mapping[curSum - sum];</span><br><span class="line">            &#125;</span><br><span class="line">            mapping[curSum]++;</span><br><span class="line">            dfs(root-&gt;left, curSum);</span><br><span class="line">            <span class="comment">// mapping[curSum]--;</span></span><br><span class="line">            <span class="comment">// mapping[curSum]++;</span></span><br><span class="line">            dfs(root-&gt;right, curSum);</span><br><span class="line">            mapping[curSum]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="666-Path-Sum-IV"><a href="#666-Path-Sum-IV" class="headerlink" title="666. Path Sum IV"></a><a href="https://leetcode.com/problems/path-sum-iv/" target="_blank" rel="noopener">666. Path Sum IV</a></h5><blockquote><p>对于一棵深度小于<code>5</code>的树，可以用一组三位十进制整数来表示。</p><p>对于每个整数：</p><p>百位上的数字表示这个节点的深度<code>D</code>，<code>1 &lt;= D &lt;= 4</code>。<br>十位上的数字表示这个节点在当前层所在的位置<code>P</code>，<code>1 &lt;= P &lt;= 8</code>。位置编号与一棵满二叉树的位置编号相同。<br>个位上的数字表示这个节点的权值<code>V</code>，<code>0 &lt;= V &lt;= 9</code>。<br>给定一个包含三位整数的升序数组，表示一棵深度小于<code>5</code>的二叉树，请你返回从根到所有叶子结点的路径之和。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [113, 215, 221]</span><br><span class="line">输出: 12</span><br><span class="line">解释: </span><br><span class="line">这棵树形状如下:</span><br><span class="line">  3</span><br><span class="line">&#x2F; \</span><br><span class="line">5   1</span><br><span class="line"></span><br><span class="line">路径和 &#x3D; (3 + 5) + (3 + 1) &#x3D; 12.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [113, 221]</span><br><span class="line">输出: 4</span><br><span class="line">解释: </span><br><span class="line">这棵树形状如下: </span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">路径和 &#x3D; (3 + 1) &#x3D; 4.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似于堆排序中将完全二叉树存储在一个向量的思路</span></span><br><span class="line"><span class="comment">// 借助一个哈希表来记录二叉树的每个节点在向量中的索引和其权重的映射</span></span><br><span class="line"><span class="comment">// 每个节点的索引可通过其深度和位置计算出来</span></span><br><span class="line"><span class="comment">// 公式为 i = 2 ^ (depth - 1) + position - 1</span></span><br><span class="line"><span class="comment">// 比如, 根节点 112, depth = 1, position = 1, i = 2 ^ (1 - 1) + 1 - 1 = 1</span></span><br><span class="line"><span class="comment">// 某节点 346, depth = 3, position = 4, i = 2 ^ (3 - 1) + 4 - 1 = 7</span></span><br><span class="line"><span class="comment">// 这样表示之后, 索引为 i 的节点</span></span><br><span class="line"><span class="comment">// 其左孩子索引为 2 * i, 右孩子索引为 2 * i + 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> depth = num / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> position = num % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> weight = num % <span class="number">10</span>;</span><br><span class="line">        mapping[<span class="built_in">pow</span>(<span class="number">2</span>, depth - <span class="number">1</span>) + position - <span class="number">1</span>] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += mapping[i];</span><br><span class="line">        <span class="comment">// 到达叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(<span class="number">2</span> * i) == <span class="number">0</span> &amp;&amp; mapping.count(<span class="number">2</span> * i + <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            res += sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去左子树</span></span><br><span class="line">        dfs(<span class="number">2</span> * i, sum);</span><br><span class="line">        <span class="comment">// 去右子树</span></span><br><span class="line">        dfs(<span class="number">2</span> * i + <span class="number">1</span>, sum);</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129. Sum Root to Leaf Numbers"></a><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers</a></h5><blockquote><p>你将获得只包含<code>0</code>到<code>9</code>的数字的二叉树的根。树中的每条从根到叶的路径都代表一个数字。</p><p>例如，从根到叶的路径<code>1 -&gt; 2 -&gt; 3</code>表示数字<code>123</code>。返回所有从根到叶的数字的总和。</p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range<code>[1, 1000]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code>.</li><li>The depth of the tree will not exceed <code>10</code>.</li></ul><p><strong>Example:</strong></p><img src="num2tree.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [4,9,0,5,1]</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="keyword">auto</span>* root, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            res += num;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(dfs, root-&gt;left, num);</span><br><span class="line">        dfs(dfs, root-&gt;right, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(dfs, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. Binary Tree Maximum Path Sum</a></h5><blockquote><p>二叉树中的路径是节点序列，其中序列中的每对相邻节点都有一条连接它们的边。 一个节点最多只能出现在序列中一次。 请注意，该路径不需要通过根。路径的路径总和是路径中节点值的总和。</p><p>给定二叉树的根，返回任何路径的最大路径总和。</p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range<code>[1, 3 * 104]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code>.</li></ul><p><strong>Example:</strong></p><img src="exx2.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历思想</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    <span class="comment">// 递归函数的定义是返回 [以 root 为首节点] 的最大路径和</span></span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="keyword">auto</span>* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果以 left 或 right 为首节点的路径和为负数</span></span><br><span class="line">        <span class="comment">// 就不加上它</span></span><br><span class="line">        <span class="comment">// 这样就能保证返回的值是以 root 为首节点的最大路径和</span></span><br><span class="line">        <span class="comment">// 就是说将 root 单节点看作一条路径</span></span><br><span class="line">        <span class="keyword">int</span> leftMaxSum = max(<span class="number">0</span>, dfs(dfs, root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> rightMaxSum = max(<span class="number">0</span>, dfs(dfs, root-&gt;right));</span><br><span class="line">        <span class="comment">// 计算 [经过] root 的最大路径和</span></span><br><span class="line">        <span class="comment">// 这样, 通过递归的过程, 保证会分别计算经过每一个节点的最大路径和</span></span><br><span class="line">        res = max(res, leftMaxSum + root-&gt;val + rightMaxSum);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + max(leftMaxSum, rightMaxSum);</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(dfs, root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h5><blockquote><p>给定两个整数数组<code>preorder</code>和<code>inorder</code>，其中<code>preorder</code>是二叉树的前序遍历，而<code>inorder</code>是同一树的中序遍历，构造并返回二叉树。</p><img src="640.jpg" alt="640" style="zoom: 50%;" /><img src="sdsef.jpg" alt="sdsef" style="zoom: 50%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要知道前序遍历的首元素就是树的根</span></span><br><span class="line"><span class="comment">// 其在中序遍历的位置的左边所有元素构成左子树, 右边所有元素构成右子树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span>&amp;&amp; build, <span class="keyword">int</span> preStart, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 定位 rootVal 在中序遍历中的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = inStart;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt;= inEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index] == rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算左子树节点数量</span></span><br><span class="line">        <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line">        root-&gt;left = build(build, preStart + <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = build(build, preStart + leftSize + <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> build(build, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用一个哈希表存储节点值在中序遍历数组中的索引</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        mapping[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span>&amp;&amp; build, <span class="keyword">int</span> rootIndex, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[rootIndex];</span><br><span class="line">        <span class="keyword">int</span> index = mapping[rootVal];</span><br><span class="line">        <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的根节点在当前根节点位置 + 1 的位置</span></span><br><span class="line">        root-&gt;left = build(build, rootIndex + <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 右子树的根节点在当前根节点位置 + 左子树长度 + 1 的位置</span></span><br><span class="line">        root-&gt;right = build(build, rootIndex + leftSize + <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 因为每次我们只是需要得到节点值在中序遍历数组中的索引</span></span><br><span class="line">    <span class="comment">// 现在我们已经预存储了节点值到索引的映射, 参数中就不需要中序遍历数组了</span></span><br><span class="line">    <span class="comment">// 并且左右树根节点的值在前序遍历数组中的位置可以通过当前根节点的位置和左子树的长度来确定</span></span><br><span class="line">    <span class="keyword">return</span> build(build, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h5><blockquote><p>给定两个整数数组<code>postorder</code>和<code>inorder</code>，其中<code>postorder</code>是二叉树的后序遍历，而<code>inorder</code>是同一树的中序遍历，构造并返回二叉树。</p><img src="444.jpg" alt="444" style="zoom: 50%;" /><img src="fgfg.jpg" alt="fgfg" style="zoom: 50%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要知道后序遍历的尾元素就是树的根</span></span><br><span class="line"><span class="comment">// 其在中序遍历的位置的左边所有元素构成左子树</span></span><br><span class="line"><span class="comment">// 右边所有元素构成右子树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span>&amp;&amp; build, <span class="keyword">int</span> rootIndex, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后序遍历尾元素就是根</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[rootIndex];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 定位根在中序遍历中的位置</span></span><br><span class="line">        <span class="comment">// 一定存在</span></span><br><span class="line">        <span class="comment">// 这里有一个特殊情况 inStart == inEnd</span></span><br><span class="line">        <span class="comment">// 出现这种情况 index 应该等于 inStart == inEnd</span></span><br><span class="line">        <span class="comment">// 递归基可以处理</span></span><br><span class="line">        <span class="keyword">int</span> index = inStart;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt;= inEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index] == rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算右子树的节点数</span></span><br><span class="line">        <span class="keyword">int</span> rightSize = inEnd - index;</span><br><span class="line">        <span class="comment">// 左子树的根节点在当前根节点位置 - 右子树长度 - 1 的位置</span></span><br><span class="line">        root-&gt;left = build(build, rootIndex - rightSize - <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 右子树的根节点在当前根节点位置 - 1 的位置</span></span><br><span class="line">        root-&gt;right = build(build, rootIndex - <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> build(build, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用一个哈希表存储节点值在中序遍历数组中的索引</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++) &#123;</span><br><span class="line">        mapping[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span>&amp;&amp; build, <span class="keyword">int</span> rootIndex, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[rootIndex];</span><br><span class="line">        <span class="keyword">int</span> index = mapping[rootVal];</span><br><span class="line">        <span class="keyword">int</span> rightSize = inEnd - index;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的根节点在当前根节点位置 - 右子树长度 - 1 的位置</span></span><br><span class="line">        root-&gt;left = build(build, rootIndex - rightSize - <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 右子树的根节点在当前根节点位置 - 1 的位置</span></span><br><span class="line">        root-&gt;right = build(build, rootIndex - <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 因为每次我们只是需要得到节点值在中序遍历数组中的索引</span></span><br><span class="line">    <span class="comment">// 现在我们已经预存储了节点值到索引的映射, 参数中就不需要中序遍历数组了</span></span><br><span class="line">    <span class="comment">// 左右树根节点的值在前序遍历数组中的位置可以通过当前根节点的位置和右子树的长度来确定</span></span><br><span class="line">    <span class="keyword">return</span> build(build, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener">889. Construct Binary Tree from Preorder and Postorder Traversal</a></h5><blockquote><p>返回与给定的前序和后序遍历匹配的任意二叉树。二叉树中的值是不同的正整数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然有些情况不能确定一棵唯一的二叉树</span></span><br><span class="line"><span class="comment">// 但我们决定左右子树的规则固定即可</span></span><br><span class="line"><span class="comment">// 首先注意到前序遍历的首元素为树的根</span></span><br><span class="line"><span class="comment">// 首元素的下一个元素可能为其左子树的根, 也可能为其右子树的根</span></span><br><span class="line"><span class="comment">// 但我们始终把它认定为左子树的根</span></span><br><span class="line"><span class="comment">// 接下来就是在后序遍历中定位到 前序遍历首元素的下一个元素 的位置</span></span><br><span class="line"><span class="comment">// 这个位置左边的就是左子树所有元素 (包括这个位置上的元素, 实际上它是左子树的根)</span></span><br><span class="line"><span class="comment">// 右边的就是右子树所有元素 (除了末元素, 因为它是当前树的根啊)</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = pre.size();</span><br><span class="line">    function&lt;TreeNode*(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; construct = [&amp;](<span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[preStart];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 这个条件判断非常重要</span></span><br><span class="line">        <span class="comment">// 如果 preStart == preEnd</span></span><br><span class="line">        <span class="comment">// 下面的 index 就会因为找不到而很大 为 postEnd</span></span><br><span class="line">        <span class="comment">// 导致错误地计算出很大的 leftSize</span></span><br><span class="line">        <span class="comment">// 这种情况递归基处理不了</span></span><br><span class="line">        <span class="keyword">if</span>(preStart == preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定位到左子树的根在后序遍历中的位置</span></span><br><span class="line">        <span class="comment">// 此时保证至少会有该元素, 也就是说 pre[preStart + 1] 在后序遍历中一定存在</span></span><br><span class="line">        <span class="keyword">int</span> index = postStart;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt; postEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(post[index] == pre[preStart + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSize = index - postStart + <span class="number">1</span>;</span><br><span class="line">        root-&gt;left = construct(preStart + <span class="number">1</span>, preStart + leftSize, postStart, index);</span><br><span class="line">        root-&gt;right = construct(preStart + leftSize + <span class="number">1</span>, preEnd, index + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> construct(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">1008. Construct Binary Search Tree from Preorder Traversal</a></h5><blockquote><p>给定一个整数已排序数组，该数组表示二叉搜索树的前序遍历结果，请构造该<code>BST</code>树并返回其根。</p><p>可以确保始终可以找到满足测试用例要求的<code>BST</code>。</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 100</code>.</li><li><code>1 &lt;= preorder[i] &lt;= 108</code>.</li><li>All the values of <code>preorder</code> are <strong>unique</strong>.</li></ul><p><strong>Example:</strong></p><img src="1266.png" alt="img" style="zoom: 50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先可以确定前序遍历的首元素为树的根</span></span><br><span class="line"><span class="comment">// 其左子树的所有元素都小于首元素</span></span><br><span class="line"><span class="comment">// 其右子树的所有元素都大于首元素</span></span><br><span class="line"><span class="comment">// 所以, 我们接下来只要确定数组中第一个大于首元素的值的位置</span></span><br><span class="line"><span class="comment">// 就能够直到左子树和右子树的元素范围</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = preorder.size();</span><br><span class="line">    function&lt;TreeNode*(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; build = [&amp;](<span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根为首元素</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="comment">// 找到第一个大于首元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> index  = preStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; index &lt;= preEnd; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[index] &gt; rootVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里, 有两种情况</span></span><br><span class="line">        <span class="comment">// 1. 左子树为空, 此时 index 应该为 prepreStart + 1</span></span><br><span class="line">        <span class="comment">// 2. 右子树为空, 此时 index 应该为 preEnd + 1</span></span><br><span class="line">        <span class="comment">// 无论哪一种情况, 递归进去之后, 递归基都可以处理</span></span><br><span class="line">        root-&gt;left = build(preStart + <span class="number">1</span>, index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = build(index, preEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="117-Populating-Next-Right-Pointers-in-Each-Node-II-LeetCode"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-LeetCode" class="headerlink" title="117. Populating Next Right Pointers in Each Node II - LeetCode"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II - LeetCode</a></h5><blockquote><p>填充二叉树的每个节点下一个指针以指向其下一个右节点。 如果没有下一个右节点，则下一个指针应设置为<code>NULL</code>。</p><p>最初，所有下一个指针都设置为<code>NULL</code>。</p><img src="117_sample.png" alt="img" style="zoom: 50%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node *left;</span></span><br><span class="line"><span class="comment">    Node *right;</span></span><br><span class="line"><span class="comment">    Node *next;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用辅助节点的迭代式解法</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    Node helper;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        Node* last = &amp;helper;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) &#123;</span><br><span class="line">                last-&gt;next = cur-&gt;left;</span><br><span class="line">                last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) &#123;</span><br><span class="line">                last-&gt;next = cur-&gt;right;</span><br><span class="line">                last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = helper.next;</span><br><span class="line">        helper.next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用队列的迭代式解法(层序遍历)</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; nodes;</span><br><span class="line">    <span class="keyword">if</span>(cur) &#123;</span><br><span class="line">        nodes.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = nodes.size(); sz &gt; <span class="number">0</span>; sz--) &#123;</span><br><span class="line">            cur = nodes.front();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            cur-&gt;next = sz &gt; <span class="number">1</span> ? nodes.front() : <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) &#123;</span><br><span class="line">                nodes.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) &#123;</span><br><span class="line">                nodes.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给定的二叉树是棵<strong>完美二叉树</strong>：<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node</a></p><img src="116_sample.png" alt="img" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对完美二叉树的递归式解法</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归函数的定义就是将 p 和 q 两节点相连</span></span><br><span class="line">    function&lt;<span class="keyword">void</span>(Node*, Node*)&gt; helper = [&amp;](Node* p, Node* q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        helper(p-&gt;left, p-&gt;right);</span><br><span class="line">        helper(q-&gt;left, q-&gt;right);</span><br><span class="line">        helper(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;;</span><br><span class="line">    helper(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. Validate Binary Search Tree</a></h5><blockquote><p>给定二叉树的根，确定它是否是有效的二叉搜索树。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须将对上层节点的约束传递给下层节点</span></span><br><span class="line">    <span class="comment">// 限定以 root 为根的子树节点必须满足 min-&gt;val &lt; root.val &lt; max-&gt;val</span></span><br><span class="line">    function&lt;<span class="keyword">bool</span>(TreeNode*, TreeNode*, TreeNode*)&gt; helper = [&amp;](TreeNode* root, TreeNode* min, TreeNode* max) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min &amp;&amp; root-&gt;val &lt;= min-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max &amp;&amp; root-&gt;val &gt;= max-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这时 left 节点的最大就是 root, right 节点的最小值就是 root</span></span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left, min, root) &amp;&amp; helper(root-&gt;right, root, max);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> helper(root, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1373-Maximum-Sum-BST-in-Binary-Tree"><a href="#1373-Maximum-Sum-BST-in-Binary-Tree" class="headerlink" title="1373. Maximum Sum BST in Binary Tree"></a><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/" target="_blank" rel="noopener">1373. Maximum Sum BST in Binary Tree</a></h5><blockquote><p>给定二叉树的根，找出所有是<code>BST</code>的子树，分别计算这些子树的所有节点值的和， 返回其中的最大值。</p><p>二叉搜索树的定义如下：</p><p>任意节点的左子树中的键值都小于此节点的键值。<br>任意节点的右子树中的键值都大于此节点的键值。<br>任意节点的左子树和右子树都是二叉搜索树。</p><p><strong>Example 1:</strong></p><img src="sample_1_1709.png" alt="img" style="zoom: 80%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="sample_2_1709.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [4,3,null,1,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 递归函数返回值依次是</span></span><br><span class="line">    <span class="comment">// 1. 以 root 为根的 BST 子树节点值的总和, 如果其不是 BST, 此值为 0</span></span><br><span class="line">    <span class="comment">// 2. 以 root 为根的树中节点的最小值, 如果其不是 BST, 此值为 INT_MIN</span></span><br><span class="line">    <span class="comment">// 3. 以 root 为根的树中节点的最大值, 如果其不是 BST, 此值为 INT_MAX </span></span><br><span class="line">    <span class="keyword">auto</span> postOrder = [&amp;res](<span class="keyword">auto</span>&amp; postOrder, TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> make_tuple(<span class="number">0</span>, INT_MAX, INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [leftSum, leftMinVal, leftMaxVal] = postOrder(postOrder, root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [rightSum, rightMinVal, rightMaxVal] = postOrder(postOrder, root-&gt;right);</span><br><span class="line">        <span class="comment">// 如果当前节点的左子树中节点的最大值比当前节点还大</span></span><br><span class="line">        <span class="comment">// 或者当前节点的右子树中节点的最小值比当前节点还小</span></span><br><span class="line">        <span class="comment">// 以当前节点为根的子树就不是 BST</span></span><br><span class="line">        <span class="comment">// 因此总和为 0</span></span><br><span class="line">        <span class="comment">// 最小值为 INT_MIN 以致于右子树中包含此树的树也被认定为非 BST</span></span><br><span class="line">        <span class="comment">// 最大值为 INT_MAX 以致于左子树中包含此树的树也被认定为非 BST</span></span><br><span class="line">        <span class="keyword">if</span>(leftMaxVal &gt;= root-&gt;val || rightMinVal &lt;= root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> make_tuple(<span class="number">0</span>, INT_MIN, INT_MAX);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时, 以当前节点为根的子树是 BST</span></span><br><span class="line">        <span class="comment">// 计算此树的总和并更新最大值</span></span><br><span class="line">        <span class="keyword">int</span> sum = leftSum + root-&gt;val + rightSum;</span><br><span class="line">        res = max(res, sum);</span><br><span class="line">        <span class="comment">// 最后还要返回以当前节点为根的子树的信息</span></span><br><span class="line">        <span class="comment">// 其总和就为 sum</span></span><br><span class="line">        <span class="comment">// 1. 当前节点有可能是叶子节点或者只有一颗子树</span></span><br><span class="line">            <span class="comment">// 所以最小值为当前节点的值和左子树中最小的值相比取小者</span></span><br><span class="line">            <span class="comment">// 最大值为当前节点的值和右子树中最大的值相比取大者</span></span><br><span class="line">            <span class="comment">// 因为 if(!root) return &#123;0, INT_MAX, INT_MIN&#125;; 语句</span></span><br><span class="line">            <span class="comment">// 保证了左子树中最小的值为 INT_MAX, 右子树中最大的值为 INT_MIN</span></span><br><span class="line">            <span class="comment">// 所以比较的结果肯定是 root-&gt;val</span></span><br><span class="line">        <span class="comment">// 2. 当前节点有两棵子树, 那么比较的结果肯定不是 root-&gt;val (这是 BST 的规则!)</span></span><br><span class="line">        <span class="keyword">return</span> make_tuple(sum, min(root-&gt;val, leftMinVal), max(root-&gt;val, rightMaxVal));</span><br><span class="line">    &#125;;</span><br><span class="line">    postOrder(postOrder, root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make_tuple(isBST, sumOfBST, minVal, maxVal)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> post = [&amp;](<span class="keyword">auto</span>&amp;&amp; post, <span class="keyword">auto</span>&amp;&amp; root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 空树也是 BST</span></span><br><span class="line">            <span class="keyword">return</span> make_tuple(<span class="literal">true</span>, <span class="number">0</span>, INT_MAX, INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp; [l_isBST, l_sumOfBST, l_minVal, l_maxVal] = post(post, root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp; [r_isBST, r_sumOfBST, r_minVal, r_maxVal] = post(post, root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(!l_isBST || !r_isBST || root-&gt;val &lt;= l_maxVal || root-&gt;val &gt;= r_minVal) &#123;</span><br><span class="line">            <span class="comment">// 不是 BST 的话, 其他值都无所谓了</span></span><br><span class="line">            <span class="keyword">return</span> make_tuple(<span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = l_sumOfBST + root-&gt;val + r_sumOfBST;</span><br><span class="line">        res = max(res, sum);</span><br><span class="line">        <span class="keyword">return</span> make_tuple(<span class="literal">true</span>, sum, min(root-&gt;val, l_minVal), max(root-&gt;val, r_maxVal));</span><br><span class="line">    &#125;;</span><br><span class="line">    post(post, root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. Serialize and Deserialize Binary Tree</a></h5><blockquote><p>序列化是将数据结构或对象转换为位序列的过程，以便可以将其存储在文件或内存缓冲区中，或者通过网络连接链接进行传输，以便稍后在相同或另一台计算机环境中进行重构。</p><p>设计一种用于对二叉树进行序列化和反序列化的算法。 序列化和反序列化算法的工作方式没有任何限制。 你只需要确保可以将二叉树序列化为字符串，并且可以将该字符串反序列化为原始树结构。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前序遍历解法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        serialize(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            res += <span class="string">"# "</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += to_string(root-&gt;val) + <span class="string">" "</span>;</span><br><span class="line">        serialize(root-&gt;left, res);</span><br><span class="line">        serialize(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">stringstream</span>&amp; ss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ss) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        ss &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="string">"#"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(temp));</span><br><span class="line">        root-&gt;left = deserialize(ss);</span><br><span class="line">        root-&gt;right = deserialize(ss);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 后序遍历解法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        serialize(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; encoded;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">while</span>(getline(ss, s, <span class="string">' '</span>)) &#123;</span><br><span class="line">            encoded.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            res += <span class="string">"# "</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serialize(root-&gt;left, res);</span><br><span class="line">        serialize(root-&gt;right, res);</span><br><span class="line">        res += to_string(root-&gt;val) + <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; encoded)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(encoded.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> s = encoded.back();</span><br><span class="line">        encoded.pop_back();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"#"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(s));</span><br><span class="line">        <span class="comment">// 后序遍历需要先构造右孩子, 再构造左孩子</span></span><br><span class="line">        root-&gt;right = deserialize(encoded);</span><br><span class="line">        root-&gt;left = deserialize(encoded);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 层序遍历解法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> encoded;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(node) &#123;</span><br><span class="line">                encoded += to_string(node-&gt;val) + <span class="string">" "</span>;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                encoded += <span class="string">"# "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> encoded;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> nodeVal;</span><br><span class="line">        ss &gt;&gt; nodeVal;</span><br><span class="line">        <span class="keyword">if</span>(nodeVal == <span class="string">"#"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(nodeVal));</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            TreeNode* root = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(ss &gt;&gt; nodeVal) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nodeVal != <span class="string">"#"</span>) &#123;</span><br><span class="line">                    root-&gt;left = <span class="keyword">new</span> TreeNode(stoi(nodeVal));</span><br><span class="line">                    q.push(root-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss &gt;&gt; nodeVal) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nodeVal != <span class="string">"#"</span>) &#123;</span><br><span class="line">                    root-&gt;right = <span class="keyword">new</span> TreeNode(stoi(nodeVal));</span><br><span class="line">                    q.push(root-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="653-Two-Sum-IV-Input-is-a-BST"><a href="#653-Two-Sum-IV-Input-is-a-BST" class="headerlink" title="653. Two Sum IV - Input is a BST"></a><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. Two Sum IV - Input is a BST</a></h5><blockquote><p>给定一个二叉搜索树和一个目标数，如果<code>BST</code>中存在两个元素的总和等于给定的目标数，则返回<code>true</code>。</p><p><strong>Example:</strong></p><img src="sum_tree_1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1 基本思想都是借助 BST 的中序遍历结果是升序排列的, 然后借助双指针搜索即可</span></span><br><span class="line"><span class="comment">// 方法 2 无论使用什么遍历 (递归或迭代), 都借助哈希表在遍历的过程中记录已经出现的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="keyword">auto</span> helper = [&amp;](<span class="keyword">auto</span>&amp;&amp; helper, <span class="keyword">auto</span> root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(setting.count(k - root-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setting.insert(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> helper(helper, root-&gt;left) || helper(helper, root-&gt;right);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> helper(helper, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List</a></h5><blockquote><p>给定二叉树的根，将树展平为“链表”：“链表”应使用相同的<code>TreeNode</code>类，其中右子指针指向列表中的下一个节点，而左子指针始终为<code>null</code>。</p><p>“链表”的顺序应与二叉树的前序遍历顺序相同。</p><img src="flaten.jpg" alt="img" style="zoom: 67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归思想: 相信递归函数的定义并毫不怀疑的去调用它!</span></span><br><span class="line"><span class="comment">// 此例中, void flatten(TreeNode* root) 函数的定义就是将 root 平展</span></span><br><span class="line"><span class="comment">// 只需要注意递归基的处理就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        <span class="comment">// 此时左右两棵子树都已经 flatten 完毕了</span></span><br><span class="line">        TreeNode* temp = root-&gt;right; <span class="comment">// 备份右子树</span></span><br><span class="line">        root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 1. 将右孩子指针指向左子树, 随后左孩子指针置空</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) &#123;</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 沿着新右指针一直往前走, 定位到尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(root &amp;&amp; root-&gt;right) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 将尾节点指向右子树</span></span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">   / \</span></span><br><span class="line"><span class="comment">  2   5</span></span><br><span class="line"><span class="comment"> / \   \</span></span><br><span class="line"><span class="comment">3   4   6</span></span><br><span class="line"><span class="comment">// 将 1 的左子树插入到右子树的地方</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">     \</span></span><br><span class="line"><span class="comment">      2         5</span></span><br><span class="line"><span class="comment">     / \         \</span></span><br><span class="line"><span class="comment">    3   4         6</span></span><br><span class="line"><span class="comment">// 将原来的右子树接到左子树的最右边节点</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">     \</span></span><br><span class="line"><span class="comment">      2</span></span><br><span class="line"><span class="comment">     / \</span></span><br><span class="line"><span class="comment">    3   4</span></span><br><span class="line"><span class="comment">         \</span></span><br><span class="line"><span class="comment">          5</span></span><br><span class="line"><span class="comment">           \</span></span><br><span class="line"><span class="comment">            6</span></span><br><span class="line"><span class="comment">// 将 2 的左子树插入到右子树的地方</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">     \</span></span><br><span class="line"><span class="comment">      2</span></span><br><span class="line"><span class="comment">       \</span></span><br><span class="line"><span class="comment">        3       4</span></span><br><span class="line"><span class="comment">                 \</span></span><br><span class="line"><span class="comment">                  5</span></span><br><span class="line"><span class="comment">                   \</span></span><br><span class="line"><span class="comment">                    6</span></span><br><span class="line"><span class="comment">// 将原来的右子树接到左子树的最右边节点</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">     \</span></span><br><span class="line"><span class="comment">      2</span></span><br><span class="line"><span class="comment">       \</span></span><br><span class="line"><span class="comment">        3</span></span><br><span class="line"><span class="comment">         \</span></span><br><span class="line"><span class="comment">          4</span></span><br><span class="line"><span class="comment">           \</span></span><br><span class="line"><span class="comment">            5</span></span><br><span class="line"><span class="comment">             \</span></span><br><span class="line"><span class="comment">              6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">auto</span> pre = cur-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;right) &#123;</span><br><span class="line">                pre = pre-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">            pre-&gt;right = cur-&gt;right;</span><br><span class="line">            <span class="comment">// 将左子树插入到右子树的地方</span></span><br><span class="line">            cur-&gt;right = cur-&gt;left;</span><br><span class="line">            cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑下一个节点</span></span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree"><a href="#1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree" class="headerlink" title="1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree"></a><a href="https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/" target="_blank" rel="noopener">1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a></h5><blockquote><p>给定一个原始树和一个克隆树，克隆树是原始树的副本。并给出对原始树中某目标节点的引用。</p><p>返回对克隆树中相同节点的引用。</p><p>请注意，不允许您更改两个树或目标节点中的任何一个，并且答案必须是对克隆树中节点的引用。</p><p>注意：你的解答要适用于在树上允许有重复的值的情况。</p><p><img src="e4.png" alt="img"></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树上允许有重复的值意味着不能通过比较节点的值来返回目标节点</span></span><br><span class="line"><span class="comment">// 题目已经给出保证 original cloned target 都不为 null</span></span><br><span class="line"><span class="comment">// 直接对两棵树同步遍历</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">getTargetCopy</span><span class="params">(TreeNode* original, TreeNode* cloned, TreeNode* target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!original) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(original == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先在左子树中找</span></span><br><span class="line">    TreeNode* found = getTargetCopy(original-&gt;left, cloned-&gt;left, target);</span><br><span class="line">    <span class="comment">// 没找到再去右子树中找</span></span><br><span class="line">    <span class="keyword">if</span>(!found) &#123;</span><br><span class="line">        found = getTargetCopy(original-&gt;right, cloned-&gt;right, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. Recover Binary Search Tree</a></h5><blockquote><p>给定一个二叉搜索树的根节点，恰好树中的两个节点错误地交换了。 在不更改其结构的前提下，恢复这棵二叉搜索树。</p><table><thead><tr><th align="center">Example 1</th><th align="center">Example 2</th></tr></thead><tbody><tr><td align="center"><img src="recover1.jpg" alt="img"></td><td align="center"><img src="recover2.jpg" alt="img"></td></tr></tbody></table><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,3,null,null,2]</span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line">Explanation: 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,null,2]</span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line">Explanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用<code>O(n)</code>空间复杂度的解决方案非常简单。 你能设计一个<code>O(1)</code>空间解决方案吗？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要知道, BST 的中序遍历是有序的</span></span><br><span class="line"><span class="comment">// 然后注意到, 如果树中有两个节点被交换了</span></span><br><span class="line"><span class="comment">// 在中序遍历序列中必然会出现逆序对 (可能一对, 也可能两对)</span></span><br><span class="line"><span class="comment">// 一对的情况是被交换的两个节点在中序遍历序列中相邻</span></span><br><span class="line"><span class="comment">// 此时我们有两个指针来分别定位这一逆序对的两个节点</span></span><br><span class="line"><span class="comment">// 交换它们的值即可</span></span><br><span class="line"><span class="comment">// 被交换的两个节点不相邻就会出现两对逆序对的情况</span></span><br><span class="line"><span class="comment">// 此时, 有一个指针定位前一个逆序对的第一个节点</span></span><br><span class="line"><span class="comment">// 另一个指针定位后一个逆序对的第二个节点</span></span><br><span class="line"><span class="comment">// 交换它们的值即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这题要学会如何跟踪遍历过程中当前节点的前一个节点的技术</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定位逆序对的第一个节点</span></span><br><span class="line">    TreeNode* first = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 定位逆序对的第二个节点</span></span><br><span class="line">    TreeNode* second = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 始终指向当前访问节点的前一个节点</span></span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> inorder = [&amp;](<span class="keyword">auto</span>&amp;&amp; inorder, <span class="keyword">auto</span>* cur) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(inorder, cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;val &gt; cur-&gt;val) &#123;</span><br><span class="line">            <span class="comment">// 如果为空, 说明遇到的是第一个逆序对</span></span><br><span class="line">            <span class="comment">// 当前节点是逆序对的第二个节点</span></span><br><span class="line">            <span class="comment">// 第一个节点由 pre 指出, 更新 first</span></span><br><span class="line">            <span class="comment">// 如果不为空, 说明遇到的是第二个逆序对</span></span><br><span class="line">            <span class="comment">// 就不更新 first, 因为我们定位第二个逆序对的第一个节点没有用</span></span><br><span class="line">            <span class="keyword">if</span>(first == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                first = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是第几个逆序对</span></span><br><span class="line">            <span class="comment">// second 都指向逆序对的第二个节点</span></span><br><span class="line">            second = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 持续跟踪前一个节点</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        inorder(inorder, cur-&gt;right);</span><br><span class="line">    &#125;;</span><br><span class="line">    inorder(inorder, root);</span><br><span class="line">    swap(first-&gt;val, second-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="687-Longest-Univalue-Path"><a href="#687-Longest-Univalue-Path" class="headerlink" title="687. Longest Univalue Path"></a><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">687. Longest Univalue Path</a></h5><blockquote><p>给定二叉树的根，返回最长路径的长度，其中路径中的每个节点都具有相同的值。 此路径可能会也可能不会通过根。</p><p>两个节点之间的路径长度由它们之间的边数表示。</p><p><strong>Example 1:</strong></p><img src="ex2.jpg" alt="img" style="zoom: 67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,4,5,4,4,5]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><img src="ex1.jpg" alt="img" style="zoom: 67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,5,1,1,5]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxPath = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 该递归函数的定义就是返回以 root 为起点的符合条件的路径的最大长度</span></span><br><span class="line">    <span class="keyword">auto</span> post = [&amp;](<span class="keyword">auto</span>&amp;&amp; post, <span class="keyword">auto</span> cur) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftMax = post(post, cur-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightMax = post(post, cur-&gt;right);</span><br><span class="line">        <span class="keyword">int</span> LeftMaxFromRoot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightMaxFromRoot = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果当前节点的值与其左孩子的值相等</span></span><br><span class="line">    <span class="comment">// 那么它就可以和其左孩子的路径连在一块, 路径长度 +1</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">            LeftMaxFromRoot = leftMax + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点的值与其右孩子的值相等</span></span><br><span class="line">    <span class="comment">// 那么它就可以和其右孩子的路径连在一块, 路径长度 +1</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">            rightMaxFromRoot = rightMax + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这两条路径是不一样的</span></span><br><span class="line">        maxPath = max(maxPath, LeftMaxFromRoot + rightMaxFromRoot);</span><br><span class="line">        <span class="comment">// 而以 root 为起点的符合条件的路径的最大长度为这两条路径的较大者</span></span><br><span class="line">        <span class="keyword">return</span> max(LeftMaxFromRoot, rightMaxFromRoot);</span><br><span class="line">    &#125;;</span><br><span class="line">    post(post, root);</span><br><span class="line">    <span class="keyword">return</span> maxPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. Maximum Binary Tree</a></h5><blockquote><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ol><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ol><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p><strong>Constraints:</strong></p><ul><li>All integers in <code>nums</code> are <strong>unique</strong>.</li></ul><p><strong>Example:</strong></p><img src="tree1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,6,0,5]</span><br><span class="line">Output: [6,3,5,null,2,0,null,null,1]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> construct(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造闭区间 [lo, hi] 内的元素</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">construct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(lo &gt; hi) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 找到最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex = findMax(nums, lo, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 另外, 装逼的话, 获取数组中最大元素的索引可以这样写</span></span><br><span class="line"><span class="comment">    int maxIndex = distance(nums.begin(),</span></span><br><span class="line"><span class="comment">    max_element(nums.begin() + lo, nums.begin() + hi + 1));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以最大值为根节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(nums[maxIndex]);</span><br><span class="line">    <span class="comment">// 左子树为最大值左边的</span></span><br><span class="line">    root-&gt;left = construct(nums, lo, maxIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 右子树为最大值右边的</span></span><br><span class="line">    root-&gt;right = construct(nums, maxIndex + <span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; maxVal)</span><br><span class="line">        &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            maxVal = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="998-Maximum-Binary-Tree-II"><a href="#998-Maximum-Binary-Tree-II" class="headerlink" title="998. Maximum Binary Tree II"></a><a href="https://leetcode.com/problems/maximum-binary-tree-ii/" target="_blank" rel="noopener">998. Maximum Binary Tree II</a></h5><blockquote><p>最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。</p><p>给出最大树的根节点<code>root</code>。</p><p>就像之前的<code>654. Maximum Binary Tree</code>问题那样，给定的树是从列表<code>A</code>递归地使用下述<code>Construct(A)</code>例程构造的：</p><p>如果<code>A</code>为空，返回<code>null</code><br>否则，令<code>A[i]</code>作为<code>A</code>的最大元素。创建一个值为<code>A[i]</code>的根节点<code>root</code><br><code>root</code>的左子树将被构建为<code>Construct([A[0], A[1], ..., A[i-1]])</code><br><code>root</code>的右子树将被构建为<code>Construct([A[i+1], A[i+2], ..., A[A.length - 1]])</code><br>返回<code>root</code><br>请注意，我们这里没有直接给定<code>A</code>，只有一个根节点<code>root = Construct(A)</code>.</p><p>假设<code>B</code>是<code>A</code>的副本，并在末尾附加值<code>val</code>。题目数据保证B中的值是不同的。返回<code>Construct(B)</code>。</p><p><strong>Example 1:</strong></p><table><thead><tr><th align="center"></th><th></th></tr></thead><tbody><tr><td align="center"><img src="maximum-binary-tree-1-1.png" alt="img"></td><td><img src="maximum-binary-tree-1-2.png" alt="img"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [4,1,3,null,null,2], val &#x3D; 5</span><br><span class="line">Output: [5,4,null,1,3,null,null,2]</span><br><span class="line">Explanation: A &#x3D; [1,4,2,3], B &#x3D; [1,4,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="maximum-binary-tree-2-1.png" alt="img"></td><td><img src="maximum-binary-tree-2-2.png" alt="img"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,2,4,null,1], val &#x3D; 3</span><br><span class="line">Output: [5,2,4,null,1,null,3]</span><br><span class="line">Explanation: A &#x3D; [2,1,5,4], B &#x3D; [2,1,5,4,3]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="maximum-binary-tree-3-1.png" alt="img"></td><td><img src="maximum-binary-tree-3-2.png" alt="img"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,2,3,null,1], val &#x3D; 4</span><br><span class="line">Output: [5,2,4,null,1,3]</span><br><span class="line">Explanation: A &#x3D; [2,1,5,3], B &#x3D; [2,1,5,3,4]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先要明确一点, 最大二叉树指的是在构造的时候最大值左边的为左子树, 右边的为右子树</span></span><br><span class="line"><span class="comment">// 因为是放在数组右边的, 所以新节点必然在右子树中</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果比人家右子树中的所有节点都小</span></span><br><span class="line">    <span class="comment">// 只能作为叶子节点了</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="comment">// 如果目标值当前节点的值大</span></span><br><span class="line">    <span class="comment">// 说明以当前节点为根的子树要成为我的左子树才行</span></span><br><span class="line">    <span class="comment">// 因为我是放在最右边的, 你在我左边我还比你大</span></span><br><span class="line">    <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val, root, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 否则, 就要向右边搜索位置</span></span><br><span class="line">    <span class="comment">// 因为你在原来最大值的右边</span></span><br><span class="line">    root-&gt;right = insertIntoMaxTree(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="508-Most-Frequent-Subtree-Sum"><a href="#508-Most-Frequent-Subtree-Sum" class="headerlink" title="508. Most Frequent Subtree Sum"></a><a href="https://leetcode.com/problems/most-frequent-subtree-sum/" target="_blank" rel="noopener">508. Most Frequent Subtree Sum</a></h5><blockquote><p>给定一棵树的根，要求你找到最频繁的子树总和。 </p><p>节点的子树总和定义为由以该节点为根的子树（包括节点本身）形成的所有节点值的总和。 那么，最频繁的子树总和的值是多少？如果有平局，则以任意顺序返回具有最高频率的所有值。</p><p><strong>Examples 1</strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   -3</span><br></pre></td></tr></table></figure><p>return [2, -3, 4], since all the values happen only once, return all of them in any order.</p><p><strong>Examples 2</strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   -5</span><br></pre></td></tr></table></figure><p>return [2], since 2 happens twice, however -5 only occur once.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想就是先通过递归获得所有子树的和</span></span><br><span class="line"><span class="comment">// 递归的过程中记录下来每一个确定的和出现的次数</span></span><br><span class="line"><span class="comment">// 这需要一个哈希表来记录 sum --&gt; preq 的映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是问题来了, 之后我们要获取出现次数最多的, 也就是值(频率)最大的键</span></span><br><span class="line"><span class="comment">// 并且频率还有可能相同而出现重复</span></span><br><span class="line"><span class="comment">// 第一种方法是 auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);</span></span><br><span class="line"><span class="comment">// 注意, cmp 需要定制 auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)</span></span><br><span class="line"><span class="comment">//                 &#123; return a.second &lt; b.second; &#125;;</span></span><br><span class="line"><span class="comment">// 这种方法效率有点低, 有多少个重复的 freq, 我们就需要遍历哈希表多少次</span></span><br><span class="line"><span class="comment">// 最坏情况下，时间复杂度为 O(n2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法是再使用一个 multimap 来 [逆映射] 原 unordered_map 中的键值对</span></span><br><span class="line"><span class="comment">// for(auto elem : mapping)</span></span><br><span class="line"><span class="comment">//        mappingSwap.insert(&#123;elem.second, elem.first&#125;);</span></span><br><span class="line"><span class="comment">// 需要注意的是, 使用有序可重复哈希表, 将原来的键变成值, 值变成键</span></span><br><span class="line"><span class="comment">// 然后通过逆迭代器直接获得最大键元素 (在红黑树的最右下边嘛)</span></span><br><span class="line"><span class="comment">// 最坏时间复杂度将为 O(n) 啦</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; findFrequentTreeSum(TreeNode* root)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     unordered_map&lt;int, int&gt; mapping;</span></span><br><span class="line"><span class="comment">//     subTreeSum(root, mapping);</span></span><br><span class="line"><span class="comment">//     auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)</span></span><br><span class="line"><span class="comment">//                 &#123; return a.second &lt; b.second; &#125;;</span></span><br><span class="line"><span class="comment">//     vector&lt;int&gt; res;</span></span><br><span class="line"><span class="comment">//     int preFreq = 0;</span></span><br><span class="line"><span class="comment">//     while(1)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if(mapping.empty()) break;</span></span><br><span class="line"><span class="comment">//         auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);</span></span><br><span class="line"><span class="comment">//         if(!res.empty() &amp;&amp; maxFreqSum.second != preFreq)</span></span><br><span class="line"><span class="comment">//             break;</span></span><br><span class="line"><span class="comment">//         preFreq = maxFreqSum.second;</span></span><br><span class="line"><span class="comment">//         res.push_back(maxFreqSum.first);</span></span><br><span class="line"><span class="comment">//         mapping.erase(maxFreqSum.first);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return res;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findFrequentTreeSum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mappingSwap;</span><br><span class="line">    subTreeSum(root, mapping);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : mapping)</span><br><span class="line">        mappingSwap.insert(&#123;elem.second, elem.first&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(mappingSwap.empty()) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> preFreq = mappingSwap.rbegin()-&gt;first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = mappingSwap.rbegin(); it != mappingSwap.rend(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;first != preFreq) <span class="keyword">break</span>;</span><br><span class="line">        res.push_back(it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subTreeSum</span><span class="params">(TreeNode* root, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; mapping)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = subTreeSum(root-&gt;left, mapping);</span><br><span class="line">    <span class="keyword">int</span> rightSum = subTreeSum(root-&gt;right, mapping);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rootSum = leftSum + rightSum + root-&gt;val;</span><br><span class="line">    mapping[rootSum]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rootSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. Lowest Common Ancestor of a Binary Tree</a></h5><blockquote><p>给定一棵二叉树，找到树中两个给定节点的最低公共祖先（<code>LCA</code>）。一个节点的祖先可以是它自己。</p><p><strong>Constraints:</strong></p><ol><li>所有<code>Node.val</code>互不相同</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code>均存在于给定的二叉树中。</li></ol><img src="236_LCA_Binary_1.png" alt="img" style="zoom: 33%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接下来的几道题全是最低公共祖先的问题</span></span><br><span class="line"><span class="comment">// 这题的限制是给定的两个节点都存在树中</span></span><br><span class="line"><span class="comment">// 基本思想就是借助递归, 时刻牢记递归函数的定义, 并且毫不怀疑的使用它</span></span><br><span class="line"><span class="comment">// 这题中, lowestCommonAncestor 函数的定义就是, 接受一个根节点和两个在树中的其它节点</span></span><br><span class="line"><span class="comment">// 返回它们的 LCA</span></span><br><span class="line"><span class="comment">// 所以, 利用后序遍历, 先分别在当前节点的左右子树中找给定两个节点的 LCA</span></span><br><span class="line"><span class="comment">// 根据返回值判断寻找情况</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前节点为空, 肯定找不到 LCA 了</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// left 为左子树中的寻找情况</span></span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="comment">// right 为右子树中的寻找情况</span></span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 注意, 如果当前节点属于这两个节点之一</span></span><br><span class="line">    <span class="comment">// 意味着 当前节点就是它们的最低公共祖先啦</span></span><br><span class="line">    <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 如果在左子树中和右子树中都找到了一个 LCA</span></span><br><span class="line">    <span class="comment">// 同样的, 说明当前节点就是它们的 LCA</span></span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 否则, 返回在 以当前节点为根的子树 中给定节点的 LCA</span></span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1644-Lowest-Common-Ancestor-of-a-Binary-Tree-II"><a href="#1644-Lowest-Common-Ancestor-of-a-Binary-Tree-II" class="headerlink" title="1644. Lowest Common Ancestor of a Binary Tree II"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/" target="_blank" rel="noopener">1644. Lowest Common Ancestor of a Binary Tree II</a></h5><blockquote><p>给定一棵二叉树的根节点<code>root</code>，返回给定节点p和q的最近公共祖先（<code>LCA</code>）节点。如果<code>p</code>或<code>q</code>之一不存在于该二叉树中，返回<code>null</code>。</p><p><strong>Constraints:</strong></p><ol><li>所有<code>Node.val</code>互不相同</li><li><code>p != q</code></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题和 I 题不同之处在于</span></span><br><span class="line"><span class="comment">// 给定的两个节点可能不在树中</span></span><br><span class="line"><span class="comment">// 所以, 这里我们使用两个 flag</span></span><br><span class="line"><span class="comment">// 在后序遍历的同时, 标志给定的两个节点是否在树中</span></span><br><span class="line"><span class="comment">// 其余的逻辑和 I 题一样</span></span><br><span class="line"><span class="keyword">bool</span> pIsInTree = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> qIsInTree = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 辅助递归函数返回 LCA</span></span><br><span class="line">    res = helper(root, p, q);</span><br><span class="line">    <span class="comment">// 如果有任何一个节点不在树中, 返回 null</span></span><br><span class="line">    <span class="keyword">if</span>(!pIsInTree || !qIsInTree) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode* left = helper(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = helper(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 将上题中的 if(root == p || root == q) return root; 分开写就行了</span></span><br><span class="line">    <span class="keyword">if</span>(root == p)</span><br><span class="line">    &#123;</span><br><span class="line">        pIsInTree = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root == q)</span><br><span class="line">    &#123;</span><br><span class="line">       qIsInTree = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III"><a href="#1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III" class="headerlink" title="1650. Lowest Common Ancestor of a Binary Tree III"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/" target="_blank" rel="noopener">1650. Lowest Common Ancestor of a Binary Tree III</a></h5><blockquote><p>给定一棵二叉树中的两个节点<code>p</code>和<code>q</code>，返回它们的最近公共祖先节点（<code>LCA</code>）。</p><p>每个节点都包含其父节点的引用（指针）。<code>Node</code>的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ol><li>所有<code>Node.val</code>互不相同</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code>均存在于给定的二叉树中。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题中的树的节点都有指向父亲的指针, 而且还说给定的两个节点还肯定存在</span></span><br><span class="line"><span class="comment">// 那就更简单了, 直接分别从给定的两个节点逐层向上找</span></span><br><span class="line"><span class="comment">// 借助一个哈希集合, 第一个节点向上找的过程中, 经过的每一个父节点都放进一个集合内</span></span><br><span class="line"><span class="comment">// 等第二个节点向上找的时候, 如果遇到已经在哈希集合中的父节点 (首个遇到的)</span></span><br><span class="line"><span class="comment">// 那就说明这个节点就是它们的 LCA 啦</span></span><br><span class="line"><span class="comment">// 和查找链表的交叉点的思路一样</span></span><br><span class="line"><span class="function">Node* <span class="title">lowestCommonAncestor</span><span class="params">(Node* p, Node* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;Node*&gt; setting;</span><br><span class="line">    <span class="comment">// p 先向上, 同样的自己也可以是自己的祖先</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 所以自己也得放进集合</span></span><br><span class="line">        setting.insert(p);</span><br><span class="line">        p = p-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已经在集合中了, 就是它!</span></span><br><span class="line">        <span class="keyword">if</span>(setting.count(q)) <span class="keyword">return</span> q;</span><br><span class="line">        setting.insert(q);</span><br><span class="line">        q = q-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1676-Lowest-Common-Ancestor-of-a-Binary-Tree-IV"><a href="#1676-Lowest-Common-Ancestor-of-a-Binary-Tree-IV" class="headerlink" title="1676. Lowest Common Ancestor of a Binary Tree IV"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/" target="_blank" rel="noopener">1676. Lowest Common Ancestor of a Binary Tree IV</a></h5><blockquote><p>给定一棵二叉树的根节点<code>root</code>和<code>TreeNode</code>类对象的数组（列表）<code>nodes</code>，返回<code>nodes</code>中所有节点的最近公共祖先（<code>LCA</code>）。数组（列表）中所有节点都存在于该二叉树中，且二叉树中所有节点的值都是互不相同的。</p><p><strong>Constraints:</strong></p><ol><li>所有的<code>Node.val</code>都是互不相同的。</li><li>所有的<code>nodes[i]</code>都存在于该树中。</li><li>所有的<code>nodes[i]</code>都是互不相同的。</li></ol><p><img src="binarytree.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 4 和 7 的最近公共祖先是 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [7,6,2,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 7、6、2 和 4 的最近公共祖先节点是 5。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一题, 我笑了</span></span><br><span class="line"><span class="comment">// I 题是找两个节点的 LCA</span></span><br><span class="line"><span class="comment">// 这题找多个节点的, 思路完全一样</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; nodes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先将 nodes 中的节点们都放进一个哈希集合中</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; setting;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : nodes)</span><br><span class="line">        setting.insert(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(root, setting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">unordered_set</span>&lt;TreeNode*&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode* left = dfs(root-&gt;left, setting);</span><br><span class="line">    TreeNode* right = dfs(root-&gt;right, setting);</span><br><span class="line">    <span class="comment">// 将 I 题中的 if(root == p || root == q) return root; 换个写法就行了</span></span><br><span class="line">    <span class="keyword">if</span>(setting.count(root)) <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree</a></h5><blockquote><p>  给定一个<strong>二叉搜索树</strong>，找到该树中两个指定节点的最近公共祖先。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. Symmetric Tree</a></h5><blockquote><p>给定二叉树，请检查其是否是其自身的镜像（即围绕其中心对称）。</p><p><strong>Example:</strong></p><img src="symtree1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左右子树同步遍历</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果都为空, 显然对称</span></span><br><span class="line">    <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 此时两者必有不为 null 的</span></span><br><span class="line">    <span class="comment">// 就判断是否有为 null 的</span></span><br><span class="line">    <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 此时两者都不为 null</span></span><br><span class="line">    <span class="comment">// 就判断它们的值是否相等</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1372-Longest-ZigZag-Path-in-a-Binary-Tree"><a href="#1372-Longest-ZigZag-Path-in-a-Binary-Tree" class="headerlink" title="1372. Longest ZigZag Path in a Binary Tree"></a><a href="https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/" target="_blank" rel="noopener">1372. Longest ZigZag Path in a Binary Tree</a></h5><blockquote><p>给你一棵以<code>root</code>为根的二叉树，二叉树中的交错路径定义如下：</p><p>选择二叉树中任意节点和一个方向（左或者右）。<br>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。<br>改变前进方向：左变右或者右变左。<br>重复第二步和第三步，直到你在树中无法继续移动。<br>交错路径的长度定义为：访问过的节点数目 <code>- 1</code>（单个节点的路径长度为<code>0</code>）。</p><p>请你返回给定树中最长交错路径的长度。</p><table><thead><tr><th align="center">Example 1</th><th align="center">Example 2</th></tr></thead><tbody><tr><td align="center"><img src="sample_1_1702.png" alt="img" style="zoom:80%;" /></td><td align="center"><img src="sample_2_1702.png" alt="img"  /></td></tr></tbody></table><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,1,1,null,1,null,null,1,1,null,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right).</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归形式 1</span></span><br><span class="line"><span class="comment">// 0 表示方向向左</span></span><br><span class="line"><span class="comment">// 1 表示方向向右</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(root-&gt;left, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    helper(root-&gt;right, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">bool</span> dir, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    res = max(res, depth);</span><br><span class="line">    <span class="keyword">if</span>(dir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点是从右方向过来的</span></span><br><span class="line">        <span class="comment">// 之后就要转去左方向</span></span><br><span class="line">        helper(node-&gt;left, <span class="number">0</span>, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 同时还可以接着去右方向</span></span><br><span class="line">        <span class="comment">// 只不过深度要重新计算</span></span><br><span class="line">        helper(node-&gt;right, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点是从左方向过来的</span></span><br><span class="line">        <span class="comment">// 之后就要转去右方向</span></span><br><span class="line">        helper(node-&gt;right, <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 同时还可以接着去左方向</span></span><br><span class="line">        <span class="comment">// 只不过深度要重新计算</span></span><br><span class="line">        helper(node-&gt;left, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归形式 2</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">bool</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp_L = <span class="number">1</span> + helper(root-&gt;left, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp_R = <span class="number">1</span> + helper(root-&gt;right, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    res = max(res, tmp_L);</span><br><span class="line">    res = max(res, tmp_R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dir ? tmp_L : tmp_R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// helper(root, 1);</span></span><br><span class="line">    <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="173-Binary-Search-Tree-Iterator"><a href="#173-Binary-Search-Tree-Iterator" class="headerlink" title="173. Binary Search Tree Iterator"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">173. Binary Search Tree Iterator</a></h5><blockquote><p>  实现一个二叉搜索树迭代器类<code>BSTIterator</code>，表示一个按中序遍历二叉搜索树（<code>BST</code>）的迭代器：</p><p>  <code>BSTIterator(TreeNode* root)</code>初始化<code>BSTIterator</code>类的一个对象。<code>BST</code>的根节点<code>root</code>会作为构造函数的一部分给出。指针应初始化为一个不存在于<code>BST</code>中的数字，且该数字小于<code>BST</code>中的任何元素。</p><p>  <code>bool hasNext()</code>如果向指针右侧遍历存在数字，则返回<code>true</code>；否则返回<code>false</code>。<br>  <code>int next()</code>将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于<code>BST</code>中的数字，所以对<code>next()</code>的首次调用将返回<code>BST</code>中的最小元素。</p><p>  你可以假设<code>next()</code>调用总是有效的，也就是说，当调用<code>next()</code>时，<code>BST</code>的中序遍历中至少存在一个下一个数字。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题考察二叉树的中序遍历的迭代实现</span></span><br><span class="line"><span class="comment">// 只不过把循环分摊在每次调用 next 函数里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode* root) : _pointer(root) &#123;&#125;</span><br><span class="line">    <span class="comment">// 这段和是中序遍历的迭代式写法 while(1) 循环体里的代码完全一样</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(_pointer)</span><br><span class="line">        &#123;</span><br><span class="line">            _stack.push(_pointer);</span><br><span class="line">            _pointer = _pointer-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        _pointer = _stack.top();</span><br><span class="line">        <span class="keyword">int</span> val = _pointer-&gt;val;</span><br><span class="line">        _stack.pop();</span><br><span class="line"></span><br><span class="line">        _pointer = _pointer-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当 _pointer 为空并且 _stack 也为空的情况下</span></span><br><span class="line">        <span class="comment">// 才没有下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> _pointer || !_stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* _pointer;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; _stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之链表</title>
      <link href="/S07PSuYxoZ6CPova/"/>
      <url>/S07PSuYxoZ6CPova/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>2</code>部分——链表，链表的大部分题目难度都不大。<code>leetcode</code>上链表部分的题目也就<code>40</code>道左右，基本上都做了，这里就把有代表性的题目发出来，共计<code>24</code>道。每道题都给出了注释，有的题目还给出了另一种思路和解法。</p><p><code>leetcode</code>刷题系列其它文章组织如下：</p><p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p><p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p><p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p><a id="more"></a><h5 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse Linked List</a></h5><blockquote><p>给定一个单链表的头节点，反转链表，然后返回反转后的链表头节点。</p><img src="rev1ex1.jpg" alt="img" style="zoom:67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* q = p;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        q = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        p = head;</span><br><span class="line">        </span><br><span class="line">        head = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* q = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse Linked List II</a></h5><blockquote><p>给定一个单链表的头以及<code>left</code>和<code>right</code>两个整数，其中<code>left &lt;= right</code>，将链表中从<code>left</code>位置到<code>right</code>位置的节点反转，返回反转后的链表。</p><img src="rev2ex2.jpg" alt="img" style="zoom:67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头插法</span></span><br><span class="line"><span class="comment">// 鲁棒性编码，如果输入无效参数，函数返回空指针</span></span><br><span class="line"><span class="comment">// 输入有效则返回反转后链表的头节点</span></span><br><span class="line"><span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || left &lt; <span class="number">1</span> || left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode <span class="title">helper</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">    ListNode* preTheLeft = &amp;helper;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(preTheLeft-&gt;next) &#123;</span><br><span class="line">            preTheLeft = preTheLeft-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* preToInsert = preTheLeft-&gt;next;</span><br><span class="line">    ListNode* ToInsert = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(preToInsert-&gt;next) &#123;</span><br><span class="line">            ToInsert = preToInsert-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preToInsert-&gt;next = ToInsert-&gt;next;</span><br><span class="line">        ToInsert-&gt;next = preTheLeft-&gt;next;</span><br><span class="line">        preTheLeft-&gt;next = ToInsert;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 纯递归解法 */</span></span><br><span class="line"><span class="comment">// 反转整个链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* q = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反转前 n 个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(--n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    p = reverseList(head);</span><br><span class="line">    head-&gt;next = q;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, right);</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = reverseBetween(head-&gt;next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 纯迭代解法 */</span></span><br><span class="line"><span class="comment">// 反转整个链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* q = p;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        q = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        p = head;</span><br><span class="line">        head = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反转前 n 个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(--n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* r = reverseList(head);</span><br><span class="line">    head-&gt;next = q;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算反转的实际节点数</span></span><br><span class="line">    <span class="keyword">int</span> n = right - left + <span class="number">1</span>;</span><br><span class="line">    ListNode* preLeft = head;</span><br><span class="line">    left--;</span><br><span class="line">    <span class="keyword">while</span>(--left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        preLeft = preLeft-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// preLeft 现在指向第 left 个节点的前一个节点</span></span><br><span class="line">    preLeft-&gt;next = reverseN(preLeft-&gt;next, n);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. Reverse Nodes in k-Group</a></h5><blockquote><p>给你一个链表，每<code>k</code>个节点一组进行翻转，请你返回翻转后的链表。<code>k</code>是一个正整数，它的值小于或等于链表的长度。如果节点总数不是<code>k</code>的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：你可以设计一个只使用常数额外空间的算法来解决此问题吗？不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><table><thead><tr><th align="center">Example 1</th><th align="center">Example 2</th></tr></thead><tbody><tr><td align="center"><img src="reverse_ex1.jpg" alt="img"  /></td><td align="center"><img src="reverse_ex2.jpg" alt="img"></td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || k &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode <span class="title">helper</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">    <span class="comment">// last 始终指向新链表的末尾节点, 方便后续链表接在其后面</span></span><br><span class="line">    <span class="comment">// last-&gt;next 就一直指向正在反转的局部链表</span></span><br><span class="line">    ListNode* last = &amp;helper;</span><br><span class="line">    <span class="comment">// cur 用于遍历每一个节点</span></span><br><span class="line">    ListNode* cur = last;</span><br><span class="line">    <span class="comment">// 反转整个链表</span></span><br><span class="line">    <span class="keyword">auto</span> reverseList = [](ListNode* head) &#123;</span><br><span class="line">        ListNode* reversedHead = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* needToReverse = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            needToReverse = head-&gt;next;</span><br><span class="line">            head-&gt;next = reversedHead;</span><br><span class="line">            reversedHead = head;</span><br><span class="line">            head = needToReverse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reversedHead;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; cur; i++) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextToReverse 始终指向后面待反转的链表的头节点</span></span><br><span class="line">        ListNode* nextToReverse = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        cur = last-&gt;next;</span><br><span class="line">        last-&gt;next = reverseList(last-&gt;next);</span><br><span class="line">        cur-&gt;next = nextToReverse;</span><br><span class="line">        last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node(<span class="keyword">int</span> _val, Node* _next) : val(_val), next(_next) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">reverseKGroup</span><span class="params">(Node* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node <span class="title">helper</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">    Node* last = &amp;helper;</span><br><span class="line">    Node* curNode = last;</span><br><span class="line">    <span class="keyword">auto</span> reverse = [](Node* head) &#123;</span><br><span class="line">        Node* p = <span class="literal">nullptr</span>;</span><br><span class="line">        Node* q = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            q = head-&gt;next;</span><br><span class="line">            head-&gt;next = p;</span><br><span class="line">            p = head;</span><br><span class="line">            head = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;next) &#123;</span><br><span class="line">                curNode = curNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                last-&gt;next = reverse(last-&gt;next);</span><br><span class="line">                curNode = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* temp = curNode-&gt;next;</span><br><span class="line">        curNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        curNode = last-&gt;next;</span><br><span class="line">        last-&gt;next = reverse(last-&gt;next);</span><br><span class="line">        curNode-&gt;next = temp;</span><br><span class="line">        last = curNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Node <span class="title">head</span><span class="params">(<span class="number">0</span>, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    Node* last = &amp;head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">        last-&gt;next = <span class="keyword">new</span> Node(i, <span class="literal">nullptr</span>);</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* newHead = reverseKGroup(head.next, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>* it = newHead; it; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="382-Linked-List-Random-Node"><a href="#382-Linked-List-Random-Node" class="headerlink" title="382. Linked List Random Node"></a><a href="https://leetcode.com/problems/linked-list-random-node/" target="_blank" rel="noopener">382. Linked List Random Node</a></h5><blockquote><p>给定一个单链表，从链表随机返回一个节点的值。 每个节点必须具有相同的被选择概率。</p><p>如果链表很大并且你不知道其长度怎么办？你能在不使用额外空间的情况下有效解决此问题吗？</p><p>如果随机返回<code>k</code>个节点的值呢？</p><p><strong>水塘抽样算法</strong>：遇到第<code>i</code>个元素时，应该有<code>1/i</code>的概率选择该元素，<code>1 - 1/i</code>的概率保持原有的选择。</p><p><strong>证明</strong>：假设总共有<code>n</code>个元素，我们要的随机性无非就是每个元素被选择的概率都是<code>1/n</code> ，那么对于第<code>i</code>个元素，它被选择的概率就是：</p><img src="formula1.png" alt="img" style="zoom: 50%;" /><p>同理，如果要随机选择<code>k</code>个数，只要在第<code>i</code>个元素处以<code>k/i</code>的概率选择该元素，以<code>1 - k/i</code>的概率保持原有选择即可。</p><p><strong>证明</strong>：略。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns a random node's value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">int</span> j = rand() % i;</span><br><span class="line">        <span class="comment">// j 等于 0 的概率就为 1/i</span></span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">            res = head-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns k random node's value. */</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRandom</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 前 k 个值默认先选上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; head; i++) &#123;</span><br><span class="line">        res[i] = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">int</span> j = rand() % i;</span><br><span class="line">        <span class="comment">// j 小于 k 的概率就为 k/i</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; k) &#123;</span><br><span class="line">            res[j] = head-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. Add Two Numbers</a></h5><blockquote><p>给定两个表示两个非负整数的非空链表。 这些数字以相反的顺序存储，即低位数在前，并且它们的每个节点都包含一个数字。 将两个数字相加并返回总和作为链接列表。</p><img src="addtwonumber1.jpg" alt="img" style="zoom: 67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* p, ListNode* q)</span> </span>&#123;</span><br><span class="line">    ListNode head;</span><br><span class="line">    ListNode* last = &amp;head;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p || q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p) &#123;</span><br><span class="line">            sum += p-&gt;val;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q) &#123;</span><br><span class="line">            sum += q-&gt;val;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += carry;</span><br><span class="line">        last-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        last-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="445. Add Two Numbers II"></a><a href="https://leetcode.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. Add Two Numbers II</a></h5><blockquote><p>给定两个表示两个非负整数的非空链表。 高位数字在前，并且它们的每个节点都包含一个数字。 将两个数字相加，然后将其作为链表返回。</p><p>如果无法修改输入列表怎么办？ 换句话说，不允许反转列表。</p><p><code>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code><br><code>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助栈后进先出的特性即可</span></span><br><span class="line"><span class="comment">// 只不过插入新节点的时候注意插在头部</span></span><br><span class="line"><span class="comment">// 另外将外面的两个 while 循环拿进去, 减少重复代码, 更优美</span></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* p, ListNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;ListNode*&gt; pStack, qStack;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        pStack.push(p);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q) &#123;</span><br><span class="line">        qStack.push(q);</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pStack.empty() || !qStack.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pStack.empty()) &#123;</span><br><span class="line">            sum += pStack.top()-&gt;val;</span><br><span class="line">            pStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!qStack.empty()) &#123;</span><br><span class="line">            sum += qStack.top()-&gt;val;</span><br><span class="line">            qStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += carry;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>, head);</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode(carry, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1721-Swapping-Nodes-in-a-Linked-List"><a href="#1721-Swapping-Nodes-in-a-Linked-List" class="headerlink" title="1721. Swapping Nodes in a Linked List"></a><a href="https://leetcode.com/problems/swapping-nodes-in-a-linked-list/" target="_blank" rel="noopener">1721. Swapping Nodes in a Linked List</a></h5><blockquote><p>给定一个链表的头以及一个整数<code>k</code>。将从头开始第<code>k</code>个节点的值与从结尾开始第<code>k</code>个节点的值交换，返回链表的头。</p><p><code>Input: head = [1, 2, 3, 4, 5], k = 2</code><br><code>Output: [1, 4, 3, 2, 5]</code></p><img src="linked1.jpg" alt="img" style="zoom:67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左右双指针的解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">swapNodes</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* left = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(--k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    left = p;</span><br><span class="line">    <span class="comment">// 此时 left 指向从左边数第 k 个节点</span></span><br><span class="line">    ListNode* right = head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">        right = right-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 right 指向从右边数第 k 个节点</span></span><br><span class="line">    swap(left-&gt;val, right-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="109. Convert Sorted List to Binary Search Tree"></a><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. Convert Sorted List to Binary Search Tree</a></h5><blockquote><p>给定一个单链表的头，其中元素按升序排序，请将其转换为高度平衡的<code>BST</code>。结果不唯一。</p><p>在此处，高度平衡的二叉树定义为这样一棵二叉树，其中每个节点的两个子树的深度相差不超过<code>1</code>。</p><img src="linked.jpg" alt="img" style="zoom: 50%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本思想是将链表的左半部分节点作为 BST 的左子树, 右半部分节点作为 BST 的右子树,</span></span><br><span class="line"><span class="comment">// 然后进行递归调用就可以了, 每次只需要处理中间节点即可</span></span><br><span class="line"><span class="comment">// 这样可保证 BST 是高度平衡的</span></span><br><span class="line"><span class="comment">// 同样的, 如果给的是有序数组, 也可以利用将中间元素构造成根节点的递归思路</span></span><br><span class="line"><span class="comment">// 分治的思路, 所以时间复杂度为 O(nlogn), 递推式为 T(n) = T(n/2) + O(n)</span></span><br><span class="line"><span class="comment">// 递归过程中空间复杂度取决于树的最大深度为 O(logn)</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先定位到链表的中间节点</span></span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* preSlow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        preSlow = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 slow 指向中间节点, preSlow 指向其前一节点</span></span><br><span class="line">    <span class="comment">// 将左半部分子链表分离</span></span><br><span class="line">    preSlow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 将中间节点构建成 BST 的根节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">    root-&gt;left = sortedListToBST(head);</span><br><span class="line">    root-&gt;right = sortedListToBST(slow-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上一方法时间复杂度的瓶颈在于寻找中间节点</span></span><br><span class="line"><span class="comment">// 由于构造出来的二叉搜索树的中序遍历结果就是给定的链表</span></span><br><span class="line"><span class="comment">// 因此, 我们假想二叉搜索树已经存在了</span></span><br><span class="line"><span class="comment">// 对此二叉搜索树进行中序遍历, 遍历的同时更新树中的节点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ListNode* temp = head; temp; temp = temp-&gt;next, size++);</span><br><span class="line">    <span class="keyword">auto</span> inOrder = [&amp;](<span class="keyword">auto</span>&amp;&amp; inOrder, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> (TreeNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode;</span><br><span class="line">        root-&gt;left = inOrder(inOrder, left, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;val = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        root-&gt;right = inOrder(inOrder, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> inOrder(inOrder, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. Linked List Cycle</a></h5><blockquote><p>给定链表的头节点，确定链表中是否有环。如果链表中有一个循环，则返回<code>true</code>。 否则，返回<code>false</code>。</p><img src="circularlinkedlist.png" alt="img" style="zoom:67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        <span class="comment">// 慢指针每次走一步</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="comment">// 快指针每次走两步</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 如果相遇就有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. Linked List Cycle II</a></h5><blockquote><p>给定一个链表头节点，返回环开始的节点。 如果没有环，则返回<code>null</code>。</p><p>第一次相遇时，假设慢指针<code>slow</code>走了<code>k</code>步，那么快指针<code>fast</code>一定走了<code>2k</code>步：</p><img src="3.jpeg" alt="img" style="zoom: 33%;" /><p><code>fast</code>一定比<code>slow</code>多走了<code>k</code>步，这多走的<code>k</code>步其实就是<code>fast</code>指针在环里转圈圈，所以<code>k</code>的值就是环长度的「整数倍」。设相遇点距环的起点的距离为<code>m</code>，那么环的起点距头结点<code>head</code>的距离为<code>k - m</code>，也就是说如果从<code>head</code>前进<code>k - m</code>步就能到达环起点。</p><p>巧的是，如果从相遇点继续前进<code>k - m</code>步，也恰好到达环起点。你甭管<code>fast</code>在环里到底转了几圈，反正走<code>k</code>步可以到相遇点，那走<code>k - m</code>步一定就是走到环起点了：</p><img src="2.jpeg" alt="img" style="zoom: 33%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是因为相遇才出循环的</span></span><br><span class="line">    <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="876-Middle-of-the-Linked-List"><a href="#876-Middle-of-the-Linked-List" class="headerlink" title="876. Middle of the Linked List"></a><a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. Middle of the Linked List</a></h5><blockquote><p>给定一个链表头节点，返回链表的中间节点。</p><p>可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。当链表的长度是奇数时，<code>slow</code>恰巧停在中点位置；如果长度是偶数，<code>slow</code>最终的位置是中间偏右。</p><img src="center.png" alt="img" style="zoom: 50%;" /><p><strong>链表的归并排序</strong>：对于链表，合并两个有序链表是很简单的，难点就在于二分。但是现在知道了找到链表的中点的方法，就能实现链表的二分了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="comment">// 节点个数为偶数时, 返回指向中间两个节点的第二个节点</span></span><br><span class="line"><span class="comment">// 为奇数时返回指向中间的节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二, 在写链表的归并排序时, 要用这个版本!</span></span><br><span class="line"><span class="comment">// 节点个数为偶数时, 返回指向中间两个节点的第一个节点</span></span><br><span class="line"><span class="comment">// 为奇数时返回指向中间的节点的前一个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow ? slow-&gt;next : head;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a></h5><blockquote><p>给定一个链表，删除链表的倒数第<code>n</code>个节点，并且返回链表的头结点。</p><p><strong>Example:</strong></p><img src="remove_ex1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">&gt;Output: [1,2,3,5]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span> &amp;&amp; fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast) &#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. Intersection of Two Linked Lists</a></h5><blockquote><p>给定两个单链列表<code>headA</code>和<code>headB</code>的头，返回两个列表相交的节点。 如果两个链接列表完全没有交集，则返回<code>null</code>。</p><p>例如，以下两个链接列表开始在节点<code>c1</code>处相交：</p><img src="160_statement.png" alt="img" style="zoom:80%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先制造出一个环来, 再借助返回环起点的思路</span></span><br><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p = headA;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 A 链表的首尾相连成环</span></span><br><span class="line">    p-&gt;next = headA;</span><br><span class="line">    ListNode* slow = headB;</span><br><span class="line">    ListNode* fast = headB;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有相遇, 说明原先不存在交点</span></span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast-&gt;next) &#123;</span><br><span class="line">        <span class="comment">// 恢复链表 A</span></span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = headB;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后别忘了恢复链表 A</span></span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很秀的思路</span></span><br><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    ListNode *A = headA, *B = headB;</span><br><span class="line">    <span class="keyword">while</span>(A != B) &#123;</span><br><span class="line">        A = A ? A-&gt;next : headB;</span><br><span class="line">        B = B ? B-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a><a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">328. Odd Even Linked List</a></h5><blockquote><p>给定一个单链列表的头，将所有具有奇数索引的节点组合在一起，然后再加上具有偶数索引的节点，然后返回重新排序的列表。</p><p>第一个节点被认为是奇数，第二个节点被认为是偶数，依此类推。请注意，偶数和奇数组中的相对顺序应保持输入中的原样。</p><img src="oddeven2-linked-list.jpg" alt="img" style="zoom:80%;" /><p>Could you solve it in <code>O(1)</code> space complexity and <code>O(nodes)</code> time complexity?</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* oddLast = head;</span><br><span class="line">    ListNode* evenHead = head-&gt;next;</span><br><span class="line">    ListNode* evenLast = evenHead;</span><br><span class="line">    <span class="keyword">while</span>(evenLast &amp;&amp; evenLast-&gt;next) &#123;</span><br><span class="line">        oddLast-&gt;next = evenLast-&gt;next;</span><br><span class="line">        oddLast = oddLast-&gt;next;</span><br><span class="line">        evenLast-&gt;next = oddLast-&gt;next;</span><br><span class="line">        evenLast = evenLast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    oddLast-&gt;next = eHead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List</a></h5><blockquote><p>给定一个单链表的头节点，如果它是回文链表，则返回<code>true</code>。例如，下面这个就为回文链表：</p><p><img src="pal1linked-list.jpg" alt="img"></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表的后序遍历结合左右指针</span></span><br><span class="line"><span class="comment">// 利用系统栈来后进先出节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(ListNode*)&gt; traverse = [&amp;](ListNode* right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(right-&gt;next);</span><br><span class="line">        res = res &amp;&amp; (left-&gt;val == right-&gt;val);</span><br><span class="line">        <span class="comment">// 左指针前进</span></span><br><span class="line">        left = left-&gt;next;</span><br><span class="line">        <span class="comment">// 结束一个递归实例后, 右指针会自动后退</span></span><br><span class="line">    &#125;;</span><br><span class="line">    traverse(left);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到链表的中间节点</span></span><br><span class="line"><span class="comment">// 再将后半部分链表反转, 判断</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 零个或一个节点的链表默认是回文链表</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当链表长度为偶数时, 返回指向中间两个节点的前一个节点</span></span><br><span class="line">    <span class="comment">// 当链表长度为奇数时, 返回指向中间节点的前一个节点</span></span><br><span class="line">    <span class="keyword">auto</span> getPreMid = [](ListNode* head) &#123;</span><br><span class="line">        ListNode* slow = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow ? slow-&gt;next : head;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 迭代式反转链表</span></span><br><span class="line">    <span class="keyword">auto</span> reverseList = [](ListNode* head) &#123;</span><br><span class="line">        ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* q = head;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            q = head-&gt;next;</span><br><span class="line">            head-&gt;next = p;</span><br><span class="line">            p = head;</span><br><span class="line">            head = q;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* preMid = getPreMid(head);</span><br><span class="line">    ListNode* headRight = preMid-&gt;next;</span><br><span class="line">    preMid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    headRight = reverseList(headRight);</span><br><span class="line">    ListNode* curNode = headRight;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(curNode &amp;&amp; head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curNode-&gt;val != head-&gt;val) &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    preMid-&gt;next = reverseList(headRight);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists</a></h5><blockquote><p>合并两个有序的链表，并将合并结果作为有序链表返回。</p><img src="merge_ex1.jpg" alt="img" style="zoom: 67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* p, ListNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 辅助节点</span></span><br><span class="line">    ListNode head;</span><br><span class="line">    ListNode* last = &amp;head;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt;= q-&gt;val) &#123;</span><br><span class="line">            last-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            last-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    last-&gt;next = p ? p : q;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* p, ListNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!q) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val &lt;= q-&gt;val) &#123;</span><br><span class="line">        head = p;</span><br><span class="line">        p-&gt;next = mergeTwoLists(p-&gt;next, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        head = q;</span><br><span class="line">        q-&gt;next = mergeTwoLists(p, q-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. Merge k Sorted Lists</a></h5><blockquote><p>给定一个由<code>k</code>个链表头节点所组成的数组，每个链表以升序排列。将所有链表合并为一个排序的链表，然后将其返回。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[</span><br><span class="line">1-&gt;4-&gt;5,</span><br><span class="line">1-&gt;3-&gt;4,</span><br><span class="line">2-&gt;6</span><br><span class="line">]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将这 k 个头节点交给优先级队列管理</span></span><br><span class="line"><span class="comment">// 优先级队列采用最小堆, 以节点内的值为排序对象</span></span><br><span class="line"><span class="comment">// 这样每次 pop 的时候保证总是全局所有节点中最小的节点出队</span></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++ 中提供的 priority_queue 默认采用最大堆, 这里需要定制成最小堆</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](ListNode* a, ListNode* b) &#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq(cmp);</span><br><span class="line">    <span class="comment">// 所有头节点移交给 priority_queue 管理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i]) &#123;</span><br><span class="line">            pq.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 辅助节点</span></span><br><span class="line">    ListNode head;</span><br><span class="line">    ListNode* p = &amp;head;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        <span class="comment">// 每次将全局最小节点入链出队</span></span><br><span class="line">        p-&gt;next = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="comment">// 放进去的将是最近入链出队的节点的下一个节点</span></span><br><span class="line">        <span class="comment">// 这样才能保证在队列中的是全局最小的 k 个节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next) &#123;</span><br><span class="line">            pq.push(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="430-Flatten-a-Multilevel-Doubly-Linked-List"><a href="#430-Flatten-a-Multilevel-Doubly-Linked-List" class="headerlink" title="430. Flatten a Multilevel Doubly Linked List"></a><a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/" target="_blank" rel="noopener">430. Flatten a Multilevel Doubly Linked List</a></h5><blockquote><p>给定一个双向链表，该链表除了拥有指向下一个节点和上一个节点的指针外，还具有一个孩子指针，该孩子指针可能指向也可能不指向单独的双向链接列表。 这些子链表可能有一个或多个自己的子链表，依此类推，以产生一个多级数据结构，如下面的示例所示：</p><p><img src="multilevellinkedlist.png" alt="img"></p><p>展平链表，以便所有节点都出现在单级双链表中。 返回链表的头。</p><p><img src="multilevellinkedlistflattened.png" alt="img"></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _prev, Node* _next, Node* _child) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        prev = _prev;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        child = _child;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将题目中的孩子节点看做左孩子, 下一节点看作右孩子</span></span><br><span class="line"><span class="function">Node* <span class="title">flatten</span><span class="params">(Node* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 辅助节点</span></span><br><span class="line">    <span class="function">Node <span class="title">head</span><span class="params">(<span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    Node* last = &amp;head;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">    s.push(p);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">        Node* cur = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        last-&gt;next = cur;</span><br><span class="line">        cur-&gt;prev = last;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next) &#123;</span><br><span class="line">            s.push(cur-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;child) &#123;</span><br><span class="line">            s.push(cur-&gt;child);</span><br><span class="line">            cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a><a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="noopener">61. Rotate List</a></h5><blockquote><p>给定一个单链表的头节点，将链表向右旋转<code>k</code>个位置。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">Output: [4,5,1,2,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [0,1,2], k &#x3D; 4</span><br><span class="line">Output: [2,0,1]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Example 1</th><th align="center">Example 2</th></tr></thead><tbody><tr><td align="center"><img src="rotate1.jpg" alt="img" style="zoom: 67%;" /></td><td align="center"><img src="roate2.jpg" alt="img" style="zoom: 67%;" /></td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要注意到:</span></span><br><span class="line"><span class="comment">// 1. 旋转了几次, 就会有末尾的几个节点整体次序不变的被平移到前面</span></span><br><span class="line"><span class="comment">// 2. 如果旋转了链表长度的倍数次, 链表将恢复原样</span></span><br><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* last = head;</span><br><span class="line">    <span class="comment">// 获取链表的长度, 并将 last 定位至尾节点</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(last-&gt;next) &#123;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算实际旋转的次数</span></span><br><span class="line">    k = k % size;</span><br><span class="line">    <span class="comment">// 如果待旋转次数为链表长度的倍数, 不需要旋转</span></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的头节点为第几个节点</span></span><br><span class="line">    k = size - k;</span><br><span class="line">    <span class="comment">// 将 q 定位到新的头节点的前一个节点</span></span><br><span class="line">    ListNode* preNewHead = head;</span><br><span class="line">    <span class="keyword">while</span>(--k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        preNewHead = preNewHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start 为新的头节点</span></span><br><span class="line">    ListNode* newHead = preNewHead-&gt;next;</span><br><span class="line">    <span class="comment">// 前后接在一块即可</span></span><br><span class="line">    preNewHead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    last-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. Copy List with Random Pointer</a></h5><blockquote><p>  给你一个长度为<code>n</code>的链表，每个节点包含一个额外增加的随机指针<code>random</code>，该指针可以指向链表中的任何节点或空节点。</p><p>  构造这个链表的深拷贝。 深拷贝应该正好由<code>n</code>个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code>指针和<code>random</code>指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>  例如，如果原链表中有<code>X</code>和<code>Y</code>两个节点，其中<code>X.random --&gt; Y</code>。那么在复制链表中对应的两个节点<code>x</code>和<code>y</code>，同样有<code>x.random --&gt; y</code>。</p><p>  返回复制链表的头节点。</p><p>  用一个由<code>n</code>个节点组成的链表来表示输入/输出中的链表。每个节点用一个<code>[val, random_index]</code>表示：</p><p>  <code>val</code>：一个表示<code>Node.val</code>的整数。<br>  <code>random_index</code>：随机指针指向的节点索引（范围从<code>0</code>到<code>n - 1</code>）；如果不指向任何节点，则为<code>null</code>。<br>  你的代码只接受原链表的头节点<code>head</code>作为传入参数。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node *random;</span><br><span class="line">    Node(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">      val = _val;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">        random = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>  <strong>Example 1:</strong></p><p><strong><img src="e3.png" alt="img" style="zoom:50%;" /></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  Input: head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">&gt;Output: [[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p><img src="e1.png" alt="img" style="zoom: 50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">&gt;Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接从头节点通过 next 指针, 向后一个一个遍历就可以了</span></span><br><span class="line"><span class="comment">// 先拷贝当前节点, 在判断当前节点的 random 指针是否为空</span></span><br><span class="line"><span class="comment">// 如果为空, 直接跳到下一个节点就可以了</span></span><br><span class="line"><span class="comment">// 如果不为空, 那就将 random 节点 new 一份</span></span><br><span class="line"><span class="comment">// 注意当前节点的 random 节点可能已经遍历过或者啊还没有遍历</span></span><br><span class="line"><span class="comment">// 1. 如果已经遍历过, 此时只需要将当前节点的拷贝节点的 random 指向它就可以了</span></span><br><span class="line"><span class="comment">// 那么我们怎么获取已经遍历过的节点的拷贝节点的指针呢？</span></span><br><span class="line"><span class="comment">// 2. 如果没有被遍历过, 直接 new 出来, 再将当前节点的拷贝节点的 random 指向它就行</span></span><br><span class="line"><span class="comment">// 但是, 下次通过 next 指针遍历到它的时候, 不能再 new 了, 因为它已经存在了</span></span><br><span class="line"><span class="comment">// 解决这个问题的方法就是借助哈希表在遍历的过程中记录当前节点和其拷贝节点之间的映射</span></span><br><span class="line"><span class="comment">// 这样在每次遍历新节点的时候先判断是否已经被 new 出来过了</span></span><br><span class="line"><span class="comment">// 下面直接看代码吧, 有详细注释</span></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录节点与其拷贝节点之间的映射</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; mapping;</span><br><span class="line">    <span class="comment">// 辅助节点, 方便插入新节点和最后返回</span></span><br><span class="line">    <span class="function">Node <span class="title">helper</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// last 之后一直指向新链表的尾节点</span></span><br><span class="line">    Node* last = &amp;helper;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(head) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有, 需要重新 new 一个</span></span><br><span class="line">            mapping[head] = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        last-&gt;next = mapping[head];</span><br><span class="line">        <span class="comment">// 如果当前节点指向了一个随机节点</span></span><br><span class="line">        <span class="comment">// 就要为它的拷贝节点也要指向一个随机节点</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;random) &#123;</span><br><span class="line">            <span class="comment">// 如果这个随机节点没有 new 过</span></span><br><span class="line">            <span class="keyword">if</span>(mapping.count(head-&gt;random) == <span class="number">0</span>) &#123;</span><br><span class="line">            mapping[head-&gt;random] = <span class="keyword">new</span> Node(head-&gt;random-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            last-&gt;next-&gt;random = mapping[head-&gt;random];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新旧链表当前节点指针同步前进一步</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种解法也是建立映射, 但思路有点差别, 这里用两次 O(n) 遍历</span></span><br><span class="line"><span class="comment">// 第一次遍历建立所有节点到其拷贝节点的映射, 第一次遍历完所有节点都被 new 过了</span></span><br><span class="line"><span class="comment">// 第二次遍历将拷贝节点的 next 指针和 random 指针安置妥当</span></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立 “原节点 -&gt; 新节点” 的映射</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; mapping;</span><br><span class="line">    Node* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        mapping[cur] = <span class="keyword">new</span> Node(cur-&gt;val);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// 构建新链表的 next 和 random 指向</span></span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        mapping[cur]-&gt;next = mapping[cur-&gt;next];</span><br><span class="line">        mapping[cur]-&gt;random = mapping[cur-&gt;random];</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> mapping[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1019-Next-Greater-Node-In-Linked-List"><a href="#1019-Next-Greater-Node-In-Linked-List" class="headerlink" title="1019. Next Greater Node In Linked List"></a><a href="https://leetcode.com/problems/next-greater-node-in-linked-list/" target="_blank" rel="noopener">1019. Next Greater Node In Linked List</a></h5><blockquote><p>  给出一个以头节点<code>head</code>作为第一个节点的链表。链表中的节点分别编号为：<code>node_1, node_2, node_3, ...</code> 。</p><p>  每个节点都可能有下一个更大值（<code>next larger value</code>）：对于<code>node_i</code>，如果其<code>next_larger(node_i)</code>是<code>node_j.val</code>，那么就有<code>j &gt; i</code>且<code>node_j.val &gt; node_i.val</code>，而<code>j</code>是可能的选项中最小的那个。如果不存在这样的<code>j</code>，那么下一个更大值为<code>0</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5]</span><br><span class="line">Output: [5,5,0]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,4,3,5]</span><br><span class="line">Output: [7,0,5,5,0]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 像这种下一个最大元素之类的问题, 一定用的是单调栈的技巧</span></span><br><span class="line"><span class="comment">// 有几道数组的题目是找下一个最大元素</span></span><br><span class="line"><span class="comment">// 这里给换成了链表了, 换汤不换药</span></span><br><span class="line"><span class="comment">// 这里主要学习的技术是链表的后序遍历</span></span><br><span class="line"><span class="comment">// 对的, 链表就是一种特殊的二叉树嘛</span></span><br><span class="line"><span class="comment">// 链表的后序遍历就是从后向前访问节点</span></span><br><span class="line"><span class="comment">// 你当然可以用栈来完成</span></span><br><span class="line"><span class="comment">// 这里用递归完成</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(ListNode*)&gt; traverse = [&amp;](ListNode* head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head) &#123;</span><br><span class="line">            <span class="comment">// 先不访问节点, 递归去下一个节点</span></span><br><span class="line">            traverse(head-&gt;next);</span><br><span class="line">            <span class="comment">// 后序遍历代码</span></span><br><span class="line">            <span class="comment">// 下面代码都是是固定的单调栈算法的模板</span></span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt;= head-&gt;val) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(s.empty() ? <span class="number">0</span> : s.top());</span><br><span class="line">            s.push(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    traverse(head);</span><br><span class="line">    <span class="comment">// 最后需要反转一下</span></span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a><a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">148. Sort List</a></h5><blockquote><p>  链表的排序。这里分别给出归并排序的递归版、迭代版以及快速排序版本。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序, 递归解法</span></span><br><span class="line"><span class="comment">// T: O(nlogn), S: O(logn)</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* mid = getMid(head);</span><br><span class="line">    ListNode* head1 = mid-&gt;next;</span><br><span class="line">    mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(sortList(head), sortList(head1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 这里的 bug 是如果链表的长度为 2</span></span><br><span class="line"><span class="comment">// // 永远返回的是指向第 2 个元素的指针</span></span><br><span class="line"><span class="comment">// // 对这个链表的归并排序将永远循环下去!</span></span><br><span class="line"><span class="comment">// // tmd 卡了我半天, 艹!</span></span><br><span class="line"><span class="comment">// ListNode* getMid(ListNode* head)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     ListNode* slow = head;</span></span><br><span class="line"><span class="comment">//     ListNode* fast = head;</span></span><br><span class="line"><span class="comment">//     while(fast &amp;&amp; fast-&gt;next)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         slow = slow-&gt;next;</span></span><br><span class="line"><span class="comment">//         fast = fast-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return slow;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是修正后的版本</span></span><br><span class="line"><span class="function">ListNode* <span class="title">getMid</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow ? slow-&gt;next : head;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* p, ListNode* q)</span> </span>&#123;</span><br><span class="line">    ListNode helper;</span><br><span class="line">    ListNode* last = &amp;helper;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">            last-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            last-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    last-&gt;next = p ? p : q;</span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序, 迭代解法</span></span><br><span class="line"><span class="comment">// T: O(nlogn), S: O(1)</span></span><br><span class="line"><span class="comment">// nextSublist 始终指向后续待归并的链表的头节点</span></span><br><span class="line">ListNode* nextSublist = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// tail 始终指向已经归并好的局部子链表的尾节点</span></span><br><span class="line">ListNode* tail = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ListNode* temp = head; temp; temp = temp-&gt;next) &#123;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 辅助头节点</span></span><br><span class="line">    ListNode helper;</span><br><span class="line">    helper.next = head;</span><br><span class="line">    <span class="comment">// 从长度为 1 开始, 每次成倍增长地归并子链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        ListNode* start = &amp;helper;</span><br><span class="line">        nextSublist = helper.next;</span><br><span class="line">        <span class="keyword">while</span>(nextSublist) &#123;</span><br><span class="line">            <span class="comment">// 划出 i 个有序节点组成一个链表</span></span><br><span class="line">            ListNode* list1 = split(nextSublist, i);</span><br><span class="line">            <span class="comment">// 再划出 i 个有序节点组成一个链表</span></span><br><span class="line">            ListNode* list2 = split(nextSublist, i);</span><br><span class="line">            <span class="comment">// 将这划分出来的两个相邻有序链表合并</span></span><br><span class="line">            start-&gt;next = merge(list1, list2);</span><br><span class="line">            start = tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 head 链表前面划出 size 长度的子链表出来</span></span><br><span class="line"><span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode* head, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(--size &gt; <span class="number">0</span> &amp;&amp; p) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p) &#123;</span><br><span class="line">        <span class="comment">// 这里说明 size 小于 head 链表的长度</span></span><br><span class="line">        <span class="comment">// 现在 p 指向被划出来链表的尾节点</span></span><br><span class="line">        nextSublist = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 size 大于 head 链表的长度</span></span><br><span class="line">    <span class="comment">// 说明已经有序了</span></span><br><span class="line">        nextSublist = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序链表, 和递归版本的没区别</span></span><br><span class="line"><span class="comment">// 主要是要更新 tail 指针</span></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* p, ListNode* q)</span> </span>&#123;</span><br><span class="line">    ListNode helper;</span><br><span class="line">    ListNode* last = &amp;helper;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">            last-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            last-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    last-&gt;next = p ? p : q;</span><br><span class="line">    <span class="comment">// 更新 tail 指针, 使其指向这被合并完成的有序链表的尾节点</span></span><br><span class="line">    <span class="keyword">while</span>(last-&gt;next) &#123;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail = last;</span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序版本, 最坏时间复杂度为 O(n2), 超时!</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接收一个左闭右开区间 [left, right)</span></span><br><span class="line">    <span class="keyword">auto</span> qs = [&amp;] (<span class="keyword">auto</span>&amp;&amp; qs, ListNode* left, ListNode* right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right || left-&gt;next == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取首节点元素为基准值</span></span><br><span class="line">        <span class="comment">// 凡小于此值的节点以头插法插入到左边</span></span><br><span class="line">        <span class="comment">// 凡大于此值的节点以尾插法插入到右边</span></span><br><span class="line">        ListNode* pivot = left;</span><br><span class="line">        ListNode* cur = left-&gt;next;</span><br><span class="line">        ListNode* tail = pivot;</span><br><span class="line">        <span class="keyword">while</span>(cur != right) &#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &lt; pivot-&gt;val) &#123;</span><br><span class="line">                <span class="comment">// 头插法</span></span><br><span class="line">                cur-&gt;next = left;</span><br><span class="line">                left = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 尾插法</span></span><br><span class="line">                tail-&gt;next = cur;</span><br><span class="line">                tail = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这行很重要, tail 一直指向右边链表的尾节点</span></span><br><span class="line">        <span class="comment">// 要把开区间的之后的节点们接到它后面</span></span><br><span class="line">        tail-&gt;next = right;</span><br><span class="line">        <span class="comment">// 此时, head 指向新链表的头节点</span></span><br><span class="line">        <span class="comment">// p 指向新链表的基准节点, 以基准节点作为右边链表的开区间尾元素进行下一次递归调用</span></span><br><span class="line">        ListNode* newHead = qs(qs, left, pivot);</span><br><span class="line">        <span class="comment">// 跳过已经归位的基准节点</span></span><br><span class="line">        pivot-&gt;next = qs(qs, pivot-&gt;next, right);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> qs(qs, head, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="143-重排链表-力扣（LeetCode）"><a href="#143-重排链表-力扣（LeetCode）" class="headerlink" title="143. 重排链表 - 力扣（LeetCode）"></a><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表 - 力扣（LeetCode）</a></h5><blockquote><p>  给定一个单链表L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为：L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>  你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>  <strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[1, 5*10^4]</code>.</li><li><code>1 &lt;= Node.val &lt;= 1000</code></li></ul><p>  <strong>Example 1:</strong></p>  <img src="reorder2-linked-list.jpg" alt="img" style="zoom:67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [1,5,2,4,3]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <img src="reorder1linked-list.jpg" alt="img" style="zoom: 67%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4]</span><br><span class="line">Output: [1,4,2,3]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双端队列解法</span></span><br><span class="line"><span class="comment">// 时间和空间复杂度均为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;ListNode*&gt; dq;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        dq.push_back(head);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode helper;</span><br><span class="line">    ListNode* last = &amp;helper;</span><br><span class="line">    <span class="keyword">while</span>(dq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        last-&gt;next = dq.front();</span><br><span class="line">        dq.pop_front();</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">        last-&gt;next = dq.back();</span><br><span class="line">        dq.pop_back();</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!dq.empty()) &#123;</span><br><span class="line">        last-&gt;next = dq.front();</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    last-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    head = helper.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 找到链表中点</span></span><br><span class="line"><span class="comment">// 2. 反转后半部分链表</span></span><br><span class="line"><span class="comment">// 3. 合并两部分链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head) &#123;</span><br><span class="line">        ListNode* mid = middleNode(head);</span><br><span class="line">        ListNode* q = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        q = reverseList(q);</span><br><span class="line">        mergeList(head, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点个数为偶数时, 返回指向中间两个节点的第二个节点</span></span><br><span class="line"><span class="comment">// 为奇数时返回指向中间的节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head) &#123;</span><br><span class="line">        q = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        p = head;</span><br><span class="line">        head = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode* p, ListNode* q)</span> </span>&#123;</span><br><span class="line">    ListNode* p_next = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* q_next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q) &#123;</span><br><span class="line">        p_next = p-&gt;next;</span><br><span class="line">        q_next = q-&gt;next;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        p = p_next;</span><br><span class="line">        </span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        q = q_next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-24-82-Remove-Duplicates-from-Sorted-List-II"><a href="#2-24-82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="2.24 82. Remove Duplicates from Sorted List II"></a><code>2.24</code> <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. Remove Duplicates from Sorted List II</a></h5><blockquote><p>存在一个按升序排列的链表，给你这个链表的头节点<code>head</code>，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中<strong>没有重复出现</strong>的数字。</p><p>返回同样按升序排列的结果链表。</p><p><strong>Example 1:</strong></p><img src="linkedlist1.jpg" alt="img" style="zoom:50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: head &#x3D; [1,2,3,3,4,4,5]</span><br><span class="line">&gt;Output: [1,2,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><img src="linkedlist2.jpg" alt="img" style="zoom:50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: head &#x3D; [1,1,1,2,3]</span><br><span class="line">&gt;Output: [2,3]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode <span class="title">helper</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">    ListNode* last = &amp;helper;</span><br><span class="line">    <span class="keyword">while</span>(last-&gt;next) &#123;</span><br><span class="line">        ListNode* temp = last-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(temp &amp;&amp; temp-&gt;val == last-&gt;next-&gt;val) &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp == last-&gt;next-&gt;next) &#123;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            last-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识C++内存管理的工具 （三）</title>
      <link href="/gMOP9F0b8zMZULMj/"/>
      <url>/gMOP9F0b8zMZULMj/</url>
      
        <content type="html"><![CDATA[<h4 id="13-重载类本身的operator-new-delete"><a href="#13-重载类本身的operator-new-delete" class="headerlink" title="13. 重载类本身的operator new/delete"></a><code>13</code>. 重载类本身的<code>operator new/delete</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A() : this:"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A(): this: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数写不写 static 都会被编译器做成 static</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用 A::operator new 版本</span></span><br><span class="line">    A* a = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用全局的 operator new, 如果想调用 A 的版本, 则需显式调用 A::operator new()</span></span><br><span class="line">    <span class="keyword">void</span>* b = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(A));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    A* c = ::<span class="keyword">new</span> A();       <span class="comment">// 调用全局的 operator new</span></span><br><span class="line">    <span class="keyword">void</span>* d = ::<span class="keyword">new</span> A();    <span class="comment">// 调用全局的 operator new</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> a;   <span class="comment">// 先调用 A 的析构函数, 再调用 A 的 operator delete</span></span><br><span class="line">    <span class="keyword">delete</span> b;   <span class="comment">// 直接调用了全局的 operator delete</span></span><br><span class="line">    ::<span class="keyword">delete</span> c;</span><br><span class="line">    ::<span class="keyword">delete</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="image-20210316211007882.png" alt="image-20210316211007882"></p><h4 id="14-本质就是重载new"><a href="#14-本质就是重载new" class="headerlink" title="14. 本质就是重载new"></a><code>14</code>. 本质就是重载<code>new</code></h4><p><code>new</code>是关键字，编译器看到<code>new</code>，会转换成<code>operator new</code>的调用。</p><p><img src="image-20210316211821850.png" alt="image-20210316211821850"></p><p><img src="image-20210316211849406.png" alt="image-20210316211849406"></p><p><img src="image-20210316211942624.png" alt="image-20210316211942624"></p><h4 id="15-重载new-delete"><a href="#15-重载new-delete" class="headerlink" title="15. 重载new()/delete()"></a><code>15</code>. 重载<code>new()/delete()</code></h4><p><img src="image-20210316212107044.png" alt="image-20210316212107044"></p><p><img src="image-20210316212317475.png" alt="image-20210316212317475"></p><h4 id="16-关于多参new对应的delete"><a href="#16-关于多参new对应的delete" class="headerlink" title="16. 关于多参new对应的delete"></a><code>16</code>. 关于多参<code>new</code>对应的<code>delete</code></h4><p><img src="image-20210316212449598.png" alt="image-20210316212449598"></p><ul><li><p>上面重载了参数不一的<code>operator new()</code>，那是不是要重载对应的<code>operator delete()</code>呢？</p><p>  理论上<code>delete</code>的工作只是为了释放内存，所以只需要一个指针就可以了，但<code>C++</code>在语法上支持多参的<code>delete</code>重载，但<code>delete</code>的调用格式只有<code>delete ptr</code>，所以关于重载的<code>delete</code>版本什么时候被调用，并不是用户手动调用，而是对应版本的<code>Ctor</code>发生异常后，会由<code>crt</code>来调用对应的<code>delete</code>。</p></li></ul><h4 id="17-basic-string使用new-extra-扩充申请量"><a href="#17-basic-string使用new-extra-扩充申请量" class="headerlink" title="17. basic_string使用new(extra)扩充申请量"></a><code>17</code>. <code>basic_string</code>使用<code>new(extra)</code>扩充申请量</h4><p><img src="image-20210316214052184.png" alt="image-20210316214052184"></p><h4 id="18-new-handler"><a href="#18-new-handler" class="headerlink" title="18. new_handler"></a><code>18</code>. <code>new_handler</code></h4><p><img src="image-20210317210723036.png" alt="image-20210317210723036"></p><p><img src="image-20210317211006818.png" alt="image-20210317211006818"></p><p><img src="image-20210317211425498.png" alt="image-20210317211425498"></p><p><img src="image-20210317211445418.png" alt="image-20210317211445418"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识C++内存管理的工具 （二）</title>
      <link href="/vgFO35JETZ2jRu74/"/>
      <url>/vgFO35JETZ2jRu74/</url>
      
        <content type="html"><![CDATA[<h4 id="7-构造和析构的直接调用方式"><a href="#7-构造和析构的直接调用方式" class="headerlink" title="7. 构造和析构的直接调用方式"></a><code>7</code>. 构造和析构的直接调用方式</h4><p>通过指针不可以直接调用构造函数，但可以直接调用析构函数。可以通过<code>placement new</code>来直接调用构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) : a(_a), b(_b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* tmp_a = <span class="keyword">new</span> A(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// tmp-&gt;A::A(2, 8); // error! cannot call constructor 'A::A' directly</span></span><br><span class="line">    tmp_a-&gt;~A(); <span class="comment">// 可以的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然调用了析构函数, 但事实上 tmp_a 的空间并没有释放</span></span><br><span class="line">    <span class="comment">// 因为没有 free 掉, 那块内存还在, 值没有被重写</span></span><br><span class="line">    <span class="comment">// 所以可以访问 通过 tmp_a 访问原对象的值</span></span><br><span class="line">    <span class="comment">// 如果是 delete tmp_a; 就不能访问</span></span><br><span class="line">    <span class="comment">// 因为 delete 调用完析构函数之后, 还调用了 free 函数释放那块内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tmp_a-&gt;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 所有这里访问的值看似没有变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="8-array-new-delete"><a href="#8-array-new-delete" class="headerlink" title="8. array new/delete"></a><code>8</code>. <code>array new/delete</code></h4><p><code>new []/delete[]</code>本质调用<code>malloc/free</code>。<code>malloc/free</code>细节：</p><ul><li><p>除了分配给定的内存之外，还会有<code>cookie</code>——用来记录分配数组的长度，查看<code>cookie</code>中的长度，然后调用适当次数的析构函数</p></li><li><p>所谓内存泄漏</p><p>  对于一个<code>new []</code>，需要有相应的<code>delete []</code>，本质上<code>cookie</code>记录了<code>free</code>本身需要释放的内存大小，泄露则发生在调用的析构函数次数上：如果对象含有指针的<code>data member</code>，指向堆上的内存，则意味着析构函数是<code>nontrival</code>，需要再析构函数中释放指针指向的内存，反之则是<code>trival</code>的，而析构函数的调用次数，则会影响指针指向的内存部分的泄露。</p></li></ul><p><img src="image-20210316200134379.png" alt="image-20210316200134379"></p><p><img src="image-20210316201727370.png" alt="image-20210316201727370"></p><p><img src="image-20210316201922911.png" alt="image-20210316201922911"></p><h4 id="9-placement-new"><a href="#9-placement-new" class="headerlink" title="9. placement new"></a><code>9</code>. <code>placement new</code></h4><p>标准不允许直接用指针调用构造函数，但给出了另一种调用语法，可以在现有的对象的内存中调用构造函数，它不会分配新的内存。这也是没有对应的<code>placement delete</code>的原因。</p><p><img src="image-20210316202736446.png" alt="image-20210316202736446"></p><h4 id="10-C-程序分配内存的途径"><a href="#10-C-程序分配内存的途径" class="headerlink" title="10. C++程序分配内存的途径"></a><code>10</code>. <code>C++</code>程序分配内存的途径</h4><p><img src="image-20210316203737564.png" alt="image-20210316203737564"></p><p><img src="image-20210316205136096.png" alt="image-20210316205136096"></p><p>从图中可以看出，当出现<code>new Foo(x)</code>后，编译器会检查<code>Foo</code>这个类有没有实现<code>operator new(size_t)</code>的<code>static</code>函数，如果有就会调用<code>Foo</code>这个版本的<code>operator new</code>，如果没有就调用全局的<code>::operator new</code>，<code>delete</code>也是如此。</p><p>所以可以为一个类单独实现<code>operator new</code>和<code>operator delete</code>。也可以重载全局的<code>operator new/delete</code>，但很少这么做，因为全局的版本是照顾所有的类。</p><h4 id="11-探究operator-new"><a href="#11-探究operator-new" class="headerlink" title="11. 探究operator new"></a><code>11</code>. 探究<code>operator new</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">new</span> (a) A(<span class="number">27</span>, <span class="number">224</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* b = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(A));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a-&gt;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汇编代码如下:</span></span><br></pre></td></tr></table></figure><img src="30.png" style="zoom:67%;" /><img src="31.png" style="zoom:67%;" /><img src="33.png" style="zoom:67%;" /><img src="34.png" style="zoom:67%;" /><h4 id="12-重载-operator-new-delete"><a href="#12-重载-operator-new-delete" class="headerlink" title="12. 重载::operator new/delete"></a><code>12</code>. 重载<code>::operator new/delete</code></h4><p>上面说了，重载全局的<code>operator new/delete</code>影响深远，谨慎使用。但可以重载，方法是在<strong>非</strong><code>namespace</code>中声明和全局版本相同的函数签名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A() : this:"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) : a(_a), b(_b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A(int,int): this: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A(): this: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下 4 个函数就在当前的文件中声明定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(len); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> A(); <span class="comment">// 调用到上面自定义的 operator new</span></span><br><span class="line">    <span class="keyword">void</span>* b = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(A)); <span class="comment">// 虽然指定的是 ::operator new, 但还是调用到上面自定义的版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 a 是正确的释放, 先调用 A 的析构函数, 再调用上面的 operator delete</span></span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 b, 释放的操作应该显示调用 operator delete</span></span><br><span class="line">    <span class="comment">// 这里用 delete 后, 并没有调用 A 的析构函数, 而是直接调用了 operator delete</span></span><br><span class="line">    <span class="comment">// 可见编译器对于 delete void* 的时候, 是直接转换为 opreator delete</span></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识C++内存管理的工具 （一）</title>
      <link href="/kZo0999uFp6r1QI2/"/>
      <url>/kZo0999uFp6r1QI2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-内存管理函数的层次"><a href="#1-内存管理函数的层次" class="headerlink" title="1. 内存管理函数的层次"></a><code>1</code>. 内存管理函数的层次</h4><p>从下图中可以看到，<code>C++</code>程序员处于的位置是最上层的<code>Applications</code>，用的最多的是<code>new</code>，<code>new[]</code>，如果用容器，则内存基本不用管理。其次也可以调用<code>malloc</code>。至于最底层的操作系统级别的<code>API</code>，没有可移植性。它们之间的调用关系如上图的箭头所示。</p><a id="more"></a><img src="20.png"  /><h4 id="2-Memory-primitives分类"><a href="#2-Memory-primitives分类" class="headerlink" title="2. Memory primitives分类"></a><code>2</code>. <code>Memory primitives</code>分类</h4><table><thead><tr><th>分配</th><th>释放</th><th>所属</th><th>可否重载</th></tr></thead><tbody><tr><td><code>malloc</code></td><td><code>free</code></td><td><code>C</code>函数</td><td>否</td></tr><tr><td><code>new</code></td><td><code>delete</code></td><td><code>C++</code>表达式</td><td>否</td></tr><tr><td><code>::operator new()</code></td><td><code>::operator delete()</code></td><td><code>C++</code>函数</td><td>可</td></tr><tr><td><code>allocator&lt;T&gt;::allocate()</code></td><td><code>allocator&lt;T&gt;::deallocate()</code></td><td><code>STL</code>分配器</td><td>可以自己设计搭配容器</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primitives_sample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// CRT 运行时函数</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>( <span class="number">512</span> );</span><br><span class="line">    <span class="built_in">free</span>( p1 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new</span></span><br><span class="line">    <span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt; *p2 = <span class="keyword">new</span> <span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ::operator new() 全局函数, 可被重载</span></span><br><span class="line">    <span class="keyword">void</span> *p3 = ::<span class="keyword">operator</span> <span class="keyword">new</span>( <span class="keyword">sizeof</span>( <span class="keyword">int</span> ) ); <span class="comment">// 内部调用 malloc</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">( p3 )</span></span>;    <span class="comment">//内部调用delete</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocator 分配器, STL 容器分配内存的方式</span></span><br><span class="line">    <span class="keyword">void</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate( <span class="number">7</span> );</span><br><span class="line">    allocator&lt;<span class="keyword">int</span>&gt;().deallocate( (<span class="keyword">int</span> *)p4, <span class="number">7</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-new的初步探究"><a href="#3-new的初步探究" class="headerlink" title="3. new的初步探究"></a><code>3</code>. <code>new</code>的初步探究</h4><p><code>c++</code>的程序员基本都会用<code>new</code>来为对象分配一个堆内存，并且<code>new</code>会调用对应的构造函数，构造函数是用来初始化对象的，所以总结出<code>new</code>的功能是：</p><ol><li>在堆中分配一块指定对象大小的内存</li><li>将返回的指针转换为指向对象类型的指针</li><li>通过指针调用对象相应的构造函数</li></ol><p><img src="image-20210315204443125.png" alt="image-20210315204443125"></p><h4 id="4-测试new的调用流程"><a href="#4-测试new的调用流程" class="headerlink" title="4. 测试new的调用流程"></a><code>4</code>. 测试<code>new</code>的调用流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b): a(_a), b(_b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* tmp_a = <span class="keyword">new</span> A(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">delete</span> tmp_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="21.png" style="zoom: 67%;" /><img src="22.png" style="zoom:67%;" /><img src="23.png" style="zoom:67%;" /><img src="24.png" style="zoom:67%;" /><p>上面的<code>4</code>张图是在<code>MSVC</code>中反汇编的运行时代码。从第<code>1</code>张图可以看出，<code>new</code>调用了<code>operator new</code>，从第<code>3</code>张图可以看出，<code>operator new</code>内部调用了<code>malloc</code>。实际上编译器是在<code>new</code>的地方调用了对应的构造函数，并不是在<code>new</code>的内部，<code>new</code>只是编译器识别的一个标识符，并不是函数，编译器看到<code>new</code>后会<code>malloc</code>，然后调用构造函数。</p><p><code>VS2019</code>可以看到<code>operator new</code>的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">_CRT_SECURITYCRITICAL_ATTRIBUTE</span><br><span class="line"><span class="function"><span class="keyword">void</span>* __CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="keyword">const</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">void</span>* <span class="keyword">const</span> block = <span class="built_in">malloc</span>(size))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == SIZE_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_array_new_length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_alloc();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The new handler was successful; try to allocate again...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>operator new</code>的作用是调用<code>malloc</code>分配内存。当<code>malloc</code>成功后直接返回。当<code>malloc</code>失败后，并不会再次<code>malloc</code>，而是调用<code>_callnewh() new_handler()</code>，这个函数的作用是向自己定义的函数索取内存，所以<code>new_handler</code>可以理解为释放一些缓存，调用完<code>new_handler</code>后，可能释放了内存，这个时候再尝试调用<code>malloc</code>获取内存。</p><h4 id="5-delete的初步探究"><a href="#5-delete的初步探究" class="headerlink" title="5. delete的初步探究"></a><code>5</code>. <code>delete</code>的初步探究</h4><p><img src="image-20210315210220075.png" alt="image-20210315210220075"></p><h4 id="6-测试delete的调用流程"><a href="#6-测试delete的调用流程" class="headerlink" title="6. 测试delete的调用流程"></a><code>6</code>. 测试<code>delete</code>的调用流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) : a(_a), b(_b) &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* tmp_a = <span class="keyword">new</span> A(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">delete</span> tmp_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="25.png" style="zoom:67%;" /><img src="26.png" style="zoom:67%;" /><img src="27.png" style="zoom:67%;" /><img src="28.png" style="zoom:67%;" /><img src="29.png" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之构造、析构、拷贝语意学</title>
      <link href="/plA8MQtWi85PlNcz/"/>
      <url>/plA8MQtWi85PlNcz/</url>
      
        <content type="html"><![CDATA[<h4 id="第5章：构造、析构、拷贝语意学"><a href="#第5章：构造、析构、拷贝语意学" class="headerlink" title="第5章：构造、析构、拷贝语意学"></a>第<code>5</code>章：构造、析构、拷贝语意学</h4><ul><li><p>可以定义和调用一个纯虚函数，不过只能被静态的调用（通过类作用域运算符），不能通过虚拟机制调用。 </p></li><li><p>你声明了一个纯虚析构函数，就必须定义它。因为在你提供了声明前提下，每一个derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。因此，只要缺乏任何一个base class destructor的定义，就会<strong>导致链接失败</strong>。</p><p>  读到这儿，你可能会有疑问，对于普通的类（没有虚机制参与进来，派生类的析构函数中也会逐一调用基类的析构函数）我们也没有提供它析构函数的，那为什么不会导致链接失败呢？这是因为你没有写析构函数，编译器会默默给你提供一个，以便于在后面的派生类的析构函数中调用它。这里的重点是你没有提供，也就是说你没有声明，如果你声明了，但没有提供定义，同样会导致链接失败。</p></li><li><p>对于基类该不该将虚函数定义为<code>const</code>的，作者不建议。因为derived class中可能会修改自己的数据成员。</p></li></ul><a id="more"></a><h5 id="5-1-无继承情况下的对象构造"><a href="#5-1-无继承情况下的对象构造" class="headerlink" title="5.1 无继承情况下的对象构造"></a><code>5.1</code> 无继承情况下的对象构造</h5><p>当编译器遇到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point global;</span><br></pre></td></tr></table></figure><p>在<code>C</code>之中，<code>global</code>被视为一个“临时性的定义”，因为它没有明确的初始化操作。一个“临时性的定义”可以在程序中发生多次。那些实例会被链接器折叠起来，只留下单独一个实体，被放在程序<code>data segment</code>中一个“特别保留给未初始化之<code>global objects</code>使用”的空间。由于历史的缘故，这块空间被称为<code>BSS</code>，是<code>Block Started by Symbol</code>的缩写。</p><p>而<code>global</code>在<code>C++</code>中被视为完全定义（它会阻止第二个或更多个定义）。<code>C</code>和<code>C++</code>的一个差异就在于，<code>BSS data segment</code>在<code>C++</code>中相对地不重要。<code>C++</code>的所有全局对象都被当作“初始化过的数据”来对待。</p><p><strong>为继承做准备</strong></p><p>虚函数的引入不仅仅是每个类对象增加了一个<code>vptr</code>，而且会引发编译器对类产生膨胀作用。我们所定义的构造函数，编译器会附加一些代码，以便<code>vptr</code>初始化。合成一个<code>copy constructor</code>和一个<code>copy assignment operator</code>，它们都不是<code>trival</code>。因为，如果<code>point</code>类对象被初始化或以一个派生类对象赋值，<code>bitwise</code>操作就存在问题了，<code>vptr</code>设置会出错。</p><p><code>C++</code>编译器要求编译器尽量延迟<code>nontrivial members</code>的实际合成操作，直到遇到使用场合为止。如果在你的设计中存在很多以传值的方式返回局部类对象，提供一个拷贝构造函数就比较合理，因为这会触发编译器的<code>NRV</code>优化。</p><h5 id="5-2-继承体系下的对象构造"><a href="#5-2-继承体系下的对象构造" class="headerlink" title="5.2 继承体系下的对象构造"></a><code>5.2</code> 继承体系下的对象构造</h5><p><code>constructor</code>可能内带大量的隐藏码，因为编译器会扩充每一个<code>constructor</code>，扩充程度视<code>class T</code>的继承体系而定。一般而言编译器所做的扩充操作大约如下：</p><ol><li>记录在<code>member initialization list</code>中的<code>data members</code>初始化操作会被放进<code>constrector</code>的函数本身，并以<code>members</code>的声明顺序为顺序。<ul><li>如果有数据成员为类对象，并被列于<code>member initialization list</code>中，那么任何明确指定的参数都应该传递过去。</li></ul></li><li>如果有一个<code>member</code>并没有出现在<code>member initialization list</code>之中，但它有一个<code>default constructor</code>，那么该<code>default constructor</code>必须被调用。</li><li>在那之前，如果<code>class object</code>有<code>vptr</code>，它（们）必须被设定初值，指向适当的<code>virtual table(s)</code>。</li><li>在那之前，所有上一层的<code>base class constructors</code>必须被调用，以<code>base class</code>的声明顺序为序：<ul><li>如果<code>basc class</code>被列于<code>member initialization list</code>中，那么任何明确指定的参数都应该传递过去。</li><li>如果<code>base class</code>没有被列于<code>member initialization list</code>中，而它有<code>default constructor</code>(或<code>default memberwise copy constructor</code>)，那么就调用之。</li><li>如果<code>base class</code>是多重继承下的第二或后继的<code>base class</code>，那么<code>this</code>指针必须有所调整。</li></ul></li><li>在那之前，所有<code>virtual base class constructors</code>必须被调用，从左到右，从最深到最浅：<ul><li>如果<code>class</code>被列于<code>member initialization list</code>中，那么如果有任何明确指定的参数，都应该传递过去。若没有列于<code>list</code>之中，而<code>class</code>有一个<code>default constructor</code>，也应该调用之。</li><li>此外，<code>class</code>中的每一个<code>virtual base class subobject</code>的偏移量必须在执行期可被存取。</li><li>如果<code>class object</code>是最底层（<code>most-derived</code>）的<code>class</code>，其<code>constructors</code>可能被调用；某些用以支持这个行为的机制必须被放进来。</li></ul></li></ol><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><strong>书中接下来的章节对上面这些做了详细的叙述。全是重点，就不做总结了，自行看书</strong>。</p><h4 id="第6章：执行期语意学"><a href="#第6章：执行期语意学" class="headerlink" title="第6章：执行期语意学"></a>第<code>6</code>章：执行期语意学</h4><p><strong>很重要，不做总结了，自行看书</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个在windows平台的定时更换壁纸的工具</title>
      <link href="/JFfWe2Uugfh1u70r/"/>
      <url>/JFfWe2Uugfh1u70r/</url>
      
        <content type="html"><![CDATA[<p>有没有感觉到自己的电脑桌面一成不变让人厌倦？虽然有一些诸如360桌面之类的软件可以使用，但弹窗、广告又太多！本文就教你用 <em>python</em> 实现一个简洁清爽的桌面壁纸定时更换工具。</p><a id="more"></a><p>本文使用的方法是用 <em>python</em> 实现一个定时更换壁纸的脚本，壁纸来源与自定义的文件夹内，因此你可以搜集一些你喜欢的壁纸图片放于该文件夹下，这样脚本程序便可以使你的电脑桌面轮流展示这些图片了。</p><p>比如我就把我喜欢的壁纸都收集在了 <em>E:/wallpapers/</em> 文件夹下。</p><p><img src="2020-06-14.png" alt=""></p><p>这里推荐几个好的壁纸来源网站 <a href="https://wallhaven.cc/" target="_blank" rel="noopener">https://wallhaven.cc/</a> ，<a href="https://www.artstation.com/wlop" target="_blank" rel="noopener">https://www.artstation.com/wlop</a> 。</p><p>下面直接看代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImages</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 这里的路径就是你放图片的文件夹路径</span></span><br><span class="line">    images_path = <span class="string">'E:\\wallpapers\\'</span></span><br><span class="line">    files = os.listdir(images_path)</span><br><span class="line">    <span class="keyword">return</span> images_path, files</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_wallpaper</span><span class="params">(it)</span>:</span></span><br><span class="line">    path, images = getImages()</span><br><span class="line">    image = path + images[it]</span><br><span class="line">    it = (it + <span class="number">1</span>) % len(images)</span><br><span class="line">    win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, image, <span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">global</span> timer</span><br><span class="line">    <span class="comment"># 我设置的是每60s更换一次，你可以根据需要自定义设置</span></span><br><span class="line">    timer = threading.Timer(<span class="number">60.0</span>, set_wallpaper, (it,))</span><br><span class="line">    timer.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    set_wallpaper(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>为了方便运行，我们可以使用 <em>pyinstaller</em> 工具将该脚本程序转成 <em>.exe</em> 可执行文件。具体的方法可以看这篇文章 <a href="https://blog.csdn.net/zengxiantao1994/article/details/76578421" target="_blank" rel="noopener">Python程序打包成exe可执行文件</a> 。</p><p>生成可执行文件之后，运行就可以了。不过，为了每次开机程序都可以自动运行，我们需要进行一些设置。首先按 <em>win+R</em> 键打开运行窗口，输入 <em>shell:startup</em> 回车，这样会打开一个启动文件夹，这个文件夹下的软件在开机时都会自动启动，将你的可执行文件或其快捷方式放在这里就可以了。</p><p>这里可以直接下载我已经生成的可执行程序：</p><p><a href="https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q</a><br>提取码：v9ng </p><p>使用方法就是在E盘下新建一个名为wallpapers的文件夹，然后把自己喜欢的照片放进去就好，即<em>E:/wallpapers/</em> 。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桌面壁纸工具 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个简易的Linux平台下的划词翻译工具</title>
      <link href="/KT2Sz9hHwziaJtFt/"/>
      <url>/KT2Sz9hHwziaJtFt/</url>
      
        <content type="html"><![CDATA[<p>这里将要介绍的是一种在 <em>Linux</em> 平台实现的划词翻译工具，当然在考虑自己实现一个如此功能的工具前，本人也是在网上搜索了一些在 <em>Linux</em> 平台实现的类似的开源工具，例如 <a href="https://github.com/axipo/pdfTranslator" target="_blank" rel="noopener">pdfTranslator</a>，<a href="https://github.com/bianjp/popup-dict" target="_blank" rel="noopener">popup-dict</a>，但它们的安装和配置都显得比较麻烦，而且使用起来也并不方便。</p><p>本人实现这个工具的初衷本是方便自己看一些英文文献和书籍的，极为方便，考虑到分享出去可以让更多人受惠，因此这里详细介绍一下它的实现步骤。</p><a id="more"></a><p>本文所实现的划词翻译工具主要有以下特性：</p><ul><li>支持英文单词和短语到中文的翻译</li><li>划词翻译，终端显示</li><li>自动过滤选中文本中的换行等特殊字符</li><li>只依赖少数几个 <em>Linux</em> 命令工具</li></ul><p>下面有动图进行演示。</p><p><img src="iKnVA63lpy.gif" alt=""></p><p>本人所使用的环境是运行在 <em>VMware</em> 虚拟机下的 <em>Linux</em> 发行版 <em>Ubuntu 18.04.3 LTS</em> ，因此这里介绍的步骤可能与其他 <em>Linux</em> 发行版中的实现略有不同。下面就来一步一步的实现它吧。</p><h4 id="一-安装必要的命令"><a href="#一-安装必要的命令" class="headerlink" title="一. 安装必要的命令"></a>一. 安装必要的命令</h4><ol><li><em>xclip</em></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install xclip</span></span><br></pre></td></tr></table></figure><p><em>xclip</em> 命令建立了终端和剪切板之间通道，可以用命令的方式将终端输出或文件的内容保存到剪切板中，也可以将剪切板的内容输出到终端或文件。详细的用法可以使用 <em>man xclip</em>，见其手册。这里介绍几个常用的用法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xclip file_name <span class="comment"># 文件内容保存到X window剪切板</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection c file_name <span class="comment">#文件内容保存到外部剪切板</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -o <span class="comment"># X window剪切板内容输出到终端显示</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection c -o <span class="comment"># 外部剪切板内容输出到终端显示</span></span></span><br></pre></td></tr></table></figure><p>值得强调的是，这里所说的 <em>X window</em> 剪切板，简单的说就是你用鼠标选择的文本会实时的存放在这个剪切板，使用鼠标中键可以粘贴。而外部剪切板是保存你用 <em>ctrl+c</em> 复制的文本，<em>ctrl+v</em> 可以粘贴。这两个地方是不一样的。</p><ol start="2"><li><em>translate-shell</em></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install translate-shell</span></span><br></pre></td></tr></table></figure><p>这是命令行版的谷歌翻译工具，之前叫做 <em>Google Translate CLI</em> 是一款借助谷歌翻译（默认）、必应翻译等来翻译的命令行翻译器。它让你可以在终端访问这些翻译引擎。 <em>translate-shell</em> 在大多数 <em>Linux</em> 发行版中都能使用。常用的方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trans en:zh [word] <span class="comment"># 英文到中文的单词翻译</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> trans en:zh -b [text] <span class="comment"># 简要的输出，进行文本翻译</span></span></span><br></pre></td></tr></table></figure><p>需要注意的是，使用这个翻译工具需要你能够<strong>访问外网</strong>，或者通过修改 <em>translate-shell</em> 的默认翻译引擎，具体的方法这里就不阐述了。</p><h4 id="二-编程实现"><a href="#二-编程实现" class="headerlink" title="二. 编程实现"></a>二. 编程实现</h4><p>这个工具整体的思路就是 <em>C</em> 程序实时检测鼠标按键的动态，当检测到用户使用鼠标选择一段文本之后，调用 <em>shell</em> 脚本获取 <em>X window</em> 剪切板的内容进行翻译后输出到终端显示。</p><p><strong>1. 定位鼠标设备文件</strong></p><p>鼠标作为输入设备。其信息可以在文件 <em>/proc/bus/input/devices</em> 中，使用下列命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /proc/bus/input/devices</span></span><br><span class="line">I: Bus=0011 Vendor=0002 Product=0013 Version=0006</span><br><span class="line">N: Name="VirtualPS/2 VMware VMMouse"</span><br><span class="line">P: Phys=isa0060/serio1/input1</span><br><span class="line">S: Sysfs=/devices/platform/i8042/serio1/input/input4</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mouse0 event2 </span><br><span class="line">B: PROP=0</span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=70000 0 0 0 0</span><br><span class="line">B: ABS=3</span><br></pre></td></tr></table></figure><p>其中的 <em>Handlers</em> 的值 <em>event2</em> 表示可以在 <em>/dev/input/event2</em> 文件下读取鼠标的状态。需要注意的是，对于不同的设备，读取鼠标的状态的文件可能不一样，比如也可能是 <em>/dev/input/event3</em>。我们可以使用下面的命令找到你的鼠标对应的是哪一个 <em>event</em>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /dev/input/event2 | hexdump <span class="comment"># 测试时改变数字即可</span></span></span><br></pre></td></tr></table></figure><p>比如，当我运行上面这条命令之后，我移动鼠标、按鼠标左键/中键/右键，终端都会输出一些值，这就说明 <em>event2</em> 文件就是对应着我的鼠标。如果操作鼠标没有反应，说明这个就不是。你可以通过这种方法找到你的鼠标对应的 <em>event</em> 文件。</p><p><strong>2. Linux 下获取按键响应</strong></p><p>在 <em>Linux</em> 内核中，<em>input</em> 设备用 <em>input_dev</em> 结构体描述，使用 <em>input</em> 子系统实现输入设备驱动的时候，驱动的核心工作就是向系统报告按键、触摸屏、键盘、鼠标等输入事件（<em>event*，通过 *input_event</em> 结构体描述），不再需要关心文件操作接口，因为 <em>input</em> 子系统已经完成了文件操作接口 <em>Linux/input.h</em> 这个文件定义了 <em>event</em> 事件的结构体，<em>API</em> 和标准按键的编码等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义见 input.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">// 按键时间</span></span><br><span class="line">    __u16 type;          <span class="comment">// 事件类型</span></span><br><span class="line">    __u16 code;          <span class="comment">// 要模拟成什么按键</span></span><br><span class="line">    __s32 value;         <span class="comment">// 是按下还是释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面宏定义见 input-event-coses.h</span></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_KEY 0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_REL 0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ABS 0x03</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_LEFT 0x110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_RIGHT 0x111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_MIDDLE 0x112</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSC_SERIAL 0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSC_PULSELED 0x01</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里稍微介绍一下 <em>type</em>，指事件类型，常见的事件类型有：<br><em>EV_KEY</em>，按键事件，如键盘的按键（按下哪个键），鼠标的左键右键（是否击下）等；<br><em>EV_REL</em>，相对坐标，主要是指鼠标的移动事件（相对位移）；<br><em>EV_ABS</em>， 绝对坐标，主要指触摸屏的移动事件 。</p><p><strong>3. 编写 <em>C</em> 程序</strong></p><p>下面就可以编写程序来检测鼠标的动态了。首先在你的用户~目录下建立文件夹 <em>Translator*。在 *Translator</em> 里建立一个 <em>ct.c</em> 源文件，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里打开的文件根据你自己的设备情况作相应的改变</span></span><br><span class="line">    keys_fd = <span class="built_in">open</span>(<span class="string">"/dev/input/event2"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (keys_fd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open /dev/input/event2 error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(keys_fd, &amp;t, <span class="keyword">sizeof</span>(t));</span><br><span class="line">        <span class="keyword">if</span> (t.type == EV_KEY)              <span class="comment">// 有键按下</span></span><br><span class="line">            <span class="keyword">if</span> (t.code == BTN_LEFT)        <span class="comment">// 鼠标左键</span></span><br><span class="line">                <span class="keyword">if</span> (t.value == MSC_SERIAL) <span class="comment">// 松开</span></span><br><span class="line">                    <span class="comment">// 调用外部shell脚本</span></span><br><span class="line">                    system(<span class="string">"~/Translator/goTranslate.sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(keys_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是调用 <em>gcc</em> 编译器生成可执行文件 <em>ct</em>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ct.c -o ct</span></span><br></pre></td></tr></table></figure><p><strong>4. 编写 <em>shell</em> 脚本翻译剪切板内容</strong></p><p>在 <em>Translator</em> 里建立 <em>goTranslate.sh</em> 文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str_old=$(cat ~/Translator/lastContent)</span><br><span class="line">str_new=$(xclip -o 2&gt;/dev/null | xargs)</span><br><span class="line">if [[ "$str_new" != "$str_old" &amp;&amp; $str_new ]]; then</span><br><span class="line">    echo -e "\n"</span><br><span class="line">    count=$(echo "$str_new" | wc -w)</span><br><span class="line">    if [ "$count" == "1" ]; then</span><br><span class="line">        echo -n -e "$str_new " &gt;&gt;~/Translator/words</span><br><span class="line">        echo "$str_new" | trans :zh-CN | tail -1 | cut -c 5- | sed "s,\x1b\[[0-9;]*[a-zA-Z],,g" | tee -a ~/Translator/words</span><br><span class="line">    else</span><br><span class="line">        echo "$str_new" | trans :zh-CN -b</span><br><span class="line">    fi</span><br><span class="line">    echo "$str_new" &gt;~/Translator/lastContent</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>原理非常简单，读者自行了解。这里我们还要在 <em>Translator</em> 里建立一个 <em>lastContent.txt</em> 文件作为缓存，目的是本次调用脚本时能够获取上一次调用时翻译的文本内容，如果和本次调用的翻译文本一样，则本次就不进行翻译。</p><p><em>*5. 设置 *ct</em> 别名 **</p><p>这里已经可以通过下面的命令运行程序了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ~/Translator/ct</span></span><br></pre></td></tr></table></figure><p>但是由于每次运行都要输出这么长的命令，因此我们在 <em>~/.bashrc</em> 文件中加入下面一条命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ct='sudo ~/Translator/ct'</span><br></pre></td></tr></table></figure><p>这样，以后每次看英文文献时就可以在命令行下输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ct</span></span><br></pre></td></tr></table></figure><h4 id="三-结束语"><a href="#三-结束语" class="headerlink" title="三. 结束语"></a>三. 结束语</h4><p>这里有一些小技巧。可以更方便的使用这个工具。比如，把终端设为置顶并缩小到合适的尺寸，这样在阅读文献划词翻译时终端屏幕不会遮挡我们的视线。</p><p>值得说明的是，由于本人完全是为了方便自己的使用，而且在搞出这么个工具时仅仅接触 <em>Linux</em> 系统才不到两周，所以里面的实现对于有经验的朋友来说略显的有些笨拙了，请理解哈。</p><p>个人觉得这个工具使用起来还是很方便的，你觉得呢？</p><p>参考文章：</p><ol><li><a href="https://blog.csdn.net/liang12360640/article/details/50350648" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/50350648</a></li><li><a href="https://www.cnblogs.com/yangwindsor/articles/3454955.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangwindsor/articles/3454955.html</a></li><li><a href="https://blog.csdn.net/liang12360640/article/details/50s350648" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/50s350648</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 划词翻译 </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之function语意学</title>
      <link href="/rRW3gD4CDal4WhRJ/"/>
      <url>/rRW3gD4CDal4WhRJ/</url>
      
        <content type="html"><![CDATA[<h4 id="第4章：Function语意学"><a href="#第4章：Function语意学" class="headerlink" title="第4章：Function语意学"></a>第<code>4</code>章：<code>Function</code>语意学</h4><h5 id="4-1-静态成员函数"><a href="#4-1-静态成员函数" class="headerlink" title="4.1 静态成员函数"></a><code>4.1</code> 静态成员函数</h5><p><code>function</code>的调用方式</p><p><code>nonmember function</code>、<code>static member function</code>、<code>nonstatic member function</code>的调用效率完全一样，因为，在内部都被编译器处理成相同的形式。而<code>virtual member function</code>的调用需要通过<code>vptr</code>所指向的<code>virtual table</code>，因此，效率有所降低。</p><p><code>static member function</code>的主要特性就是它没有<code>this</code>指针。以下的次要特性统统根源于其主要特性：</p><a id="more"></a><ul><li>它不能够直接存取其<code>class</code>中的<code>nonstatic members</code>；</li><li>它不能够被声明为<code>const</code>、<code>volatile</code>或<code>virtual</code>；</li><li>它不需要经由<code>class object</code>才被调用——虽然大部分时候它是这样被调用的。</li></ul><p>若取一个<code>static member function</code>的地址不会得到指向其<code>class member function</code>类型的指针（不是<code>return_type (class_type::*)(parameter_types)</code>）。而是一个<code>non-member</code>函数指针（类型为<code>return_type (*)(parameter_types)</code>）。</p><h5 id="4-2-虚拟成员函数"><a href="#4-2-虚拟成员函数" class="headerlink" title="4.2 虚拟成员函数"></a><code>4.2</code> 虚拟成员函数</h5><p>在<code>C++</code>中，<strong>多态</strong>表示以一个指向<code>public base class</code>类型的<code>pointer</code>或<code>reference</code>，寻址出一个<code>derived class object</code>的意思。多态机能体现在通过<code>pointer</code>或<code>reference</code>对虚函数的调用身上。因此，识别一个<code>class</code>是否支持多态，唯一适当的方法就是看看它是否有任何<code>virtual function</code>。</p><p>为了支持多态，需要在执行期决议出正确的<code>virtual function</code>实例，这需要如下执行期信息的支持：</p><ol><li>它所引用的对象的地址，也就是当前它自身的值；</li><li>所引用对象的真实类型。这可使我们选择正确的虚函数所在的实体；</li><li><code>virtual function</code>实体位置，也就是函数地址，以便我能够调用它。</li></ol><p>在实现上，在每一个多态的<code>class object</code>身上增加两个<code>member</code>：</p><ol><li>一个字符串或数字，表示<code>class</code>的类型；</li><li>一个指针，指向某表格，表格中带有程序的<code>virtual function</code>的执行期地址。</li></ol><p><code>virtual function</code>的地址是固定不变的，执行期不可能新增或替换，而表格的大小和内容在执行期不会改变，因此其建构和存取皆在编译期就可以完成。</p><p>为了找到<code>virtual function</code>的地址，需要：</p><ol><li>为了找到表格，每一个<code>class object</code>被安插上一个由编译器内部产生的指针，指向该表格；</li><li>为了找到函数地址，每一个<code>virtual function</code>被指派一个表格索引值。</li></ol><p>这些工作都由编译器完成。执行期要做的，只是在特定的<code>virtual table slot</code>（记录着<code>virtual function</code>的地址）中调用<code>virtual function</code>。这些<code>virtual function</code>可以是：</p><ol><li>这个<code>class</code>所定义的函数实体。它<code>override</code>了一个<code>base class virtual function</code>函数实体；</li><li>继承自<code>base class</code>的函数实体。这是在<code>derived class</code>中决定不<code>override</code>的<code>virtual function</code>时的情况；</li><li>一个<code>pure_virtual_called()</code>函数实体。它既可以扮演<code>pure virtual function</code>的空间保卫者角色，也可以当做执行期异常处理函数（有时候会用到）。</li></ol><p><strong><em>单一继承</em></strong></p><p>例如，对于如下的<strong>单一继承体系</strong>：</p><p><img src="image-20210312160159297.png" alt="image-20210312160159297"></p><p><code>virtual destriucior</code>被赋值<code>slot 1</code>，而<code>mult()</code>被赋值<code>slot 2</code>。此例并没有<code>mult()</code>的函数定义，因为它是一个<code>pure virtual function</code>，所以<code>pure _virtual_called()</code>的函数地址会被放在<code>slot 2</code>中。如果该函数意外地被调用，通常的操作是结束掉这个程序。<code>y()</code>被赋值<code>slot 3</code>而<code>z()</code>被赋值<code>slot 4</code>。<code>x()</code>没有<code>slot</code>，因为<code>x()</code>并非<code>virtual function</code>。</p><p><img src="image-20210312160324194.png" alt="image-20210312160324194"></p><p><img src="image-20210312160340269.png" alt="image-20210312160340269"></p><p>此时，一共有三种可能性：</p><ol><li>它可以继承<code>base class</code>所声明的<code>virtual function</code>的函数实体。正确地说，是该函数实体的地址会被拷贝到<code>derived class</code>的<code>virtual table</code>相对应的<code>slot</code>之中；</li><li>它可以使用自己的函数实体。这表示它自己的函数实体地址必须放在对应的<code>slot</code>之中；</li><li>它可以加人一个新的<code>virtual function</code>。这时候<code>virtual table</code>的尺寸会增大一个<code>slot</code>，而新的函数实体地址会被放进该<code>slot</code>之中。</li></ol><p><code>Point2d</code>的<code>virtual table</code>在<code>slot 1</code>中指出<code>destructor</code>，而在<code>slot 2</code>中指出<code>mult()</code>取代<code>pure virtual function</code>。它自己的<code>y()</code>函数实体地址放在<code>slot 3</code>，继承自<code>Point</code>的<code>z()</code>函数实体地址则放在<code>slot 4</code>。</p><p>类似的情况：</p><p><img src="image-20210312160431103.png" alt="image-20210312160431103"></p><p><code>Point3d</code>的<code>virtual table</code>中的<code>slot 1</code>放置<code>Point3d</code>的<code>destructor</code>，<code>slot 2</code>放置<code>Point3d::mult()</code>函数地址。<code>slot 3</code>放置继承自<code>Point2d</code>的<code>y()</code>函数地址，<code>slot 4</code>放置自己的<code>z()</code>函数地址。</p><p>这个继承体系中的三个类的<code>virtual table</code>布局如下所示：</p><p><img src="image-20210312161401843.png" alt="image-20210312161401843"></p><p>现在，如果我们有这样的式子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;z();</span><br></pre></td></tr></table></figure><p>那么，我如何有足够的知识在编译时期设定<code>virtual function</code>的调用呢？</p><ol><li>一般而言，我并不知道<code>ptr</code>所指对象的真正类型。然而我知道，经由<code>ptr</code>可以存取到该对象的<code>virtual table</code>；</li><li>虽然我不知道哪一个<code>z()</code>函数实体会被调用，但我知道每一个<code>z()</code>函数地址都被放在<code>slot 4</code>。</li></ol><p>这些信息使得编译器可以将该调用转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">4</span>])(ptr);</span><br></pre></td></tr></table></figure><p>在一个单一继承体系中，<code>virtual function</code>机制的行为十分良好，不但有效率而且很容易塑造出模型。但是在多重继承和虚拟继承之中，就呵呵了。</p><p><strong><em>多重继承</em></strong>和<strong><em>虚拟继承</em></strong></p><p>懒得总结了，看是看懂了，乱七八糟的！</p><h5 id="4-3-指向Member-Function的指针"><a href="#4-3-指向Member-Function的指针" class="headerlink" title="4.3 指向Member Function的指针"></a><code>4.3</code> 指向<code>Member Function</code>的指针</h5><p>取一个<code>nonstatic member function</code>的地址，如果该函数是<code>nonvirtual</code>，则得到的结果是它在内存中真正的地址。然而这个值也是不完全的，它也需要被绑定于某个<code>class object</code>的地址上，才能够通过它调用该函数（以参数<code>this</code>指出）。</p><p>回顾一下，一个指向<code>member function</code>的指针，其声明语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (Point::*pmf)();</span><br></pre></td></tr></table></figure><p>然后我们可以这样定义并初始化该指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (Point::*coord)() = &amp;Point::x;</span><br></pre></td></tr></table></figure><p>也可以这样指定其值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord = &amp;Point::y;</span><br></pre></td></tr></table></figure><p>想调用它，可以这么做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(origin.*coord)();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(ptr-&gt;*coord)();</span><br></pre></td></tr></table></figure><p>这些操作会被编译器转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(coord)(&amp;origin);</span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line">(coord)(ptr);</span><br></pre></td></tr></table></figure><p>获得该函数在内存中的地址。然而面对一个<code>virtual function</code>，其地址在编译时期是未知的，所能知道的仅是<code>virtual function</code>在其相关之<code>virtual table</code>中的索引值，也就是说，对一个<code>virtual member function</code>取其地址，所能获得的只是一个索引值。</p><p>那么问题来了，假设我们有以下的<code>Point</code>声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取<code>z()</code>函数的地址得到的索引值是<code>2</code>，而不是函数地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> (Point::*pmf)() = &amp;Point::z;</span><br><span class="line">Point *ptr = <span class="keyword">new</span> Point3d;</span><br></pre></td></tr></table></figure><p>那么如果通过<code>pmf</code>来间接调用<code>z()</code>函数的话：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(ptr-&gt;*pmf)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为</span></span><br><span class="line"></span><br><span class="line">(*ptr-&gt;vptr[(<span class="keyword">int</span>)pmf]<span class="number">5</span>(ptr);</span><br></pre></td></tr></table></figure><p>那么如何知道<code>pmf</code>指向的是<code>virtual function</code>还是<code>nonvirtual function</code>，毕竟<code>pmf</code>如果对<code>nonvirtual function</code>取地址的话得到的是在内存中的地址。也就是说，<code>pmf</code>的内部定义需要允许该函数能够寻址出<code>nonvirtual</code>和<code>virtual</code>两个<code>member function</code>。</p><p>同时为了让执行<code>member function</code>的指针也能支持多重继承和虚拟继承，实现方法为使用一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用以支持在多重继承之下指向 member function 的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">mptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// virtual 函数 在 virtual table 的索引, 当 index 不指向 virtual table 时值为 -1</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptrtofunc faddr; <span class="comment">// nonvirtual 函数的地址</span></span><br><span class="line">        <span class="keyword">int</span> voffset;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这样的模型下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(ptr-&gt;*pmf)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为</span></span><br><span class="line"></span><br><span class="line">(pmf.inidex &lt; <span class="number">0</span>) ? (*pmf.faddr)(ptr) : (*ptr-&gt;vptr[pmf.index](ptr));</span><br></pre></td></tr></table></figure><h5 id="4-4-inline函数"><a href="#4-4-inline函数" class="headerlink" title="4.4 inline函数"></a><code>4.4</code> <code>inline</code>函数</h5>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之data语意学</title>
      <link href="/ShyaVw4WHERlLCqZ/"/>
      <url>/ShyaVw4WHERlLCqZ/</url>
      
        <content type="html"><![CDATA[<h4 id="第3章：Data语意学"><a href="#第3章：Data语意学" class="headerlink" title="第3章：Data语意学"></a>第<code>3</code>章：<code>Data</code>语意学</h4><p><code>The size of class</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// char c; // 此时, sizeof(X) == 1, sizeof(Y) == 8, sizeof(Z) == 8, sizeof(A) == 16</span></span><br><span class="line">    <span class="keyword">char</span> c; <span class="comment">// 此时, sizeof(X) == 1, sizeof(Y) == 16, sizeof(Z) == 16, sizeof(A) == 24</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123; &#125;;</span><br></pre></td></tr></table></figure><p>一个类的大小主要受三个因素的影响：</p><ol><li><p>语言支持的特性所造成的负担</p><p> 比如，含虚函数的类会额外多一个<code>vptr</code>指针，含<code>virtual base class</code>会再多一个额外的指针（它或者指向<code>virtual base class subobject</code>，或者指向一个相关表格；表格中存放的若不是<code>virtual base class subobject</code>地址，就是其偏移量）。</p></li><li><p>编译器对于特殊情况所提供的优化处理</p><p> 现代编译器的对于空基类的优化处理：一个<code>empty virtual base class</code>被视为<code>derived class object</code>最开头的一部分，也就是说它并没有花费任何的额外空间。因为既然有了<code>members</code>，就不需要原本为了<code>empty class</code>而安插的一个<code>char</code>。</p></li><li><p><code>alignment</code>（内存对齐）</p><p> 就是将数值调整到某数的整数倍。在<code>64</code>位计算机上，通常<code>alignment</code>为<code>8 bytes</code>，以使<code>bus</code>的“运输量”达到最高效率。</p></li></ol><a id="more"></a><p><code>nonstatic data members</code>放置的是“个别的<code>class object</code>”感兴趣的数据，<code>static data members</code>则放置的是“整个<code>class</code>”感兴趣的数据。</p><p><code>static data members</code>被放置在程序的一个<code>global data segment</code>中，不会影响个别的<code>class object</code>的大小。在程序之中，不管该<code>class</code>被产生出多少个<code>objects</code>（经由直接产生或间接派生），<code>static data member</code>永远只存在一份实体（即使该<code>class</code>没有任何<code>object</code>实体，其<code>static data members</code>也已存在）。</p><h5 id="3-1-data-member的绑定"><a href="#3-1-data-member的绑定" class="headerlink" title="3.1 data member的绑定"></a><code>3.1</code> <code>data member</code>的绑定</h5><p>类成员函数的<code>argument list</code>中的名称会在它们第一次遭遇时被适当地决议（<code>resolved</code>）完成。因此在<code>extern</code>和<code>nested type name</code>之间的非直觉绑定操作还是会发生。例如在下面的程序片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数列表中的 length 被决议成 std::string!!!</span></span><br><span class="line">    <span class="comment">// 里面的 val_ 被正确决议成 int</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(length val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val_ = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line">    length val_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以这需要使用防御性的程序风格：将<code>nested type name</code>写在class的起始处！</p><h5 id="3-2-数据成员的布局"><a href="#3-2-数据成员的布局" class="headerlink" title="3.2 数据成员的布局"></a><code>3.2</code> 数据成员的布局</h5><p>下面这个<code>template function</code>，接受两个<code>data member</code>，然后判断谁先出现在<code>class object</code>之中。如果两个<code>member</code>都是不同的<code>access sections</code>中的第一个被声明者，此函数就可以用来判断哪一个<code>section</code>先出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">class_type</span>, <span class="title">class</span> <span class="title">data_typel</span>, <span class="title">class</span> <span class="title">data_type2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="function"><span class="built_in">string</span> <span class="title">access_order</span><span class="params">(data_type1 class_type::* mem1, data_type2 class_type::* mem2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(mem1 != mem2);</span><br><span class="line">    <span class="keyword">return</span> mem1 &lt; mem2 ? <span class="string">"member 1 occurs first"</span> : <span class="string">"member 2 occurs first"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数可以这样被调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_order(&amp;Point3d::y, &amp;Point3d::z);</span><br></pre></td></tr></table></figure><h5 id="3-3-data-member的存取"><a href="#3-3-data-member的存取" class="headerlink" title="3.3 data member的存取"></a><code>3.3</code> <code>data member</code>的存取</h5><p><code>static data member</code></p><p>对于类中的静态数据成员，通过一个指针和通过一个对象来存取，效率完全相同，不论这个静态数据成员经过了多么复杂的继承体系。</p><p>若取一个<code>static data member</code>的地址不会得到指向其<code>class member</code>的指针（不是<code>value_type class_type::*</code>类型）。而是指向其数据类型的指针（类型为<code>value_type*</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Point::x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = &amp;Point::func1; <span class="comment">// p 的类型是 void (Point::*p)()</span></span><br><span class="line">    <span class="keyword">auto</span> q = &amp;Point::func2; <span class="comment">// q 的类型是 void (*q)(int a)</span></span><br><span class="line">    <span class="keyword">auto</span> p = &amp;Point::x;<span class="comment">// r 的类型是 int* r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数不能是静态成员函数：如果构造函数是静态成员函数，那么将不能访问非静态变量，也没办法完成初始化的工作。</p><p><code>non static data member</code></p><p>对于类中的非静态数据成员，通过一个指针和通过一个对象来存取，当此数据成员属于继承而来的<code>virtual base class</code>时，使用指针效率较低。如果使用对象直接存取，就不会有这些问题，其类型无疑是确定的，而即使它继承自<code>virtual base class</code>，<code>members</code>的<code>offset</code>位置也在编译时期就固定了。</p><p>欲对一个<code>nonstatic data member</code>进行存取操作，编译器需要把<code>class object</code>的起始地址加上<code>data member</code>的偏移量。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;origin._y == &amp;origin + (&amp;Point3d::_y - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>请注意其中的<code>-1</code>操作。指向<code>data member</code>的指针，其<code>offset</code>值总是被加上<code>1</code>，这样可以使编译系统区分出是用以指出<code>class</code>的第一个<code>member</code>还是没有指出任何<code>member</code>的两种情况。</p><h5 id="3-4-C-对象布局"><a href="#3-4-C-对象布局" class="headerlink" title="3.4 C++对象布局"></a><code>3.4</code> <code>C++</code>对象布局</h5><ol><li><p>个别<code>struct</code>的数据布局</p><p> <img src="image-20210310151329468.png" alt="image-20210310151329468"></p></li><li><p>单一继承而且没有<code>virtual function</code>时的数据布局</p><p> <img src="image-20210310151502431.png" alt="image-20210310151502431"></p></li><li><p><code>C++</code>语言保证——出现在<code>derived class</code>中的<code>base class subobject</code>有其完整原样性</p><p> <img src="image-20210310151740707.png" alt="image-20210310151740707"></p><p> <img src="image-20210310151814511.png" alt="image-20210310151814511"></p></li><li><p>单一继承并含虚拟函数情况下的数据布局</p><p> <img src="image-20210310151910413.png" alt="image-20210310151910413"></p></li><li><p>多重继承</p><p> <img src="image-20210310152020878.png" alt="image-20210310152020878"></p><p> <img src="image-20210310152043648.png" alt="image-20210310152043648"></p></li><li><p>虚拟继承，使用<code>pointer strategy</code>和<code>virtual table offset strategy</code></p><p> <img src="image-20210310152208905.png" alt="image-20210310152208905"></p><p> <img src="image-20210310152330536.png" alt="image-20210310152330536"></p><p> <img src="image-20210310152521106.png" alt="image-20210310152521106"></p></li></ol><h5 id="3-5-指向data-member成员的指针"><a href="#3-5-指向data-member成员的指针" class="headerlink" title="3.5 指向data member成员的指针"></a><code>3.5</code> 指向<code>data member</code>成员的指针</h5><p>取一个<code>nonstatic data member</code>的地址，将会得到它在<code>class</code>中的<code>offset</code>（指针类型为<code>data_type class_type::*</code>），取一个“绑定于真正<code>class object</code>身上的<code>data member</code>”的地址，将会得到该<code>member</code>在内存中的真正地址（指针类型为<code>data_type*</code>）。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之构造函数语意学</title>
      <link href="/FXn6nXyz1FEw9e8Y/"/>
      <url>/FXn6nXyz1FEw9e8Y/</url>
      
        <content type="html"><![CDATA[<h4 id="第2章：构造函数语意学"><a href="#第2章：构造函数语意学" class="headerlink" title="第2章：构造函数语意学"></a>第<code>2</code>章：构造函数语意学</h4><p>在这一章中，主要介绍编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”的冲击。</p><h5 id="2-1-Default-Constructor的构造操作"><a href="#2-1-Default-Constructor的构造操作" class="headerlink" title="2.1 Default Constructor的构造操作"></a><code>2.1</code> <code>Default Constructor</code>的构造操作</h5><p>对于未声明构造函数的类，只有在以下四种情况下编译器才会为它们合成默认构造函数：</p><ul><li>类有一个类对象（<code>Member Class Object</code>）成员，且该成员含有默认构造函数（<code>Default Constructor</code>）</li><li>继承自带有默认构造函数（<code>Default Constructor</code>）的基类（<code>Base class</code>）</li><li>带有虚函数（<code>Virtual function</code>）的类</li><li>继承自虚基类（<code>Virtual base class</code>）的类</li></ul><a id="more"></a><p>对于以上四种情况，<code>C++</code>标准把合成的默认构造函数叫隐式的有意义默认构造函数(<code>implicit nontrivial default constructors</code>)。被合成的构造函数只能满足编译器（而非程序）的需要，它之所以能够完成任务，是借着调用成员对象或基类的默认构造函数（情况<code>1/2</code>），或是为每一个对象初始化其虚函数机制或虚基类机制（情况<code>3/4</code>）。</p><p>至于没有存在上述四种情况，而又没有声明任何构造函数的类，那么它们拥有的是隐式无意义默认构造函数(<code>implicit trivial default constructors</code>)，实际上它们并不会被合成出来。</p><p><code>Default Constructor</code>会在<strong>编译器需要</strong>的时候被产生出来，被合成出来的<code>Constructor</code>只执行编译器所需要的行为。如果程序有需要，定制<code>Default Constructor</code>的行为是程序员的责任。</p><ol><li><p>“带有<code>Default Constructor</code>”的<code>Member Class Object</code></p><p> 如果有多个<code>class member objects</code>都要求<code>constructor</code>初始化操作，将如何呢？<code>C++</code>语言要求以“<code>member objects</code>在<code>class</code>中的声明次序”来调用各个<code>constructors</code>。这一点由编译器完成，它为每一个<code>constructor</code>安插程序代码，以“<code>member</code>声明次序”调用每一个<code>member</code>所关联的<code>default constructors</code>。这些码将被安插在<code>explicit user code</code>之前。举个例子：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dopey</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dopey();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneezy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sneezy(<span class="keyword">int</span>);</span><br><span class="line">    Sneezy();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bashful</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bashful();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snow_White</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Dopey dopey;</span><br><span class="line">    Sneezy sneezy;</span><br><span class="line">    Bashful bashful;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 如果<code>Snow_White</code>没有定义<code>default constructor</code>，就会有一个<code>nontrivial constructor</code>被合成出来，依序调用<code>Dopey</code>、<code>Sneezy</code>、<code>Bashful</code>的<code>default constructors</code>。然而如果<code>Snow_White</code>定义了下面这样的<code>default constructor</code>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序员所写的 default constructor</span></span><br><span class="line">Snow_White::Snow_White() : sneezy(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 它会被扩张为：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器扩张后的 C++ 伪码</span></span><br><span class="line">Snow_White::Snow_White()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用其 constructor</span></span><br><span class="line">    dopey.Dopey::Dopey();</span><br><span class="line">    Sneezy.Sneezy::Sneezy(<span class="number">1024</span>);</span><br><span class="line">    bashful.Bashful::Bashful();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// explicit user code</span></span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>“带有<code>Default Constructor</code>”的<code>Base Class</code></p><p> 类似的道理，如果一个没有任何<code>constructors</code>的<code>class</code>派生自一个“带有<code>default constructor</code>”的<code>base class</code>，那么这个<code>derived class</code>的<code>default constructor</code>会被视为<code>nontrivial</code>，并因此需要被合成出来。它将调用上一层<code>base classes</code>的<code>default constructor</code>（根据它们的声明次序）。对一个后继派生的<code>class</code>而言，这个合成的<code>constructor</code>和一个“被明确提供的<code>default constructor</code>”没有什么差异。</p><p> 如果设计者提供多个<code>constructors</code>，但其中都没有<code>default constructor</code>呢？编译器会扩张现有的每一个<code>constructors</code>，将“用以调用所有必要之<code>default constructors</code>”的程序代码加进去。它不会合成一个新的<code>default constructor</code>，这是因为其它“由<code>user</code>所提供的<code>constructors</code>”存在的缘故。如果同时亦存在着“带有<code>default constructors</code>”的<code>member class objects</code>，那些<code>default constructor</code>也会被调用。</p></li><li><p>“带有（声明或继承）一个<code>Virtual Function</code>”的<code>Class</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">const</span> Widget&amp; widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    widget.flip();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 Bell 和 Whistle 都派生自 Widget</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line">    </span><br><span class="line">    flip(b);</span><br><span class="line">    flip(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 下面两个扩张操作会在编译期间发生：</p><ol><li><p>一个<code>virtual function table</code>会被编译器产生出来，内放<code>class</code>的<code>virtual functions</code>地址。</p></li><li><p>在每一个<code>class object</code>中，一个额外的<code>pointer member</code>会被编译器合成出来，内含相关的<code>class vtbl</code>的地址。</p><p>此外，<code>widget.flip()</code>的虚拟引发操作会被重新改写，以使用<code>widget</code>的<code>vptr</code>和<code>vtbl</code>中的<code>flip()</code>条目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 表示 flip() 在 virtual table 的固定索引</span></span><br><span class="line"><span class="comment">// &amp;widget 代表要交给"被调用的某个 flip() 实体"的 this 指针</span></span><br><span class="line">(*widget.vptr[<span class="number">1</span>])(&amp;widget));</span><br></pre></td></tr></table></figure><p>为了让这个机制发挥功效，编译器必须为每一个<code>Widget</code>（或其派生类之）<code>object</code>的<code>vptr</code>设定初值，放置适当的<code>virtual table</code>地址。对于<code>class</code>所定义的每一个<code>constructor</code>，编译器会安插一些码来做这样的事情。对于那些未声明任何<code>constructors</code>的<code>classes</code>，编译器会为它们合成一个<code>default constructor</code>，以便正确地初始化每一个<code>class object</code>的<code>vptr</code>。</p></li></ol></li><li><p>“带有一个<code>Virtual Base Class</code>”的<code>Class</code></p><p> 编译器必须使<code>virtual base class</code>在其每一个<code>derived class object</code>中的位置，能够在执行期准备妥当。一种可能的做法是在<code>derived class</code>中安插一个指向每一个<code>virtual base class</code>的指针，所有“经由<code>reference</code>和<code>pointer</code>来存取其中<code>virtual base class</code>中数据的操作”都通过此指针完成。</p><p> 同样地，这个<code>virtual base class</code>指针是在<code>class object</code>构建期间完成的，编译器的默认行为和<code>3</code>中的<code>vptr</code>的处理方式一样。</p></li></ol><h5 id="2-2-Copy-Constructor的构造操作"><a href="#2-2-Copy-Constructor的构造操作" class="headerlink" title="2.2 Copy Constructor的构造操作"></a><code>2.2</code> <code>Copy Constructor</code>的构造操作</h5><p>有三种情况会调用<code>copy constructor</code>：</p><ul><li><p>对一个<code>class object</code>做明确的初始化操作</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>...&#125;;</span><br><span class="line">X x;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">xx</span><span class="params">(x)</span></span>;</span><br><span class="line">X xx = x;</span><br></pre></td></tr></table></figure></li><li><p>当<code>class object</code>被当作参数交给某个函数时</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    foo(xx);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当函数返回一个<code>class object</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p><code>Default Memberwise Initialization</code></p><p> 如果<code>class</code>没有提供一个<code>explicit copy constructor</code>又当如何？当<code>class object</code>以“相同<code>class</code>的另一个<code>object</code>”作为初值时，其内部是以所谓的<code>default memberwise initialization</code>完成的，也就是把每一个内建的或派生的<code>data member</code>的值，从某个<code>object</code>拷贝一份到另一个<code>object</code>身上。不过它并不会拷贝其中的<code>member class object</code>，而是以递归的方式施行<code>memberwise initialization</code>。</p><p> 一个良好的编译器可以为大部分<code>class objects</code>产生<code>bitwise copies</code>，因为它们有<code>bitwise copy semantics</code>。<code>copy constructors</code>在<strong>必要的时候</strong>才由编译器产生出来。这个句子中的“必要”意指当<code>class</code>不展现<code>bitwise copy semantics</code>时。</p></li><li><p><code>Bitwise Copy Semantics</code></p><p> <code>C++ Standard</code>把<code>copy constructor</code>区分为<code>trivial</code>和<code>nontrivial</code>两种。只有<code>nontrivial</code>的实体才会被合成于程序之中。决定一个<code>copy constructor</code>是否为<code>trivial</code>的标准在于<code>class</code>是否展现出所谓的“<code>bitwise copy semantics</code>”。</p><p> 什么时候一个class不展现出<code>Bitwise Copy Semantics</code>呢？</p><ul><li><p>当<code>class</code>内含一个<code>member object</code>而后者的<code>class</code>声明有一个<code>copy constructor</code>时（不论是被<code>class</code>设计者明确地声明；或是被编译器合成）。</p></li><li><p>当<code>class</code>继承自一个<code>base class</code>而后者存在有一个<code>copy constructor</code>（再次强调，不论是被明确声明或是被合成而得）。</p></li><li><p>当<code>class</code>声明了一个或多个<code>virtual functions</code>时。</p></li><li><p>当<code>class</code>派生自一个继承串链，其中有一个或多个<code>virtual base classes</code>时。</p><p>有一点很值得注意：在被合成出来的<code>copy constructor</code>中，如整数、指针、数组等等的<code>nonclass members</code>也都会被复制。</p></li></ul></li><li><p>重新设定<code>virtual table</code>的指针<code>vptr</code></p><p> 当编译器导入一个<code>vptr</code>到<code>class</code>之中时，该<code>class</code>就不再展现<code>bitwise semantics</code>了。编译器需要合成出一个<code>copy constructor</code>，以求将<code>vptr</code>适当地初始化。</p><p> <code>base class object</code>以另一个<code>base class object</code>作为初值，或<code>derived class object</code>以另一个<code>derived  class object</code>作为初值，都可以直接靠“<code>bitwise copy semantics</code>”完成。当一个<code>base class object</code>以其<code>derived class</code>的<code>object</code>内容做初始化操作时，其<code>vptr</code>复制操作必须保证安全。此时，合成出来的<code>base copy constructor</code>会明确设定<code>object</code>的<code>vptr</code>指向<code>base class</code>的<code>virtual table</code>，而不是直接从右手边的<code>class object</code>中将其<code>vptr</code>现值拷贝过来。</p></li><li><p>处理<code>virtual base class subject</code></p><p> 和<code>3</code>同理，需要合成<code>copy constructor</code>来明确的设定<code>virtual base class pointer</code>的初值。</p></li></ol><h5 id="2-3-程序转化语意学"><a href="#2-3-程序转化语意学" class="headerlink" title="2.3 程序转化语意学"></a><code>2.3</code> 程序转化语意学</h5><p>已知有这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X x0;</span><br></pre></td></tr></table></figure><p>下面有三个定义，每一个都明显地以<code>x0</code>来初始化其<code>class object</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">xl</span><span class="params">(x0)</span></span>;</span><br><span class="line">    X x2 = x0;</span><br><span class="line">    X x3 = X(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必要的程序转化有两个阶段：</p><ol><li>重写每一个定义，其中的初始化操作会被剥除。</li><li><code>class</code>的<code>copy constructor</code>调用操作会被安插进去。</li></ol><p>举个例子，在明确的双阶段转化之后，<code>foo_bar()</code>可能看起来像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能的程序转换</span></span><br><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意没有初始化操作</span></span><br><span class="line">    X x1;</span><br><span class="line">    X x2;</span><br><span class="line">    X x3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译器安插X copy construction的调用操作</span></span><br><span class="line">    x1.X::X(x0);</span><br><span class="line">    x2.X::X(x0);</span><br><span class="line">    x3.X::X(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>参数的初始化</p><p>  把一个<code>class object</code>当做参数传给一个函数，相当于以下形式的初始化操作：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx 代表形式参数, arg 代表真正的参数值</span></span><br><span class="line">X xx = arg;</span><br></pre></td></tr></table></figure></li><li><p>返回值的初始化</p><p>  已知下面这个函数定义：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 处理 xx ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里有一个双阶段转化：</p><ol><li><p>首先加上一个额外参数，类型是<code>class object</code>的一个<code>reference</code>。这个参数将用来放置被“拷贝建构（<code>copy constructed</code>）”而得的返回值。</p></li><li><p>在<code>return</code>指令之前安插一个<code>copy constructor</code>调用操作，以便将欲传回之<code>object</code>的内容当做上述新增参数的初值。</p><p>根据这样的算法，<code>bar()</code>转换如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 编译器所产生的 default constructor 调用操作</span></span><br><span class="line">    xx.X::X();</span><br><span class="line">    <span class="comment">// ... 处理 xx</span></span><br><span class="line">    <span class="comment">// 编译器所产生的 copy constructor</span></span><br><span class="line">    result.X::X(xx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在编译器必须转换每一个<code>bar()</code>调用操作，以反映其新定义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X xx = bar();</span><br></pre></td></tr></table></figure><p>将被转换为下列两个指令句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意, 不必施行 default constructor</span></span><br><span class="line">X xx;</span><br><span class="line">bar(xx);</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>NRV</code>优化</p><p>  已知下面这个函数定义：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 处理 xx ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  编译器会把它优化为：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  default constructor 调用操作</span></span><br><span class="line">    _result.X::X();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 直接处理 _result</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>只有当程序提供了<code>explicit copy constructor</code>，编译器才会实施<code>NRV</code>优化。没有提供的话（编译器自己合成的），是不会实施<code>NRV</code>优化的。</strong></p></li><li><p><code>copy constructor</code>要还是不要？</p><p>  对于下面的<code>3D</code>坐标点类，这个<code>class</code>的设计者应该提供一个<code>explicit copy constructor</code>吗？</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  除非你预见该<code>class</code>需要大量的<code>memberwise</code>初始化操作，例如函数以传值（<code>by value</code>）的方式传回<code>objects</code>，那么提供一个<code>copy constructor</code>的<code>explicit inline</code>函数实体就非常合理——可以激活编译器提供的<code>NRV</code>优化。否则，不提供<code>explicit copy constructor</code>既快速又安全。</p></li></ul><h5 id="2-4-Member-initialization-list"><a href="#2-4-Member-initialization-list" class="headerlink" title="2.4 Member initialization list"></a><code>2.4</code> <code>Member initialization list</code></h5><p>为了让你的程序能够被顺利编译，必须使用<code>member initialization list</code>的情况：</p><ol><li>当初始化一个<code>refercnce member</code>时；</li><li>当初始化一个<code>const member</code>时；</li><li>当调用一个<code>base class</code>的<code>constructor</code>，而它拥有一组参数时；</li><li>当调用一个<code>member class</code>的<code>constructor</code>，而它拥有一组参数时。</li></ol><p>在这四种情况之外，不使用<code>member initialization list</code>，程序可以被正确编译并执行，但是效率不彰。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Word()</span><br><span class="line">    &#123;</span><br><span class="line">        _name = <span class="number">0</span>;</span><br><span class="line">        _cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String _name;</span><br><span class="line">    <span class="keyword">int</span> _cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是编译器对<code>constructor</code>可能的内部扩张结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line">Word::Word(<span class="comment">/* this pointer goes here */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 String default constructor</span></span><br><span class="line">    _name.String::String();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产生临时性对象</span></span><br><span class="line">    String temp = String(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// memberwise 地拷贝 _name</span></span><br><span class="line">    _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 摧毁暂时性对象</span></span><br><span class="line">    temp.String::~String();</span><br><span class="line">    </span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更有效率的实现方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 较佳的方式</span></span><br><span class="line">Word::Word : _name(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会被扩张成这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line">Word::Word(<span class="comment">/* this pointer goes here */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 String(int) constructor</span></span><br><span class="line">    _name.String::String(<span class="number">0</span>);</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会一一操作<code>initialization list</code>，以<code>member</code><strong>声明次序</strong>（不是由<code>initialization list</code>中的排列次序决定的）在<code>constructor</code>之内的<strong><code>explicit user code</code>之前</strong>安插初始化操作。</p><p>调用一个<code>member function</code>以设定一个<code>member</code>的初值是可以的，因为此时<code>this</code>指针已经被构造妥当。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// X::xfoo() 被调用</span></span><br><span class="line">X::X(<span class="keyword">int</span> val) : i(xfoo(val)), j(val)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会被扩张为</span></span><br><span class="line">X::X(<span class="comment">/* this pointer */</span>, <span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="keyword">this</span>-&gt;xfoo(val);</span><br><span class="line">    i = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果一个<code>derived class member function</code>被调用，其返回值被当做<code>base class constructor</code>的一个参数，这不是一个好主意！！！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之前言</title>
      <link href="/jOQUhpad0yAY7aMb/"/>
      <url>/jOQUhpad0yAY7aMb/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>Simplifier</code>是编译器的一部分，处于<code>type checking</code>和<code>code generation</code>之间。它用来转换内部的程序表现。有<code>3</code>种转换是任何对象模型都需要的：</p><ol><li><p>与编译器息息相关的转换（<code>Implementation-dependent transformations</code>）</p><p> 例如，当<code>parser</code>看到这个表达式：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fct();</span><br></pre></td></tr></table></figure><p> 它并不知道是否（<code>a</code>）这是一个函数调用操作，或者（<code>b</code>）这是<code>overloaded calloperator</code>在<code>class object fct</code>上的一种应用。默认情况下，这个式子所代表的是一个函数调用，但是当（<code>b</code>）的情况出现，<code>Simplifier</code>就要重写并调换<code>call subtree</code>。</p></li><li><p>语言语意转换（<code>Language semantics transformations</code>）</p><p> 这包括<code>constructor</code>/<code>destructor</code>的合成和扩展、<code>memberwise</code>初始化、对于<code>memberwise copy</code>的支持、在程序代码中安插<code>conversion operators</code>、临时性对象，以及对<code>constructor</code>/<code>destructor</code>的调用。</p></li><li><p>程序代码和对象模型的转换（<code>Code and object model transformations</code>）</p><p> 这包括对<code>virtual functions</code>、<code>virtual base class</code>和<code>inheritance</code>的一般支持、<code>new</code>和<code>delete</code>运算符、<code>class objects</code>所组成的数组、<code>local static class instances</code>、带有非常量表达式（<code>nonconstant cxpression</code>）之<code>global object</code>的静态初始化操作。</p></li></ol><p>什么是<code>C++</code>对象模型？</p><ul><li>语言中直接支持面向对象程序设计的部分</li><li>对于各种支持的底层实现机制</li></ul><a id="more"></a><h4 id="第1章：关于对象"><a href="#第1章：关于对象" class="headerlink" title="第1章：关于对象"></a>第<code>1</code>章：关于对象</h4><p>在<code>C</code>语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。</p><p><code>C++</code>在布局以及存取时间上主要的额外负担是由<code>virtual</code>引起，包括：</p><ol><li><code>virtual function</code>机制——用以支持一个有效率的“执行期绑定”</li><li><code>virtual base class</code>——用以实现“多次出现在继承体系中的<code>base class</code>，有一个单一而被共享的实体”</li><li>此外，还有一些多重继承下的额外负担，发生在“一个<code>derived class</code>和其第二或后继之<code>base class</code>的转换”之间。</li></ol><h5 id="1-1-C-对象模型"><a href="#1-1-C-对象模型" class="headerlink" title="1.1 C++对象模型"></a><code>1.1</code> <code>C++</code>对象模型</h5><p>在<code>C++</code>中，有两种<code>class data members</code>：<code>static</code>和<code>nonstatic</code>，以及三种<code>class member functions</code>：<code>static</code>、<code>nonstatic</code>和<code>virtual</code>。</p><p>在<code>C++</code>对象模型中，<code>nonstatic data members</code>被配置于每一个<code>class object</code>之内，<code>static data members</code>则被存放在所有的<code>class object</code>之外。<code>static</code>和<code>nonstatic function members</code>也被放在所有的<code>class object</code>之外。<code>virtual functions</code>则以两个步骤支持之：</p><ol><li>每一个<code>class</code>产生出一堆指向<code>virtual functions</code>的指针，放在表格之中。这个表格被称为 <code>vtbl</code>。</li><li>每一个<code>class object</code>被添加了一个指针，指向相关的<code>virtual table</code>。通常这个指针被称为<code>vptr</code>。<code>vptr</code>的设定（<code>setting</code>）和重置（<code>resetting</code>）由每一个<code>class</code>的<code>constructor</code>、<code>destructor</code>和<code>copy assignment</code>运算符自动完成。</li></ol><p>在虚拟继承的情况下，<code>base class</code>不管在继承串链中被派生（<code>derived</code>）多少次，永远只会存在一个实体（称为<code>subobject</code>）。</p><p><code>C++</code>最初采用的继承模型并不运用任何间接性: <code>base class subobject</code>的<code>data members</code>被直接放置于<code>derived class object</code>中。这提供了对<code>base class members</code>最紧凑而且最有效率的存取。缺点就是: <code>base class members</code>的任何改变，包括增加﹑移除或改变类型等等，都使得所有用到“此<code>base class</code>或其<code>derived class</code>之<code>objects</code>”者重新编译。</p><p><code>virtual base class</code>的原始模型是在<code>class object</code>中为每一个有关联的<code>virtual base class</code>加上一个指针。</p><p>对象模型如何影响程序？</p><p>不同的对象模型，会导致“现有的程序代码必须修改”以及“必须加人新的程序代码”两个结果。例如下面这个函数，其中<code>class X</code>定义了一个<code>copy constructor</code>，一个<code>virtual destructor</code>，和一个<code>virtual function foo</code>：</p><img src="image-20210219212057818.png" alt="image-20210219212057818" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foobar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    X* px = <span class="keyword">new</span> X;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// foo 是一个虚函数</span></span><br><span class="line">    xx.foo();</span><br><span class="line">    px-&gt;foo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> px;</span><br><span class="line">    <span class="keyword">return</span> xx; <span class="comment">// 这里会用到 copy constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有可能在内部被转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(X&amp; _result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造 _result</span></span><br><span class="line">    <span class="comment">// _result 用来取代 local xx...</span></span><br><span class="line">    _result.X::X();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 ×* px= new x;</span></span><br><span class="line">    px = _new(<span class="keyword">sizeof</span>(X));</span><br><span class="line">    <span class="keyword">if</span>(px != <span class="number">0</span>)</span><br><span class="line">        px-&gt;X::X();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 xx.foo() 但不使用 virtual 机制</span></span><br><span class="line">    <span class="comment">// 以 _result 取代 xx</span></span><br><span class="line">    foo(&amp;_result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 virtual 机制扩展 px-&gt;foo()</span></span><br><span class="line">    (*px-&gt;vtbl[<span class="number">2</span>])(px);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 delete px;</span></span><br><span class="line">    <span class="keyword">if</span>(px != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (*px-&gt;vtbl[<span class="number">1</span>])(px); <span class="comment">// destructor</span></span><br><span class="line">        _delete(px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需使用 named return statement</span></span><br><span class="line">    <span class="comment">//不需要摧毁 local object xx</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-关键词所带来的差异"><a href="#1-2-关键词所带来的差异" class="headerlink" title="1.2 关键词所带来的差异"></a><code>1.2</code> 关键词所带来的差异</h5><ul><li>掌握<code>struct</code>和<code>class</code>关键字的差异</li></ul><p><code>struct</code>关键词的使用实现了<code>C</code>的数据萃取概念，而<code>class</code>关键词实现的是<code>C++</code>的<code>ADT</code>（<code>Abstract Data Type</code>）概念。</p><p><code>C</code>程序员的巧计（<code>C++</code>中不可用）。例如把单一元素的数组放在一个<code>struct</code>的尾端，于是每个<code>struct objects</code>可以拥有可变大小的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// stuff</span></span><br><span class="line">    <span class="keyword">char</span> pc[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从档案或标准输入装置中取得一个字符串 str</span></span><br><span class="line"><span class="comment">// 然后为 struct 本身和该字符串配置足够的内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span> *<span class="title">pmumble</span> = (<span class="title">struct</span> <span class="title">mumble</span>*)</span></span><br><span class="line"><span class="class">                         <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">mumble</span>) + <span class="title">strlen</span>(<span class="title">str</span>) + 1);</span></span><br><span class="line"><span class="built_in">strcpy</span>(&amp;(pmumble-&gt;pc), str);</span><br></pre></td></tr></table></figure><p><code>C++</code>中凡处于同一个<code>access section</code>的数据，必定保证以其声明次序出现在内存布局当中。然而被放置在多个<code>access sections</code>中的各笔数据，排列次序就不一定了。组合（<code>composition</code>)，而非继承，才是把<code>C</code>和<code>C++</code>结合在一起的唯一可行方法（<code>conversion</code>运算符提供了一个十分便利的萃取方法）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C_point</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">C_point</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c_point_; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    C_point c_point_;</span><br></pre></td></tr></table></figure><p><code>C struct</code>在<code>C++</code>中的一个合理用途，是当你要传递“一个复杂的<code>class object</code>的全部或部分”到某个<code>C</code>函数中去时，<code>struct</code>声明可以将数据封装起来，并保证拥有与<code>C</code>兼容的空间布局。然而这项保证只在组合的情况下才存在。</p><h5 id="1-3-对象的差异"><a href="#1-3-对象的差异" class="headerlink" title="1.3 对象的差异"></a><code>1.3</code> 对象的差异</h5><p><code>C++</code>支持<code>3</code>种程序设计模型：</p><ol><li>程序模型（面向过程）</li><li>抽象数据类型模型（基于对象模型）（封装）</li><li>面向对象模型（继承、多态）</li></ol><p>在<code>C++</code>，多态只存在于一个个的<code>public class</code>体系中。<code>nonpublic</code>的派生行为以及类型为<code>void*</code>的指针可以说是多态，但它们并没有被语言明白地支持，也就是说它们必须由程序员通过明白的<strong>转型操作</strong>来管理。<code>C++</code>以下列方法支持多态：</p><ol><li><p>经由一组隐含的转化操作。例如把一个<code>derived class</code>指针转化为一个指向其<code>public base type</code>的指针</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure></li><li><p>经由<code>virtual function</code>机制</p></li><li><p>经由<code>dynamic_cast</code>和<code>typeid</code>运算符</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Circle* pc = <span class="keyword">dynamic_cast</span>&lt;Circle*&gt;(ps))</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol><p><code>virtual function</code>机制不只使得“当类型有所增加、修改、或删减时，我们的程序代码不需改变”。而且也使一个新的<code>subtype</code>的供应者不需要重新写出“对继承体系中的所有类型都共通”的行为和操作。</p><p>需要多少内存才能够表现一个<code>class object</code>？</p><ul><li><code>nonstatic data members</code>的总和大小</li><li>加上任何<code>alignment</code>（内存对齐）</li><li>加上为了支持<code>virtual</code>（<code>function</code>，<code>base class</code>）而由内部产生的额外负担</li></ul><p>转型（<code>cast</code>）其实是一种编译器指令。<strong>大部分情况下</strong>它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。</p><p>一个<code>Base</code>指针<code>pb</code>和一个<code>Derived</code>指针<code>pd</code>有什么不同？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;</span><br><span class="line">Derived* pd = &amp;d;</span><br></pre></td></tr></table></figure><p>它们每个都指向<code>Base object</code>的第一个<code>byte</code>。其间的差别是，<code>pd</code>所涵盖的地址包含整个<code>Derived object</code>，而<code>pb</code>所涵盖的地址只包含<code>Derived object</code>中的<code>Base subobject</code>。</p><p>除了<code>Base subobject</code>中出现的<code>members</code>，你不能使用<code>pb</code>来直接处理<code>Derived</code>的任何<code>members</code>。例外是通过<code>virtual</code>机制或转型操作。</p><p>当一个<code>base class object</code>被直接初始化为（或是被指定为）一个<code>derived class object</code>时，<code>derived object</code>就会被切割，以塞人较小的<code>base type</code>内存中，<code>derived type</code>将没有留下任何蛛丝马迹。</p><p>下面这一组定义，其可能的内存布局为：</p><img src="image-20210220202640585.png" alt="image-20210220202640585" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal za;</span><br><span class="line">ZooAnimal *pza;</span><br><span class="line">Bear b;</span><br><span class="line">Panda* pp = <span class="keyword">new</span> Panda;</span><br><span class="line">pza = &amp;b;</span><br></pre></td></tr></table></figure><img src="image-20210220153355200.png" alt="image-20210220153355200" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之模板与泛型编程</title>
      <link href="/MBICE5WlMJtd4Rku/"/>
      <url>/MBICE5WlMJtd4Rku/</url>
      
        <content type="html"><![CDATA[<h4 id="第7章：模板与泛型编程"><a href="#第7章：模板与泛型编程" class="headerlink" title="第7章：模板与泛型编程"></a>第<code>7</code>章：模板与泛型编程</h4><h5 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款<code>41</code>：了解隐式接口和编译期多态</h5><ul><li><p>哪一个重载函数被调用——发生在编译期</p></li><li><p>哪一个<code>virtual</code>函数被绑定——发生在运行期</p></li><li><p><code>class</code>和<code>template</code>都支持接口和多态</p><p>  对<code>class</code>而言，接口是显式的，以成员函数的签名为中心，多态则通过<code>virtual</code>函数发生在运行期。对<code>template</code>而言，接口是隐式的，以有效表达式为中心，多态则通过<code>template</code>具现化和函数重载解析发生于编译期。</p></li></ul><a id="more"></a><h5 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款<code>42</code>：了解<code>typename</code>的双重意义</h5><ul><li><p>当我们声明模板类型参数，<code>class</code>和<code>typename</code>的意义完全相同</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>typename</code>用来标识嵌套从属类型名称</p><p>  <code>template</code>内出现的名称如果相依于某个<code>template</code>参数，称这个名称为从属名称，如果丛属名称在<code>class</code>内呈嵌套状，称为嵌套从属名称。如果嵌套从属名称还指涉某种类型名称为嵌套从属类型名称</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::iterator_traits&lt;IterT&gt;::value_type 就是嵌套从属类型名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须使用 typename 关键字标识</span></span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 typedef 少打几个字</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须使用 typename 关键字标识</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不允许在<code>base class list</code>或<code>member initialization list</code>内使用<code>typename</code>作为<code>base class</code>的标识符</p></li></ul><h5 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款<code>43</code>：学习处理模板化基类内的名称</h5><p>假设我们需要撰写一个<code>MsgSender</code>类，它能够传送信息到若干不同的<code>Company</code>去。信息要不进行加密后的密文，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于<code>template</code>的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 针对其他公司设计的 class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgInfo</span> &#123;</span>...&#125;; <span class="comment">// 这个 class 以备将来产生信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">//构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">        ... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.sendCleartext(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">        ... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.sendEncrypted(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在假设我们想要在每次送出信息时<code>log</code>某些信息。<code>derived class</code>可轻易提供解决方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">        sendClear(info); <span class="comment">// 调用 base class 函数, 这段码无法通过编译!</span></span><br><span class="line">        ... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译器会抱怨<code>sendClear</code>函数不存在，明明在那里，为什么？</p><p>问题在于，当编译器看见<code>class template LoggingMsgSender</code>定义式时，并不知道它继承什么样的<code>class</code>。当然它继承的是<code>MsgSender&lt;Company&gt;</code>，但其中的<code>Company</code>是个<code>template</code>参数，不当<code>LoggingMsgSender</code>被具现化之前无法确切知道它是什么。而如果不知道<code>Company</code>是什么，就无法知道<code>class MsgSender&lt;Company&gt;</code>看起来像什么——更明确地说是没办法知道它是否有个<code>sendClear</code>函数。</p><p>具体点说，假设现在有个<code>CompanyZ</code>坚持只使用加密通讯：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不提供 sendCleartext 函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyZ</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般性的<code>MsgSender template</code>对<code>CompanyZ</code>并不合适，因为那个<code>template</code>提供了一个<code>sendClearMsg</code>函数，而这对<code>CompanyZ</code>对象并不合理。欲矫正这个问题，我们可以针对<code>CompanyZ</code>产生一个<code>MsgSender</code>特化版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全特化版本只提供 sendSecret 函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&lt;CompanyZ&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">//构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">        ... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.sendEncrypted(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就解释了前面编译器拒绝那个调用的原因：它知道<code>base class template</code>有可能被特化，而那个特化版本可能不提供和一般性<code>template</code>相同的接口。因此它往往拒绝在<code>templatized base class</code>（本例的<code>MsgSender&lt;Company&gt;</code>）内寻找继承而来的名称（本例的<code>SendClear</code>)。</p><ul><li>当我们从<code>Object Oriented C++</code>跨进<code>Template C++</code>（见条款<code>1</code>) ，继承就不像以前那样畅行无阻了</li></ul><p>有三个解决令<code>C++</code>编译器“不进入<code>templatized base class</code>观察”的行为失效的办法：</p><ol><li><p>使用<code>this</code>指针</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">        ... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>using</code>声明</p><p> 虽然<code>using</code>声明式在在条款<code>33</code>或在这里都可有效运作，但两处解决的问题其实不相同。前者是<code>base class</code>名称被<code>derived class</code>名称遮掩，而后者是编译器不进入<code>base class</code>作用域内查找，于是我们通过<code>using</code>告诉它，请它那么做。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">    ... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">        sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">        ... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用作用域运算符<code>::</code>明确指定</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">        MsgSender&lt;Company&gt;::sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">        ... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>即使如此，如果稍后这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoggingMsgSender&lt;Companyz&gt;zMsgSender;</span><br><span class="line">MsgInfo msgData;</span><br><span class="line">...</span><br><span class="line">zMsgSender.sendClearMsg(msgData); <span class="comment">// 仍然无法通过编译</span></span><br></pre></td></tr></table></figure><p>其中对<code>sendClearMsg</code>的调用动作将无法通过编译，因为在那个点上，编译器知道<code>base class</code>是个<code>template</code>特化版本<code>MsgSender&lt;CompanyZ&gt;</code>，而且它知道那个<code>class</code>不提供<code>sendClear</code>函数，而<code>sendClear</code>却是<code>sendClearMsg</code>尝试调用的函数。 </p><h5 id="条款44：将与基类无关的代码抽离template"><a href="#条款44：将与基类无关的代码抽离template" class="headerlink" title="条款44：将与基类无关的代码抽离template"></a>条款<code>44</code>：将与基类无关的代码抽离<code>template</code></h5><p>当你编写某个函数，其中某些部分的实现码和另一个函数的实现码实质相同，你会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。如果你正在编写某个<code>class</code>，而你明白其中某些部分和另一个<code>class</code>的某些部分相同，你也不会重复这共同的部分。你会把共同部分搬移到新<code>class</code>去，然后使用继承或复合（见条款<code>32</code>，<code>38</code>，<code>39</code>) ，令原先的<code>class</code>取用这共同特性。而原<code>class</code>的互异部分仍然留在原位置不动。</p><p>编写<code>template</code>时，也是做相同的分析，以相同的方式避免重复。然而在<code>template</code>代码中，重复是隐晦的：毕竟只存在一份<code>template</code>源码，所以你必须训练自己去感受当<code>template</code>被具现化多次时可能发生的重复。</p><p>举个例子，假设你想为固定尺寸的正方矩阵编写一个<code>template</code>。该矩阵的性质之一是支持逆矩阵运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template 支持 n x n 矩阵, 元素类型为 T</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">squareMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">( )</span></span>; <span class="comment">// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; sml;</span><br><span class="line">...</span><br><span class="line">sm1.invert(); <span class="comment">// 调用 SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">sSquareMatrix&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.invert(); <span class="comment">// 调用 SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure><p>这会具现化两份<code>invert</code>。这些函数并非完完全全相同，因为其中一个操作的是<code>5x5</code>矩阵而另一个操作的是<code>10x10</code>矩阵，但除了常量<code>5</code>和<code>10</code>，两个函数的其他部分完全相同。这是<code>template</code>引出代码膨胀的一个典型例子。</p><p>第一次修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与尺寸无关的 base class</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">size_t</span> matrixSize)</span> <span class="comment">// 以给定的尺寸求逆矩阵</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明为 private 是为了不让客户看见</span></span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert; <span class="comment">// 避免遮掩 base 版的 invert, 见条款 33</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invert(n);<span class="comment">// inline 调用 base class 版的 invert</span></span><br><span class="line">        <span class="comment">// 为什么这儿出现 this-&gt; 见条款 43</span></span><br><span class="line">        <span class="comment">// LYL 认为前面已经使用了 using, this-&gt; 应该也不需要了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>base class</code>只是为了帮助<code>derived class</code>实现，不是为了表现<code>SquareMatrix</code>和<code>SquareMatrixBase</code>之间的<code>is-a</code>关系（关于<code>private</code>继承，见条款<code>39</code>)。</p><p>目前为止一切都好，但还有一些棘手的题目没有解决。<code>SquareMatrixBase::invert</code>如何知道该操作什么数据？虽然它从参数中知道矩阵尺寸，但它如何知道哪个特定矩阵的数据在哪儿？想必只有<code>derived class</code>知道。<code>derived class</code>如何联络其<code>base class</code>做逆运算动作？一个可能的做法是为<code>SquareMatrixBase::invert</code>添加另一个参数，可以是个指针，指向一块用来放置矩阵数据的内存地址。</p><p>第二次修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 存储矩阵大小和一个指针, 指向矩阵数值</span></span><br><span class="line">    squareMatrixBase(<span class="keyword">size_t</span> n, T* pMem) : size(n), pData(pMem) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span> <span class="comment">// 不用指定尺寸了</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> size; <span class="comment">// 矩阵的大小</span></span><br><span class="line">    T* pData; <span class="comment">// 指针, 指向矩阵内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SquareMatrix() : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n * n];<span class="comment">// 这里直接将数据矩阵存储在 SquareMatrix 对象内部</span></span><br><span class="line">                    <span class="comment">// 也可以使用动态内存分配的方案</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个条款只讨论由<code>non-type template parameter</code>（非类型模板参数）带来的膨胀，其实<code>type parameter</code>（类型参数）也会导致膨胀。例如在许多平台上<code>int</code>和 <code>long</code>有相同的二进制表述，所以像<code>vector&lt;int&gt;</code>和<code>vector&lt;long&gt;</code>的成员函数有可能完全相同。某些链接器（<code>linker</code>）会合并完全相同的函数实现码，但有些不会，后者意味某些<code>template</code>被具现化为<code>int</code>和<code>long</code>两个版本，并因此造成代码膨胀。类似情况，所有指针类型都有相同的二进制表述，因此凡<code>template</code>持有指针者（例如<code>list&lt;int*&gt;</code>，<code>list&lt;const int*&gt;</code>，<code>list&lt;SquareMatrix&lt;long, 3&gt;*&gt;</code>等等）往往应该对每一个成员函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它们操作强型指针（<code>strongly typed pointer</code>，即<code>T*</code>），你应该令它们调用另一个操作无类型指针（<code>untyped pointer</code>，即<code>void*</code>）的函数，由后者完成实际工作。某些<code>C++</code>标准程序库实现版本的确为<code>vector</code>，<code>deque</code>和<code>list</code>等<code>template</code>做了这件事。</p><h5 id="条款45：成员函数模板接受所有兼容类型"><a href="#条款45：成员函数模板接受所有兼容类型" class="headerlink" title="条款45：成员函数模板接受所有兼容类型"></a>条款<code>45</code>：成员函数模板接受所有兼容类型</h5><p>内置指针是支持隐式转换的，比如<code>derived class</code>的指针可以隐式转换为<code>base class</code>指针，指向<code>non-const</code>对象的指针可以转换为指向<code>const</code>对象等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> :</span> <span class="keyword">public</span> Top &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> :</span> <span class="keyword">public</span> Middle &#123;...&#125;;</span><br><span class="line">Top* pt1 = <span class="keyword">new</span> Middle; <span class="comment">// 将 Middle* 转换为 Top*</span></span><br><span class="line">Top* pt2 = <span class="keyword">new</span> Bottom; <span class="comment">// 将 Bottom* 转换为 Top*</span></span><br><span class="line"><span class="keyword">const</span> Top* = pt1; <span class="comment">// Top* 转换为 const Top*</span></span><br></pre></td></tr></table></figure><p>但是我们自己实现的智能指针模板类，想做到这样就稍稍有点麻烦了。我们希望下面的代码能够通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">temmplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* realPtr)</span></span>; <span class="comment">// 智能指针通常以内置指针完成初始化</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Middle&gt;转 换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(<span class="keyword">new</span> Middle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Bottom&gt; 转换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Top&gt; 转换为 SmartPtr&lt;const Top&gt;</span></span><br><span class="line">SmartPtr&lt;<span class="keyword">const</span> Top&gt; pct2 = ptl;</span><br></pre></td></tr></table></figure><p><strong>注意，这些赋值表达式需要调用的都是<code>copy</code>构造函数。</strong>这里的代码不能通过编译，因为如果以带有<code>base-derived</code>关系的<code>B</code>，<code>D</code>两类型分别具现化某个<code>template</code>，产生出来的两个具现体并不带有<code>base-derived</code>关系，所以编译器视<code>SmartPtr&lt;Middle&gt;</code>和<code>SmartPtr&lt;Top&gt;</code>为完全不同的<code>class</code>，为了获得我们希望获得的<code>SmartPtr class</code>之间的转换能力，我们必须将它们明确地编写出来。</p><p>我们应该为它写一个<strong>构造模板</strong>。这样的模板是所谓<code>member function template</code>，其作用是为<code>class</code>生成函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// member template, 为了生成 copy 构造函数</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们称之为泛化（<code>generalized</code>）<code>copy</code>构造函数。它并未被声明为<code>explicit</code>，那是因为内置指针类型之间的转换（例如从<code>derived class</code>指针转为<code>base class指针</code>）是隐式转换，所以让智能指针按照这种形式也属合理。</p><p>但是，这个为<code>SmartPtr</code>而写的“泛化<code>copy</code>构造函数”提供的东西比我们需要的更多。我们只希望根据一个<code>SmartPtr&lt;Bottom&gt;</code>创建一个<code>SmartPtr&lt;Top&gt;</code>，却不希望根据一个<code>SmartPtr&lt;Top&gt;</code>创建一个<code>SmartPtr&lt;Bottomr&gt;</code>，因为那对<code>public</code>继承而言（见条款32）是矛盾的。我们也不希望根据一个<code>SmartPtr&lt;double&gt;</code>创建一个<code>SmartPtr&lt;int&gt;</code>，我们必须从某方面对这一<code>member template</code>所创建的成员函数群进行挑拣。</p><p>假设<code>SmartPtr</code>遵循<code>std::shared_ptr</code>也提供一个<code>get</code>成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以 other 的 heldPtr 初始化 this 的 heldPtr</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) : heldPtr(other.get()) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr; <span class="comment">// 这个 SmartPtr 持有的内置指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个行为只有当“存在某个隐式转换可将一个<code>U*</code>指针转为一个<code>T*</code>指针”时才能通过编译，而这正是我们想要的。</p><p><code>member function template</code>（成员函数模板）的效用不限于构造函数，<strong>它常扮演的另一个角色是支持赋值操作。</strong>例如<code>std::shared_ptr</code>同时支持所有“来自兼容之内置指针、<code>std::shared_ptr</code>、<code>std::weak_ptr</code>”的构造行为以及赋值操作（<code>std::weak_ptr</code>除外）。赋值操作符和<code>copy</code>构造函数实现类似，故省略。</p><ul><li>如果你声明<code>member template</code>用于“泛化<code>copy</code>构造”或“泛化<code>assignment</code>操作”你还是需要声明正常的<code>copy</code>构造函数和<code>copy assignment</code>操作符</li></ul><p>条款<code>5</code>说过，编译器可能为我们产生四个成员函数，其中两个是<code>copy</code>构造函数和<code>copy assignment</code>操作符。现在，<code>SmartPtr</code>声明了一个泛化<code>copy</code>构造函数，而显然一旦类型<code>T</code>和<code>U</code>相同，泛化<code>copy</code>构造函数会被具现化为“正常的”<code>copy</code>构造函数。那么究竟编译器会暗自为<code>SmartPtr</code>生成一个<code>copy</code>构造函数呢？或当某个<code>SmartPtr</code>对象根据另一个同型的<code>SmartPtr</code>对象展开构造行为时，编译器会将“泛化copy构造函数模板”具现化呢？</p><p><code>member template</code>并不改变语言规则：“如果程序需要一个<code>copy</code>构造函数，你却没有声明它，编译器会为你暗自生成一个”。在<code>class</code>内声明泛化<code>copy</code>构造函数（是个<code>member template</code>）并不会阻止编译器生成它们自己的<code>copy</code>构造函数（一个<code>non-template</code>），所以如果你想要控制<code>copy</code>构造的方方面面，你必须同时声明泛化<code>copy</code>构造函数和“正常的”<code>copy</code>构造函数。相同规则也适用于赋值操作。</p><h5 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款<code>46</code>：需要类型转换时请为模板定义非成员函数</h5><p>条款<code>24</code>讨论过为什么惟有<code>non-member</code>函数才有能力“在所有实参身上实施隐式类型转换”，该条款并以<code>Rational class</code>的<code>operator*</code>函数为例。本条款将<code>Rational</code>和<code>operator*</code>模板化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 条款 20 告诉你为什么参数以 passed by reference 方式传递</span></span><br><span class="line">    Rational(<span class="keyword">const</span> T&amp; numerator = <span class="number">0</span>, <span class="keyword">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条款 28 告诉你为啥返回值以 passed by value 方式传递</span></span><br><span class="line">    <span class="comment">// 条款 3 告诉你为啥它们是 const</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像条款<code>24</code>一样，我们也希望支持混合式算术运算，然而以下代码却不能通过编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;int&gt; oneHalf(1, 2);</span><br><span class="line">Rational&lt;int&gt; result &#x3D; oneHalf * 2; &#x2F;&#x2F; 错误!无法通过编译</span><br></pre></td></tr></table></figure><p>在这里，编译器不知道我们想要调用哪个函数！它们试图找到什么函数被名为<code>operator*</code>的<code>template</code>具现化出来。它们知道它们应该可以具现化某个“名为<code>operator*</code>并接受两个<code>Rational&lt;T&gt;</code>参数”的函数，但为完成这一具现化行动，必须先算出<code>T</code>是什么。</p><p>为了推导<code>T</code>，它们看了看<code>operator*</code>调用动作中的实参类型。分别是<code>Rational&lt;int&gt;</code>（<code>oneHalf</code>的类型）和<code>int</code>（<code>2</code>的类型）。</p><p>以<code>oneHalf</code>进行推导，过程并不困难。第二参数的推导则没有这么顺利。<code>operator*</code>的第二参数被声明为<code>Rational&lt;T&gt;</code>，但传递给<code>operator*</code>的类型是<code>int</code>（<code>2</code>）。编译器如何根据这个<code>2</code>推算出<code>T</code>？你或许会期盼编译器使用<code>Rational&lt;int&gt;</code>的<code>non-explicit</code>构造函数将转换为<code>Rational&lt;int&gt;</code>，进而将<code>T</code>推导为<code>int</code>，然而<strong><code>template</code>实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。</strong></p><p><code>template class</code>内的<code>friend</code>声明式可以指涉某个特定函数。这意味<code>class Rational&lt;T&gt;</code>可以声明<code>operator*</code>是它的一个<code>friend</code>函数。<code>class template</code>并不倚赖<code>template</code>实参推导，所以编译器总是能够在<code>class Rational&lt;T&gt;</code>具现化时得知<code>T</code>。因此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                                <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>，<code>class Rational&lt;int&gt;</code>于是被具现化出来，而作为过程的一部分，<code>friend</code>函数<code>operator*</code>（接受<code>Rational&lt;int&gt;</code>参数）也就被自动声明出来。后者身为一个函数而非<code>function template</code>，因此编译器可在调用它时使用隐式转换函数（例如调用<code>Rational</code>的<code>non-explicit</code>构造函数）。                                                        </p><p>但是，虽然这段代码通过编译，却无法连接。</p><p>因为这个友元函数只被声明于<code>Rational</code>内，并没有被定义出来。我们意图令此<code>class</code>外部的<code>operator* template</code>提供定义式，是行不通的。既然我们没有提供定义式，连接器当然找不到它！</p><p>最简单的方法就是，将函数本体放进<code>class</code>内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                        lhs.denominator() * rhs.denominator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了让类型转换可能发生于所有实参身上，我们需要一个<code>non-member</code>函数（条款<code>24</code>）；为了令这个函数被自动具现化，我们需要将它声明在<code>class</code>内部；而在class内部声明<code>non-member</code>函数的唯一办法就是：令它成为一个<code>friend</code>。因此我们就这样做了。</p><ul><li><p>当此<code>friend</code>函数过于复杂时，令其调用类外的辅助函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rational</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp;rhs)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational&lt;T&gt;(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                       lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="keyword">const</span> Rational&lt;T&gt;<span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                                <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> doMultiply(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  作为一个<code>template</code>，<code>doMultiply</code>当然不支持混合式乘法，但它其实也不需要。它只被<code>operator*</code>调用，而<code>operator*</code>支持混合式操作。</p></li></ul><h5 id="条款47：traits-classes表现类型信息"><a href="#条款47：traits-classes表现类型信息" class="headerlink" title="条款47：traits classes表现类型信息"></a>条款<code>47</code>：<code>traits classes</code>表现类型信息</h5><p><code>STL</code>迭代器分类：</p><ol><li><p><code>input</code>迭代器</p><p> 只能向前移动，一次一步，用户只能读取它所指的东西，而且只能读取一次，读完立即自动向前一步。程序库中的输入流迭代器<code>istream_iterator</code>就属于这一类。</p></li><li><p><code>output</code>迭代器</p><p> 只能向前移动，一次一步，用户只能涂写它所指的东西，而且只能涂写一次，写完立即自动向前一步。程序库中的输出流迭代器<code>ostream_iterator</code>就属于这一类。</p></li><li><p><code>forward</code>迭代器</p><p> 可以做上述两种迭代器做的事情，而且支持多次读写，读写完由用户自行决定是否前进。单向链表<code>slist</code>提供的迭代器就属于这一类。</p></li><li><p><code>bidirectional</code>迭代器</p><p> 除了能做<code>forward</code>迭代器做的事情，还可以向后移动。双向链表<code>list</code>以及<code>set</code>，<code>mutilset</code>，<code>map</code>，<code>mutilmap</code>提供的迭代器属于这一类。</p></li><li><p><code>random access</code>迭代器</p><p> 功能类似于内置指针，可以进行算数操作。<code>vector</code>，<code>deque</code>和<code>string</code>提供的迭代器属于这一类。</p></li><li><p><em>迭代器适配器</em></p><ul><li><em><code>reverse</code>迭代器</em></li><li><em><code>insert</code>迭代器</em><ul><li><em><code>back inserter</code></em></li><li><em><code>front inserter</code></em></li><li><em><code>general inserter</code></em></li></ul></li><li><em><code>stream</code>迭代器</em></li><li><em><code>move</code>迭代器</em></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional</span> <span class="title">iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这些<code>struct</code>之间的继承关系是有效的<code>is-a</code>关系：所有<code>forward</code>迭代器都是<code>input</code>迭代器，依此类推。</p><p>关于<code>iterator_trait</code>的实现技术（参考书籍<code>P227-P232</code>）</p><h5 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款<code>48</code>：认识<code>template</code>元编程</h5><ul><li>如题，以后买本书再专门去学吧！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之继承与面向对象设计</title>
      <link href="/5pPP61A5gGyfCrjb/"/>
      <url>/5pPP61A5gGyfCrjb/</url>
      
        <content type="html"><![CDATA[<h4 id="第6章：继承与面向对象设计"><a href="#第6章：继承与面向对象设计" class="headerlink" title="第6章：继承与面向对象设计"></a>第<code>6</code>章：继承与面向对象设计</h4><h5 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款<code>32</code>：确定你的<code>public</code>继承塑模出<code>is-a</code>关系</h5><ul><li>“<code>public</code>继承”意味<code>is-a</code>。适用于<code>base class</code>身上的每一件事情一定也适用于<code>derived class</code>身上，因为每一个<code>derived class</code>对象也都是一个<code>base class</code>对象</li></ul><a id="more"></a><h5 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款<code>33</code>：避免遮掩继承而来的名称</h5><ul><li><p><code>derived class</code>的作用域被嵌套在<code>base class</code>作用域内</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); <span class="comment">// 没问题, 调用 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 错误! 因为 Derived::mf1 遮掩了 Base::mf1</span></span><br><span class="line">d.mf2(); <span class="comment">// 没问题, 调用 Derived::mf2</span></span><br><span class="line">d.mf2(x); <span class="comment">// 错误! 因为 Derived::mf2 遮掩了 Base::mf2</span></span><br></pre></td></tr></table></figure><p>  这段代码中<code>base class</code>内所有名为<code>mf1</code>和<code>mf2</code>的函数都被<code>derived class</code>内的<code>mf1</code>和<code>mf2</code>函数遮掩掉了。从名称查找观点来看，<code>Base::mf1</code>和<code>Base::mf2</code>不再被<code>Derived</code>继承！</p><p>  实际上如果你正在使用<code>public</code>继承而又不继承那些重载函数，就是违反<code>base</code>和<code>derived class</code>之间的<code>is-a</code>关系，而条款<code>32</code>说过<code>is-a</code>是<code>public</code>继承的基石。因此你几乎总会想要推翻<code>C++</code>对“继承而来的名称”的缺省遮掩行为。</p><ul><li><p>使用<code>using</code>声明式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1; <span class="comment">// 让 Base class 内名为 mf1 和 mf2 的所有东西</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf2; <span class="comment">// 在 Derived 作用域内都可见, 并且 public</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); <span class="comment">// 没问题, 调用 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 现在没问题了, 调用 Based::mf1</span></span><br><span class="line">d.mf2(); <span class="comment">// 没问题, 调用 Derived::mf2</span></span><br><span class="line">d.mf2(x); <span class="comment">// 现在没问题了, 调用 Based::mf2</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>inline</code>转交函数（<code>forwarding function</code>）</p><p>  然而在<code>private</code>继承之下（见条款<code>39</code>），有时候你并不想继承<code>base class</code>的所有函数。假设<code>Derived</code>以<code>private</code>形式继承<code>Base</code>，而<code>Derived</code>唯一想继承的<code>mf1</code>是那个无参数版本。<code>using</code>声明式在这里派不上用场，因为<code>using</code>声明式会令继承而来的某给定名称之所有同名函数在<code>derived class</code>中都可见。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    ... <span class="comment">// 与前同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="comment">// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::mf1(); <span class="comment">// 暗自成为 inline (见条款 30)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">d.mf1(); <span class="comment">// 很好, 调用的是 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 错误! Base::mf1 被遮掩</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款<code>34</code>：区分接口继承和实现继承</h5><p>身为<code>class</code>设计者，有时候你会希望<code>derived class</code>只继承成员函数的接口，也就是声明；有时候你又会希望<code>derived class</code>同时继承函数的接口和实现，但又希望能够覆写（<code>override</code>）它们所继承的实现；又有时候你希望<code>derived class</code>同时继承函数的接口和实现，并且不允许覆写任何东西。</p><p><code>base</code>类强烈影响以<code>public</code>形式继承它的<code>derived class</code>，因为：</p><ul><li><p>成员函数的接口总是会被继承</p></li><li><p>声明一个<code>pure virtual</code>函数的目的是为了让<code>derived</code>类只继承函数接口</p><p>  含有<code>pure virtual</code>函数的类属于抽象基类，不能被实例化。继承了它们的类必须重新声明此函数接口并给予实现。抽象基类可以给<code>pure virtual</code>函数提供定义，但调用它的唯一途径是“调用时指定其<code>class</code>的名称”。</p></li><li><p>声明<code>impure</code>函数的目的是让<code>derived class</code>继承该函数的接口和缺省实现</p><p>  但是，允许<code>impure virtual</code>函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑<code>XYZ</code>航空公司设计的飞机继承体系。该公司只有<code>A</code>型和<code>B</code>型两种飞机，两者都以相同方式飞行。因此<code>XYZ</code>设计出这样的继承体系：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span> &#123;</span>...&#125;; <span class="comment">// 用以表现机场</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省代码, 将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>  为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的<code>fly</code>实现”，<code>Airplane::fly</code>被声明为<code>virtual</code>。然而为了避免在<code>ModelA</code>和<code>ModelB</code>中撰写相同代码，缺省飞行行为由<code>Airplane::fly</code>提供，它同时被<code>ModelA</code>和<code>ModelB</code>继承。</p><p>  现在，<code>XYZ</code>航空公司决定购买一种新式<code>C</code>型飞机。<code>C</code>型和<code>A</code>型以及<code>B</code>型的飞行方式不同。<code>XYZ</code>公司的程序员在继承体系中针对<code>C</code>型飞机添加了一个<code>class</code>，但由于他们急着让新飞机上线服务，竟忘了重新定义其<code>fly</code>函数：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 未声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Airport <span class="title">PDX</span><span class="params">(... )</span></span>; <span class="comment">// PDX 是我家附近的机场</span></span><br><span class="line">Airplane* pa= <span class="keyword">new</span> ModelC;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这将酿成大灾难</span></span><br><span class="line">pa-&gt;fly(PDX); <span class="comment">// 调用 Airplane::fly</span></span><br></pre></td></tr></table></figure><p>  一种解救办法为切断“<code>virtual</code>函数接口”和其“缺省实现”之间的连接。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 现在是 pure virtual 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span> <span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省行为, 将飞机飞至指定的目的地。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        defaultFly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        defaultFly (destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 ModelC class 不可能意外继承不正确的 fly 实现代码了</span></span><br><span class="line"><span class="comment">// 因为 Airplane 中的 pure virtual 函数追使 ModelC 必须提供自己的 f1y 版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ... <span class="comment">// 将 C 型飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  另一种解救方法是，利用“<code>pure virtual</code>函数必须在<code>derived class</code>中重新声明，但它们也可以拥有自己的实现”这一事实。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 现在是 pure virtual 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给予 pure virtual 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省行为, 将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Airplane::fly(destination); <span class="comment">// 通过指定其类名调用它</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">virtuai <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Airplane::fly(destination); <span class="comment">// 通过指定其类名调用它</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 将 C 型飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明<code>non-virtual</code>函数的目的是为了<code>derived class</code>继承函数的接口及其强制性实现</p><p>  <code>non-virtual</code>函数为其所属<code>class</code>建立的意义是不变性凌驾其特异性，所以它不该在<code>derived class</code>中被重新定义。</p></li></ul><h5 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款<code>35</code>：考虑<code>virtual</code>函数以外的其他选择</h5><p>假设你正在写一个视频游戏软件，你的游戏属于暴力砍杀类型，剧中人物存在被伤害而降低健康状态的情况。因此你决定提供一个成员函数 <code>healthvalue</code>，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将<code>healthvalue</code>声明为<code>virtual</code>似乎是再明白不过的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 返回人物的健康指数,</span></span><br><span class="line">                                    <span class="comment">// derived classes 可重新定义它</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在考虑一些其它解法：</p><ul><li><p>借助<code>non-virtual interface</code>(<code>NVI</code>)手法实现<code>Template Method</code>模式</p><p>  保留<code>healthvalue</code>为<code>public</code>成员函数，但让它成为<code>non-virtual</code>，并调用一个<code>private virtual</code>函数进行实际工作：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// derived class 不重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 做一些事前工作</span></span><br><span class="line">        <span class="keyword">int</span> retval = doHealthvalue(); <span class="comment">// 做真正的工作</span></span><br><span class="line">        ... <span class="comment">// 做一些事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NVI 手法下没必要让 virtual 函数一定是 private</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// derived class 可重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省算法, 计算健康指数。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这一基本设计，“令客户通过<code>public non-virtual</code>成员函数间接调用<code>private virtual</code>函数”，称为<code>non-virtual interface</code>(<code>NVI</code>)手法。它是所谓<code>Template Method</code>设计模式的一个独特表现形式。我把这个<code>non-virtual</code>函数（<code>healthvalue</code>）称为<code>virtual</code>函数的外覆器（<code>wrapper</code>) 。</p><p>  <code>NVI</code>手法的一个优点隐藏在上述代码注释“做一些事前工作”和“做一些事后工作”之中。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证 <code>class</code>约束条件、验证函数先决条件等。“事后工作”可以包括互斥器解除锁定、验证函数的事后条件、再次验证<code>class</code>约束条件等。如果你让客户直接调用<code>virtual</code>函数，就没有任何好办法可以做这些事。</p></li><li><p>借助<code>Function Pointer</code>实现<code>Strategy</code>模式</p><p>  另一个设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个函数指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"><span class="comment">// 以下函数是计算健康指数的缺省算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span> <span class="params">(HealthCalcFunc hcf = defaultFealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">healthFunc</span><span class="params">(hcf)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这种设计策略和前面介绍的方法相比提供了一些有趣的弹性：</p><ul><li><p>同一人物类型的不同实体可以有不同的健康计算函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span> :</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">GameCharacter</span><span class="params">(hcf)</span> </span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 健康指数计算函数 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 健康指数计算函数 2</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>; <span class="comment">// 相同类型的人物搭配</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>; <span class="comment">// 不同的健康计算方式</span></span><br></pre></td></tr></table></figure></li><li><p>某已知人物之健康指数计算函数可在运行期变更</p><p>  例如<code>GameCharacter</code>可提供一个成员函数<code>setHealthcalculator</code>，用来替换当前的健康指数计算函数。</p><p>然而这种策略意味着，计算函数并不能访问“被计算健康指数的”那个对象的内部（<code>non-public</code>）成分。如果需要访问<code>non-public</code>成分进行精确计算，这就有问题了。</p><p>唯一能够解决的办法就是：弱化<code>class</code>的封装。例如，将健康计算函数声明为<code>friend</code>。或是为其实现的某一部分提供<code>public</code>访问函数。这需要你来权衡利弊进行抉择。</p></li></ul></li><li><p>借助<code>std::function</code>实现<code>Strategy</code>模式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不同之处</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span> <span class="params">(HealthCalcFunc hcf = defaultFealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">healthFunc</span><span class="params">(hcf)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  那个签名代表的函数是“接受一个<code>reference</code>指向<code>const GameCharacter</code>，并返回<code>int</code>”。这个<code>std::function</code>类型（也就是我们所定义的<code>HealthCalcFunc</code>类型）产生的对象可以持有（保存）任何与此签名式<strong>兼容的</strong>可调用物。所谓兼容，意思是这个可调用物的参数可被<strong>隐式转换</strong>为<code>const GameCharacter&amp;</code>，而其返回类型可被<strong>隐式转换</strong>为<code>int</code>。</p><p>  这就提供了很大的灵活性：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">short <span class="title">calcHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// 健康计算函数</span></span><br><span class="line">                                        <span class="comment">// 注意其返回类型为 non-int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HealthCalculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 为计算健康而设计的函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameLevel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">health</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span>;<span class="comment">// 成员函数, 用以计算健康</span></span><br><span class="line">    <span class="comment">// 注意其 non-int 返回类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物类型 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span>:</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 同前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物类型 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EyeCandyCharacter</span>:</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 假设其构造函数与 EvilBadGuy 同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物 1, 使用某个函数计算健康指数</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物 2, 使用某个函数对象计算健康指数</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator())</span></span>;</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 人物 3, 使用某个成员函数计算健康指数</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(<span class="built_in">std</span>::bind(&amp;GameLevel::health, &amp;currentLevel, _1))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>传统的<code>Strategy</code>模式</p><p>  <img src="strategy.png" alt=""></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~HealthCalcFunc() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlowHealthLoser</span> :</span> HealthCalcFunc</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastHealthLoser</span> :</span> HealthCalcFunc</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf)</span> : <span class="title">pHealthCalc</span><span class="params">(phcf)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc-&gt;calc(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款<code>36</code>：绝不重新定义继承而来的<code>non-virtual</code>函数</h5><ul><li>如题</li></ul><h5 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款<code>37</code>：绝不重新定义继承而来的缺省参数值</h5><p>本条款的讨论局限于“继承一个带有缺省参数值的<code>virtual</code>函数”：<code>virtual</code>函数是动态绑定（后期绑定，延迟绑定），而缺省参数值却是静态绑定（前期绑定，早绑定）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个用以描述几何形状的class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> ShapeColor&#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="comment">// 所有形状都必须提供一个函数, 用来绘出自己</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注意, 赋予不同的缺省参数值, 这真糟糕!</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 请注意，以上这么写则当客户以 对象 调用此函数一定要指定参数值</span></span><br><span class="line">    <span class="comment">// 因为静态绑定下这个函数并不从其 base 继承缺省参数值</span></span><br><span class="line">    <span class="comment">// 但若以指针或 reference 调用此函数, 可以不指定参数值</span></span><br><span class="line">    <span class="comment">// 因为动态绑定下这个函数会从其 base 继承缺省参数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>对象的静态类型就是它在程序中所声明的类型，对象的动态类型则是指“目前所指对象的类型”</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shape* ps; <span class="comment">// 静态类型为 shape*, 无动态类型</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle; <span class="comment">// 静态类型为 Shape*, 动态类型是 Circle*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle; <span class="comment">// 静态类型为 shape*, 动态类型是 Rectangle*</span></span><br></pre></td></tr></table></figure><p>  动态类型可在程序执行过程中改变（通常是经由赋值动作）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = pc; <span class="comment">// ps 的动态类型如今是 circle*</span></span><br><span class="line">ps = pr; <span class="comment">// ps 的动态类型如今是 Rectangle*</span></span><br></pre></td></tr></table></figure></li></ul><p><code>virtual</code>函数系动态绑定而来，意思是调用一个<code>virtual</code>函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pr-&gt;draw(); <span class="comment">// 调用的是 Rectangle::draw(shape::Red)!</span></span><br><span class="line">            <span class="comment">// 注意缺省参数是 Red 而不是 Green</span></span><br></pre></td></tr></table></figure><p>此例之中，<code>pr</code>的动态类型是<code>Rectangle*</code>，所以调用的是<code>Rectangle</code>的<code>virtual</code>函数。<code>Rectangle::draw</code>函数的缺省参数值应该是<code>Green</code>，但由于<code>pr</code>的静态类型是<code>shape*</code>，所以此一调用的缺省参数值来自<code>Shape class</code>而非<code>Rectangle class</code>！这不符合预期。</p><p>解救方法是利用条款<code>35</code>中介绍的<code>NVI</code>手法替代<code>virtual</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> shapeColor&#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span><span class="comment">// 如今它是 non-virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        doDraw(color); <span class="comment">// 调用一个 virtual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 真正的工作在此处完成</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span> <span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>; <span class="comment">// 注意, 不须指定缺省参数值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个设计很清楚地使得<code>draw</code>函数的<code>color</code>缺省参数值总是<code>Red</code>。</p><h5 id="条款38：通过复合塑模出has-a或is-implemented-in-terms-of"><a href="#条款38：通过复合塑模出has-a或is-implemented-in-terms-of" class="headerlink" title="条款38：通过复合塑模出has-a或is-implemented-in-terms-of"></a>条款<code>38</code>：通过复合塑模出<code>has-a</code>或<code>is-implemented-in-terms-of</code></h5><p>当某种类型的对象内含其它对象时便形成了复合关系。</p><ul><li><p>应用域</p><p>  程序中的对象其实相当于你所塑造出来的世界中的某些事物。比如人，汽车，高楼大厦等。这样的对象属于应用域部分。</p></li><li><p>实现域</p><p>  其它对象如缓冲区，互斥器，搜索树等纯粹是实现细节上的工具。这些对象相当于软件中的实现域。</p></li></ul><p>当复合发生于应用域对象之间表现出<code>has-a</code>关系，当它发生于实现域内则表现出<code>is-implemented-in-terms-of</code>（根据某物实现出）的关系。</p><ul><li><p>复合的意义和<code>public</code>继承完全不同</p><p>  注意区分<code>is-a</code>和<code>is-implemented-in-terms-of</code>这两种对象关系。</p></li></ul><h5 id="条款39：明智而谨慎地使用private继承"><a href="#条款39：明智而谨慎地使用private继承" class="headerlink" title="条款39：明智而谨慎地使用private继承"></a>条款<code>39</code>：明智而谨慎地使用<code>private</code>继承</h5><p>一个<code>derived</code>类继承<code>base</code>类有<code>public</code>、<code>protected</code>或<code>private</code>三种继承方式。</p><ul><li><p>公有继承（<code>public</code>）（普遍使用）</p><p>  <code>base</code>类的<code>public</code>成员也是<code>derived</code>类的<code>public</code>成员，<code>base</code>类的<code>protected</code>成员也是<code>derived</code>类的<code>protected</code>成员</p></li><li><p>保护继承（<code>protected</code>）（基本不使用）</p><p>  <code>base</code>类的<code>public</code>和<code>protected</code>成员将成为<code>derived</code>类的<code>protected</code>成员。</p></li><li><p>私有继承（<code>private</code>）（少的情况使用）</p><p>  <code>base</code>类的<code>public</code>和<code>protected</code>成员将成为<code>derived</code>类的<code>private</code>成员。</p></li></ul><p>无论哪一种继承方式，<code>base</code>类的<code>private</code>成员都不能直接被<code>derived</code>类访问，但是可以通过调用<code>base</code>类的<code>public</code>和<code>protected</code>成员间接来访问（如果<code>base</code>类提供了访问接口的话）。</p><ul><li><p><code>private</code>继承意味着<code>is-implemented-in-terms-of</code></p><p>  <code>private</code>继承只限于软件实现层面，这就是为什么<code>private</code>继承后，<code>base class</code>的所有成分（除了<code>private</code>）在你的<code>class</code>内都是<code>private</code>，因为它们都只是实现细节而已。</p></li><li><p>尽可能使用复合，<strong>必要时</strong>才使用<code>private</code>继承</p><ol><li><p>当<code>derived</code>类想要访问<code>base class</code>的<code>protected</code>成员时</p></li><li><p>当<code>derived</code>类为了重新定义<code>base class</code>的<code>virtual</code>函数时</p><p> 现在考虑一个<code>Widget</code>类，它需要用到另一个计时器<code>Timer</code>类来实现一些业务。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> tickFrequecy)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 定时器每滴答一次, 此函数就调用一次</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p> 为了让<code>Widget</code>重新定义<code>Timer</code>内的<code>virtual</code>函数，<code>Widget</code>必须继承自<code>Timer</code>。因为<code>Widget</code>不是个<code>Timer</code>，因此<code>public</code>继承不合适。必须以<code>private</code>方式继承：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 通过<code>private</code>继承，<code>Timer</code>的<code>public onTick</code>函数在<code>Widget</code>内变成<code>private</code>，而我们重新声明（定义）时仍然把它留在那儿。如果把<code>onTick</code>放进<code>public</code>内会误导客户以为他们可以调用它，那就违反了条款<code>18</code>。</p><p> 另一种设计方案是采用复合 + <code>public</code>继承：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在 Widget 内声明一个嵌套式 private class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WidgetTimer</span> :</span> <span class="keyword">public</span> Timer</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 以 public 方式继承并重新定义 virtual 函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 采用第二种较为复杂的方式的两点理由：</p><ul><li>你或许会想设计<code>Widget</code>使它得以拥有<code>derived class</code>，但同时你可能会想阻止<code>derived class</code>重新定义<code>onTick</code>。如果<code>Widget</code>继承自<code>Timer</code>，上面的想法就不可能实现，即使是<code>private</code>继承也不可能。但如果<code>WidgetTimer</code>是<code>Widget</code>内部的一个<code>private</code>成员并继承自<code>Timer</code>，<code>Widget</code>的<code>derived class</code>将无法取用<code>WidgetTimer</code>，因此无法继承它或重新定义它的<code>virtual</code>函数。</li><li>你或许会想要将<code>Widget</code>的编译依存性降至最低（条款<code>31</code>）。如果<code>Widget</code>继承<code>Timer</code>，当<code>Widget</code>被编译时<code>Timer</code>的定义必须可见，所以定义<code>Widget</code>的那个文件恐怕必须<code>#include Timer.h</code>。但如果<code>WidgetTimer</code>移出<code>Widget</code>所在文件之外而<code>Widget</code>内含指针指向一个<code>WidgetTimer</code>，<code>Widget</code>可以只带着一个简单的<code>WidgetTimer</code>前向声明式，不再需要<code>#include</code>任何与<code>Timer</code>有关的东西。很容易就实现了解耦。</li></ul></li><li><p><code>EBO</code>（<code>empty base optimization</code>）</p><p> <code>empty class</code>指的是没有<code>non-static</code>成员变量，没有<code>virtual</code>函数，也没有<code>virtual base class</code>。于是这种<code>class</code>不占用理论上不占用任何内存空间。然而在实现技术上，<code>C++</code>要求<strong>独立（非附属）对象</strong>都必须有非零大小。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;; <span class="comment">// 没有任何需要存储的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论上 sizeof(HoldAnInt) = 4 字节(就一个 int)</span></span><br><span class="line"><span class="comment">// 实际上 sizeof(HoldAnInt) = 8 字节</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 字节</span></span><br><span class="line">    Empty e; <span class="comment">// 理论上应该不占据内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>C++</code>编译器默认为<code>empty class</code><strong>独立对象</strong>安插一个<code>char</code>（<code>1</code>字节）</p></li><li><p>由于内存对齐<code>HoldAnInt</code>的实际大小为<code>4 + 1(内存对齐至 4) = 8</code></p><p>但这个约束不适用于<code>derived class</code>对象的<code>base class</code>成分（非独立）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论和实际上 sizeof(HoldAnInt) = 4 字节(就一个 int)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span> :</span> <span class="keyword">public</span> Empty</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现实中的<code>empty class</code>并非真是<code>empty</code>。往往内含<code>typedef</code>，<code>enum</code>，<code>static</code>成员变量，或<code>non-virtual</code>函数。<code>STL</code>就有许多技术用途的<code>empty class</code>，其中内含有用的成员（通常是<code>typedef</code>），包括<code>base class unary_function</code>和<code>binary_function</code>，这些是“用户自定义之函数对象”通常会继承的<code>class</code>。由于<code>EBO</code>，这样的继承很少增加<code>derived class</code>的大小。</p></li></ul></li></ol></li></ul><h5 id="条款40：明智而谨慎地使用多重继承"><a href="#条款40：明智而谨慎地使用多重继承" class="headerlink" title="条款40：明智而谨慎地使用多重继承"></a>条款<code>40</code>：明智而谨慎地使用多重继承</h5><ul><li><p>多重继承较单一继承复杂，可能导致歧义性</p><p>  当继承的多个<code>base</code>具有同名成员函数时，<code>derived</code>类调用时会出现歧义。</p></li><li><p>有时多重继承不得不需要<code>virtual</code>继承，而这会带来额外的体积、运行速度、初始化复杂度等成本</p><p>  比如这样的钻石继承体系：</p><p>  <img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.png" alt=""></p><p>  这个继承体系中某个<code>base class</code>和某个<code>derived class</code>之间有一条以上的相通路线，假设<code>File class</code>有个成员变量<code>fileName</code>，那么<code>IOFile</code>从每一个<code>base class</code>各继承一份，所以其对象内会有两份<code>fileName</code>成员变量。然而<code>IOFile</code>对象只该有一个文件名称，所以名称<code>fileName</code>不该重复。</p><p>  解决办法就是采用<code>virtual</code>继承：</p><p>  <img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BFvirtual%E7%BB%A7%E6%89%BF.png" alt=""></p><p>  <code>virtual</code>继承带来的后果是：</p><ul><li><p>使用<code>virtual</code>继承的那些<code>class</code>所产生的对象往往比使用<code>non-virtual</code>继承的<code>class</code>体积大</p></li><li><p>访问<code>virtual base class</code>的成员变量时，也比访问<code>non-virtual base class</code>的成员变量速度慢</p></li><li><p>另外，支配“<code>virtual base class</code>初始化”的规则比起<code>non-virtual base class</code>的情况远为复杂且不直观。<code>virtual base class</code>的初始化责任是由继承体系中的最低层（<code>most derived</code>）<code>class</code>负责的，这意味着：</p><ol><li><code>class</code>若派生自<code>virtual base</code>而需要初始化，必须知道其<code>virtual base class</code>——不论那些<code>base class</code>距离多远。</li><li>当一个新的<code>derived class</code>加入继承体系中，它必须承担其<code>virtual base class</code>的初始化责任。</li></ol><p>关于<code>virtual</code>继承的忠告：</p></li></ul><ol><li>非必要不使用<code>virtual base</code>。平常请使用<code>non-virtual</code>继承。</li><li>如果必须使用<code>virtual base class</code>，尽可能避免在其中放置数据。这么一来你就不需担心这些<code>class</code>身上的初始化（和赋值）所带来的诡异事情了。</li></ol></li></ul><p>最后看一个多重继承的应用例子——<code>public</code>继承某个<code>Interface class</code>和<code>private</code>继承某个协助实现的<code>class</code>。</p><p><img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90.png" alt=""></p><p>（参考书籍<code>P195-P198</code>）</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之概论</title>
      <link href="/eSK55yN7G7dNea2c/"/>
      <url>/eSK55yN7G7dNea2c/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>相互之间存在一种或多种特定关系的数据元素的集合。研究数据结构，关心的是数据对象的描述以及相关操作函数的实现。</p><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如整型、浮点型等数值类型，以及声音、图像等非数值类型。</p><h4 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h4><p>是组成数据的、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。</p><a id="more"></a><h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p>一个数据元素可以由若干个数据项组成。它是数据不可分割的最小单位。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p>是性质相同的数据元素（即有相同的数量和类型的数据项）的集合，是数据的子集。</p><h4 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h4><ul><li><p>线性数据结构：向量<code>vector</code>（顺序存储）、链表<code>list</code>（链式存储）、栈<code>stack</code>和队列<code>queue</code>（优先队列）。</p></li><li><p>半线性数据结构：二叉树、搜索树（二叉搜索树<code>BST</code>、<code>AVL</code>树、<code>B</code>树、红黑树）、竞赛树等。</p></li><li><p>非线性数据结构：图。</p></li><li><p>哈希表<code>hashtable</code>、字典<code>dictionary</code>。</p></li></ul><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><ul><li><p>数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p></li><li><p>抽象数据类型：指一个数学模型及定义在该模型上的一组操作。可以理解为<code>C++</code>中的类<code>class</code>。它体现的是程序设计中问题分解、抽象和信息隐藏的特性。</p></li></ul><h4 id="抽象数据类型的标准格式"><a href="#抽象数据类型的标准格式" class="headerlink" title="抽象数据类型的标准格式"></a>抽象数据类型的标准格式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">    数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">    操作<span class="number">1</span></span><br><span class="line">    操作<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是解决指定问题求解步骤的描述。在计算机中是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。</p><h4 id="计算或信息处理"><a href="#计算或信息处理" class="headerlink" title="计算或信息处理"></a>计算或信息处理</h4><p>指借助某种工具，按照一定的规则，以明确而机械的形式进行。</p><p>算法中的计算模型就是计算机，即信息处理工具。</p><h4 id="算法必须具备的几大要素"><a href="#算法必须具备的几大要素" class="headerlink" title="算法必须具备的几大要素"></a>算法必须具备的几大要素</h4><ol><li>输入：待处理的信息或问题。</li><li>输出：经处理的信息，即答案。</li><li>正确性：的确可以解决指定的问题。</li><li>确定性：任何一个算法都可以描述为一个由基本操作组成的序列。</li><li>可行性：每一基本操作都可实现，且能在常数时间内完成。</li><li>有穷性：对于任何输入，经有限次的基本操作，都可以得到输出。</li></ol><h4 id="一个好的算法"><a href="#一个好的算法" class="headerlink" title="一个好的算法"></a>一个好的算法</h4><ol><li><p>正确，即符合语法，能够编译、链接。</p><blockquote><p>能够正确处理<strong>简单的</strong>、<strong>大规模的</strong>、<strong>一般性的</strong>、<strong>退化的</strong>、<strong>任意合法</strong>的输入。</p></blockquote></li><li><p>健壮，能够辨别不合法的输入并做适当处理，而不致非正常退出。</p></li><li><p>可读，结构化 <code>+</code> 准确命名 <code>+</code> 注释 <code>+</code> …。</p></li><li><p>效率，运行速度尽可能快，用到的存储空间尽可能少。</p></li></ol><h4 id="常见的算法"><a href="#常见的算法" class="headerlink" title="常见的算法"></a>常见的算法</h4><ol><li><p>查找</p><p> 顺序查找、二分查找、插值查找、斐波那契查找、分块查找和哈希查找等。</p></li><li><p>排序</p><p> 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序和希尔排序等。</p></li><li><p>递归、分而治之、动态规划、回溯法和分支定界法等。</p></li></ol><p>要对数据结构和算法设计方法给予评价，就必须能够计算程序性能。</p><h4 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h4><ul><li><p>数据结构(<code>data structures</code>) + 算法(<code>algorithms</code>) = 程序(<code>programs</code>)</p></li><li><p><code>(data structures + algorithms) x efficiency = computation</code></p></li></ul><h3 id="程序性能分析"><a href="#程序性能分析" class="headerlink" title="程序性能分析"></a>程序性能分析</h3><p>是指分析一个程序对于内存空间和运行时间的需求。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>指程序运行时临时占用内存的大小。广义上的概念是包括存储算法本身所占用的空间、算法的输入输出数据所占用的空间以及算法在运行过程中临时占用的存储空间这三个方面。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>指运行程序所需要的时间。这里度量的是程序中基本操作执行的次数，它是问题规模<code>n</code>的函数<code>f(n)</code>。记<code>T(n)=O(f(n))</code>，它表示随问题规模<code>n</code>的增大，算法执行时间的增长率和<code>f(n)</code>相同，称作算法的渐进时间复杂度。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>这里的复杂度分析通常指的是最坏时间复杂度分析。</p><ul><li>常数阶<code>O(1)</code></li></ul><p><img src="image-20200101210400776.png" alt=""></p><p>取前三个元素<code>x = S[0]</code>、<code>y = S[1]</code>和<code>z = S[2]</code>，这一步只需执行三次（从特定单元读取元素的）基本操作，耗费<code>O(3)</code>时间。接下来，为确定这三个元素的大小次序，最多需要做三次比较，也需<code>O(3)</code>时间。最后，输出居中的非极端元素只需<code>O(1)</code>时间。因此，上面取非极端元素算法的时间复杂度为：<br><code>T(n) = O(3) + O(3) + O(1) = O(7) = O(1)</code>。</p><ul><li>对数阶<code>O(logn)</code></li></ul><p><img src="image-20200101210742484.png" alt=""></p><p>根据右移运算的性质，每右移一位，<code>n</code>都至少缩减一半。也就是说，至多经过<code>1 + log2n</code>次循环，<code>n</code>必然缩减至<code>0</code>，从而算法终止。因此时间复杂度为：<code>O(1 + log2n) = O(log2n)</code> 。</p><ul><li>线性阶<code>O(n)</code></li></ul><p><img src="image-20200101211150536.png" alt=""></p><ul><li>平方阶<code>O(n)</code></li></ul><p><img src="image-20200101211909446.png" alt=""></p><p>时间复杂度为：<code>O(2n^2 + n + 1) = O(n^2)</code>。</p><h4 id="常见的算法时间复杂度排序"><a href="#常见的算法时间复杂度排序" class="headerlink" title="常见的算法时间复杂度排序"></a>常见的算法时间复杂度排序</h4><p><code>Ο(1) ＜ Ο(logn) ＜ Ο(n) ＜ Ο(nlogn) ＜ Ο(n^2) ＜ … ＜ Ο(2^n) ＜ Ο(n!)</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之实现</title>
      <link href="/hNsvEFKo8ZJPUeMf/"/>
      <url>/hNsvEFKo8ZJPUeMf/</url>
      
        <content type="html"><![CDATA[<h4 id="第5章：实现"><a href="#第5章：实现" class="headerlink" title="第5章：实现"></a>第<code>5</code>章：实现</h4><h5 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款<code>26</code>：尽可能延后变量定义式的出现时间</h5><ul><li>应该延长变量的定义，直到非得使用它时</li><li>应该延后这份定义，直到能够给它初值实参</li></ul><p>对于循环存在的情况：</p><ul><li><p>做法<code>A</code>：定义于循环外</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    w = 取决于 i 的某个值；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>做法<code>B</code>：定义于循环内</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于 i 的某个值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这两种写法的成本如下：</p><ul><li><p>做法<code>A</code>：<code>1</code>个构造函数 + <code>1</code>个析构函数 + <code>n</code>个赋值操作</p></li><li><p>做法<code>B</code>：<code>n</code>个构造函数 + <code>n</code>个析构函数</p></li><li><p>做法<code>A</code>会造成名称<code>w</code>的作用域比做法<code>B</code>更大</p><p>除非（1）你知道赋值成本比构造 + 析构成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法<code>B</code>。</p></li></ul></li></ul><a id="more"></a><h5 id="条款27：尽量少做转型操作"><a href="#条款27：尽量少做转型操作" class="headerlink" title="条款27：尽量少做转型操作"></a>条款<code>27</code>：尽量少做转型操作</h5><p>旧式<code>C</code>转型：</p><ul><li><code>T(expression)</code></li><li><code>(T)expression</code></li></ul><p>新式<code>C++</code>转型：</p><ul><li><p><code>const_cast&lt;T&gt;(expression)</code></p><p>  用来将对象的常量性（<code>const</code>）转除（只有它能办到）。</p></li><li><p><code>dynamic_cast&lt;T&gt;(expression)</code></p><p>  用来执行安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型。</p></li><li><p><code>reinterpret_cast&lt;T&gt;(expression)</code></p><p>  用来执行低级转型，如将一个<code>pointer to in</code>t 转为一个<code>int</code>。很少使用（在条款<code>50</code>中使用过一次）。</p></li><li><p><code>static_cast&lt;T&gt;(expression)</code></p><p>  用来强迫隐式转换，例如将<code>non-const</code>对象转为<code>const</code>对象，将<code>int</code>转为<code>double</code>，将<code>void*</code>指针转为<code>typed</code>指针，或将<code>pointer to base</code>转为<code>pointer to derived</code>。</p></li></ul><p>任何一种类型转换（无论显式转换还是隐式转换）往往都会令编译器编译出运行期间执行的码。如将<code>int</code>转为<code>double</code>会产生一些代码，因为<code>int</code>的底层表述不同于<code>double</code>的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> z = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">// 隐喻的将 Derived* 转换为 Base*</span></span><br></pre></td></tr></table></figure><p>这种情况下有时候会有一个偏移量在运行期被施行于<code>Derived*</code>身上，用来取得正确的<code>Base*</code>指针值。这个例子表明单一对象可能有一个以上的地址（以<code>Base*</code>指向它时的地址和以<code>Derived*</code>指向它时的地址）。</p><p>假设我们有个<code>base class Window</code>和一个<code>derived class Specialwindow</code>，两者都定义了<code>virtual</code>函数<code>onResize</code>。进一步假设<code>Specialwindow</code>的<code>onResize</code>函数被要求首先调用<code>Window</code>的<code>onResize</code>。下面实际上是错的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span> <span class="params">()</span> </span>&#123;...&#125; <span class="comment">// base onResize实现代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Specialwindow</span>:</span> <span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">// derived onResize 实现代码</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).onResize(); <span class="comment">// 将 *this 转型为 Window,</span></span><br><span class="line">                                                <span class="comment">// 然后调用其 onResize;</span></span><br><span class="line">        <span class="comment">// 这不可行!</span></span><br><span class="line">        ... <span class="comment">// 这里进行 Specialwindow 专属行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“<code>*this</code>对象之<code>base class</code>成分”的<strong>暂时副本</strong>身上的<code>onResize</code>！如果<code>Window::onResize</code>修改了对象内容，当前对象其实没被改动，改动的是副本。然而<code>SpecialWindow::onResize</code>内如果也修改对象，当前对象真的会被改动。这使当前对象进入一种“伤残”状态：其<code>base class</code>成分的更改没有落实，而<code>derived class</code>成分的更改倒是落实了。</p><p>正确的做法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Specialwindow</span>:</span> <span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Window::onResize();<span class="comment">// 调用 Window::onResize 作用于 *this 身上</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code>的实现版本执行速度相当慢，应该在注重效率的代码中保持对<code>dynamic_cast</code>的警觉</li><li>优良的<code>C++</code>代码很少使用转型，我们应该尽可能隔离转型动作，通过将它隐藏在某个函数内，使得客户可以调用该函数而不需要将转型放进他们自己代码内</li><li>宁可使用新式转型，也不要使用旧式转型，前者很容易辨识出来</li></ul><h5 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款<code>28</code>：避免返回<code>handles</code>指向对象内部成分</h5><ul><li><code>handles</code>指指针、引用和迭代器</li><li>成员变量的封装性最多只等于“返回其<code>reference</code>”的函数的访问级别</li><li>如果<code>const</code>成员函数不得不传出去一个<code>reference</code>，则最好将返回类型限定为<code>const</code></li><li>有可能会导致空悬的<code>handles</code>，它的生命期却长于其所指对象</li></ul><h5 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款<code>29</code>：为“异常安全”而努力是值得的</h5><p>当异常被抛出时，带有异常安全性的函数会：</p><ul><li>不泄露任何资源</li><li>不允许数据败坏</li></ul><p>较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也少。异常安全码必须提供以下三个保证之一：</p><ul><li><p>基本承诺</p><p>  如果异常被抛出，程序内的任何事物仍然保证在有效状态（只要那是个合法状态）下，没有任何对象或数据结构会因此而败坏，所有对象处于一种内部前后一致的状态。</p></li><li><p>强烈保证</p><p>  如果异常被抛出，程序状态不改变。</p></li><li><p>不抛掷保证</p><p>  承诺绝不抛出异常，因为它们总能完成原先承诺的功能。</p></li></ul><p>可以实现强烈保证的<code>copy and swap</code>技术：为你打算修改的对象做出<code>copy</code>一份副本，然后在副本身上做一切修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。带所有改变都成功后，再将修改后的副本和原对象<code>swap</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之所以实现为 struct 是因为其 PrettyMenu 的数据封装性</span></span><br><span class="line"><span class="comment">// 已经由 pImpl 是 private 获得了保证</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> &#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PMImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pImpl; <span class="comment">// pimpl idiom 详细描述见条款 31</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    <span class="comment">// 见条款25</span></span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 获得mutex的副本数据</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">    pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc)); <span class="comment">// 修改副本</span></span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    swap(pImpl, pNew); <span class="comment">// 置换(swap)数据, 释放 mutex</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意，并非所有函数都可实现强烈保证或其具备现实意义。</p></blockquote><p>函数提供的”异常安全保证“通常最高只等于其所调用各个函数提供的”异常安全保证“中的最弱者。</p><h5 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款<code>30</code>：透彻了解<code>inlining</code>的里里外外</h5><p><code>inline</code>函数是指将对此函数的每一个调用都以函数本体替换之。这将导致两种情况：</p><ul><li>目标码增加（显然）</li><li>如果<code>inline</code>函数的体积很小，编译器对“函数本体”所产出的码可能比“函数调用”所产出的码小</li></ul><p><code>inline</code>只是对编译器的一个申请，不是强制命令，也就是说编译器可以拒绝将太过复杂（带有递归或循环）的函数进行<code>inline</code>。通过对函数使用<code>inline</code>关键字属于明确提出申请，将函数定义于类内属于隐喻申请。</p><ul><li><p>将大多数<code>inline</code>限制在小型、被频繁调用的函数身上</p></li><li><p><code>inline</code>函数通常一定被置于头文件内</p><p>  因为大多数构建环境在编译过程中进行<code>inlining</code>，而为了将一个函数调用替换为被调用函数的本体，编译器必须知道那个函数长什么样子。</p></li><li><p>所有对<code>virtual</code>函数的<code>inline</code>申请都会被拒绝（因为对<code>virtual</code>函数的调用在运行期才确定）</p></li></ul><h5 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款<code>31</code>：将文件间的编译依存关系降至最低</h5><ul><li><p>将接口从实现中分离</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> theName; <span class="comment">// 实现细目</span></span><br><span class="line">    Date theBirthDate; <span class="comment">// 实现细目</span></span><br><span class="line">    Address theAddress; <span class="comment">// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这里的<code>class</code>无法通过编译，因为编译器没有取得其实现代码所用到的<code>class string</code>，<code>Date</code>，<code>Address</code>的定义式，通常应该在<code>Person</code>定义文件的最上方存在<code>include</code>头文件。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"date.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"address.h"</span></span></span><br></pre></td></tr></table></figure><p>  不幸的是，这么一来便是在<code>Person</code>定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其他头文件有任何改变，那么每一个含入<code>Person class</code>的文件就得重新编译，任何使用<code>person class</code>的文件也必须重新编译。这样的连串编译依存关系（<code>cascading compilation dependencies</code>）会对许多项目造成难以形容的灾难。</p></li><li><p><code>Handle classes</code>：<code>pimpl idiom</code>(<code>pointer to implenmentation</code>) + 前向声明</p><p>  把<code>Person</code>分割成两个<code>class</code>，一个只提供接口，另一个负责实现接口。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //标准程序库组件不该被前向声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向声明而不是包含头文件, 这个很关键</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span> <span class="comment">// Person 实现类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 接口用到的 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl; <span class="comment">// 指针, 指向实现物</span></span><br><span class="line">    <span class="comment">// 如果不这样做的话, 编译器在编译 Person 类的时候，必须知道 Person 类的大小</span></span><br><span class="line">    <span class="comment">// 就不得不包含这三个实现细目</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    string theName; // 实现细目</span></span><br><span class="line"><span class="comment">Date theBirthDate; // 实现细目</span></span><br><span class="line"><span class="comment">Address theAddress; // 实现细目</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 然而一旦这样写, 前面的前向声明就没用了, 必须包含头文件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这样一来，<code>Person</code>类的使用者就完全于<code>Date</code>，<code>Address</code>以及<code>Person</code>的实现细目相分离了。这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：实现上让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。</p><p>  几个简单的设计策略：</p><ul><li><p>如果使用<code>object reference</code>或<code>object pointer</code>可以完成任务，就不要使用<code>object</code></p><p>  你可以只靠一个类型声明式就定义出指向该类型的<code>reference</code>和<code>pointer</code>；但如果定义某类型的<code>object</code>，就需要用到该类型的定义式。</p></li><li><p>如果能够，尽量以<code>class</code>声明式替换<code>class</code>定义式</p><p>  注意，当你声明一个函数而它用到某个<code>class</code>时，你并不需要该<code>class</code>的定义。</p></li><li><p>为声明式和定义式提供不同的头文件</p><p>  对于前面代码中的前向声明，最好是提供一个声明式头文件，包含全部的前向声明。</p><p>下面式<code>Person.cpp</code>文件的部分实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Person.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;PersonImpl.h&gt; </span></span></span><br><span class="line"><span class="comment">// 注意，Person 和PersonImpl的成员函数完全相同, 两者接口完全相同</span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span><br><span class="line">        <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">        <span class="keyword">const</span> Address&amp; addr) : pImpl(<span class="keyword">new</span> PersonImpl(name, birthday,addr)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::narne</span><span class="params">( )</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pImpl-&gt;name();&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Interface classes</code>：<code>abstract base class</code> + <code>factory</code>函数</p><p>  <code>abstract base class</code>通常没有成员变量，也没有构造函数，只有一个<code>virtual</code>析构函数和一组<code>pure virtual</code>函数。但<code>Interface class</code>的客户必须有办法为这种<code>class</code>创建新对象。他们通常调用一个特殊函数，此函数创建实际实现的<code>derived class</code>，这样的函数通常称为<code>factory</code>(工厂）函数（见条款<code>13</code>），它们返回智能指针指向动态分配所得对象，而该对象支持<code>Interface class</code>的接口。这样的函数又往往在<code>Interface class</code>内被声明为<code>static</code>：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 Person.h</span></span><br><span class="line"><span class="comment">// 抽象基类, 只有声明</span></span><br><span class="line"><span class="comment">// 提供给客户使用的头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> strng <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> strng <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// static 的 factory 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Address&amp; addr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于 Person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealPerson(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span><br><span class="line">               <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="keyword">const</span> Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RealPerson() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 虚函数的实现码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>Handle classes</code>和<code>Interface classes</code>解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之设计与声明</title>
      <link href="/S0Qfg61EKNlwLo15/"/>
      <url>/S0Qfg61EKNlwLo15/</url>
      
        <content type="html"><![CDATA[<h4 id="第4章：设计与声明"><a href="#第4章：设计与声明" class="headerlink" title="第4章：设计与声明"></a>第<code>4</code>章：设计与声明</h4><h5 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款<code>18</code>：让接口容易被正确使用，不容易被误用</h5><ul><li>如果客户企图使用某个接口却没有获得所预期的行为，这个代码不应该通过编译；如果代码通过了编译，则它的行为就应该是客户想要的</li><li>欲达“让接口容易被正确使用，不容易被误用”的目的，必须考虑客户调用接口时可能做出什么样的错误</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型兼容</li><li>“阻止误用”的办法包括建立新类型、限制在类型上的操作，束缚对象值以及消除客户的资源管理责任</li></ul><a id="more"></a><h5 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款<code>19</code>：设计class犹如设计<code>type</code></h5><p>你应该带着“语言设计者当初设计语言内置类型时”一样的谨慎来研讨每一个<code>class</code>的设计。因为，重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结…全都在你手上。</p><ul><li><p>新的<code>type</code>的对象应该如何创建和销毁？</p><p>  设计函数为类的构造函数和析构函数以及内存分配函数和释放函数（见条款<code>49-52</code>）。</p></li><li><p>对象的初始化和对象的赋值该有什么样的差别？</p><p>  决定了构造函数和赋值操作符的行为以及差异。</p></li><li><p>新<code>type</code>的对象被<code>passed by value</code>，意味着什么？</p><p>  取决于<code>copy</code>构造函数的实现。</p></li><li><p>什么新<code>type</code>的合法值？</p></li><li><p>你的新<code>type</code>需要配合某个继承图系吗？</p><p>  见条款<code>7</code>、<code>34</code>、<code>36</code>。</p></li><li><p>你的新<code>type</code>需要什么样的转换？</p><p>  <code>explicit</code>和<code>operator</code>关键字的使用。见条款<code>15</code>。</p></li><li><p>什么样的操作符和函数对此新<code>type</code>而言时合理的？</p><p>  见条款<code>23</code>、<code>24</code>、<code>46</code>。</p></li><li><p>什么样的标准函数应该驳回？</p><p>  见条款<code>6</code>。</p></li><li><p>谁该取用新<code>type</code>的成员？</p><p>  决定了数据成员是<code>public</code>、<code>private</code>还是<code>protected</code>，以及<code>friend</code>关键的使用。</p></li><li><p>什么是新<code>type</code>的“未声明接口”？</p><p>  见条款<code>29</code>。</p></li><li><p>你的新<code>type</code>有多么一般化？</p><p>  决定<code>class template</code>的使用。</p></li><li><p>你真的需要一个新<code>type</code>吗？</p></li></ul><h5 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass by reference to const替换pass by value"></a>条款<code>20</code>：宁以<code>pass by reference to const</code>替换<code>pass by value</code></h5><ul><li>当把具有继承关系的类作为参数传递时，如果<code>pass by value</code>可能会出现“截断”问题。</li></ul><h5 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款<code>21</code>：必须返回对象时，别妄想返回其<code>reference</code></h5><ul><li>绝不要返回指向一个<code>local stack</code>对象的<code>pointer</code>或<code>reference</code></li><li>绝不要返回指向一个<code>heap allocated</code>对象的<code>reference</code></li><li>除非有单例模式的设计要求，否则绝对不要返回指向一个<code>local static</code>对象的<code>pointer</code>或<code>reference</code></li></ul><h5 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款<code>22</code>：将成员变量声明为<code>private</code></h5><ul><li><p>客户访问数据的一致性</p><p>  <code>public</code>里都是函数。</p></li><li><p>可以对成员变量有更精确的控制</p><p>  可以实现成员变量的不可访问，只读、只写、读写访问。</p></li><li><p>封装性</p><p>  将成员变量隐藏在函数接口背后，可以为所有可能的实现提供弹性。</p></li><li><p>从封装的角度看，只有两种权限：<code>private</code>（提供封装）和其它</p><p>  <code>protected</code>并不比<code>private</code>更具封装性。</p></li></ul><h5 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款<code>23</code>：宁以<code>non-member</code>、<code>non-friend</code>替换<code>member</code>函数</h5><p>考虑一个用来表示网页浏览器的<code>class</code>，这个<code>class</code>提供的众多成员函数中，有用来清除下载元素高速缓冲区的，有用来清除访问过的历史记录的，有用来移除系统中所有<code>cookies</code>的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleatCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户想一整个执行所有的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以提供一个 member 函数的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverthing</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以提供一个 non-member 函数的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wb.clearCache();</span><br><span class="line">    wb.clearHistory();</span><br><span class="line">    wb.cleatCookies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后者比较好。因为：</p><ul><li><p>增加封装性</p><p>  <code>non-member non-friend</code>将提供较大的封装性，因为它并不增加能够访问<code>class</code>内的<code>private</code>成分的函数数量。<code>friend</code>函数对<code>class private</code>成员的访问权力和<code>member</code>函数相同，两者对封装的冲击力度是一样的。</p></li><li><p>增加扩充机能性</p><p>  在<code>C++</code>中，正确且自然的做法是：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span>...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>; <span class="comment">// 为 WebBrowser “提供便利”的函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>namespace</code>和<code>class</code>的不同是，前者可跨越多个源码文件而后者不能。</p><p>像<code>WebBrowser</code>这样的类可能有大量的“提供便利”函数，某些与书签有关，与打印有关，与<code>cookie</code>有关… 分离它们最直接的做法就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 WebBrowser.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span>...&#125;;</span><br><span class="line">    ... <span class="comment">// 核心机能, 例如所有客户都想要的 non-member 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件 WebBrowserBookmarks.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 与书签相关的 non-member 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件 WebBrowserCookies.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 与 cookie 相关的 non-member 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有“便利函数”放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组“便利函数”。</p></li></ul></li></ul><h5 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款<code>24</code>：若所有参数皆需类型转换，请为此采用<code>non-member</code>函数</h5><ul><li><p>有理数类<code>Rational</code>的实现</p><p>  重点关注用来将两个有理数相乘的<code>operator*</code>操作符重载函数的实现方式。</p></li></ul><h5 id="条款25：考虑写出一个不抛异常的swap函数"><a href="#条款25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛异常的swap函数"></a>条款<code>25</code>：考虑写出一个不抛异常的<code>swap</code>函数</h5><p>标准程序库提供的<code>swap</code>算法的典型实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要<code>T</code>类型支持<code>copying</code>函数（<code>copy</code>构造函数和<code>copy assignment</code>操作符）。对于用户自定义类型，效率低下（需要三次复制）。</p><p>现在考虑所谓的<code>pimpl(pointer to implementation)</code>实现手法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这是个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 细节不重要</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ... <span class="comment">// 有很多数据, 意味着复制时间很长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这是个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&lt;T&gt;&amp; rhs);</span><br><span class="line">    <span class="comment">// 关于 operator= 的一般性实现参考条款 10, 11, 12</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl&lt;T&gt;* pImpl; <span class="comment">// 指向实际实现的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一旦需要置换两个<code>Widget</code>对象值，我们实际唯一需要的是置换两个指针即可。但缺省的<code>swap</code>函数不知道这一点！</p><p>下面是正确的实现步骤：</p><ol><li><p>令<code>Widget</code>实现一个名为<code>swap</code>的<code>public</code>成员函数做真正的置换工作</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 必须的</span></span><br><span class="line">        swap(pImpl, other.pImpl); <span class="comment">// 直接置换指针即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>std::swap</code>特化，令它调用该成员函数<strong>（当<code>Widget</code>是类时。这里的例子中，<code>Widget</code>是个模板类则不要这一步）</strong></p><ul><li><p>因为，<code>C++</code>只允许对<code>class template</code>偏特化，不允许对<code>function template</code>进行偏特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.swap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>声明一个<code>non-member swap</code>，令它调用<code>member swap</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意, 要将它放在和 Widget&lt;T&gt; 同一个空间内(全局或者自定义的 namespace)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编程时，在调用<code>swap</code>置换对象的语句之前加上<code>using std::swap</code>声明</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户代码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1. T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 令 std::swap 在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    swap(obj1, obj2); <span class="comment">// 这样一来, 编译器将为 T 类型对象调用最佳版本 swap</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译器首先在全局作用域或<code>T</code>所在命名空间内寻找<code>T</code>（在这里，<code>T</code>就是例子中的<code>Widget</code>哦）专属的<code>swap</code>（也就是步骤<code>3</code>中实现的）。如果没有实现这些，则调用<code>std</code>内的<code>swap</code>，如果步骤<code>2</code>还实现了特化版本，将会选中特化版本。</p></li></ol><ul><li><p>劝告，<code>member swap</code>绝不可抛出异常</p><p>  具体参考条款29。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之资源管理</title>
      <link href="/ojSMOM86r5rbvAqL/"/>
      <url>/ojSMOM86r5rbvAqL/</url>
      
        <content type="html"><![CDATA[<h4 id="第3章：资源管理"><a href="#第3章：资源管理" class="headerlink" title="第3章：资源管理"></a>第<code>3</code>章：资源管理</h4><h5 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款<code>13</code>：以对象管理资源</h5><ul><li><p><code>RAII</code>(<code>Resource Acquisition Is Initialization</code>)</p><p>  使用<code>new</code>获取资源后于同一条语句内以它初始化某个资源管理对象。利用当管理对象离开作用域被销毁时自动调用其析构函数的机制确保资源被释放。不直接用<code>new</code>和<code>delete</code>，多用智能指针。</p></li><li><p>智能指针在其析构函数中做<code>delete</code>动作而非<code>delete[]</code>动作</p><p>  因此，不要在动态分配来的数组身上使用智能指针（虽然它仍然会通过编译）。</p></li></ul><a id="more"></a><h5 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款<code>14</code>：在资源管理类中小心<code>copying</code>行为</h5><ul><li>当不想<code>RAII</code>类被复制时可以继承<code>Uncopyable</code>类</li></ul><p>将智能指针施于<code>heap-based</code>资源身上是个好主意，但并不是所有资源都是<code>heap-based</code>的，比如互斥器<code>mutex</code>，<code>mutex</code>就不可复制。</p><h5 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款<code>15</code>：在资源管理类中提供对原始资源的访问</h5><ul><li><p>显示转换（安全）</p><p>  例如，<code>shared_ptr</code>类就提供可一个<code>get</code>成员函数来返回智能指针内部的原始指针。</p></li><li><p><code>operator</code>隐式转换（调用方便）</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// operator 可以实现隐式转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B b; <span class="comment">// B 类型对象成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受 B 类型对象的一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(B b)</span></span>;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">func(a); <span class="comment">// a 会被编译器隐式转换为 B 类型对象</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="条款16：使用new和delete时要采用相同的形式"><a href="#条款16：使用new和delete时要采用相同的形式" class="headerlink" title="条款16：使用new和delete时要采用相同的形式"></a>条款<code>16</code>：使用<code>new</code>和<code>delete</code>时要采用相同的形式</h5><ul><li><p>编译器在给数组分配内存时，会包括数组大小的记录</p><p>  这样的好处是，<code>delete[]</code>时知道需要调用多少次析构函数。</p></li><li><p>不要对数组形式进行<code>typedef</code>动作</p></li></ul><h5 id="条款17：以独立语句将new来的对象置入智能指针"><a href="#条款17：以独立语句将new来的对象置入智能指针" class="headerlink" title="条款17：以独立语句将new来的对象置入智能指针"></a>条款<code>17</code>：以独立语句将<code>new</code>来的对象置入智能指针</h5><p>考虑这样两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>; <span class="comment">// 调用这个函数不排除会发生异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><p>如果这样调用编译不通过，因为<code>shared_ptr</code>接收原始指针的构造函数是<code>explicit</code>的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="keyword">new</span> Widget, priority());</span><br></pre></td></tr></table></figure><p>如果这样调用可能会造成内存泄漏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure><p>因为编译器在编译这条语句时，实际上会创建三个动作：</p><ul><li>调用<code>priority()</code></li><li>执行<code>new Widget</code></li><li>调用<code>shared_ptr</code>的构造函数</li></ul><p>而<code>C++</code>编译器安排这三个动作的次序是不确定的。</p><p>如果执行次序是这样：</p><ol><li>执行<code>new Widget</code></li><li>调用<code>priority()</code></li><li>调用<code>shared_ptr</code>的构造函数</li></ol><p>一旦中途<code>priority()</code>导致异常，那么<code>new</code>返回的原始指针并未交给智能指针保管，将造成资源泄露。</p><p>正确的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure><p>因为，编译器对“跨越语句的各项操作”没有重新排列执行次序的自由。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之构造、析构、赋值运算</title>
      <link href="/MeCvwFxjI4asjddf/"/>
      <url>/MeCvwFxjI4asjddf/</url>
      
        <content type="html"><![CDATA[<h4 id="第2章：构造、析构、赋值运算"><a href="#第2章：构造、析构、赋值运算" class="headerlink" title="第2章：构造、析构、赋值运算"></a>第<code>2</code>章：构造、析构、赋值运算</h4><h5 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款<code>05</code>：了解<code>C++</code>默默编写并调用哪些函数</h5><ul><li><p>编译器会暗自为<code>class</code>创建<code>default</code>构造函数、<code>copy</code>构造函数、<code>copy assignment</code>操作符以及析构函数</p></li><li><p>对于<code>class</code>内含<code>reference</code>成员或<code>const</code>成员，编译器拒绝为其生成<code>copy</code>构造函数和<code>copy assignment</code>操作符</p><blockquote><p>因为<code>C++</code>不允许<code>reference</code>改指向不同的对象以及更改<code>const</code>成员。 </p></blockquote></li></ul><a id="more"></a><h5 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款<code>06</code>：若不想使用编译器自动生成的函数，就该明确拒绝</h5><ul><li><p>为驳回编译器自动提供的函数，可将相应的成员函数声明为<code>private</code>并且不予实现。</p></li><li><p>掌握<code>Uncopyable</code>类的实现机制</p><ul><li><p>将构造函数和析构函数设置为<code>protected</code>的</p></li><li><p>将拷贝构造函数和拷贝赋值运算符设置为<code>private</code>的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable() &#123;&#125;</span><br><span class="line">    ~Uncopyable() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">    <span class="keyword">const</span> Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款<code>07</code>：为多态基类声明<code>virtual</code>析构函数</h5><ul><li><p>带多态性质的<code>base class</code>应该声明一个<code>virtual</code>析构函数</p></li><li><p>当<code>class</code>内至少含有一个<code>virtual</code>函数，才为它声明<code>virtual</code>析构函数</p></li><li><p><code>class</code>的设计目的如果不是作为<code>base class</code>使用，或不是为了具备多态性，就不该声明<code>virtual</code>析构函数</p></li><li><p>然而，有时候你希望拥有一个抽象类，但没有任何需要的<code>pure virtual</code>方法，怎么办？</p><p>  由于<code>abstract class</code>（不能实例化）总是被期望当作多态基类，多态基类又需要<code>virtual</code>析构函数，而<code>pure virtual</code>函数会导致<code>abstract class</code>，因此可将析构函数声明为<code>pure virtual</code>并且给出默认实现。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小技巧:pure virtual 析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AWOV::~AWOV() &#123;<span class="comment">/* default */</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款<code>08</code>：别让异常逃离析构函数</h5><ul><li>析构函数绝对不要吐出异常</li></ul><p>假设有一个类负责数据库的连接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; <span class="comment">// 关闭联机, 失败则抛出异常</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了确保客户不忘记在<code>DBConnection</code>对象上调用<code>close</code>函数，一个合理的想法是创建一个用来管理<code>DBConnection</code>资源的类，并在析构函数中调用<code>close</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~DBConn()</span><br><span class="line">    &#123;</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户可以写出这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 区块作用域结束，调用析构函数销毁对象</span></span><br></pre></td></tr></table></figure><p>如果被析构函数调用的函数<code>close</code>可能抛出异常，析构函数应该捕获异常然后吞下它们或者结束程序。</p><p>一个好的策略是，开放一个<code>close</code>接口供用户调用，把调用<code>close</code>的责任从<code>DBConn</code>析构函数手上移到用户手上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.close();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DBConn()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                 db.close(); <span class="comment">// 关闭连接（如果客户没做的话）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(...)</span><br><span class="line">            &#123;</span><br><span class="line">                日志记录下对 close 调用的失败;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，如果客户需要对某个操作函数运行期间的异常作出反应，那么<code>class</code>应该提供一个接口执行该操作。如果<code>close</code>的确发生了异常，而客户没有调用<code>close</code>接口进行处理，<code>DBConn</code>只能吞下或结束程序。</p><h5 id="条款09：绝不在析构和构造函数中调用virtual函数"><a href="#条款09：绝不在析构和构造函数中调用virtual函数" class="headerlink" title="条款09：绝不在析构和构造函数中调用virtual函数"></a>条款<code>09</code>：绝不在析构和构造函数中调用<code>virtual</code>函数</h5><ul><li>派生类对象内的基类成分会在派生类自身成分被构造之前先被构造</li><li>基类构造期间，虚函数绝不会下降到派生类层</li></ul><p>需要注意的是，有时类有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复时会把相同的初始化代码放到一个<code>init</code>函数中实现，如果这时在<code>init</code>函数中同样调用了虚函数，情况是一样的但<strong>比较隐秘</strong>。 </p><h5 id="条款10：令赋值操作符operator-返回一个reference-to-this"><a href="#条款10：令赋值操作符operator-返回一个reference-to-this" class="headerlink" title="条款10：令赋值操作符operator=返回一个reference to *this"></a>条款<code>10</code>：令赋值操作符<code>operator=</code>返回一个<code>reference to *this</code></h5><ul><li>为了实现连续赋值</li></ul><h5 id="条款11：在operator-中处理自我赋值"><a href="#条款11：在operator-中处理自我赋值" class="headerlink" title="条款11：在operator=中处理自我赋值"></a>条款<code>11</code>：在<code>operator=</code>中处理自我赋值</h5><ul><li>有些自我赋值并不明显，如通过指针或引用</li></ul><p>假设你建立一个<code>class</code>来保存一个指针指向一块动态分配的位图（<code>bitmap</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb; <span class="comment">// 指向一个从 heap 分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>错误的<code>operator=</code>实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自我赋值不安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过一个“证同测试”来检验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自我赋值安全, 但不具备异常安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的异常安全指的是，如果<code>new Bitmap</code>发生异常，会导致<code>Widget</code>最终会持有一个指针指向一块被删除的<code>Bitmap</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具备异常安全, 则自动具备自我赋值安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* oldPb = pb; <span class="comment">// 记住之前的 pb</span></span><br><span class="line">    </span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">delete</span> oldPb;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用更好的<code>copy and swap</code>技术：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 交换 *this 和 rhs 的数据, 见条款 25</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提升点效率 ?</span></span><br><span class="line">    <span class="comment">// if(this == &amp;rhs)</span></span><br><span class="line">    <span class="comment">//     return *this;</span></span><br><span class="line">    </span><br><span class="line">    Widget temp(rhs); <span class="comment">// copy</span></span><br><span class="line">    </span><br><span class="line">    swap(temp); <span class="comment">// swap</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="条款12：复制对象时勿忘每一个成分"><a href="#条款12：复制对象时勿忘每一个成分" class="headerlink" title="条款12：复制对象时勿忘每一个成分"></a>条款<code>12</code>：复制对象时勿忘每一个成分</h5><ul><li>每一个成分包括对象内所有成员变量以及所继承的<strong>基类成分</strong><ul><li>在拷贝构造函数中的初始化列表中调用所继承的类的拷贝构造函数</li><li>在拷贝赋值操作符函数中调用所继承的类的拷贝赋值操作符函数</li></ul></li><li>不要尝试让拷贝构造函数和拷贝赋值操作符函数互相调用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之让自己习惯C++</title>
      <link href="/l4snoL8SUW9lGasI/"/>
      <url>/l4snoL8SUW9lGasI/</url>
      
        <content type="html"><![CDATA[<h4 id="第1章：让自己习惯C"><a href="#第1章：让自己习惯C" class="headerlink" title="第1章：让自己习惯C++"></a>第<code>1</code>章：让自己习惯<code>C++</code></h4><h5 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款<code>01</code>：视<code>C++</code>为一个语言联邦</h5><ul><li>将<code>C++</code>视为由<code>4</code>个次语言组成的联邦：<ul><li><code>C</code>：没有模板、没有异常、没有重载…</li><li><code>Object-Oriented C++</code>：类、封装、继承、多态、虚函数、动态绑定等等；</li><li><code>Template C++</code>：泛型编程部分；</li><li><code>STL</code>：是一个<code>Template</code>程序库，容器、迭代器、算法以及函数对象。</li></ul></li></ul><p>从某个此语言切换到另一个时，高效编程守则可能会发生变化。比如，<code>C-like</code>类型（内置类型）<code>pass by value</code>更好；对于<code>Object-Oriented C++</code>而言，<code>pass by reference to-const</code>更好；再切换到<code>STL</code>，由于迭代器和函数对象都是在<code>C</code>指针之上塑造出来的，<code>pass by value</code>守则再次适用。</p><a id="more"></a><h5 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款<code>02</code>：尽量以<code>const</code>，<code>enum</code>，<code>inline</code>替换<code>#define</code></h5><ul><li><p>对于单纯常量，最好以<code>const</code>对象或<code>enum hack</code>替换<code>#define</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记号名称未进入符号表, 难以调试</span></span><br><span class="line"><span class="comment">// 在多处出现目标码, 尤其浮点常量</span></span><br><span class="line"><span class="comment">// 无作用域概念, 不提供任何封装性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量会被编译器看到, 进入符号表</span></span><br><span class="line"><span class="comment">// 导致较小量的目标码, 因为只有一份</span></span><br><span class="line"><span class="comment">// 可放置在类内或 namespace 中限制其作用域</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以放在类或 namespace 中</span></span><br><span class="line"><span class="comment">// 令 NumTurns 成为 5 的记号名称, 一般用在类中做常量用</span></span><br><span class="line"><span class="comment">// 行为像 #define, 对 const 取地址合法，对 enum 和 #define 取地址就不合法</span></span><br><span class="line"><span class="keyword">enum</span> &#123;NumTurns = <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>对于形似函数的宏，最好用<code>inline</code>（或模板）函数替换</p><p>  宏中的变量有可能会被运算多次。</p></li></ul><h5 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款<code>03</code>：尽可能使用<code>const</code></h5><ul><li><p><code>const</code>作用于迭代器</p><p>  <code>STL</code>迭代器是以指针为根据塑模出来的，其作用就像个<code>T*</code>指针。声明迭代器为<code>const</code>只是声明一个<code>const</code>指针（作用就像<code>T* const</code>），表明的是迭代器本身不可变，但其所指的值是可以改动的。如果希望迭代器所指的值不可改动，需要的是<code>const_iterator</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line">*iter = <span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">++iter; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator citer = vec.begin();</span><br><span class="line">*citer = <span class="number">10</span>; <span class="comment">// 错误</span></span><br><span class="line">++citer; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>将<code>operator*</code>的返回类型声明为<code>const-by-value</code></p></li><li><p><code>const</code>可被施加于任何作用域内的对象、函数参数（常用<code>pass-by-reference-to-const</code>），函数返回类型、类成员函数本体</p></li><li><p><code>const</code>施加于成员函数</p><p>  成员函数上的<code>const</code>限定符意味着不能修改<code>non-mutable</code>，<code>non-static</code>类数据成员。</p></li><li><p>当<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>成员函数调用<code>const</code>版本可避免代码重复</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验</span></span><br><span class="line">        ... <span class="comment">// 日记数据访问</span></span><br><span class="line">        ... <span class="comment">// 检验数据完整性</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    char&amp; operator[](std::size_t position)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ... // 边界检验</span></span><br><span class="line"><span class="comment">        ... // 日记数据访问</span></span><br><span class="line"><span class="comment">        ... // 检验数据完整性</span></span><br><span class="line"><span class="comment">        return text[position];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用 const_cast 移除对象身上的 const</span></span><br><span class="line">        <span class="comment">// 调用 static_cast 为 *this 加上 cosnt</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBook&amp;&gt;(*<span class="keyword">this</span>)[position]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>const</code>版本成员函数调用<code>non-const</code>版本不合法</p></li></ul><h5 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款<code>04</code>：确定对象被使用前已先被初始化</h5><ul><li><p>为内置型对象进行手工初始化，因为<code>C++</code>并不保证初始化它们</p></li><li><p>构造函数使用成员初始化列表，初始化顺序与在类中声明顺序一致</p></li><li><p>为避免“跨编译单元内定义的<code>non-local static</code>对象的初始化问题”，以<code>local</code>对象替换<code>non-local static</code>对象</p><ul><li><code>static</code>对象包括<code>global</code>对象、定义与<code>namespace</code>作用域内的对象、在<code>class</code>内、函数内、以及在<code>file</code>作用域内被声明为static的对象</li><li>函数内的<code>static</code>被称为<code>local static</code>对象，其它<code>static</code>对象被称为<code>non-local static</code>对象</li><li>程序结束时，<code>static</code>对象会被自动销毁，也就是它们的析构函数在<code>main</code>函数结束时被自动调用</li><li>编译单元是指产出单一目标文件的源码文件以及所含入的头文件</li></ul></li></ul><p>现在有两个源码文件，每个至少含入一个<code>non-local static</code>对象，其中一个<code>non-local static</code>对象用到了另一个<code>non-local static</code>对象，而被用到的尚未被初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 FileSystem.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span><span class="keyword">const</span></span>; <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs; <span class="comment">// 预备给客户使用的对象, non-local static 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 Directory.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(); <span class="comment">// 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks(); <span class="comment">// 使用 tfs 对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在客户决定创建一个Directory对象，用来放置临时文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Directory tempDir; <span class="comment">// 为临时文件而做出的目录</span></span><br></pre></td></tr></table></figure><p>这个时候就会出现初始化次序带来的问题。由于<code>tfs</code>和<code>tempDir</code>是不同的人在不同的时间于不同的源码文件中创建出来的，因此初始化次序不一定。</p><p>解决方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 FileSystem.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> <span class="comment">// 用于创建预备给客户使用的对象的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs; <span class="comment">// local static 对象</span></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 Directory.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(); <span class="comment">// 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这样就保证了被使用对象先被初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks(); <span class="comment">// 使用 tfs() 创建对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
