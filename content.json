[{"title":"一种在Linux平台下的划词翻译工具原理及实现","date":"2020-06-12T13:35:42.000Z","path":"20200602/","text":"欢迎分享，转载务必注明来源！ --- 这里将要介绍的是一种在 Linux 平台实现的划词翻译工具，当然在考虑自己实现一个如此功能的工具前，本人也是在网上搜索了一些在 Linux 平台实现的类似的开源工具，例如 pdfTranslator，popup-dict，但它们的安装和配置都显得比较麻烦，而且使用起来也并不方便。 本人实现这个工具的初衷本是方便自己看一些英文文献和书籍的，极为方便，考虑到分享出去可以让更多人受惠，因此这里详细介绍一下它的实现步骤。 本文所实现的划词翻译工具主要有以下特性： 支持英文单词和短语到中文的翻译 划词翻译，终端显示 自动过滤选中文本中的换行等特殊字符 只依赖少数几个 Linux 命令工具 下面有动图进行演示。 本人所使用的环境是运行在 VMware 虚拟机下的 Linux 发行版 Ubuntu 18.04.3 LTS ，因此这里介绍的步骤可能与其他 Linux 发行版中的实现略有不同。下面就来一步一步的实现它吧。 一. 安装必要的命令 xclip 1$ sudo apt install xclip xclip 命令建立了终端和剪切板之间通道，可以用命令的方式将终端输出或文件的内容保存到剪切板中，也可以将剪切板的内容输出到终端或文件。详细的用法可以使用 man xclip，见其手册。这里介绍几个常用的用法。 1234$ xclip file_name # 文件内容保存到X window剪切板$ xclip -selection c file_name #文件内容保存到外部剪切板$ xclip -o # X window剪切板内容输出到终端显示$ xclip -selection c -o # 外部剪切板内容输出到终端显示 值得强调的是，这里所说的 X window 剪切板，简单的说就是你用鼠标选择的文本会实时的存放在这个剪切板，使用鼠标中键可以粘贴。而外部剪切板是保存你用 ctrl+c 复制的文本，ctrl+v 可以粘贴。这两个地方是不一样的。 translate-shell 1$ sudo apt install translate-shell 这是命令行版的谷歌翻译工具，之前叫做 Google Translate CLI 是一款借助谷歌翻译（默认）、必应翻译等来翻译的命令行翻译器。它让你可以在终端访问这些翻译引擎。 translate-shell 在大多数 Linux 发行版中都能使用。常用的方法如下： 12$ trans en:zh [word] # 英文到中文的单词翻译$ trans en:zh -b [text] # 简要的输出，进行文本翻译 需要注意的是，使用这个翻译工具需要你能够访问外网，或者通过修改 translate-shell 的默认翻译引擎，具体的方法这里就不阐述了。 二. 编程实现这个工具整体的思路就是 C 程序实时检测鼠标按键的动态，当检测到用户使用鼠标选择一段文本之后，调用 shell 脚本获取 X window 剪切板的内容进行翻译后输出到终端显示。 1. 定位鼠标设备文件 鼠标作为输入设备。其信息可以在文件 /proc/bus/input/devices 中，使用下列命令查看： 1234567891011$ sudo cat /proc/bus/input/devicesI: Bus=0011 Vendor=0002 Product=0013 Version=0006N: Name=\"VirtualPS/2 VMware VMMouse\"P: Phys=isa0060/serio1/input1S: Sysfs=/devices/platform/i8042/serio1/input/input4U: Uniq=H: Handlers=mouse0 event2 B: PROP=0B: EV=bB: KEY=70000 0 0 0 0B: ABS=3 其中的 Handlers 的值 event2 表示可以在 /dev/input/event2 文件下读取鼠标的状态。需要注意的是，对于不同的设备，读取鼠标的状态的文件可能不一样，比如也可能是 /dev/input/event3。我们可以使用下面的命令找到你的鼠标对应的是哪一个 event。 1$ sudo cat /dev/input/event2 | hexdump # 测试时改变数字即可 比如，当我运行上面这条命令之后，我移动鼠标、按鼠标左键/中键/右键，终端都会输出一些值，这就说明 event2 文件就是对应着我的鼠标。如果操作鼠标没有反应，说明这个就不是。你可以通过这种方法找到你的鼠标对应的 event 文件。 2. Linux 下获取按键响应 在 Linux 内核中，input 设备用 input_dev 结构体描述，使用 input 子系统实现输入设备驱动的时候，驱动的核心工作就是向系统报告按键、触摸屏、键盘、鼠标等输入事件（event*，通过 *input_event 结构体描述），不再需要关心文件操作接口，因为 input 子系统已经完成了文件操作接口 Linux/input.h 这个文件定义了 event 事件的结构体，API 和标准按键的编码等。 12345678910111213141516171819202122232425// 结构体定义见 input.hstruct input_event &#123; struct timeval time; // 按键时间 __u16 type; // 事件类型 __u16 code; // 要模拟成什么按键 __s32 value; // 是按下还是释放 &#125;; // 下面宏定义见 input-event-coses.h// type#define EV_KEY 0x01#define EV_REL 0x02#define EV_ABS 0x03// ...// code#define BTN_LEFT 0x110#define BTN_RIGHT 0x111#define BTN_MIDDLE 0x112// ...// value#define MSC_SERIAL 0x00#define MSC_PULSELED 0x01// ... 这里稍微介绍一下 type，指事件类型，常见的事件类型有：EV_KEY，按键事件，如键盘的按键（按下哪个键），鼠标的左键右键（是否击下）等；EV_REL，相对坐标，主要是指鼠标的移动事件（相对位移）；EV_ABS， 绝对坐标，主要指触摸屏的移动事件 。 3. 编写 C 程序 下面就可以编写程序来检测鼠标的动态了。首先在你的用户~目录下建立文件夹 Translator*。在 *Translator 里建立一个 ct.c 源文件，代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/input.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int keys_fd; struct input_event t; // 注意这里打开的文件根据你自己的设备情况作相应的改变 keys_fd = open(\"/dev/input/event2\", O_RDONLY); if(keys_fd &lt;= 0) &#123; printf(\"open /dev/input/event2 error!\\n\"); return -1; &#125; while(1) &#123; read(keys_fd, &amp;t, sizeof(t)); if(t.type == EV_KEY) // 有键按下 if(t.code == BIN_LEFT) // 鼠标左键 if(t.value == MSC_SERIAL) // 松开 // 调用外部shell脚本 system(\"~/Translator/goTranslate.sh\"); &#125; close(keys_fd); return 0;&#125; 然后就是调用 gcc 编译器生成可执行文件 ct： 1$ gcc ct.c -o ct 4. 编写 shell 脚本翻译剪切板内容 在 Translator 里建立 goTranslate.sh 文件，内容如下： 123456789#!/bin/bashstr_old=$(cat ~/Translator/lastContent.txt)str_new=$(xclip -o 2&gt;/dev/null | xargs)if [[ \"$str_new\" != \"$str_old\" &amp;&amp; $str_new ]]; then echo -e \"\\n\" echo \"$str_new\" | xargs | trans :zh-CN -bfiecho \"$str_new\" | xargs &gt; ~/Translator/lastContent.txt 原理非常简单，读者自行了解。这里我们还要在 Translator 里建立一个 lastContent.txt 文件作为缓存，目的是本次调用脚本时能够获取上一次调用时翻译的文本内容，如果和本次调用的翻译文本一样，则本次就不进行翻译。 *5. 设置 *ct 别名 ** 这里已经可以通过下面的命令运行程序了： 1$ sudo ~/Translator/ct 但是由于每次运行都要输出这么长的命令，因此我们在 ~/.bashrc 文件中加入下面一条命令。 1alias ct='sudo ~/Translator/ct' 这样，以后每次看英文文献时就可以在命令行下输入： 1$ ct 三. 结束语这里有一些小技巧。可以更方便的使用这个工具。比如，把终端设为置顶并缩小到合适的尺寸，这样在阅读文献划词翻译时终端屏幕不会遮挡我们的视线。 值得说明的是，由于本人完全是为了方便自己的使用，而且在搞出这么个工具时仅仅接触 Linux 系统才不到两周，所以里面的实现对于有经验的朋友来说略显的有些笨拙了，请理解哈。 个人觉得这个工具使用起来还是很方便的，你觉得呢？ 参考文章： https://blog.csdn.net/liang12360640/article/details/50350648 https://www.cnblogs.com/yangwindsor/articles/3454955.html https://blog.csdn.net/liang12360640/article/details/50s350648","tags":[{"name":"Linux工具","slug":"Linux工具","permalink":"https://yuanlehome.github.io/tags/Linux%E5%B7%A5%E5%85%B7/"}]},{"title":"数据结构与算法学习笔记之概论","date":"2020-04-04T05:54:42.000Z","path":"20200404/","text":"数据结构 相互之间存在一种或多种特定关系的数据元素的集合。研究数据结构，关心的是数据对象的描述以及相关操作函数的实现。 数据 是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如整型、浮点型等数值类型，以及声音、图像等非数值类型。 数据元素 是组成数据的、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。 数据项 一个数据元素可以由若干个数据项组成。它是数据不可分割的最小单位。 数据对象 是性质相同的数据元素（即有相同的数量和类型的数据项）的集合，是数据的子集。 常见的数据结构 线性数据结构：向量vector（顺序存储）、链表list（链式存储）、栈stack和队列queue（优先队列）。 半线性数据结构：二叉树、搜索树（二叉搜索树BST、AVL树、B树、红黑树）、竞赛树等。 非线性数据结构：图。 哈希表hashing table、字典dictionary。 抽象数据类型 数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 抽象数据类型：指一个数学模型及定义在该模型上的一组操作。可以理解为C++中的类class。它体现的是程序设计中问题分解、抽象和信息隐藏的特性。 抽象数据类型的标准格式12345678ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义Operation 操作1 操作2 ...endADT 算法 算法是解决指定问题求解步骤的描述。在计算机中是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。 计算或信息处理 指借助某种工具，按照一定的规则，以明确而机械的形式进行。 算法中的计算模型就是计算机，即信息处理工具。 算法必须具备的几大要素 输入：待处理的信息或问题。 输出：经处理的信息，即答案。 正确性：的确可以解决指定的问题。 确定性：任何一个算法都可以描述为一个由基本操作组成的序列。 可行性：每一基本操作都可实现，且能在常数时间内完成。 有穷性：对于任何输入，经有限次的基本操作，都可以得到输出。 一个好的算法 正确，即符合语法，能够编译、链接。 能够正确处理简单的、大规模的、一般性的、退化的、任意合法的输入。 健壮，能够辨别不合法的输入并做适当处理，而不致非正常退出。 可读，结构化 + 准确命名 + 注释 + …。 效率，运行速度尽可能快，用到的存储空间尽可能少。 常见的算法 查找 顺序查找、二分查找、插值查找、斐波那契查找、分块查找和哈希查找等。 排序 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序和希尔排序等。 递归、分而治之、动态规划、回溯法和分支定界法等。 要对数据结构和算法设计方法给予评价，就必须能够计算程序性能。 数据结构和算法的关系 数据结构(data structures) + 算法(algorithms) = 程序(programs) (data structures + algorithms) x efficiency = computation 程序性能分析 是指分析一个程序对于内存空间和运行时间的需求。 空间复杂度 指程序运行时临时占用内存的大小。广义上的概念是包括存储算法本身所占用的空间、算法的输入输出数据所占用的空间以及算法在运行过程中临时占用的存储空间这三个方面。 时间复杂度 指运行程序所需要的时间。这里度量的是程序中基本操作执行的次数，它是问题规模n的函数f(n)。记T(n)=O(f(n))，它表示随问题规模n的增大，算法执行时间的增长率和f(n)相同，称作算法的渐进时间复杂度。 复杂度分析这里的复杂度分析通常指的是最坏时间复杂度分析。 常数阶O(1) 取前三个元素x = S[0]、y = S[1]和z = S[2]，这一步只需执行三次（从特定单元读取元素的）基本操作，耗费O(3)时间。接下来，为确定这三个元素的大小次序，最多需要做三次比较，也需O(3)时间。最后，输出居中的非极端元素只需O(1)时间。因此，上面取非极端元素算法的时间复杂度为：T(n) = O(3) + O(3) + O(1) = O(7) = O(1)。 对数阶O(logn) 根据右移运算的性质，每右移一位，n都至少缩减一半。也就是说，至多经过1 + log2n次循环，n必然缩减至0，从而算法终止。因此时间复杂度为：O(1 + log2n) = O(log2n) 。 线性阶O(n) 平方阶O(n) 时间复杂度为：O(2n^2 + n + 1) = O(n^2)。 常见的算法时间复杂度排序 Ο(1) ＜ Ο(logn) ＜ Ο(n) ＜ Ο(nlogn) ＜ Ο(n^2) ＜ … ＜ Ο(2^n) ＜ Ο(n!)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}]