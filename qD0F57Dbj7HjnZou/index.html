<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章是leetcode刷题系列的第1部分——数组。这里把有代表性的题目发出来，共计82道。主要涉及滑动窗口、哈希表、堆、二分搜索、扫描线、区间相关、拓扑排序、树状数组等算法。 leetcode刷题系列其它文章组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 8. 刷题小知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题系列之数组">
<meta property="og:url" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="这篇文章是leetcode刷题系列的第1部分——数组。这里把有代表性的题目发出来，共计82道。主要涉及滑动窗口、哈希表、堆、二分搜索、扫描线、区间相关、拓扑排序、树状数组等算法。 leetcode刷题系列其它文章组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 8. 刷题小知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/hint_valid_mountain_array.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/question_11.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/rainwatertrap.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/searchgrid.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/searchgrid2.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/diag1-grid.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/sample_1_1784.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/sample_2_1784.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/spiral1.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/spiral.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/interval1.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/535_Contiguous_Array.PNG">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/ic236-q4-ex1-1.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/ic236-q4-ex2.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/ic236-q4-ex3.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/merged.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/Video_2021-04-27_200311.gif">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/Video_2021-04-27_195717.gif">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/mat2.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/grid1.jpg">
<meta property="article:published_time" content="2021-04-10T13:35:42.000Z">
<meta property="article:modified_time" content="2021-04-10T13:35:42.000Z">
<meta property="article:author" content="Liu Y.L.">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/hint_valid_mountain_array.png">

<link rel="canonical" href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode刷题系列之数组 | LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode刷题系列之数组
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 21:35:42" itemprop="dateCreated datePublished" datetime="2021-04-10T21:35:42+08:00">2021-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>108k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:38</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章是<code>leetcode</code>刷题系列的第<code>1</code>部分——数组。这里把有代表性的题目发出来，共计<code>82</code>道。主要涉及滑动窗口、哈希表、堆、二分搜索、扫描线、区间相关、拓扑排序、树状数组等算法。</p>
<p><code>leetcode</code>刷题系列其它文章组织如下：</p>
<p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p>
<p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p>
<p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p>
<a id="more"></a>

<h5 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h5><blockquote>
<p>给定一个<strong>有序整数数组</strong>和一个目标数，在数组中找到总和等于目标数的两个元素，返回它们的索引。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左右指针</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h5><blockquote>
<p>给定一个<strong>无序整数数组</strong>和一个目标数，在数组中找到总和等于目标数的两个元素，返回它们的索引。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助 hashtable 记录元素的存在情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;mapping[target - nums[i]], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mapping[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="560-Subarray-Sum-Equals-K"><a href="#560-Subarray-Sum-Equals-K" class="headerlink" title="560. Subarray Sum Equals K"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. Subarray Sum Equals K</a></h5><blockquote>
<p>给定一个整数数组和一个目标数，返回数组中其总和等于目标数的<strong>连续子数组的个数</strong>。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为这题数组中可以存在负数, 所有不能使用滑动窗口方法</span></span><br><span class="line"><span class="comment">// 暴力解法 超时</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">if</span>(sum == k) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助前缀和思想</span></span><br><span class="line"><span class="comment">// 使用 hashtable 记录所有的前缀和及其对应的数目</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须存在的 base case</span></span><br><span class="line">    <span class="comment">// 表示 sum 直接等于 k 的情况</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(sum - k)) &#123;</span><br><span class="line">            res += mapping[sum - k];</span><br><span class="line">        &#125;</span><br><span class="line">        mapping[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="724-Find-Pivot-Index"><a href="#724-Find-Pivot-Index" class="headerlink" title="724. Find Pivot Index"></a><a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. Find Pivot Index</a></h5><blockquote>
<p>给定一个整数数组，请计算该数组的枢轴索引。枢轴索引使得该索引左侧的所有数字的总和等于在该索引右侧的所有数字的总和。</p>
<p>如果索引在数组的左边缘，则左总和为<code>0</code>，因为左侧没有元素，这也适用于数组的右边缘。如果存在多个枢轴索引，返回最左边的。 如果不存在这样的索引，则返回<code>-1</code>。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,7,3,6,5,6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The pivot index is 3.</span><br><span class="line">Left sum &#x3D; nums[0] + nums[1] + nums[2] &#x3D; 1 + 7 + 3 &#x3D; 11</span><br><span class="line">Right sum &#x3D; nums[4] + nums[5] &#x3D; 5 + 6 &#x3D; 11</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">There is no index that satisfies the conditions in the problem statement.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,1,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">The pivot index is 0.</span><br><span class="line">Left sum &#x3D; 0 (no elements to the left of index 0)</span><br><span class="line">Right sum &#x3D; nums[1] + nums[2] &#x3D; 1 + -1 &#x3D; 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(N), S: O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 计算前缀和数组</span></span><br><span class="line">    <span class="comment">// 子数组和 nums[i..j] = prefix[j + 1] - prefix[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((prefix[i] - prefix[<span class="number">0</span>]) == (prefix[n] - prefix[i + <span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(N), S: O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum - leftSum - nums[i] == leftSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="523-Continuous-Subarray-Sum"><a href="#523-Continuous-Subarray-Sum" class="headerlink" title="523. Continuous Subarray Sum"></a><a href="https://leetcode.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. Continuous Subarray Sum</a></h5><blockquote>
<p>给定一个非负整数数组和目标整数<code>k</code>，编写一个函数以检查该数组是否具有大小至少为<code>2</code>的连续子数组，该子数组的总和为<code>k</code>的倍数。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: [23, 2, 4, 6, 7],  k &#x3D; 6</span><br><span class="line">&gt;Output: True</span><br><span class="line">&gt;Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: [23, 2, 6, 4, 7],  k &#x3D; 6</span><br><span class="line">&gt;Output: True</span><br><span class="line">&gt;Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数学知识 (a - b) % c = 0 --&gt; a % c = b % c</span></span><br><span class="line"><span class="comment">// 借助前缀和思想</span></span><br><span class="line"><span class="comment">// 使用哈希表记录所有的 (前缀和对 k 的余数) 及其 (对应的索引)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须存在的 base case</span></span><br><span class="line">    <span class="comment">// 为了处理 sum 本身 对 k 取余为 0 的情况</span></span><br><span class="line">    <span class="comment">// 也就是说这时满足条件的数组是首元素打头的子数组</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">int</span> mod = sum % k;</span><br><span class="line">        <span class="comment">// 记住对于前缀和数组</span></span><br><span class="line">        <span class="comment">// 子数组和 nums[i..j] = prefixSum[j + 1] - prefixSum[i]</span></span><br><span class="line">        <span class="comment">// 就理解了为什么是 &gt; 1 而不是 &gt;= 1 了</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(mod)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - mapping[mod] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mapping[mod] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1089-复写零"><a href="#1089-复写零" class="headerlink" title="1089. 复写零"></a><a href="https://leetcode-cn.com/problems/duplicate-zeros/" target="_blank" rel="noopener">1089. 复写零</a></h5><blockquote>
<p>给定固定长度的整数数组<code>arr</code>，请复制每次出现的零，将其余元素向右移动。请注意，不会写入超出原始数组长度的元素。</p>
<p>对输入数组进行就地修改，不要从函数中返回任何内容。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2,3,0,4,5,0]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,2,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的解法, 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">     <span class="comment">// 提前计算出原始数组中 0 的个数</span></span><br><span class="line">    <span class="keyword">int</span> zerosCnt = count(arr.begin(), arr.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(zerosCnt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算非零元素的新索引</span></span><br><span class="line">            <span class="comment">// 在此处, 保证 zerosCnt 变量始终是大于 0 的</span></span><br><span class="line">            <span class="comment">// 且表示此非零元素前面的 0 的个数</span></span><br><span class="line">            <span class="keyword">int</span> newPos = i + zerosCnt;</span><br><span class="line">            <span class="comment">// 如果有效就搬过去</span></span><br><span class="line">            <span class="keyword">if</span>(newPos &lt; n) &#123;</span><br><span class="line">                arr[newPos] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原索引处赋 0</span></span><br><span class="line">            arr[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 每次遇到一个 0, 就减 1</span></span><br><span class="line">            zerosCnt--;</span><br><span class="line">            <span class="comment">// 前面没有 0 了, 就不需要搬移了</span></span><br><span class="line">            <span class="keyword">if</span>(zerosCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="941-Valid-Mountain-Array"><a href="#941-Valid-Mountain-Array" class="headerlink" title="941. Valid Mountain Array"></a><a href="https://leetcode.com/problems/valid-mountain-array/" target="_blank" rel="noopener">941. Valid Mountain Array</a></h5><blockquote>
<p>给定一个整数数组<code>arr</code>，当且仅当它是有效的山峰数组时，才返回<code>true</code>。当且仅当满足以下条件时，<code>arr</code>是一个山峰数组：</p>
<ul>
<li><code>arr.size() &gt;= 3</code></li>
<li>There exists some <code>i</code> with <code>0 &lt; i &lt; arr.size() - 1</code></li>
</ul>
<p>such that：</p>
<ul>
<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>
<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.size() - 1]</code></li>
</ul>
<img src="hint_valid_mountain_array.png" alt="img" style="zoom: 50%;" />

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [3,5,5]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [0,3,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接模拟就行</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 递增扫描</span></span><br><span class="line">    <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最高点不能是数组的第一个位置或最后一个位置</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递减扫描</span></span><br><span class="line">    <span class="keyword">while</span>(i + <span class="number">1</span> &lt; n &amp;&amp; arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. Find All Numbers Disappeared in an Array</a></h5><blockquote>
<p>给定一个整数数组，其中<code>1 ≤ a[i] ≤ n (n = 数组大小)</code>，某些元素出现两次，而另一些元素出现一次。查找<code>[1，n]</code>包含的所有未出现在此数组中的元素。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 将所有出现过的值作为索引 (值减 1 ), 将该索引所在处的值映射为负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 最后没被映射为负数的值, 其对应的索引 +1 就是未出现的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="442-Find-All-Duplicates-in-an-Array"><a href="#442-Find-All-Duplicates-in-an-Array" class="headerlink" title="442. Find All Duplicates in an Array"></a><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">442. Find All Duplicates in an Array</a></h5><blockquote>
<p>给定一个整数数组，即<code>1 ≤ a[i] ≤ n (n = 数组大小)</code>，其中有些元素出现<strong>两次</strong>而其他元素出现<strong>一次</strong>。找到所有出现<strong>两次</strong>的元素。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 将所有出现过的值作为索引 (值减 1 ), 将该索引所在处的值映射为负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果已经被映射为负数, 说明之前这个数出现过一次了</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1744-Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day"><a href="#1744-Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day" class="headerlink" title="1744. Can You Eat Your Favorite Candy on Your Favorite Day?"></a><a href="https://leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/" target="_blank" rel="noopener">1744. Can You Eat Your Favorite Candy on Your Favorite Day?</a></h5><blockquote>
<p>  给你一个下标从<code>0</code>开始的正整数数组<code>candiesCount</code>，其中<code>candiesCount[i]</code>表示你拥有的第<code>i</code>类糖果的数目。同时给你一个二维数组<code>queries</code>，其中<code>queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]</code>。</p>
<p>  你按照如下规则进行一场游戏：</p>
<ul>
<li><p>你从第<code>0</code>天开始吃糖果。</p>
</li>
<li><p>你在吃完所有第<code>i - 1</code>类糖果之前，不能吃任何一颗第<code>i</code>类糖果。</p>
</li>
<li><p>在吃完所有糖果之前，你必须每天至少吃一颗糖果。</p>
<p>请你构建一个布尔型数组<code>answer</code>，满足<code>answer.length == queries.length</code>。<code>answer[i]</code>为<code>true</code>的条件是：在每天吃不超过<code>dailyCap_i</code>颗糖果的前提下，你可以在第<code>favoriteDay_i</code>天吃到第<code>favoriteType_i</code>类糖果；否则<code>answer[i]</code>为<code>false</code>。注意，只要满足上面<code>3</code>条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。</p>
<p>请你返回得到的数组<code>answer</code>。</p>
</li>
</ul>
<p>  <strong>示例</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candiesCount &#x3D; [7,4,5,3,8], queries &#x3D; [[0,2,2],[4,2,4],[2,13,1000000000]]</span><br><span class="line">输出：[true,false,true]</span><br><span class="line">提示：</span><br><span class="line">1. 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果</span><br><span class="line">2. 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果</span><br><span class="line">3. 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀和 + 区间交集</span></span><br><span class="line"><span class="comment">// 对每一颗糖果依次进行编号</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">canEat</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candiesCount, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; queries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = candiesCount.size();</span><br><span class="line">    <span class="comment">// 用 long 防止后面的乘法和加法溢出</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; <span class="title">prefixSum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        prefixSum[i] = prefixSum[i - <span class="number">1</span>] + candiesCount[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">    res.reserve(queries.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;query : queries)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每天至少吃 1 颗, 至多吃 query[2] 颗</span></span><br><span class="line">        <span class="comment">// 因此在第 query[1] 天能吃到的糖果的编号范围是 [x1, y1]</span></span><br><span class="line">        <span class="keyword">long</span> x1 = query[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y1 = <span class="keyword">long</span>((query[<span class="number">1</span>] + <span class="number">1</span>)) * query[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 类型为 query[0] 的糖果的编号范围为 [x2, y2]</span></span><br><span class="line">        <span class="keyword">long</span> x2 = prefixSum[query[<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y2 = prefixSum[query[<span class="number">0</span>] + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果有交集就满足条件</span></span><br><span class="line">        res.push_back(x1 &lt;= y2 &amp;&amp; x2 &lt;= y1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="710-黑名单中的随机数"><a href="#710-黑名单中的随机数" class="headerlink" title="710. 黑名单中的随机数"></a><a href="https://leetcode-cn.com/problems/random-pick-with-blacklist/" target="_blank" rel="noopener">710. 黑名单中的随机数</a></h5><blockquote>
<p>给你输入一个正整数<code>N</code>，代表左闭右开区间<code>[0,N)</code>，再给你输入一个数组<code>blacklist</code>，其中包含一些「黑名单数字」，且<code>blacklist</code>中的数字都是区间<code>[0,N)</code>中的数字。</p>
<p>编写一个函数以随机返回<code>[0，N)</code>中的一个整数，该整数不在<code>blacklist</code>中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本思路是记录下实际有效的数字的个数 actual</span></span><br><span class="line"><span class="comment">// 通过一个哈希表将黑名单中的在 [0, actual) 范围内的数字映射到 [actual N) 中不在黑名单中的数字身上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> actual;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; blacklist) &#123;</span><br><span class="line">        <span class="comment">// 先把黑名单中的所有数字放在哈希表中</span></span><br><span class="line">        <span class="comment">// 便于快速得到 [actual, N) 范围内的数字是否在黑名单中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : blacklist) &#123;</span><br><span class="line">            mapping[val] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        actual = N - blacklist.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : blacklist) &#123;</span><br><span class="line">            <span class="comment">// 黑名单中在 [0, actual) 范围内的数字才需要映射</span></span><br><span class="line">            <span class="keyword">if</span>(val &lt; actual) &#123;</span><br><span class="line">                N--;</span><br><span class="line">                <span class="comment">// 从后向前映射</span></span><br><span class="line">                <span class="comment">// 如果映射为的数字已经在黑名单中了</span></span><br><span class="line">                <span class="comment">// 就跳过</span></span><br><span class="line">                <span class="keyword">while</span>(mapping.count(N)) &#123;</span><br><span class="line">                    N--;</span><br><span class="line">                &#125;</span><br><span class="line">            	mapping[val] = N;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % actual;</span><br><span class="line">        <span class="comment">// 如果这个数字在黑名单中, 需要返回其映射</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(i) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mapping[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="528-Random-Pick-with-Weight"><a href="#528-Random-Pick-with-Weight" class="headerlink" title="528. Random Pick with Weight"></a><a href="https://leetcode.com/problems/random-pick-with-weight/" target="_blank" rel="noopener">528. Random Pick with Weight</a></h5><blockquote>
<p>给定一个正整数数组<code>w</code>，其中<code>w[i]</code>描述第<code>i</code>个索引的权重。</p>
<p>我们需要调用函数<code>pickIndex()</code>，该函数随机返回范围为<code>[0，w.size())</code>的整数。 <code>pickIndex()</code>应该返回与其在<code>w</code>数组中的权重成比例的数。 例如，对于<code>w = [1，3]</code>，选择索引<code>0</code>的概率为<code>1 / (1 + 3) = 0.25</code>，而选择索引<code>1</code>的概率为<code>3 / (1 + 3)  = 0.75</code>。或者说，选择索引<code>i</code>的概率为<code>w[i] / sum(w)</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用前缀和数组</span></span><br><span class="line"><span class="comment">// 从 [0, sum(w)) 区间内随机产生一个数</span></span><br><span class="line"><span class="comment">// 看这个随机数落在前缀和数组的哪个区间内</span></span><br><span class="line"><span class="comment">// 比如 w = &#123;1, 4, 7, 2&#125;;</span></span><br><span class="line"><span class="comment">// prefixSum = &#123;0, 1, 5, 12, 14&#125;;</span></span><br><span class="line"><span class="comment">// 从 [0, 14) 区间内随机产生一个数</span></span><br><span class="line"><span class="comment">// 落在 [0, 1) 区间返回 0</span></span><br><span class="line"><span class="comment">// 落在 [1, 5) 区间返回 1</span></span><br><span class="line"><span class="comment">// 落在 [5, 12) 区间返回 2</span></span><br><span class="line"><span class="comment">// 落在 [12, 14) 区间返回 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefixSum;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) : prefixSum(w.size() + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.size(); i++) &#123;</span><br><span class="line">            prefixSum[i + <span class="number">1</span>] = prefixSum[i] + w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> target = rand() % prefixSum.back();</span><br><span class="line">        <span class="comment">// 通过二分搜索加快搜索速度</span></span><br><span class="line">        <span class="comment">// 右边界搜索第一个大于目标值的索引</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = prefixSum.size();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = (hi + lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(prefixSum[mi] &lt;= target) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water</a></h5><blockquote>
<p>给你<code>n</code>个非负整数<code>a1, a2, ..., an</code>，每个数代表坐标中的一个点<code>(i, ai)</code> 。在坐标内画<code>n</code>条垂直线，垂直线<code>i</code>的两个端点分别为<code>(i, ai)</code>和<code>(i, 0)</code> 。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。</p>
<p>返回容纳的水量。</p>
<p><strong>Example:</strong></p>
<img src="question_11.jpg" alt="img" style="zoom: 67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = height.size();</span><br><span class="line">    <span class="comment">// 左右指针解法</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt;= height[right]) &#123;</span><br><span class="line">            res = max(res, (right - left) * height[left]);</span><br><span class="line">            <span class="comment">// 小的变化, 大的不变</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = max(res, (right - left) * height[right]);</span><br><span class="line">            <span class="comment">// 小的变化, 大的不变</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. Trapping Rain Water</a></h5><blockquote>
<p>给定<code>n</code>个表示海拔图的非负整数，其中每个条的宽度为<code>1</code>，计算下雨后它可以捕集多少水。</p>
<p><strong>Example:</strong></p>
<img src="rainwatertrap.png" alt="img"  />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每一个槽, 它所能接的水量取决于它左边最高的柱子和右边最高的柱子中的较低者</span></span><br><span class="line"><span class="comment">// 较低的值减去自身的高度就为该槽所能接的水量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了备忘录的方法</span></span><br><span class="line"><span class="comment">// 提前计算出每个槽左边最高的柱子和右边最高的柱子(包括它自己的高度)</span></span><br><span class="line"><span class="comment">// left_max[i] 表示第 i 个槽左边最高的柱子的高度</span></span><br><span class="line"><span class="comment">// right_max[i] 表示第 i 个槽右边最高的柱子的高度</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n), 但空间复杂度也为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = height.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left_max</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_max</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    left_max.front() = height.front();</span><br><span class="line">    right_max.back() = height.back();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        left_max[i] = max(height[i], left_max[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right_max[i] = max(height[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res += min(left_max[i], right_max[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用双指针解法</span></span><br><span class="line"><span class="comment">// 边走边记录左边柱子最高值和右边柱子最高值</span></span><br><span class="line"><span class="comment">// 优化后的时间复杂度为 O(n), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = height.size();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        left_max = max(left_max, height[left]);</span><br><span class="line">        right_max = max(right_max, height[right]);</span><br><span class="line">        <span class="keyword">if</span>(left_max &lt; right_max) &#123;</span><br><span class="line">            res += left_max - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += right_max - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1395-Count-Number-of-Teams"><a href="#1395-Count-Number-of-Teams" class="headerlink" title="1395. Count Number of Teams"></a><a href="https://leetcode.com/problems/count-number-of-teams/" target="_blank" rel="noopener">1395. Count Number of Teams</a></h5><blockquote>
<p><code>n</code>名士兵站成一排。每个士兵都有一个<strong>独一无二的评分</strong><code>rating</code>。每<code>3</code>个士兵可以组成一个作战单位，分组规则如下：</p>
<ol>
<li>从队伍中选出下标分别为<code>i、j、k</code>的<code>3</code>名士兵，他们的评分分别为<code>rating[i]、rating[j]、rating[k]</code>；</li>
<li>作战单位需满足：<code>rating[i] &lt; rating[j] &lt; rating[k]</code>或者<code>rating[i] &gt; rating[j] &gt; rating[k]</code>，其中<code>0 &lt;= i &lt; j &lt; k &lt; n</code>。</li>
</ol>
<p>你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。</p>
<p><strong>Example 1</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [2,5,3,4,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). </span><br></pre></td></tr></table></figure>

<p><strong>Example 2</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [2,1,3]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: We can&#39;t form any team given the conditions.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [1,2,3,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前求得每个元素右边的比它大的元素个数和比它小的元素个数</span></span><br><span class="line"><span class="comment">// 通过两次 O(n2) 的循环, 将时间复杂度减少到 O(n2), 但空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = rating.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_max</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_min</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rating[i] &lt; rating[j]) &#123;</span><br><span class="line">                right_max[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right_min[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rating[i] &lt; rating[j]) &#123;</span><br><span class="line">                res += right_max[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += right_min[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h5 id="480-Sliding-Window-Median"><a href="#480-Sliding-Window-Median" class="headerlink" title="480. Sliding Window Median"></a><a href="https://leetcode.com/problems/sliding-window-median/" target="_blank" rel="noopener">480. Sliding Window Median</a></h5><blockquote>
<p>中值是有序整数列表中的中间值。 如果列表的大小是偶数，则没有中间值，此时，中位数是两个中间值的平均值。</p>
<p>给定一个数组<code>num</code>，存在一个大小为<code>k</code>的滑动窗口，该窗口从数组的最左边移到最右边。 你只能在窗口中看到<code>k</code>个数字。 每次滑动窗口向右移动一个位置。 你的工作是输出原始数组中每个窗口的中值数组。</p>
<p>For example, Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window position               Median</span><br><span class="line">---------------               ------</span><br><span class="line">[1  3  -1] -3  5  3  6  7       1</span><br><span class="line">1  [3  -1  -3] 5  3  6  7      -1</span><br><span class="line">1  3  [-1  -3  5] 3  6  7      -1</span><br><span class="line">1  3  -1  [-3  5  3] 6  7       3</span><br><span class="line">1  3  -1  -3  [5  3  6] 7       5</span><br><span class="line">1  3  -1  -3  5  [3  6  7]      6</span><br></pre></td></tr></table></figure>

<p>Therefore, return the median sliding window as<code>[1,-1,-1,3,5,6]</code>.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; median;</span><br><span class="line">    <span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">window</span><span class="params">(nums.begin(), next(nums.begin(), k))</span></span>;</span><br><span class="line">    <span class="comment">// k 为奇数, mid 指向中间元素, k 为偶数, mid 指向中间两个元素的后一个元素</span></span><br><span class="line">    <span class="comment">// 之后每一次插入和删除元素都要维护 mid 正确性</span></span><br><span class="line">    <span class="keyword">auto</span> mid = next(window.begin(), k / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            median.push_back(*mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            median.push_back((<span class="keyword">double</span>(*prev(mid)) + <span class="keyword">double</span>(*mid)) * <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果插入相同的元素</span></span><br><span class="line">        <span class="comment">// multiset 的 insert 操作将其插入到范围上界</span></span><br><span class="line">        window.insert(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; *mid) &#123;</span><br><span class="line">            mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i - k] &lt;= *mid) &#123;</span><br><span class="line">            mid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除时从范围下界删除可保证 mid 不失效</span></span><br><span class="line">        window.erase(window.lower_bound(nums[i - k]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> medianSlidingWindowForOdd(nums, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> medianSlidingWindowForEven(nums, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只考虑 k 为奇数的情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindowForOdd</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; median;</span><br><span class="line">    <span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">window</span><span class="params">(nums.begin(), next(nums.begin(), k))</span></span>;</span><br><span class="line">    <span class="comment">// 窗口内有奇数个元素时, mid 指向中间元素</span></span><br><span class="line">    <span class="comment">// 窗口内有偶数个元素时, mid 指向中间两个元素的后一个元素</span></span><br><span class="line">    <span class="comment">// 之后每一次插入和删除元素都要维护 mid 正确性</span></span><br><span class="line">    <span class="keyword">auto</span> mid = next(window.begin(), k / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; ; i++) &#123;</span><br><span class="line">        median.push_back(*mid);</span><br><span class="line">        <span class="keyword">if</span>(i == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意, 插入前集合中的元素数为奇数个</span></span><br><span class="line">        <span class="comment">// 如果插入相同的元素, multiset 的 insert 操作将其插入到范围上界</span></span><br><span class="line">        window.insert(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果插入在 mid 右边</span></span><br><span class="line">            ++mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入后变为偶数个元素了</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i - k] &lt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果在 mid 左边删除</span></span><br><span class="line">            window.erase(window.find(nums[i - k]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i - k] &gt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果在 mid 右边删除</span></span><br><span class="line">            window.erase(window.find(nums[i - k]));</span><br><span class="line">            --mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果删除的就是 mid</span></span><br><span class="line">            mid = window.erase(mid); <span class="comment">// 注意 erase 会返回删除元素的后继元素迭代器</span></span><br><span class="line">            --mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只考虑 k 为偶数的情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindowForEven</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; median;</span><br><span class="line">    <span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">window</span><span class="params">(nums.begin(), next(nums.begin(), k))</span></span>;</span><br><span class="line">    <span class="comment">// 窗口内有偶数个元素时, mid 指向中间元素</span></span><br><span class="line">    <span class="comment">// 窗口内有奇数个元素时, mid 指向中间两个元素的后一个元素</span></span><br><span class="line">    <span class="comment">// 之后每一次插入和删除元素都要维护 mid 正确性</span></span><br><span class="line">    <span class="keyword">auto</span> mid = next(window.begin(), k / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; ; i++) &#123;</span><br><span class="line">        median.push_back((<span class="keyword">double</span>(*prev(mid)) + <span class="keyword">double</span>(*mid)) * <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">if</span>(i == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意, 插入前集合中的元素数为偶数个</span></span><br><span class="line">        <span class="comment">// 如果插入相同的元素, multiset 的 insert 操作将其插入到范围上界</span></span><br><span class="line">        window.insert(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果插入在 mid 左边</span></span><br><span class="line">            --mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入后变为奇数个元素了</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i - k] &lt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果在 mid 左边删除</span></span><br><span class="line">            window.erase(window.find(nums[i - k]));</span><br><span class="line">            ++mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i - k] &gt; *mid) &#123;</span><br><span class="line">            <span class="comment">// 如果在 mid 右边删除</span></span><br><span class="line">            window.erase(window.find(nums[i - k]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果删除的就是 mid</span></span><br><span class="line">            mid = window.erase(mid); <span class="comment">// 注意 erase 会返回删除元素的后继元素迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. Sliding Window Maximum</a></h5><blockquote>
<p>  给你一个整数数组<code>num</code>，有一个大小为<code>k</code>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的<code>k</code>个数字。滑动窗口每次只向右移动一位。</p>
<p>  返回滑动窗口中的最大值。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line">1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line">1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line">1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line">1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line">1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列保证从队头到队尾是递减的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonoQ</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; monoQ;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 如果入队的值比队尾的值大, 就把队尾元素 pop 掉, 这样保证是递减的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!monoQ.empty() &amp;&amp; monoQ.back() &lt; val) &#123;</span><br><span class="line">            monoQ.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        monoQ.push_back(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pop 的时候如果不是队头元素就什么也不做</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(monoQ.front() == val) &#123;</span><br><span class="line">            monoQ.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大值就是队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> monoQ.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 维护一个大小为 k 的递减队列</span></span><br><span class="line"><span class="comment">// 这个队列就相当于是题目中的滑动窗口</span></span><br><span class="line"><span class="comment">// 只是单调之后取其中的最大值很方便</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    MonoQ monoQ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        monoQ.push(nums[i]);</span><br><span class="line">        <span class="comment">// 如果窗口内的元素数等于 k</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 最大值就是队头元素</span></span><br><span class="line">            res.push_back(monoQ.maxVal());</span><br><span class="line">            <span class="comment">// pop 掉最左边的将要出窗口的元素</span></span><br><span class="line">            monoQ.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当然也可以不先写好一个单调队列类</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 用 deque 模拟队列</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; monoQ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!monoQ.empty() &amp;&amp; monoQ.back() &lt; nums[i]) &#123;</span><br><span class="line">            monoQ.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        monoQ.push_back(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            res.push_back(monoQ.front());</span><br><span class="line">            <span class="keyword">if</span>(monoQ.front() == nums[i - k + <span class="number">1</span>]) &#123;</span><br><span class="line">                monoQ.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1834-Single-Threaded-CPU"><a href="#1834-Single-Threaded-CPU" class="headerlink" title="1834. Single-Threaded CPU"></a><a href="https://leetcode.com/problems/single-threaded-cpu/" target="_blank" rel="noopener">1834. Single-Threaded CPU</a></h5><blockquote>
<p>给你一个二维数组<code>tasks</code>，用于表示<code>n</code>项从<code>0</code>到<code>n - 1</code>编号的任务。其中<code>tasks[i] = [enqueueTimei, processingTimei]</code>意味着第<code>i</code>项任务将会于<code>enqueueTimei</code>时进入任务队列，需要<code>processingTimei</code>的时长完成执行。</p>
<p>现有一个单线程<code>CPU</code>，同一时间只能执行最多一项任务，该<code>CPU</code>将会按照下述方式运行：</p>
<ul>
<li>如果<code>CPU</code>空闲，且任务队列中没有需要执行的任务，则<code>CPU</code>保持空闲状态。</li>
<li>如果<code>CPU</code>空闲，但任务队列中有需要执行的任务，则<code>CPU</code>将会选择执行时间最短的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。</li>
<li>一旦某项任务开始执行，<code>CPU</code>在执行完整个任务前都不会停止。</li>
<li><code>CPU</code>可以在完成一项任务后，立即开始执行一项新任务。</li>
</ul>
<p>返回<code>CPU</code>处理任务的顺序。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: tasks &#x3D; [[1,2],[2,4],[3,2],[4,1]]</span><br><span class="line">&gt;Output: [0,2,3,1]</span><br><span class="line">&gt;Explanation: The events go as follows: </span><br><span class="line">&gt;- At time &#x3D; 1, task 0 is available to process. Available tasks &#x3D; &#123;0&#125;.</span><br><span class="line">&gt;- Also at time &#x3D; 1, the idle CPU starts processing task 0. Available tasks &#x3D; &#123;&#125;.</span><br><span class="line">&gt;- At time &#x3D; 2, task 1 is available to process. Available tasks &#x3D; &#123;1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 3, task 2 is available to process. Available tasks &#x3D; &#123;1, 2&#125;.</span><br><span class="line">&gt;- Also at time &#x3D; 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks &#x3D; &#123;1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 4, task 3 is available to process. Available tasks &#x3D; &#123;1, 3&#125;.</span><br><span class="line">&gt;- At time &#x3D; 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks &#x3D; &#123;1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 6, the CPU finishes task 3 and starts processing task 1. Available tasks &#x3D; &#123;&#125;.</span><br><span class="line">&gt;- At time &#x3D; 10, the CPU finishes task 1 and becomes idle.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: tasks &#x3D; [[7,10],[7,12],[7,5],[7,4],[7,2]]</span><br><span class="line">&gt;Output: [4,3,2,0,1]</span><br><span class="line">&gt;Explanation: The events go as follows:</span><br><span class="line">&gt;- At time &#x3D; 7, all the tasks become available. Available tasks &#x3D; &#123;0,1,2,3,4&#125;.</span><br><span class="line">&gt;- Also at time &#x3D; 7, the idle CPU starts processing task 4. Available tasks &#x3D; &#123;0,1,2,3&#125;.</span><br><span class="line">&gt;- At time &#x3D; 9, the CPU finishes task 4 and starts processing task 3. Available tasks &#x3D; &#123;0,1,2&#125;.</span><br><span class="line">&gt;- At time &#x3D; 13, the CPU finishes task 3 and starts processing task 2. Available tasks &#x3D; &#123;0,1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 18, the CPU finishes task 2 and starts processing task 0. Available tasks &#x3D; &#123;1&#125;.</span><br><span class="line">&gt;- At time &#x3D; 28, the CPU finishes task 0 and starts processing task 1. Available tasks &#x3D; &#123;&#125;.</span><br><span class="line">&gt;- At time &#x3D; 40, the CPU finishes task 1 and becomes idle.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Pair = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> taskCount = tasks.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> taskId = <span class="number">0</span>; taskId &lt; taskCount; taskId++) &#123;</span><br><span class="line">        tasks[taskId].push_back(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(tasks.begin(), tasks.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    priority_queue&lt;Pair, <span class="built_in">vector</span>&lt;Pair&gt;, greater&lt;Pair&gt;&gt; tasksQueue;</span><br><span class="line">    <span class="keyword">int</span> taskId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> timeStamp = <span class="number">0</span>; <span class="comment">// 时刻</span></span><br><span class="line">    <span class="keyword">while</span>(taskId &lt; taskCount || !tasksQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tasksQueue.empty()) &#123;</span><br><span class="line">            timeStamp = max(timeStamp, (<span class="keyword">long</span>)tasks[taskId][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(taskId &lt; taskCount &amp;&amp; tasks[taskId][<span class="number">0</span>] &lt;= timeStamp) &#123;</span><br><span class="line">            tasksQueue.push(&#123;tasks[taskId][<span class="number">1</span>], tasks[taskId][<span class="number">2</span>]&#125;);</span><br><span class="line">            taskId++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [duration, id] = tasksQueue.top();</span><br><span class="line">        tasksQueue.pop();</span><br><span class="line">        timeStamp += duration;</span><br><span class="line">        res.push_back(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>，请你将该数组升序排列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下滤操作, 复杂度正比于完全二叉树的高度为 log(n)</span></span><br><span class="line">    <span class="comment">// 参数 n 代表 [有效堆] 数组的长度, 可用于验证待下滤元素 hole 的左右孩子节点的合法性</span></span><br><span class="line">    <span class="keyword">auto</span> down = [&amp;](<span class="keyword">int</span> hole, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 先保存待下滤的值, hole 代表洞号</span></span><br><span class="line">        <span class="keyword">int</span> holeVal = nums[hole];</span><br><span class="line">        <span class="comment">// 先找到待下滤元素的左孩子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lc = <span class="number">2</span> * hole + <span class="number">1</span>; lc &lt; n; lc = <span class="number">2</span> * hole + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果右子节点存在并且左子节点的值小于等于右子节点</span></span><br><span class="line">            <span class="keyword">if</span>(lc + <span class="number">1</span> &lt; n &amp;&amp; nums[lc] &lt;= nums[lc + <span class="number">1</span>]) &#123;</span><br><span class="line">                lc++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时, lc 指向孩子节点中较大的那一个</span></span><br><span class="line">            <span class="comment">// 如果待下滤的值比孩子中较大的还大, 就不需要下滤了</span></span><br><span class="line">            <span class="keyword">if</span>(nums[lc] &lt;= holeVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[hole] = nums[lc];</span><br><span class="line">            <span class="comment">// 产生新的洞号</span></span><br><span class="line">            hole = lc;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[hole] = holeVal;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 获取末元素的父亲, 也就是最后一个内部节点</span></span><br><span class="line">    <span class="keyword">int</span> lastInternal = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 建堆操作, 复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">while</span>(lastInternal &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        down(lastInternal--, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 此时最大元素是首元素</span></span><br><span class="line">        <span class="comment">// 首尾交换, 末元素就位</span></span><br><span class="line">        swap(nums[i], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 将新首元素下滤</span></span><br><span class="line">        down(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序, 自顶向下递归实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 排序 [0, n - 1] 之间的元素</span></span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单元素自动有序</span></span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, lo, mi);</span><br><span class="line">    mergeSort(nums, mi + <span class="number">1</span>, hi);</span><br><span class="line">    merge(nums, lo, mi, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="comment">// [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 辅助空间, 存储 [mi + 1, hi] 元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(next(nums.begin(), mi + <span class="number">1</span>), next(nums.begin(), hi + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 对两个数组中的元素, 依次从后向前比较</span></span><br><span class="line">    <span class="comment">// 从后向前放置元素, 先放较大者</span></span><br><span class="line">    <span class="keyword">int</span> i = mi;</span><br><span class="line">    <span class="keyword">int</span> j = hi - mi - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = hi;</span><br><span class="line">    <span class="comment">// 注意 i 的终止条件</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= lo &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意, 这里如果是 &gt;= 就不稳定了</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; helper[j]) &#123;</span><br><span class="line">            nums[k--] = nums[i--];</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">        	nums[k--] = helper[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 归并排序, 自底向上迭代实现 */</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">    <span class="comment">// 中间节点相对于起点的位置是 1 个 step</span></span><br><span class="line">    <span class="comment">// 终点相对于起点是 2 个 step</span></span><br><span class="line">    <span class="comment">// step 从 1 开始直到等于数组的长度 sz </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= sz; step *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意, 这里 lo 从 0 开始直到等于 sz - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; sz; lo += <span class="number">2</span> * step) &#123;</span><br><span class="line">            <span class="comment">// 因为 merge 函数实现的原因, 都是闭区间, 而且 [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line">            <span class="comment">// 所以这里求出的 mi 和 hi 都需要减 1</span></span><br><span class="line">            merge(nums, lo, min(lo + step - <span class="number">1</span>, sz - <span class="number">1</span>), min(lo + <span class="number">2</span> * step - <span class="number">1</span>, sz - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quick sort</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机置乱闭区间 [lo, hi] 内的元素</span></span><br><span class="line">    <span class="keyword">auto</span> shuffle = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = rand() % (hi - i + <span class="number">1</span>) + i;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> partition = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        shuffle(lo, hi);</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = lo;</span><br><span class="line">        <span class="keyword">while</span>(++j &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= nums[lo]) &#123;</span><br><span class="line">                swap(nums[++i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[lo], nums[i]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(lo, hi);</span><br><span class="line">    quickSort(nums, lo, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, pivot + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. Find First and Last Position of Element in Sorted Array</a></h5><blockquote>
<p>给定一个以升序排列的整数<code>nums</code>数组，请找到给定目标值的开始和结束位置。如果在数组中未找到目标，则返回<code>[-1，-1]</code>。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = right_bound(nums, target - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> right = right_bound(nums, target);</span><br><span class="line">    <span class="keyword">if</span>(left &lt; <span class="number">0</span> || left &gt;= nums.size() || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;left, right - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边界搜索是返回第一个大于目标值的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[mi]) &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. Search a 2D Matrix II</a></h5><blockquote>
<p>  编写一个高效的算法来搜索<code>m x n</code>矩阵<code>matrix</code>中的一个目标值<code>target</code>。该矩阵具有以下特性：</p>
<ol>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ol>
<p>  <strong>Example 1:</strong></p>
  <img src="searchgrid.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <img src="searchgrid2.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; n &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; matrix[r][c]) &#123;</span><br><span class="line">            c--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[r][c]) &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">162. Find Peak Element</a></h5><blockquote>
<p>  峰值元素是指其值严格大于左右相邻值的元素。给你一个输入数组<code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回<strong>任何一个峰值</strong>所在位置即可。</p>
<p>  你可以假设<code>nums[-1] = nums[n] = -∞</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mi] &gt; nums[mi + <span class="number">1</span>])</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="658-Find-K-Closest-Elements"><a href="#658-Find-K-Closest-Elements" class="headerlink" title="658. Find K Closest Elements"></a><a href="https://leetcode.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. Find K Closest Elements</a></h5><blockquote>
<p>  给定一个排序好的数组<code>arr</code>，两个整数<code>k</code>和<code>x</code>，从数组中找到最靠近<code>x</code>（两数之差最小）的<code>k</code>个数。返回的结果必须要是按升序排好的。</p>
<p>  整数<code>a</code>比整数<code>b</code>更接近<code>x</code>需要满足：</p>
<ul>
<li><code>|a - x| &lt; |b - x|</code>或者</li>
<li><code>|a - x| == |b - x|</code>且<code>a &lt; b</code>.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照与 x 差值的绝对值进行排序</span></span><br><span class="line"><span class="comment">// 返回排序后数组的前 k 个元素的原始顺序即可</span></span><br><span class="line"><span class="comment">// 时间复杂度为排序的复杂度 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(arr)</span></span>;</span><br><span class="line">    sort(res.begin(), res.end(),</span><br><span class="line">         [x](<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">abs</span>(a - x) == <span class="built_in">abs</span>(b - x) ? a &lt; b : <span class="built_in">abs</span>(a - x) &lt; <span class="built_in">abs</span>(b - x);</span><br><span class="line">         &#125;);</span><br><span class="line">    res.resize(k);</span><br><span class="line">    sort(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为数组已经是有序的, 先通过二分搜索找到 x 在数组中的位置</span></span><br><span class="line"><span class="comment">// 根据 x 的位置不同有几种情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; res(k);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 里面这段二分搜索是左边界搜索</span></span><br><span class="line">    <span class="comment">// lo 最后指向第一个大于等于 x 的元素</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = arr.size();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= arr[mi]) &#123;</span><br><span class="line">            hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 小于等于数组中的任何数, 那离 x 最近的就是前 k 个元素</span></span><br><span class="line">    <span class="keyword">if</span>(lo == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// copy_n(arr.begin(), k, res.begin());</span></span><br><span class="line">        copy(arr.begin(), arr.end(), back_inserter(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 大于等于数组中的任何数, 那离 x 最近的就是后 k 个元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(lo == arr.size()) &#123;</span><br><span class="line">        <span class="comment">// copy_n(arr.end() - k, k, res.begin());</span></span><br><span class="line">        copy(prev(arr.end(), k), arr.end(), back_inserter(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在中间, 就设置两个指针</span></span><br><span class="line">        <span class="comment">// 左右指针离 lo 的位置都为 k, 组成一个窗口</span></span><br><span class="line">        <span class="comment">// 在窗口中移动双指针使得窗口内元素数缩减为最接近 x 的 k 个数即可</span></span><br><span class="line">        <span class="keyword">int</span> left = max(lo - k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right = min(lo + k, <span class="keyword">int</span>(arr.size()) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(right - left &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[left] - x) &lt;= <span class="built_in">abs</span>(arr[right] - x)) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy_n(arr.begin() + left, k, res.begin());</span></span><br><span class="line">        copy(next(arr.begin(), left), next(arr.begin(), left + k), back_inserter(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="719-Find-K-th-Smallest-Pair-Distance"><a href="#719-Find-K-th-Smallest-Pair-Distance" class="headerlink" title="719. Find K-th Smallest Pair Distance"></a><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/" target="_blank" rel="noopener">719. Find K-th Smallest Pair Distance</a></h5><blockquote>
<p>  给定一个整数数组，返回所有数对之间的<strong>第<code>k</code>个最小距离</strong>。一对<code>(A, B)</code> 的距离被定义为<code>A</code>和<code>B</code>之间的绝对差值。</p>
<p>  <strong>Note:</strong></p>
<ol>
<li><code>2 &lt;= len(nums) &lt;= 10000</code>.</li>
<li><code>0 &lt;= nums[i] &lt; 1000000</code>.</li>
<li><code>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2</code>.</li>
</ol>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums &#x3D; [1,3,1]</span><br><span class="line">k &#x3D; 1</span><br><span class="line">Output: 0 </span><br><span class="line">Explanation:</span><br><span class="line">Here are all the pairs:</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">Then the 1st smallest distance pair is (1,1), and its distance is 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力解法</span></span><br><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distances;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</span><br><span class="line">            distances.push_back(<span class="built_in">abs</span>(nums[i] - nums[j]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = distances.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(distances, lo, hi);</span><br><span class="line">        <span class="keyword">if</span>(pivot == k - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> distances[pivot];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pivot &lt; k - <span class="number">1</span>)</span><br><span class="line">            lo = pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = pivot - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = lo;</span><br><span class="line">    <span class="keyword">while</span>(++j &lt;= hi)</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &lt; nums[lo])</span><br><span class="line">            swap(nums[++i], nums[j]);</span><br><span class="line">    swap(nums[lo], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用一个 multiset 实现起来更简单, 但还是 Time Limit Exceeded!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="comment">// 因为核心在这, 计算所有的 pair 复杂度为 O(n2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</span><br><span class="line">            setting.insert(<span class="built_in">abs</span>(nums[i] - nums[j]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = next(setting.begin(), k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binary search, a good idea.</span></span><br><span class="line"><span class="comment">// another problem, 373. Find K Pairs with Smallest Sums</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先把数组排序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// pairs 之间的差值最小无非就是 0</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最大就是尾元素减去首元素嘛</span></span><br><span class="line">    <span class="keyword">int</span> hi = nums.back() - nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 问题转化为在这个范围内找到一个差值</span></span><br><span class="line">    <span class="comment">// 使得有 k - 1 个 pair 的差值不比它大</span></span><br><span class="line">    <span class="comment">// 这种在有序的数值范围内搜索一个特定值就是典型的二分搜索的应用</span></span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取差值的中间</span></span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 下面应用一个滑动窗口算法计算有多少个比 mi 小的差值</span></span><br><span class="line">        <span class="comment">// 不要被两个 while 循环吓到了, 实际复杂度只有 O(n), 不清楚看最下面注释</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[right] - nums[left] &gt; mi)</span><br><span class="line">                left++;</span><br><span class="line">            count += right - left;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// count == number of pairs with distance &lt;= mi</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= count)</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. Time Complexity:O(NlogW + NlogN), where N is the length of nums, and W is equal to nums[nums.length - 1] - nums[0]. The logW factor comes from our binary search, and we do O(N) work inside our call to possible (or to calculate count). The final O(NlogN) factor comes from sorting.</span></span><br><span class="line"><span class="comment">2. Space Complexity: O(1). No additional space is used except for integer variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">It is O(N). the possible function is a classic sliding windowing solution, left and right would always increment in each outer loop iteration, that is 'left' and 'right' sweeps elements in the array only once. So time complexity is O(2N) = O(N).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/" target="_blank" rel="noopener">373. Find K Pairs with Smallest Sums</a></h5><blockquote>
<p>  给定两个以升序排列的整形数组<code>nums1</code>和<code>nums2</code>，以及一个整数<code>k</code>。</p>
<p>  定义一对值<code>(u,v)</code>，其中第一个元素来自<code>nums1</code>，第二个元素来自<code>nums2</code>。</p>
<p>  找到和最小的<code>k</code>对数字<code>(u1,v1),(u2,v2)...(uk,vk)</code>。</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li>
<li><code>nums1</code> and <code>nums2</code> both are sorted in <strong>ascending order</strong>.</li>
<li><code>1 &lt;= k &lt;= 1000</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3</span><br><span class="line">Output: [[1,2],[1,4],[1,6]]</span><br><span class="line">Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,1,2], nums2 &#x3D; [1,2,3], k &#x3D; 2</span><br><span class="line">Output: [[1,1],[1,1]]</span><br><span class="line">Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [3], k &#x3D; 3</span><br><span class="line">Output: [[1,3],[2,3]]</span><br><span class="line">Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kSmallestPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123; <span class="keyword">return</span> a.first + a.second &lt; b.first + b.second; &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; pq(cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num1 : nums1) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num2 : nums2) &#123;</span><br><span class="line">            pq.push(&#123;num1, num2&#125;);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k) &#123;</span><br><span class="line">                pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        res.push_back(&#123;pq.top().first, pq.top().second&#125;);</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. Minimum Size Subarray Sum</a></h5><blockquote>
<p>  给定一个含有<code>n</code>个正整数的数组和一个正整数<code>target</code>。</p>
<p>  找出该数组中满足其和<code>≥ target</code>的长度最小的连续子数组<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回<code>0</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 4, nums &#x3D; [1,4,4]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(n), S: O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(nums.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(prefix[right] - prefix[left] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            res = min(res, right - left);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(n), S: O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            res = min(res, right - left);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(nlogn), S: O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefixSum</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++)</span><br><span class="line">        prefixSum[i] = prefixSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to_find = target + prefixSum[i];</span><br><span class="line">        <span class="comment">// auto it = lower_bound(prefixSum.begin(), prefixSum.end(), to_find);</span></span><br><span class="line">        <span class="comment">// if(it != prefixSum.end())</span></span><br><span class="line">        <span class="comment">//     res = min(res, int(distance(prefixSum.begin(), it)) - i);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> it = _lower_bound(prefixSum, to_find);</span><br><span class="line">        <span class="keyword">if</span>(it != prefixSum.size())</span><br><span class="line">            res = min(res, it - i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _lower_bound(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[mi])</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"></a><a href="https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</a></h5><blockquote>
<p>给你一个整数数组<code>nums</code>，和一个表示限制的整数<code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于<code>limit</code>。如果不存在满足条件的子数组，则返回<code>0</code>。</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
<li><code>0 &lt;= limit &lt;= 109</code></li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">&gt;Output: 2 </span><br><span class="line">&gt;Explanation: All subarrays are: </span><br><span class="line">&gt;[8] with maximum absolute diff |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">&gt;[8,2] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">&gt;[8,2,4] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">&gt;[8,2,4,7] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">&gt;[2] with maximum absolute diff |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">&gt;[2,4] with maximum absolute diff |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">&gt;[2,4,7] with maximum absolute diff |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">&gt;[4] with maximum absolute diff |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">&gt;[4,7] with maximum absolute diff |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">&gt;[7] with maximum absolute diff |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">&gt;Therefore, the size of the longest subarray is 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">&gt;Output: 4 </span><br><span class="line">&gt;Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| &#x3D; 5 &lt;&#x3D; 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">&gt;Output: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题使用一个滑动窗口是毋庸置疑的</span></span><br><span class="line"><span class="comment">// 关键是我们希望实时的知道窗口内元素的最大值和最小值</span></span><br><span class="line"><span class="comment">// 那么我们要将窗口内的元素存储在哪种合适的数据结构中</span></span><br><span class="line"><span class="comment">// 满足我们要求的同时还能保证效率呢</span></span><br><span class="line"><span class="comment">// 1. 二叉搜索树, 我们可以方便的获得其中的最大值和最小值, 并且插入的效率为 o(logn)</span></span><br><span class="line"><span class="comment">//    最小值在树的最左边, 最大值在树的最右边</span></span><br><span class="line"><span class="comment">// 2. 单调队列, 使用两个单调队列, 一个是从队首到队尾递减的顺序, 一个是从队首到队尾递增的顺序</span></span><br><span class="line"><span class="comment">//    这样最大值和最小值分别都在它们的队首, 插入的效率为 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意窗口中可能存在的重复值的情况</span></span><br><span class="line"><span class="comment">// 这些重复值在搜索树或者在队列中都要同时存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口 + multiset</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        setting.insert(nums[right++]);</span><br><span class="line">        <span class="keyword">while</span>(*setting.rbegin() - *setting.begin() &gt; limit)</span><br><span class="line">            setting.erase(setting.find(nums[left++]));</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小技巧: 对于需要实时获取序列中最大值或最小值的问题, 单调队列是非常适合的数据结构!</span></span><br><span class="line"><span class="comment">// 滑动窗口 + 单调队列</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; minQ;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxQ;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!minQ.empty() &amp;&amp; minQ.back() &gt; nums[right])</span><br><span class="line">            minQ.pop_back();</span><br><span class="line">        <span class="keyword">while</span>(!maxQ.empty() &amp;&amp; maxQ.back() &lt; nums[right])</span><br><span class="line">            maxQ.pop_back();</span><br><span class="line"></span><br><span class="line">        minQ.push_back(nums[right]);</span><br><span class="line">        maxQ.push_back(nums[right]);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(!minQ.empty() &amp;&amp; !maxQ.empty() &amp;&amp; (maxQ.front() - minQ.front() &gt; limit))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(minQ.front() == nums[left])</span><br><span class="line">                minQ.pop_front();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(maxQ.front() == nums[left])</span><br><span class="line">                maxQ.pop_front();</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一个数组模拟两个单调队列是真的秀啊</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// minL 和 minR 是最小值区间的左右指针, maxL 和 maxR 是最大值区间的左右指针</span></span><br><span class="line">    <span class="keyword">int</span> minL = <span class="number">0</span>, minR = <span class="number">-1</span>, maxL = nums.size(), maxR = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// l, r 是 nums 的左右指针</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个数组用来记录最小值和最大值</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ascending</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="comment">// 开始遍历 nums</span></span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果遍历到的数字在最小值区间内, 就收缩最小值区间</span></span><br><span class="line">        <span class="keyword">while</span>(minR &gt;= minL &amp;&amp; nums[r] &lt; ascending[minR])</span><br><span class="line">            minR--;</span><br><span class="line">        <span class="comment">// 如果遍历到的数字在最大值区间内, 就收缩最大值区间</span></span><br><span class="line">        <span class="keyword">while</span>(maxR &gt;= maxL &amp;&amp; nums[r] &gt; ascending[maxL])</span><br><span class="line">            maxL++;</span><br><span class="line">        <span class="comment">// 拓展最小值和最大值区间</span></span><br><span class="line">        ascending[++minR] = nums[r];</span><br><span class="line">        ascending[--maxL] = nums[r];</span><br><span class="line">        r++;</span><br><span class="line">        <span class="comment">// 判断子集长度是否符合 limit 的要求, 如果不符合要求, 就收缩子集</span></span><br><span class="line">        <span class="keyword">while</span>(ascending[maxR] - ascending[minL] &gt; limit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 开始收缩子集, 使子集左指针右移</span></span><br><span class="line">            <span class="comment">// 如果子集左指针是最小值, 那么最小值将被移除, 所以更新存储最小值的区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == ascending[minL])</span><br><span class="line">                minL++;</span><br><span class="line">            <span class="comment">// 如果子集左指针是最大值, 那么最大值将被移除, 所以更新存储最大值的区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == ascending[maxR])</span><br><span class="line">                maxR--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, r - l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220. Contains Duplicate III"></a><a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. Contains Duplicate III</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>和两个整数<code>k</code>和<code>t</code>。请你判断是否存在两个不同下标<code>i</code>和<code>j</code>，使得<code>abs(nums[i] - nums[j]) &lt;= t</code>，同时又满足<code>abs(i - j) &lt;= k</code>。如果存在则返回<code>true</code>，不存在返回<code>false</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,0,1,1], k &#x3D; 1, t &#x3D; 2</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口 + 二叉搜索树</span></span><br><span class="line"><span class="comment">// 在 set 中维护一个元素数为 k 的滑动窗口</span></span><br><span class="line"><span class="comment">// 这可保证在 set 中的元素的索引满足 abs(i - j) &lt;= k</span></span><br><span class="line"><span class="comment">// 我们每迭代到数组中的下一个元素 [nums[i], 在更新 set 前</span></span><br><span class="line"><span class="comment">// 都要在其中找到一个在 [nums[i] - k, nums[i] + k] 范围内的值</span></span><br><span class="line"><span class="comment">// 如果存在, 那么就满足 abs(nums[i] - nums[j]) &lt;= t</span></span><br><span class="line"><span class="comment">// 为什么选择 multiset?</span></span><br><span class="line"><span class="comment">// 因为 set 具有自动排序的特性, 并且每次查找、删除和插入的复杂度都为</span></span><br><span class="line"><span class="comment">// 高效的 log(n). 因为我们要频繁地查找在范围 [nums[i] - k,</span></span><br><span class="line"><span class="comment">// nums[i] + k] 内的值, 还要频繁地删除和插入元素以维持固定地滑动窗口大小</span></span><br><span class="line"><span class="comment">// 注意一点, 在计算 nums[i] - k 和 nums[i] + k 的时候可能会出现数值溢出</span></span><br><span class="line"><span class="comment">// 所以要全部用 long</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; ms;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意此时 nums[i] 是不包含在窗口内的</span></span><br><span class="line">        <span class="comment">// 并且窗口内的元素数量 ? &lt;= k, 我们以第 ? + 1 个元素为对象</span></span><br><span class="line">        <span class="comment">// 寻找满足条件的另一个元素, 这样每一个元素都会 [被看作对象] 一次</span></span><br><span class="line">        <span class="keyword">long</span> valMin = (<span class="keyword">long</span>)nums[i] - (<span class="keyword">long</span>)t;</span><br><span class="line">        <span class="comment">// iter 指向首次进入 [nums[i] - k, ... 范围的数</span></span><br><span class="line">        <span class="comment">// 因此还要验证这个数是否也在 ..., nums[i] + k] 范围内</span></span><br><span class="line">        <span class="keyword">auto</span> iter = ms.lower_bound(valMin);</span><br><span class="line">        <span class="comment">// 如果存在这么一个数, 就找到满足条件的两个数了</span></span><br><span class="line">        <span class="keyword">if</span>(iter != ms.end() &amp;&amp; *iter &lt;= (<span class="keyword">long</span>)nums[i] + (<span class="keyword">long</span>)t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前对象已经处理过了, 将它放进窗口</span></span><br><span class="line">        <span class="comment">// 如果窗口大小超过 k 了, 还要将最左边的那个数剔出窗口</span></span><br><span class="line">        ms.insert(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(ms.size() &gt; k)</span><br><span class="line">            ms.erase(nums[i - k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口 + 分桶</span></span><br><span class="line"><span class="comment">// 将数组中的数值按照映射函数分配到相应桶中</span></span><br><span class="line"><span class="comment">// 映射函数为 桶号 id = value / (t + 1)</span></span><br><span class="line"><span class="comment">// 这样可保证</span></span><br><span class="line"><span class="comment">// 1. 映射到同一个桶的数值之差一定小于等于 t</span></span><br><span class="line"><span class="comment">// 2. 相邻桶中也有可能存在差值小于等于 t 的情况</span></span><br><span class="line"><span class="comment">// 3. 不相邻的桶中元素差值必定大于 t</span></span><br><span class="line"><span class="comment">// 如数组为 [1 5 9 1 3 7 8], k = 2, t = 3, 桶宽度为 t + 1 = 4</span></span><br><span class="line"><span class="comment">// 0 号桶: [1 1 3], 1 号桶: [5 7], 2 号桶: [9 8]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bucketsWidth = <span class="keyword">long</span>(t) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; buckets;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = getKey(nums[i], bucketsWidth);</span><br><span class="line">        <span class="comment">// 在一个桶中一定满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.count(id)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 在左边相邻桶中, 再判断差值是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.count(id - <span class="number">1</span>) &amp;&amp; nums[i] - buckets[id - <span class="number">1</span>] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 在右边相邻桶中, 再判断差值是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.count(id + <span class="number">1</span>) &amp;&amp; buckets[id + <span class="number">1</span>] - nums[i] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        buckets[id] = nums[i];</span><br><span class="line">        <span class="comment">// 保证所有桶中的元素小于等于 k 个</span></span><br><span class="line">        <span class="comment">// 如果大于 k, 就将窗口最左边的元素剔除</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.size() &gt; k)</span><br><span class="line">            buckets.erase(getKey(nums[i - k], bucketsWidth));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKey</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">long</span> bucketsWidth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = value / bucketsWidth;</span><br><span class="line">    <span class="comment">// 注意这里如果 value 为负数, 需要将桶号减 1</span></span><br><span class="line">    <span class="comment">// 保证 0 号桶的正确性</span></span><br><span class="line">    <span class="keyword">if</span>(value &lt; <span class="number">0</span>) id--;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="498-Diagonal-Traverse"><a href="#498-Diagonal-Traverse" class="headerlink" title="498. Diagonal Traverse"></a><a href="https://leetcode.com/problems/diagonal-traverse/" target="_blank" rel="noopener">498. Diagonal Traverse</a></h5><blockquote>
<p>  给定一个含有<code>m x n</code>个元素的矩阵（<code>m</code>行，<code>n</code>列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p>
<p>  <strong>Example 1:</strong></p>
  <img src="diag1-grid.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[1,2],[3,4]]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">v</span><span class="params">(m + n - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            v[i + j].push_back(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            reverse(v[i].begin(), v[i].end());</span><br><span class="line">        res.insert(res.end(), v[i].begin(), v[i].end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].size(); j++)</span><br><span class="line">            mapping[i + j].push_back(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: mapping)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.first % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            res.insert(res.end(), p.second.rbegin(), p.second.rend());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.insert(res.end(), p.second.begin(), p.second.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1424-Diagonal-Traverse-II"><a href="#1424-Diagonal-Traverse-II" class="headerlink" title="1424. Diagonal Traverse II"></a><a href="https://leetcode.com/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">1424. Diagonal Traverse II</a></h5><blockquote>
<p>给你一个列表<code>num</code>，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回<code>num</code>中对角线上的整数。</p>
<p><strong>Example 1:</strong></p>
<p><img src="sample_1_1784.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">&gt;Output: [1,4,2,7,5,3,8,6,9]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="sample_2_1784.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">&gt;Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].size(); j++)</span><br><span class="line">            mapping[i + j].push_back(nums[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: mapping)</span><br><span class="line">        res.insert(res.end(), p.second.rbegin(), p.second.rend());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a><a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. Spiral Matrix</a></h5><blockquote>
<p>  给你一个<code>m</code>行<code>n</code>列的矩阵<code>matrix</code>，请按照<strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p>
<p>  <strong>Example 1:</strong></p>
  <img src="spiral1.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <img src="spiral.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Traverse the matrix in the spiral order by keeping four variables</span></span><br><span class="line"><span class="comment">// u for the uppermost row, d for the downmost row</span></span><br><span class="line"><span class="comment">// l for the leftmost column, r for the rightmost column.</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>, d = m - <span class="number">1</span>, l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">order</span><span class="params">(m * n)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (u &lt;= d &amp;&amp; l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = l; col &lt;= r; col++)</span><br><span class="line">            order[p++] = matrix[u][col];</span><br><span class="line">        <span class="keyword">if</span>(++u &gt; d) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = u; row &lt;= d; row++)</span><br><span class="line">            order[p++] = matrix[row][r];</span><br><span class="line">        <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = r; col &gt;= l; col--)</span><br><span class="line">            order[p++] = matrix[d][col];</span><br><span class="line">        <span class="keyword">if</span>(--d &lt; u) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = d; row &gt;= u; row--)</span><br><span class="line">            order[p++] = matrix[row][l];</span><br><span class="line">        <span class="keyword">if</span>(l++ &gt; r) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1288-Remove-Covered-Intervals"><a href="#1288-Remove-Covered-Intervals" class="headerlink" title="1288. Remove Covered Intervals"></a><a href="https://leetcode.com/problems/remove-covered-intervals/" target="_blank" rel="noopener">1288. Remove Covered Intervals</a></h5><blockquote>
<p>  Given a list of <code>intervals</code>, remove all intervals that are covered by another interval in the list.</p>
<p>  Interval <code>[a,b)</code> is covered by interval <code>[c,d)</code> if and only if <code>c &lt;= a</code> and <code>b &lt;= d</code>.</p>
<p>  After doing so, return <em>the number of remaining intervals</em>.</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 1000</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= intervals[i][0] &lt; intervals[i][1] &lt;= 10^5</code></li>
<li>All the intervals are <strong>unique</strong>.</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[3,6],[2,8]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[2,3]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所谓区间问题, 就是线段问题, 让你合并所有线段、找出线段的交集等等.</span></span><br><span class="line"><span class="comment">// 主要有两个技巧:</span></span><br><span class="line"><span class="comment">// 1. 排序, 常见的排序方法就是按照区间起点或者终点排序. 一般都是先按照起点升序排序.</span></span><br><span class="line"><span class="comment">//    若起点相同，则按照终点降序排序</span></span><br><span class="line"><span class="comment">// 2. 画图, 就是说不要偷懒, 勤动手, 两个区间的相对位置到底有几种可能,</span></span><br><span class="line"><span class="comment">//    不同的相对位置我们的代码应该怎么去处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    res.reserve(intervals.size());</span><br><span class="line">    res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; interval = intervals[i];</span><br><span class="line">        <span class="comment">// 区间相交</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt;= interval[<span class="number">0</span>] &amp;&amp; right &lt; interval[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            right = interval[<span class="number">1</span>];</span><br><span class="line">            res.push_back(interval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 区间不相交</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right &lt;= interval[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            left = interval[<span class="number">0</span>];</span><br><span class="line">            right = interval[<span class="number">1</span>];</span><br><span class="line">            res.push_back(interval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 区间被覆盖的扔掉就行了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">56. Merge Intervals</a></h5><blockquote>
<p>  Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 104</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)&#123; <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? b[<span class="number">1</span>] &lt; a[<span class="number">1</span>] : a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; &#125;;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>], right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; interval = intervals[i];</span><br><span class="line">        <span class="comment">// 区间相交</span></span><br><span class="line">        <span class="comment">// 可能会有 [3, 3] 这样的区间, 判定和 [1, 3] 相交就行了</span></span><br><span class="line">        <span class="comment">// 不然的话会被当做不相交被加进去</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt;= interval[<span class="number">0</span>] &amp;&amp; right &lt;= interval[<span class="number">1</span>])</span><br><span class="line">            right = interval[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 区间不相交</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right &lt; interval[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(&#123;left, right&#125;);</span><br><span class="line">            left = interval[<span class="number">0</span>];</span><br><span class="line">            right = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 区间被覆盖的扔掉就行了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意最后一个区间可能没被加进去</span></span><br><span class="line">    <span class="keyword">if</span>(res.empty() || res.back() != <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left, right&#125;))</span><br><span class="line">        res.push_back(&#123;left, right&#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="noopener">57. Insert Interval</a></h5><blockquote>
<p>  给你一个<strong>无重叠的</strong>，按照区间起始端点排序的区间列表。</p>
<p>  在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [], newInterval &#x3D; [5,7]</span><br><span class="line">Output: [[5,7]]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,5]], newInterval &#x3D; [2,7]</span><br><span class="line">Output: [[1,7]]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a1 = newInterval[<span class="number">0</span>], b1 = newInterval[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a2 = intervals[i][<span class="number">0</span>], b2 = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 相交</span></span><br><span class="line">        <span class="keyword">if</span>(b2 &gt;= a1 &amp;&amp; b1 &gt;= a2)</span><br><span class="line">        &#123;</span><br><span class="line">            a1 = min(a1, a2);</span><br><span class="line">            b1 = max(b1, b2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不相交</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b1 &lt; a2 &amp;&amp; !found)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(&#123;a1, b1&#125;);</span><br><span class="line">            res.push_back(&#123;a2, b2&#125;);</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(&#123;a2, b2&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!found) res.push_back(&#123;a1, b1&#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="986-Interval-List-Intersections"><a href="#986-Interval-List-Intersections" class="headerlink" title="986. Interval List Intersections"></a><a href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener">986. Interval List Intersections</a></h5><blockquote>
<p>  给定两个由一些闭区间组成的列表，<code>firstList</code>和<code>secondList</code>，其中<code>firstList[i] = [start_i, end_i]</code>而<code>secondList[j] = [start_j, end_j]</code>。每个区间列表都是成对不相交的，并且已经排序。</p>
<p>  返回这两个区间列表的交集 。</p>
<p>  形式上，闭区间<code>[a, b]</code>（其中<code>a &lt;= b</code>）表示实数<code>x</code>的集合，而<code>a &lt;= x &lt;= b</code>。</p>
<p>  两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，<code>[1, 3]</code>和<code>[2, 4]</code>的交集为<code>[2, 3]</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <img src="interval1.png" alt="img" style="zoom: 33%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: firstList &#x3D; [[0,2],[5,10],[13,23],[24,25]], secondList &#x3D; [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: firstList &#x3D; [[1,3],[5,9]], secondList &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: firstList &#x3D; [], secondList &#x3D; [[4,8],[10,12]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= firstList.length, secondList.length &lt;= 1000</code></li>
<li><code>firstList.length + secondList.length &gt;= 1</code></li>
<li><code>0 &lt;= start_i &lt; end_i &lt;= 109</code></li>
<li><code>endi &lt; start_(i + 1)</code></li>
<li><code>0 &lt;= start_j &lt; end_j &lt;= 109</code></li>
<li><code>endj &lt; start_(j + 1)</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">intervalIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; firstList, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; secondList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; firstList.size() &amp;&amp; j &lt; secondList.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a1 = firstList[i][<span class="number">0</span>], b1 = firstList[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> a2 = secondList[j][<span class="number">0</span>], b2 = secondList[j][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(b1 &gt;= a2 &amp;&amp; b2 &gt;= a1)</span><br><span class="line">            res.push_back(&#123;max(a1, a2), min(b1, b2)&#125;);</span><br><span class="line">        <span class="keyword">if</span>(b1 &lt;= b2) i++;</span><br><span class="line">        <span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a><a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. Non-overlapping Intervals</a></h5><blockquote>
<p>  给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>  注意:</p>
<ul>
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间<code>[1,2]</code>和<code>[2,3]</code>的边界相互“接触”，但没有相互重叠。</li>
</ul>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= intervals.size() &lt;= 2 * 10^4</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[1,2],[1,2]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2],[2,3]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题问的是至少删除多少个区间使得不再存在重叠区间</span></span><br><span class="line"><span class="comment">// 按照区间起点排序, 起点相同按终点排序</span></span><br><span class="line"><span class="comment">// 计数相交区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(intervals.begin(), intervals.end());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a1 = intervals[<span class="number">0</span>][<span class="number">0</span>], b1 = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a2 = intervals[i][<span class="number">0</span>], b2 = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果相交就移除后面那个区间</span></span><br><span class="line">        <span class="keyword">if</span>(b2 &gt; a1 &amp;&amp; b1 &gt; a2)</span><br><span class="line">        &#123;</span><br><span class="line">            a1 = min(a1, a2);</span><br><span class="line">            b1 = min(b1, b2);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a1 = a2;</span><br><span class="line">            b1 = b2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题问的是至少删除多少个区间使得不再存在重叠区间</span></span><br><span class="line"><span class="comment">// 换个思路</span></span><br><span class="line"><span class="comment">// 按照区间终点排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123; <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; &#125;;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">    <span class="keyword">int</span> pre_end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> start = intervals[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 如果后一个区间的起点比前一个的终点小就重叠了</span></span><br><span class="line">        <span class="keyword">if</span>(start &lt; pre_end)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pre_end = intervals[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. Minimum Number of Arrows to Burst Balloons</a></h5><blockquote>
<p>  在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>  一支弓箭可以沿着<code>x</code>轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为<code>xstart</code>，<code>xend</code>， 且满足<code>xstart ≤ x ≤ xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>  给你一个数组<code>points</code>，其中<code>points [i] = [xstart, xend]</code>，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: One way is to shoot one arrow for example at x &#x3D; 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x &#x3D; 11 (bursting the other two balloons).</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照区间终点排序</span></span><br><span class="line"><span class="comment">// 最多有多少个不重叠的区间 == n - 至少删除多少个区间使得不再存在重叠区间</span></span><br><span class="line"><span class="comment">// 最多有多少个不重叠的区间就是题目所问的至少需要的箭的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123; <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; &#125;;</span><br><span class="line">    sort(points.begin(), points.end(), cmp);</span><br><span class="line">    <span class="comment">// count 是最多有多少个不重叠的区间</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = points.size();</span><br><span class="line">    <span class="keyword">int</span> pre_end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> start = points[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 如果后一个区间的起点比前一个的终点小就重叠了</span></span><br><span class="line">        <span class="comment">// 因为这题边界触碰也能引爆气球, 所以属于重叠区间</span></span><br><span class="line">        <span class="comment">// 因此不是 &gt;= 号</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; pre_end)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            pre_end = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="436-Find-Right-Interval"><a href="#436-Find-Right-Interval" class="headerlink" title="436. Find Right Interval"></a><a href="https://leetcode.com/problems/find-right-interval/" target="_blank" rel="noopener">436. Find Right Interval</a></h5><blockquote>
<p>  给你一个区间数组<code>intervals</code>，其中<code>intervals[i] = [starti, endi]</code>，且每个<code>starti</code>都不同 。</p>
<p>  区间<code>i</code>的右侧区间可以记作区间<code>j</code>，并满足<code>startj &gt;= endi</code>，且<code>startj</code>最小化 。</p>
<p>  返回一个由每个区间<code>i</code>的右侧区间的最小起始位置组成的数组。如果某个区间<code>i</code>不存在对应的右侧区间，则下标<code>i</code>处的值设为<code>-1</code>。</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 2 * 10^4</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>-10^6 &lt;= starti &lt;= endi &lt;= 10^6</code></li>
<li>The start point of each interval is <strong>unique</strong>.</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,2]]</span><br><span class="line">Output: [-1]</span><br><span class="line">Explanation: There is only one interval in the collection, so it outputs -1.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[3,4],[2,3],[1,2]]</span><br><span class="line">Output: [-1,0,1]</span><br><span class="line">Explanation: There is no right interval for [3,4].</span><br><span class="line">The right interval for [2,3] is [3,4] since start0 &#x3D; 3 is the smallest start that is &gt;&#x3D; end1 &#x3D; 3.</span><br><span class="line">The right interval for [1,2] is [2,3] since start1 &#x3D; 2 is the smallest start that is &gt;&#x3D; end2 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[2,3],[3,4]]</span><br><span class="line">Output: [-1,2,-1]</span><br><span class="line">Explanation: There is no right interval for [1,4] and [3,4].</span><br><span class="line">The right interval for [2,3] is [3,4] since start2 &#x3D; 3 is the smallest start that is &gt;&#x3D; end1 &#x3D; 3.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序后顺序搜索, 最差情况下时间复杂度为 O(n2)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        intervals[i].push_back(i);</span><br><span class="line">    sort(intervals.begin(), intervals.end());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &lt;= intervals[j][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                res[intervals[i][<span class="number">2</span>]] = intervals[j][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序后二分搜索, 时间复杂度降为 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        intervals[i].push_back(i);</span><br><span class="line">    sort(intervals.begin(), intervals.end());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = left_bound(intervals, i, n, intervals[i]);</span><br><span class="line">        <span class="keyword">if</span>(index &lt; n)</span><br><span class="line">            res[intervals[i][<span class="number">2</span>]] = intervals[index][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; interval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(interval[<span class="number">1</span>] &lt;= intervals[mi][<span class="number">0</span>])</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="713-Subarray-Product-Less-Than-K"><a href="#713-Subarray-Product-Less-Than-K" class="headerlink" title="713. Subarray Product Less Than K"></a><a href="https://leetcode.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">713. Subarray Product Less Than K</a></h5><blockquote>
<p>  给定一个正整数数组<code>nums</code>。找出该数组内乘积小于<code>k</code>的连续的子数组的个数。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [10, 5, 2, 6], k &#x3D; 100</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</span><br><span class="line">Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</span><br></pre></td></tr></table></figure>

<p>  <strong>Note:</strong></p>
<ul>
<li><code>0 &lt; nums.length &lt;= 50000</code>.</li>
<li><code>0 &lt; nums[i] &lt; 1000</code>.</li>
<li><code>0 &lt;= k &lt; 10^6</code>.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> product = <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        product *= nums[right++];</span><br><span class="line">        <span class="keyword">while</span>(product &gt;= k)</span><br><span class="line">            product /= nums[left++];</span><br><span class="line">        count += right - left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="525-Contiguous-Array"><a href="#525-Contiguous-Array" class="headerlink" title="525. Contiguous Array"></a><a href="https://leetcode.com/problems/contiguous-array/" target="_blank" rel="noopener">525. Contiguous Array</a></h5><blockquote>
<p>  Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p>
<p>  解题方法说明图：</p>
<p>  The following figure illustrates the observation for the sequence <code>[0 0 1 0 0 0 1 1]</code>。</p>
  <img src="535_Contiguous_Array.PNG" alt="Contiguous_Array" style="zoom: 67%;" />

<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置一个计数器 counter, 遇 0 减 1, 遇 1 加 1</span></span><br><span class="line"><span class="comment">// 出现相等的 counter 时则说明从第 1 次出现时的索引开始到当前索引的子数组满足条件</span></span><br><span class="line"><span class="comment">// 并且是最长的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cnt += nums[i] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(cnt)) &#123;</span><br><span class="line">            res = max(res, i - mapping[cnt]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mapping[cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h5><blockquote>
<p>  给定一个包含<code>n</code>个整数的数组<code>nums</code>和一个目标值<code>target</code>，判断<code>nums</code>中是否存在四个元素<code>a</code>，<code>b</code>，<code>c</code>和<code>d</code>，使得<code>a + b + c + d</code>的值与<code>target</code>相等？找出所有满足条件且不重复的四元组。</p>
<p>  注意：答案中不可以包含重复的四元组。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nTargetSum(nums, target, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">nTargetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nSumResult;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curVals;</span><br><span class="line">    <span class="keyword">auto</span> twoSum = [&amp;](<span class="keyword">int</span> start, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> lo = start, hi = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">            <span class="keyword">int</span> loVal = nums[lo], hiVal = nums[hi];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 跳过重复数字，避免出现重复结果</span></span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == loVal) &#123;</span><br><span class="line">                    lo++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; sum) &#123;</span><br><span class="line">                <span class="comment">// 跳过重复数字，避免出现重复结果</span></span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == hiVal) &#123;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nSumResult.push_back(&#123;loVal, hiVal&#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> val : curVals) &#123;</span><br><span class="line">                    nSumResult.back().push_back(val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 跳过重复数字，避免出现重复结果</span></span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == loVal) &#123;</span><br><span class="line">                    lo++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == hiVal) &#123;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> nSum = [&amp;](<span class="keyword">auto</span>&amp;&amp; nSum, <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归基</span></span><br><span class="line">            twoSum(start, target);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; len; i++) &#123;</span><br><span class="line">            curVals.push_back(nums[i]);</span><br><span class="line">            nSum(nSum, i + <span class="number">1</span>, target - nums[i], n - <span class="number">1</span>);</span><br><span class="line">            curVals.pop_back();</span><br><span class="line">            <span class="comment">// 跳过重复数字，避免出现重复结果</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; len - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    nSum(nSum, <span class="number">0</span>, target, n);</span><br><span class="line">    <span class="keyword">return</span> nSumResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="面试题-17-10-主要元素"><a href="#面试题-17-10-主要元素" class="headerlink" title="面试题 17.10. 主要元素"></a><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/" target="_blank" rel="noopener">面试题 17.10. 主要元素</a></h5><blockquote>
<p>  数组中占比超过一半的元素称之为主要元素。给你一个整数数组，找出其中的主要元素。若没有，返回<code>-1</code>。</p>
<p>  请设计时间复杂度为<code>O(n)</code>、空间复杂度为<code>O(1)</code>的解决方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速选择，使中间元素就位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    nth_element(nums.begin(), nums.begin() + n / <span class="number">2</span>, nums.end());</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[n / <span class="number">2</span>]) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[n / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摩尔投票</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            lastNum = num;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == lastNum) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == lastNum) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lastNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位运算</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &amp; mask) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">            res |= mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == res) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; n/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253. Meeting Rooms II"></a><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="noopener">253. Meeting Rooms II</a></h5><blockquote>
<p>  给你一个会议时间安排的数组<code>intervals</code>，每个会议时间都会包括开始和结束的时间<code>intervals[i] = [start_i, end_i]</code>，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。</p>
<p>  <strong>示例 1：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[0,30],[5,10],[15,20]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 2：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals &#x3D; [[7,10],[2,4]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; times;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; interval : intervals) &#123;</span><br><span class="line">        times.emplace_back(interval[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">        times.emplace_back(interval[<span class="number">1</span>], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(times.begin(), times.end());</span><br><span class="line">    <span class="comment">// cnt 记录当前正在进行的会议数</span></span><br><span class="line">    <span class="comment">// res 记录最多的同时进行的会议数</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; [_, flag] : times) &#123;</span><br><span class="line">        cnt += flag;</span><br><span class="line">        res = max(res, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1094-Car-Pooling"><a href="#1094-Car-Pooling" class="headerlink" title="1094. Car Pooling"></a><a href="https://leetcode.com/problems/car-pooling/" target="_blank" rel="noopener">1094. Car Pooling</a></h5><blockquote>
<p>  假设你是一位顺风车司机，车上最初有<code>capacity</code>个空座位可以用来载客。由于道路的限制，车只能向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。</p>
<p>  这儿有一份乘客行程计划表<code>trips</code>[][]，其中<code>trips[i] = [num_passengers, start_location, end_location]</code>包含了第<code>i</code>组乘客的行程信息：</p>
<ul>
<li><p>必须接送的乘客数量；</p>
</li>
<li><p>乘客的上车地点；</p>
</li>
<li><p>以及乘客的下车地点。</p>
</li>
<li><p>这些给出的地点位置是从你的初始出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。</p>
<p>请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回<code>true</code>，否则请返回<code>false</code>）。</p>
</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[2,1,5],[3,5,7]], capacity &#x3D; 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips &#x3D; [[3,2,7],[3,7,9],[8,3,9]], capacity &#x3D; 11</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ol>
<li><code>trips.length &lt;= 1000</code></li>
<li><code>trips[i].length == 3</code></li>
<li><code>1 &lt;= trips[i][0] &lt;= 100</code></li>
<li><code>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000</code></li>
<li><code>1 &lt;= capacity &lt;= 100000</code></li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将这 1000 个距离点看作一个数组, 数组中元素是那一距离点的乘客数</span></span><br><span class="line"><span class="comment">// 把路程中每一个位置的乘客数在数组中构造出来</span></span><br><span class="line"><span class="comment">// 时时比较乘客数是否超过客容量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 距离最远就 1000 个距离单位</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">passengers</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; trip : trips) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = trip[<span class="number">1</span>]; i &lt; trip[<span class="number">2</span>]; i++) &#123;</span><br><span class="line">            passengers[i] += trip[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(passengers[i] &gt; capacity) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组</span></span><br><span class="line"><span class="comment">// 将这 1000 个距离点看作一个数组, 数组中元素是那一距离点的乘客数, 初始数组元素都为 0</span></span><br><span class="line"><span class="comment">// 对每一个 trip 更新数组区间的值, 使用差分数组记录这些更新</span></span><br><span class="line"><span class="comment">// 最后还原数组的时候, 判断是否出现超载</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; trip : trips) &#123;</span><br><span class="line">        diff[trip[<span class="number">1</span>]] += trip[<span class="number">0</span>];</span><br><span class="line">        diff[trip[<span class="number">2</span>]] -= trip[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        diff[i] += diff[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(diff[i] &gt; capacity) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1840-Maximum-Building-Height"><a href="#1840-Maximum-Building-Height" class="headerlink" title="1840. Maximum Building Height"></a><a href="https://leetcode.com/problems/maximum-building-height/" target="_blank" rel="noopener">1840. Maximum Building Height</a></h5><blockquote>
<p>  在一座城市里，你需要建<code>n</code>栋新的建筑。这些新的建筑会从<code>1</code>到<code>n</code>编号排成一列。</p>
<p>  这座城市对这些新建筑有一些规定：</p>
<ul>
<li><p>每栋建筑的高度必须是一个非负整数。</p>
</li>
<li><p>第一栋建筑的高度必须是<code>0</code>。</p>
</li>
<li><p>任意两栋相邻建筑的高度差不能超过<code>1</code>。</p>
</li>
<li><p>除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组<code>restrictions</code>的形式给出，其中<code>restrictions[i] = [idi, maxHeighti]</code>，表示建筑<code>idi</code>的高度 不能超过<code>maxHeighti</code>。</p>
<p>题目保证每栋建筑在<code>restrictions</code>中至多出现一次 ，同时建筑<code>1</code>不会 出现在<code>restrictions</code>中。</p>
<p>请你返回最高建筑能达到的最高高度 。</p>
</li>
</ul>
<p>  <strong>示例 1：</strong></p>
  <img src="ic236-q4-ex1-1.png" alt="img" style="zoom: 67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, restrictions &#x3D; [[2,1],[4,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [0,1,2,1,2] ，最高建筑的高度为 2 。</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 2：</strong></p>
  <img src="ic236-q4-ex2.png" alt="img" style="zoom: 67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 6, restrictions &#x3D; []</span><br><span class="line">输出：5</span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [0,1,2,3,4,5] ，最高建筑的高度为 5 。</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 3：</strong></p>
  <img src="ic236-q4-ex3.png" alt="img" style="zoom: 67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10, restrictions &#x3D; [[5,3],[2,5],[7,4],[10,3]]</span><br><span class="line">输出：5</span><br><span class="line">解释：上图中的绿色区域为每栋建筑被允许的最高高度。</span><br><span class="line">我们可以使建筑高度分别为 [0,1,2,3,3,4,4,5,4,3] ，最高建筑的高度为 5 。</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10^9</code></li>
<li><code>0 &lt;= restrictions.length &lt;= min(n - 1, 10^5)</code></li>
<li><code>2 &lt;= idi &lt;= n</code></li>
<li><code>idi</code> is <strong>unique</strong>.</li>
<li><code>0 &lt;= maxHeighti &lt;= 10^9</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxBuilding</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增加限制 (1, 0)</span></span><br><span class="line">    r.push_back(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    sort(r.begin(), r.end());</span><br><span class="line">    <span class="comment">// 增加限制 (n, n-1)</span></span><br><span class="line">    <span class="keyword">if</span>(r.back()[<span class="number">0</span>] != n) &#123;</span><br><span class="line">        r.push_back(&#123;n, n - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = r.size();</span><br><span class="line">    <span class="comment">// 从左向右传递限制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        r[i][<span class="number">1</span>] = min(r[i][<span class="number">1</span>], r[i - <span class="number">1</span>][<span class="number">1</span>] + (r[i][<span class="number">0</span>] - r[i - <span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右向左传递限制</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        r[i][<span class="number">1</span>] = min(r[i][<span class="number">1</span>], r[i + <span class="number">1</span>][<span class="number">1</span>] + (r[i + <span class="number">1</span>][<span class="number">0</span>] - r[i][<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 计算 r[i][0] 和 r[i + 1][0] 之间的建筑的最大高度</span></span><br><span class="line">        <span class="keyword">int</span> best = ((r[i + <span class="number">1</span>][<span class="number">0</span>] - r[i][<span class="number">0</span>]) + r[i][<span class="number">1</span>] + r[i + <span class="number">1</span>][<span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        res = max(res, best);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1838-Frequency-of-the-Most-Frequent-Element"><a href="#1838-Frequency-of-the-Most-Frequent-Element" class="headerlink" title="1838. Frequency of the Most Frequent Element"></a><a href="https://leetcode.com/problems/frequency-of-the-most-frequent-element/" target="_blank" rel="noopener">1838. Frequency of the Most Frequent Element</a></h5><blockquote>
<p>  元素的频数是该元素在一个数组中出现的次数。</p>
<p>  给你一个整数数组<code>nums</code>和一个整数<code>k</code>。在一步操作中，你可以选择<code>nums</code>的一个下标，并将该下标对应元素的值增加<code>1</code>。</p>
<p>  执行最多<code>k</code>次操作后，返回数组中<strong>最高频元素的最大可能频数</strong>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,4], k &#x3D; 5</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Increment the first element three times and the second element two times to make nums &#x3D; [4,4,4].</span><br><span class="line">4 has a frequency of 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,4,8,13], k &#x3D; 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are multiple optimal solutions:</span><br><span class="line">- Increment the first element three times to make nums &#x3D; [4,4,8,13]. 4 has a frequency of 2.</span><br><span class="line">- Increment the second element four times to make nums &#x3D; [1,8,8,13]. 8 has a frequency of 2.</span><br><span class="line">- Increment the third element five times to make nums &#x3D; [1,4,13,13]. 13 has a frequency of 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,9,6], k &#x3D; 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降序排序后顺序模拟操作即可</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n2), 超时！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp_k = k;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[j] &lt;= temp_k) &#123;</span><br><span class="line">                temp_k -= nums[i] - nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = max(cnt, j - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降序排序后, 滑动窗口模拟操作</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size()) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>((right - left) * nums[right - <span class="number">1</span>] &gt; sum + k) &#123;</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1011-Capacity-To-Ship-Packages-Within-D-Days"><a href="#1011-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="1011. Capacity To Ship Packages Within D Days"></a><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011. Capacity To Ship Packages Within D Days</a></h5><blockquote>
<p>  传送带上的包裹必须在<code>days</code>天内从一个港口运送到另一个港口。</p>
<p>  传送带上的第<code>i</code>个包裹的重量为<code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>  返回能在<code>days</code>天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:</span><br><span class="line">1st day: 1, 2, 3, 4, 5</span><br><span class="line">2nd day: 6, 7</span><br><span class="line">3rd day: 8</span><br><span class="line">4th day: 9</span><br><span class="line">5th day: 10</span><br><span class="line"></span><br><span class="line">Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:</span><br><span class="line">1st day: 3, 2</span><br><span class="line">2nd day: 2, 4</span><br><span class="line">3rd day: 1, 4</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: weights &#x3D; [1,2,3,1,1], D &#x3D; 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">1st day: 1</span><br><span class="line">2nd day: 2</span><br><span class="line">3rd day: 3</span><br><span class="line">4th day: 1, 1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 船的最低运载能力至少为所有包裹的最大重量</span></span><br><span class="line"><span class="comment">// 最高运载能力充其量不过是一次把所有货物全部运完, 也就是所有货物重量之和</span></span><br><span class="line"><span class="comment">// 知道了最小值和最大值, 现在要我们求中间满足条件的一个最小值</span></span><br><span class="line"><span class="comment">// 如果说从最小值到最大值一个一个去试的话时间复杂度显然是线性的</span></span><br><span class="line"><span class="comment">// 其实这是二分搜索的一个典型应用场景</span></span><br><span class="line"><span class="comment">// 具体使用的是二分法的左边界搜索 (因为要求最低运载量嘛)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> computeDays = [&amp;](<span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> load = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> weight : weights) &#123;</span><br><span class="line">            <span class="keyword">if</span>(load + weight &gt; limit) &#123;</span><br><span class="line">                days++;</span><br><span class="line">                load = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            load += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> days;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> minLoad = *max_element(weights.begin(), weights.end());</span><br><span class="line">    <span class="keyword">int</span> maxLoad = accumulate(weights.begin(), weights.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(minLoad &lt; maxLoad) &#123;</span><br><span class="line">        <span class="keyword">int</span> midLoad = minLoad + ((maxLoad - minLoad) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(days &gt;= computeDays(midLoad)) &#123;</span><br><span class="line">            maxLoad = midLoad;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minLoad = midLoad + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLoad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="875-Koko-Eating-Bananas"><a href="#875-Koko-Eating-Bananas" class="headerlink" title="875. Koko Eating Bananas"></a><a href="https://leetcode.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. Koko Eating Bananas</a></h5><blockquote>
<p>珂珂喜欢吃香蕉。这里有<code>N</code>堆香蕉，第<code>i</code>堆中有<code>piles[i]</code>根香蕉。警卫已经离开了，将在<code>hours</code>小时后回来。</p>
<p>珂珂可以决定她吃香蕉的速度<code>K</code>（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉<code>K</code>根。如果这堆香蕉少于<code>K</code>根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p>
<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>
<p>返回她可以在<code>hours</code>小时内吃掉所有香蕉的最小速度<code>K</code>（<code>K</code>为整数）。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: piles &#x3D; [3,6,7,11], h &#x3D; 8</span><br><span class="line">&gt;Output: 4</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 5</span><br><span class="line">&gt;Output: 30</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 6</span><br><span class="line">&gt;Output: 23</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和上题一样, 吃香蕉的速度至少为 1 吧</span></span><br><span class="line"><span class="comment">// 最大速度充其量不过是一次把最大的一堆全部吃完, 也就是最大堆的香蕉个数</span></span><br><span class="line"><span class="comment">// 知道了最小值和最大值, 现在要我们求中间满足条件的一个最小值</span></span><br><span class="line"><span class="comment">// 如果说从最小值到最大值一个一个去试的话时间复杂度显然是线性的</span></span><br><span class="line"><span class="comment">// 其实这是二分搜索的一个典型应用场景</span></span><br><span class="line"><span class="comment">// 具体使用的是二分法的左边界搜索 (因为要求最小速度嘛)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> hours)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> computeHours = [&amp;](<span class="keyword">int</span> speed) &#123;</span><br><span class="line">        <span class="keyword">int</span> hours = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles) &#123;</span><br><span class="line">            <span class="comment">// pile / speed 向上取整</span></span><br><span class="line">            hours += (pile + speed - <span class="number">1</span>) / speed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hours;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> minSpeed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSpeed = *max_element(piles.begin(), piles.end()) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(minSpeed &lt; maxSpeed) &#123;</span><br><span class="line">        <span class="keyword">int</span> midSpeed = minSpeed + ((maxSpeed - minSpeed) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(hours &gt;= computeHours(midSpeed)) &#123;</span><br><span class="line">            maxSpeed = midSpeed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minSpeed = midSpeed + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1760-Minimum-Limit-of-Balls-in-a-Bag"><a href="#1760-Minimum-Limit-of-Balls-in-a-Bag" class="headerlink" title="1760. Minimum Limit of Balls in a Bag"></a><a href="https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/" target="_blank" rel="noopener">1760. Minimum Limit of Balls in a Bag</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>，其中<code>nums[i]</code>表示第<code>i</code>个袋子里球的数目。同时给你一个整数<code>maxOperations</code>。你可以进行如下操作至多<code>maxOperations</code>次：</p>
<p>  选择任意一个袋子，并将袋子里的球分到<code>2</code>个新的袋子中，每个袋子里都有正整数个球。<br>  比方说，一个袋子里有<code>5</code>个球，你可以把它们分到两个新袋子里，分别有<code>1</code>个和<code>4</code>个球，或者分别有<code>2</code>个和<code>3</code>个球。</p>
<p>  你的开销是单个袋子里球数目的最大值 ，你想要最小化开销。请你返回进行上述操作后的最小开销。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [9], maxOperations &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">- Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -&gt; [6,3].</span><br><span class="line">- Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -&gt; [3,3,3].</span><br><span class="line">The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,4,8,2], maxOperations &#x3D; 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">- Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -&gt; [2,4,4,4,2].</span><br><span class="line">- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -&gt; [2,2,2,4,4,2].</span><br><span class="line">- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -&gt; [2,2,2,2,2,4,2].</span><br><span class="line">- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -&gt; [2,2,2,2,2,2,2,2].</span><br><span class="line">The bag with the most number of balls has 2 balls, so your penalty is 2 an you should return 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,17], maxOperations &#x3D; 2</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minCost = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCost = *max_element(nums.begin(), nums.end()) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(minCost &lt; maxCost) &#123;</span><br><span class="line">        <span class="keyword">int</span> midCost = minCost + (maxCost - minCost &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> need = operations(nums, midCost);</span><br><span class="line">        <span class="keyword">if</span>(need &lt;= maxOperations) &#123;</span><br><span class="line">            maxCost = midCost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minCost = midCost + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        op += (num - <span class="number">1</span>) / cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. Find Minimum in Rotated Sorted Array</a></h5><blockquote>
<p>  已知一个长度为<code>n</code>的数组，预先按照升序排列，经由<code>1</code>到<code>n</code>次旋转后，得到输入数组。例如，原数组<code>nums = [0,1,2,4,5,6,7]</code>在变化后可能得到：<br>  若旋转<code>4</code>次，则可以得到<code>[4,5,6,7,0,1,2]</code><br>  若旋转<code>7</code>次，则可以得到<code>[0,1,2,4,5,6,7]</code><br>  注意，数组<code>[a[0], a[1], a[2], ..., a[n-1]]</code>旋转一次的结果为数组<code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>。</p>
<p>  给你一个<strong>元素值互不相同</strong>的数组<code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素 。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,5,1,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The original array was [1,2,3,4,5] rotated 3 times.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [11,13,15,17]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: The original array was [11,13,15,17] and it was rotated 4 times. </span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>
<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>nums.length</code> times.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mi] &lt;= nums[hi]) &#123;</span><br><span class="line">            hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[lo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="154. Find Minimum in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. Find Minimum in Rotated Sorted Array II</a></h5><blockquote>
<p>  已知一个长度为<code>n</code>的数组，预先按照升序排列，经由<code>1</code>到<code>n</code>次旋转后，得到输入数组。例如，原数组<code>nums = [0,1,2,4,5,6,7]</code>在变化后可能得到：<br>  若旋转<code>4</code>次，则可以得到<code>[4,5,6,7,0,1,2]</code><br>  若旋转<code>7</code>次，则可以得到<code>[0,1,2,4,5,6,7]</code><br>  注意，数组<code>[a[0], a[1], a[2], ..., a[n-1]]</code>旋转一次的结果为数组<code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>。</p>
<p>  给你一个可能<strong>存在重复元素值</strong>的数组<code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的<strong>最小元素</strong>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,5]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,2,0,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mi] &lt; nums[hi]) &#123;</span><br><span class="line">            hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mi] &gt; nums[hi]) &#123;</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[lo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. Search in Rotated Sorted Array</a></h5><blockquote>
<p>  整数数组<code>nums</code>按升序排列，数组中的值<strong>互不相同</strong>。给你<strong>旋转后</strong>的数组<code>nums</code>和一个整数<code>target</code>，如果<code>nums</code>中存在这个目标值<code>target</code>，则返回它的下标，否则返回<code>-1</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有重复值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target == nums[mi]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mi] &gt;= nums[lo]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mi] &amp;&amp; target &gt;= nums[lo]) &#123;</span><br><span class="line">                hi = mi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;             </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mi] &amp;&amp; target &lt;= nums[hi]) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="81. Search in Rotated Sorted Array II"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. Search in Rotated Sorted Array II</a></h5><blockquote>
<p>  已知存在一个按<strong>非降序排列</strong>的整数数组<code>nums</code>，数组中的值<strong>不必互不相同</strong>。</p>
<p>  给你旋转后的数组<code>nums</code>和一个整数<code>target</code>，请你编写一个函数来判断给定的目标值是否存在于数组中。如果<code>nums</code>中存在这个目标值<code>target</code>，则返回<code>true</code>，否则返回<code>false</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有重复值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target == nums[mi]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 和 I 题相比, 就添加这一个判断语句就行了</span></span><br><span class="line">        <span class="comment">// 跳过 nums[lo] == nums[mi] == nums[hi] 的情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums[lo] == nums[mi] &amp;&amp; nums[mi] == nums[hi]) &#123;</span><br><span class="line">            lo++;</span><br><span class="line">            hi--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mi] &gt;= nums[lo]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mi] &amp;&amp; target &gt;= nums[lo]) &#123;</span><br><span class="line">                hi = mi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mi] &amp;&amp; target &lt;= nums[hi]) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1004-Max-Consecutive-Ones-III"><a href="#1004-Max-Consecutive-Ones-III" class="headerlink" title="1004. Max Consecutive Ones III"></a><a href="https://leetcode.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener">1004. Max Consecutive Ones III</a></h5><blockquote>
<p>  Given a binary array <code>nums</code> and an integer <code>k</code>, return <em>the maximum number of consecutive</em> <code>1</code><em>‘s in the array if you can flip at most</em> <code>k</code> <code>0</code>‘s.</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,0,0,0,1,1,1,1,0], k &#x3D; 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [1,1,1,0,0,1,1,1,1,1,1]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k &#x3D; 3</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口, 关注窗口中 0 的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size()) &#123;</span><br><span class="line">        zeros += <span class="number">1</span> - nums[right++];</span><br><span class="line">        <span class="keyword">while</span>(zeros &gt; k) &#123;</span><br><span class="line">            zeros += nums[left++] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 魔改到让人看不懂为止</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        k += nums[r++] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">0</span>) k += <span class="number">1</span> - nums[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r - l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="391-数飞机"><a href="#391-数飞机" class="headerlink" title="391. 数飞机"></a><a href="https://www.lintcode.com/problem/number-of-airplanes-in-the-sky/?utm_source=sc-bky-sz-20dec" target="_blank" rel="noopener">391. 数飞机</a></h5><blockquote>
<p>给出飞机的起飞和降落时间，用<code>interval</code>序列表示，请计算出天上同时最多有多少架飞机？</p>
<ul>
<li>如果多架飞机降落和起飞在同一时刻，我们认为降落有优先权。</li>
</ul>
<p><strong>样例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [[1, 10], [2, 3], [5, 8], [4, 7]</span><br><span class="line">&gt;输出: 3</span><br><span class="line">&gt;解释: </span><br><span class="line">&gt;第一架飞机在 1 时刻起飞, 10 时刻降落.</span><br><span class="line">&gt;第二架飞机在 2 时刻起飞, 3 时刻降落.</span><br><span class="line">&gt;第三架飞机在 5 时刻起飞, 8 时刻降落.</span><br><span class="line">&gt;第四架飞机在 4 时刻起飞, 7 时刻降落.</span><br><span class="line">&gt;在 5 时刻到 6 时刻之间, 天空中有三架飞机.</span><br></pre></td></tr></table></figure>

<p><strong>样例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [[1, 2], [2, 3], [3, 4]]</span><br><span class="line">&gt;输出: 1</span><br><span class="line">&gt;解释: 降落优先于起飞.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描线算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOfAirplanes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;airplanes)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; timeSeries;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; interval : airplanes) &#123;</span><br><span class="line">        timeSeries.push_back(&#123;interval[<span class="number">0</span>], <span class="number">1</span>&#125;); <span class="comment">// 起飞是 1</span></span><br><span class="line">        timeSeries.push_back(&#123;interval[<span class="number">1</span>], <span class="number">-1</span>&#125;); <span class="comment">// 降落是 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序时就决定了降落在前, 起飞在后</span></span><br><span class="line">    <span class="comment">// 因为如果起飞时间和降落时间相等的话, 降落的第二个值是 -1, 小于起飞的 1</span></span><br><span class="line">    sort(timeSeries.begin(), timeSeries.end());</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; [_, p] : timeSeries) &#123;</span><br><span class="line">        count += p;</span><br><span class="line">        res = max(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="218-The-Skyline-Problem"><a href="#218-The-Skyline-Problem" class="headerlink" title="218. The Skyline Problem"></a><a href="https://leetcode.com/problems/the-skyline-problem/" target="_blank" rel="noopener">218. The Skyline Problem</a></h5><blockquote>
<p>  城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的<strong>天际线</strong> 。</p>
<p>  每个建筑物的几何信息由数组<code>buildings</code>表示，其中三元组<code>buildings[i] = [lefti, righti, heighti]</code>表示：</p>
<ul>
<li><p><code>lefti</code>是第<code>i</code>座建筑物左边缘的<code>x</code>坐标。</p>
</li>
<li><p><code>righti</code>是第<code>i</code>座建筑物右边缘的<code>x</code>坐标。</p>
</li>
<li><p><code>heighti</code>是第i座建筑物的高度。</p>
<p>天际线应该表示为由 “关键点” 组成的列表，格式<code>[[x1,y1],[x2,y2],...]</code>，并按<code>x</code>坐标进行排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，<code>y</code>坐标始终为<code>0</code>，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>注意：输出天际线中不得有连续的相同高度的水平线。例如<code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code>是不正确的答案；三条高度为<code>5</code>的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p>
</li>
</ul>
<p>  <strong>示例：</strong></p>
  <img src="merged.jpg" alt="img" style="zoom: 33%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：buildings &#x3D; [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</span><br><span class="line">输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</span><br><span class="line">解释：</span><br><span class="line">图 A 显示输入的所有建筑物的位置和高度，</span><br><span class="line">图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</span><br></pre></td></tr></table></figure>

  <img src="Video_2021-04-27_200311.gif" alt="Video_2021-04-27_200311" style="zoom: 50%;" />

  <img src="Video_2021-04-27_195717.gif" alt="Video_2021-04-27_195717" style="zoom: 50%;" />
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用扫描线算法求解的关键点就在于找出 [高度发生突变] 的位置</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getSkyline</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buildings)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; geometrixPoints;</span><br><span class="line">    <span class="comment">// 将每一个建筑分成两个部分, 每部分都代表这栋建筑的几何点</span></span><br><span class="line">    <span class="comment">// 例如: [2, 9, 10] 可以转换成 [2, -10] [9, 10]</span></span><br><span class="line">    <span class="comment">// 我们用高度是否为负值来标志 左/右 边界点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; building : buildings) &#123;</span><br><span class="line">        geometrixPoints.emplace_back(building[<span class="number">0</span>], <span class="number">0</span> - building[<span class="number">2</span>]);</span><br><span class="line">        geometrixPoints.emplace_back(building[<span class="number">1</span>], building[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 x 值对这些关键点进行排序</span></span><br><span class="line">    <span class="comment">// 由于 pair 比较的特性, 排序完之后将保证扫描线从左往右走</span></span><br><span class="line">    <span class="comment">// 先出现的建筑先被扫描到, 后出现的建筑后被扫描到</span></span><br><span class="line">    sort(geometrixPoints.begin(), geometrixPoints.end());</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; heights;</span><br><span class="line">    <span class="comment">// 将 0 提前放入高度集中可以处理扫描线没有扫到任何建筑导致高度突变到 0 时的情况</span></span><br><span class="line">    heights.insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; keyPoints;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; [x_pos, height] : geometrixPoints) &#123;</span><br><span class="line">        <span class="keyword">if</span>(height &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 是左边界点, 将高度入堆</span></span><br><span class="line">            heights.insert(<span class="built_in">abs</span>(height));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 是右边界点, 将高度出堆</span></span><br><span class="line">            heights.erase(heights.find(height));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前最大高度</span></span><br><span class="line">        <span class="keyword">int</span> curMaxHeight = *heights.rbegin();</span><br><span class="line">        <span class="comment">// 看新加入/删除的建筑高度是否影响了建筑的最大高度</span></span><br><span class="line">        <span class="comment">// 当前最大高度不等于原先的最大高度就表示这是一个高度突变点</span></span><br><span class="line">        <span class="keyword">if</span>(curMaxHeight != maxHeight) &#123;</span><br><span class="line">            <span class="comment">// 添加坐标</span></span><br><span class="line">            keyPoints.emplace_back(<span class="built_in">vector</span>&#123;&#123;x_pos, curMaxHeight&#125;&#125;);</span><br><span class="line">            <span class="comment">// 更新最大高度</span></span><br><span class="line">            maxHeight = curMaxHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPoints;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&lt;pair&lt;int, int&gt;&gt; 对 pair 排序默认的方式是，先比较 first，哪个小则排在前</span></span><br><span class="line"><span class="comment">first 相等则 second 小的排在前。而 first 这里表示横坐标，second 为负时，</span></span><br><span class="line"><span class="comment">表示建筑的左侧在这一位置；second 为正时，表示建筑的右侧在这一位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以对 geometrixPoints 遍历时，首先会取出横坐标小的点。如果 2 个点横坐标相等，</span></span><br><span class="line"><span class="comment">会先取出 second 小的点，对于负数来说，其实就是高度更高的建筑。也就是说，</span></span><br><span class="line"><span class="comment">两个点上有高度不同的建筑，会先取高的出来放入高度集合，集合中高度最大值和之前高度不同，</span></span><br><span class="line"><span class="comment">就直接以更高的高度作为关键点的高度。后面更低高度的建筑加入并不会改变最大高度，</span></span><br><span class="line"><span class="comment">因此不会错误的当作关键点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果 second 为正，表示建筑物在此处结束，需要把相应高度从高度集合中删除。</span></span><br><span class="line"><span class="comment">有相同建筑同时在此结束，则会先让较低的建筑离开，因为它们不会改变最大高度。</span></span><br><span class="line"><span class="comment">只有当最高的建筑物离开时，才进行改变。如果一个位置既有建筑物进来，又有建筑物离开，</span></span><br><span class="line"><span class="comment">会先以进来的建筑的高度来更新高度集，原因同理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这一系列正确的遍历顺序都取决于把高度的负值作为左边界点地标志, 高度的正值作为</span></span><br><span class="line"><span class="comment">右边界点的标志, 并将它们组合成一个 pair 这一巧妙的设计！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. Median of Two Sorted Arrays</a></h5><blockquote>
<p>  给定两个大小分别为<code>m</code>和<code>n</code>的<strong>有序</strong>（从小到大）数组<code>nums1</code>和<code>nums2</code>。请你找出并返回这两个正序数组的<strong>中位数</strong>。</p>
<p>  <strong>进阶：</strong>你能设计一个时间复杂度为<code>O(log(m+n))</code>的算法解决此问题吗？</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">Output: 2.00000</span><br><span class="line">Explanation: merged array &#x3D; [1,2,3] and median is 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">Output: 2.50000</span><br><span class="line">Explanation: merged array &#x3D; [1,2,3,4] and median is (2 + 3) &#x2F; 2 &#x3D; 2.5.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class="line">Output: 0.00000</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class="line">Output: 1.00000</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一, 双指针归并两个有序数组</span></span><br><span class="line"><span class="comment">// 时间和空间复杂度都为 O(m + n)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merged</span><span class="params">(m + n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m || j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= n || (i &lt; m &amp;&amp; nums1[i] &lt; nums2[j])) &#123;</span><br><span class="line">            merged[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            merged[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">double</span>(merged[(m + n) / <span class="number">2</span>] + merged[(m + n - <span class="number">1</span>) / <span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二, [伪归并] 双指针寻找中位数的位置</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(m + n), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> preValue = <span class="number">0</span>, curValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((i &lt; m || j &lt; n) &amp;&amp; (i + j) &lt;= (m + n) / <span class="number">2</span>) &#123;</span><br><span class="line">        preValue = curValue;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= n || (i &lt; m &amp;&amp; nums1[i] &lt; nums2[j])) &#123;</span><br><span class="line">            curValue = nums2[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            curValue = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (m + n) &amp; <span class="number">1</span> ? curValue : <span class="keyword">double</span>(preValue + curValue) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法三, 划分数组 + 二分查找, 时间复杂度为 O(log(min(m, n))), 空间复杂度为 O(1)</span></span><br></pre></td></tr></table></figure>

<h5 id="457-Circular-Array-Loop"><a href="#457-Circular-Array-Loop" class="headerlink" title="457. Circular Array Loop"></a><a href="https://leetcode.com/problems/circular-array-loop/" target="_blank" rel="noopener">457. Circular Array Loop</a></h5><blockquote>
<p>  存在一个不含<code>0</code>的环形数组<code>nums</code>，每个<code>nums[i]</code>都表示位于下标<code>i</code>的角色应该向前或向后移动的下标个数：</p>
<ul>
<li><p>如果<code>nums[i]</code>是正数，向前移动<code>nums[i]</code>步</p>
</li>
<li><p>如果<code>nums[i]</code>是负数，向后移动<code>nums[i]</code>步</p>
</li>
<li><p>因为数组是环形的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p>
<p>数组中的循环由长度为k的下标序列<code>seq</code>：</p>
</li>
<li><p>遵循上述移动规则将导致重复下标序列<code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code>所有<code>nums[seq[j]]</code>应当不是全正就是全负</p>
</li>
<li><p><code>k &gt; 1</code></p>
<p>如果<code>nums</code>中存在循环，返回<code>true</code>；否则，返回<code>false</code>。</p>
</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,-1,1,2,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">There is a cycle from index 0 -&gt; 2 -&gt; 3 -&gt; 0 -&gt; ...</span><br><span class="line">The cycle&#39;s length is 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The sequence from index 1 -&gt; 1 -&gt; 1 -&gt; ... is not a cycle because the sequence&#39;s length is 1.</span><br><span class="line">By definition the sequence&#39;s length must be strictly greater than 1 to be a cycle.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,1,-1,-2,-2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The sequence from index 1 -&gt; 2 -&gt; 1 -&gt; ... is not a cycle because nums[1] is positive, but nums[2] is negative.</span><br><span class="line">Every nums[seq[j]] must be either all positive or all negative.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度为 O(n), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">circularArrayLoop</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">auto</span> getnext = [&amp;](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> ((i + nums[i]) % n + n) % n; &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = i, fast = i;</span><br><span class="line">        <span class="comment">// 符号相同则乘积 &gt; 0</span></span><br><span class="line">        <span class="keyword">while</span>(nums[i] * nums[getnext(fast)] &gt; <span class="number">0</span> &amp;&amp; nums[i] * nums[getnext(getnext(fast))] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = getnext(slow);</span><br><span class="line">            fast = getnext(getnext(fast));</span><br><span class="line">            <span class="comment">// 出现环</span></span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 排除长度为 1 的环</span></span><br><span class="line">                <span class="keyword">if</span>(slow == getnext(slow)) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的 while 循环没有返回, 说明上面访问过的点的路径不会出现环</span></span><br><span class="line">        <span class="comment">// 把访问过的点置 0, 下次不会再次进入同样的无效路径</span></span><br><span class="line">        slow = i;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] * nums[slow] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = getnext(slow);</span><br><span class="line">            nums[slow] = <span class="number">0</span>;</span><br><span class="line">            slow = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. First Missing Positive</a></h5><blockquote>
<p>  给你一个未排序的整数数组<code>nums</code>，请你找出其中没有出现的最小的正整数。</p>
<p>  请你实现时间复杂度为<code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<p>  <strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/" target="_blank" rel="noopener">缺失的第一个正数 - 缺失的第一个正数</a></p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 300</code></li>
<li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上, 对于一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 其中没有出现的最小正整数只能在 [1, n+1] 中</span></span><br><span class="line"><span class="comment">// 这是因为如果 [1, n] 都出现了, 那么答案是 n+1</span></span><br><span class="line"><span class="comment">// 否则答案是 [1, n] 中没有出现的最小正整数</span></span><br><span class="line"><span class="comment">// 哈希表, 时间和空间复杂度都为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        setting.insert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!setting.count(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于本题来说 O(n) 的空间复杂度是不符合要求的</span></span><br><span class="line"><span class="comment">// 由于我们已经得出了一个关键的结论:</span></span><br><span class="line"><span class="comment">// 没有出现的正整数只能在 [1, n+1] 中</span></span><br><span class="line"><span class="comment">// 这和数组的索引就存在着对应关系了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 由于我们只关注 [1, n+1] 内的正整数</span></span><br><span class="line">    <span class="comment">// 因此, 将数组中 &lt;= 0 的数都映射为 n+1 (足够大的正数)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] = n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数值对应的索引处的数值映射为负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= n &amp;&amp; nums[num - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[num - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有被映射为负数的第一个数的下标 +1</span></span><br><span class="line">    <span class="comment">// 就是缺失的第一个正整数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则</span></span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1482-Minimum-Number-of-Days-to-Make-m-Bouquets"><a href="#1482-Minimum-Number-of-Days-to-Make-m-Bouquets" class="headerlink" title="1482. Minimum Number of Days to Make m Bouquets"></a><a href="https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">1482. Minimum Number of Days to Make m Bouquets</a></h5><blockquote>
<p>  给你一个整数数组<code>bloomDay</code>，以及两个整数<code>m</code>和<code>k</code>。现需要制作<code>m</code>束花。制作花束时，需要使用花园中相邻的<code>k</code>朵花 。花园中有<code>n</code>朵花，第<code>i</code>朵花会在<code>bloomDay[i]</code>时盛开，恰好可以用于一束花中。请你返回从花园中摘<code>m</code>束花需要等待的最少的天数。如果不能摘到<code>m</code>束花则返回<code>-1</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Let&#39;s see what happened in the first three days. x means flower bloomed and _ means flower didn&#39;t bloom in the garden.</span><br><span class="line">We need 3 bouquets each should contain 1 flower.</span><br><span class="line">After day 1: [x, _, _, _, _]   &#x2F;&#x2F; we can only make one bouquet.</span><br><span class="line">After day 2: [x, _, _, _, x]   &#x2F;&#x2F; we can only make two bouquets.</span><br><span class="line">After day 3: [x, _, x, _, x]   &#x2F;&#x2F; we can make 3 bouquets. The answer is 3.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [7,7,7,7,12,7,7], m &#x3D; 2, k &#x3D; 3</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: We need 2 bouquets each should have 3 flowers.</span><br><span class="line">Here&#39;s the garden after the 7 and 12 days:</span><br><span class="line">After day 7: [x, x, x, x, _, x, x]</span><br><span class="line">We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.</span><br><span class="line">After day 12: [x, x, x, x, x, x, x]</span><br><span class="line">It is obvious that we can make two bouquets in different ways.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 4:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [1000000000,1000000000], m &#x3D; 1, k &#x3D; 1</span><br><span class="line">Output: 1000000000</span><br><span class="line">Explanation: You need to wait 1000000000 days to have a flower ready for a bouquet.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 5:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: bloomDay &#x3D; [1,10,2,9,3,8,4,7,5,6], m &#x3D; 4, k &#x3D; 2</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>bloomDay.length == n</code></li>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; bloomDay.size() / k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">auto</span> [minVal, maxVal] = minmax_element(bloomDay.begin(), bloomDay.end());</span><br><span class="line">    <span class="keyword">int</span> lo = *minVal, hi = *maxVal;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(canMake(bloomDay, m, k, mi))</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canMake</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k, <span class="keyword">int</span> days)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flowers = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bloomDay.size() &amp;&amp; m &gt; <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bloomDay[i] &gt; days)</span><br><span class="line">        &#123;</span><br><span class="line">            flowers = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flowers++;</span><br><span class="line">            <span class="keyword">if</span>(flowers == k)</span><br><span class="line">            &#123;</span><br><span class="line">                m--;</span><br><span class="line">                flowers = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1109-Corporate-Flight-Bookings"><a href="#1109-Corporate-Flight-Bookings" class="headerlink" title="1109. Corporate Flight Bookings"></a><a href="https://leetcode.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener">1109. Corporate Flight Bookings</a></h5><blockquote>
<p>  这里有<code>n</code>个航班，它们分别从<code>1</code>到<code>n</code>进行编号。</p>
<p>  有一份航班预订表<code>bookings</code>，表中第<code>i</code>条预订记录<code>bookings[i] = [first_i, last_i, seats_i]</code>意味着在从<code>first_i</code>到<code>last_i</code>（包含<code>first_i</code>和<code>last_i</code>）的每个航班上预订了<code>seats_i</code>个座位。</p>
<p>  请你返回一个长度为<code>n</code>的数组<code>answer</code>，其中<code>answer[i]</code>是航班<code>i</code>上预订的座位总数。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</span><br><span class="line">Output: [10,55,45,25,25]</span><br><span class="line">Explanation:</span><br><span class="line">Flight labels:        1   2   3   4   5</span><br><span class="line">Booking 1 reserved:  10  10</span><br><span class="line">Booking 2 reserved:      20  20</span><br><span class="line">Booking 3 reserved:      25  25  25  25</span><br><span class="line">Total seats:         10  55  45  25  25</span><br><span class="line">Hence, answer &#x3D; [10,55,45,25,25]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: bookings &#x3D; [[1,2,10],[2,2,15]], n &#x3D; 2</span><br><span class="line">Output: [10,25]</span><br><span class="line">Explanation:</span><br><span class="line">Flight labels:        1   2</span><br><span class="line">Booking 1 reserved:  10  10</span><br><span class="line">Booking 2 reserved:      15</span><br><span class="line">Total seats:         10  25</span><br><span class="line">Hence, answer &#x3D; [10,25]</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>
<li><code>1 &lt;= bookings.length &lt;= 2 * 10^4</code></li>
<li><code>bookings[i].length == 3</code></li>
<li><code>1 &lt;= firsti &lt;= lasti &lt;= n</code></li>
<li><code>1 &lt;= seatsi &lt;= 10^4</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diff;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Difference(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        diff.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                diff[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将闭区间 [i, j] 元素加上 val</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; diff.size()) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.size(); i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本题相当于原数组元素均为 0</span></span><br><span class="line">    <span class="comment">// 因此其差分数组的元素也都为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">Difference <span class="title">difference</span><span class="params">(diff)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; booking : bookings) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = booking[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = booking[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = booking[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 将数组 [i..j] 区间内元素加上 val</span></span><br><span class="line">        difference.add(i, j, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difference.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本题相当于原数组元素均为 0</span></span><br><span class="line">    <span class="comment">// 因此其差分数组的元素也都为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">difference</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; booking : bookings) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = booking[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = booking[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = booking[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 将数组 [i..j] 区间内元素加上 val</span></span><br><span class="line">        difference[i] += val;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">            difference[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据差分数组构造原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        difference[i] += difference[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> difference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-64-995-Minimum-Number-of-K-Consecutive-Bit-Flips"><a href="#1-64-995-Minimum-Number-of-K-Consecutive-Bit-Flips" class="headerlink" title="1.64 995. Minimum Number of K Consecutive Bit Flips"></a><code>1.64</code> <a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/" target="_blank" rel="noopener">995. Minimum Number of K Consecutive Bit Flips</a></h5><blockquote>
<p>  在仅包含<code>0</code>和<code>1</code>的数组<code>A</code>中，一次<code>K</code>位翻转包括选择一个长度为<code>K</code>的（连续）子数组，同时将子数组中的每个<code>0</code>更改为<code>1</code>，而每个<code>1</code>更改为<code>0</code>。</p>
<p>  返回所需的<code>k</code>位翻转的最小次数，以便数组没有值为<code>0</code>的元素。如果不可能，返回<code>-1</code>。</p>
<p>  <strong>xample 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [0,1,0], K &#x3D; 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Flip A[0], then flip A[2].</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [1,1,0], K &#x3D; 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: No matter how we flip subarrays of size 2, we can&#39;t make the array become [1,1,1].</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: A &#x3D; [0,0,0,1,0,1,1,0], K &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]</span><br><span class="line">Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]</span><br><span class="line">Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]</span><br></pre></td></tr></table></figure>

<p>  <strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>1 &lt;= K &lt;= A.length</code></li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接模拟反转过程</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(nk), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="comment">// 超时 TLE!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到下一个 0 所在的位置</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; A[i] != <span class="number">0</span>) i++;</span><br><span class="line">        <span class="comment">// 如果没有 0 了, 就全部翻转成功</span></span><br><span class="line">        <span class="keyword">if</span>(i == n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果需要翻转的不够 K 位, 就不可能翻转成功</span></span><br><span class="line">        <span class="keyword">if</span>(i + K &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 实际地进行翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j++)</span><br><span class="line">            A[i + j] = <span class="number">1</span> - A[i + j];</span><br><span class="line">        <span class="comment">// 翻转次数加一</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组</span></span><br><span class="line"><span class="comment">// 自然而然, 我们会想到使用一个数组来记录每一位的翻转次数</span></span><br><span class="line"><span class="comment">// 但是我们又不希望是通过 [遍历数组的 K 位进行 +1 操作] 来完成记录</span></span><br><span class="line"><span class="comment">// 所以可以借助差分数组来记录每个区间元素被翻转的次数</span></span><br><span class="line"><span class="comment">// 当翻转的次数为奇数次时, 才真的要翻转, 为偶数次时并不需要实际地翻转</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n), 空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 多一个位置防止越位</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 实时计算数组索引 i 处的翻转次数</span></span><br><span class="line">        <span class="comment">// 这时计算的是从索引 i 开始的 K 位被翻转之前的该位已经被翻转的次数</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) diff[i] += diff[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 判断索引 i 处开始的 K 位是否需要被翻转</span></span><br><span class="line">        <span class="keyword">if</span>((A[i] + diff[i]) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + K &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            diff[i] += <span class="number">1</span>;</span><br><span class="line">            diff[i + K] -= <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里的逻辑需要好好理一理, 这里相当于一边更新 diff 数组, 一边还原数组的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="307-Range-Sum-Query-Mutable"><a href="#307-Range-Sum-Query-Mutable" class="headerlink" title="307. Range Sum Query - Mutable"></a><a href="https://leetcode.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">307. Range Sum Query - Mutable</a></h5><blockquote>
<p>  给你一个数组<code>nums</code>，请你完成两类查询，其中一类查询要求更新数组下标对应的值，另一类查询要求返回数组中某个范围内元素的总和。</p>
<p>  实现<code>NumArray</code>类：</p>
<ul>
<li><code>NumArray(int[] nums)</code>：用整数数组<code>nums</code>初始化对象</li>
<li><code>void update(int index, int val)</code>：将<code>nums[index]</code>的值更新为<code>val</code></li>
<li><code>int sumRange(int left, int right)</code>：返回子数组<code>nums[left, right]</code>的总和（即，<code>nums[left] + nums[left + 1], ..., nums[right]</code>）</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状数组又称二叉索引树 (Binary Indexed Tree)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// O(nlogn) 的复杂度建立树状数组</span></span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) : _nums(nums), bit(_nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _nums.size(); i++)</span><br><span class="line">            add(i + <span class="number">1</span>, _nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	// O(n) 的复杂度建立树状数组</span></span><br><span class="line"><span class="comment">    NumArray(vector&lt;int&gt;&amp; nums)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 原有的值为 _nums[index], 要更新为 val, 需要加上 val - _nums[index]</span></span><br><span class="line">        add(index + <span class="number">1</span>, val - _nums[index]);</span><br><span class="line">        _nums[index] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getsum(right + <span class="number">1</span>) - getsum(left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _nums;</span><br><span class="line">    <span class="comment">// 注意 bit 数组的索引 [语义] 是从 1 开始</span></span><br><span class="line">    <span class="comment">// 长度和原数组相同</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将第 pos 个数加上 val</span></span><br><span class="line">    <span class="comment">// 时间复杂度为 O(logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt;= bit.size(); i += lowbit(i))</span><br><span class="line">            bit[i - <span class="number">1</span>] += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回前 pos 个数的和</span></span><br><span class="line">    <span class="comment">// 时间复杂度为 O(logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &gt; <span class="number">0</span>; i -= lowbit(i))</span><br><span class="line">            res += bit[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1310-XOR-Queries-of-a-Subarray"><a href="#1310-XOR-Queries-of-a-Subarray" class="headerlink" title="1310. XOR Queries of a Subarray"></a><a href="https://leetcode.com/problems/xor-queries-of-a-subarray/" target="_blank" rel="noopener">1310. XOR Queries of a Subarray</a></h5><blockquote>
<p>  有一个正整数数组<code>arr</code>，现给你一个对应的查询数组<code>queries</code>，其中<code>queries[i] = [Li, Ri]</code>。</p>
<p>  对于每个查询<code>i</code>，请你计算从<code>Li</code>到<code>Ri</code>的<code>XOR</code>值（即<code>arr[Li] xor arr[Li+1] xor ... xor arr[Ri]</code>）作为本次查询的结果。并返回一个包含给定查询<code>queries</code>所有结果的数组。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; pos &lt;= bit.size(); pos += lowbit(pos))</span><br><span class="line">        bit[pos - <span class="number">1</span>] ^= val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">for</span>(; pos &gt; <span class="number">0</span>; pos -= lowbit(pos))</span><br><span class="line">        res ^= bit[pos - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">xorQueries</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bit.resize(arr.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i++)</span><br><span class="line">        add(i + <span class="number">1</span>, arr[i]);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; query : queries)</span><br><span class="line">        res.push_back(getsum(query[<span class="number">1</span>] + <span class="number">1</span>) ^ getsum(query[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="315-Count-of-Smaller-Numbers-After-Self"><a href="#315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="315. Count of Smaller Numbers After Self"></a><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. Count of Smaller Numbers After Self</a></h5><blockquote>
<p>  给定一个整数数组<code>nums</code>，按要求返回一个新数组<code>counts</code>。数组<code>counts</code>有该性质：<code>counts[i]</code>的值是<code>nums[i]</code>右侧小于<code>nums[i]</code>的元素的数量。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bit(<span class="keyword">int</span> _n) : n(_n), bit(n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 本题原数组相当于全 0 数组, 不需要创建 bit</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.size(); i++)</span></span><br><span class="line">        <span class="comment">//     add(i + 1, nums[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt;= n) &#123;</span><br><span class="line">            bit[pos] += val;</span><br><span class="line">            pos += lowbit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += bit[pos];</span><br><span class="line">            pos -= lowbit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 离散化树状数组</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums)</span></span>;</span><br><span class="line">    sort(temp.begin(), temp.end());</span><br><span class="line">    <span class="comment">// 离散化数组的方式, 将数组中的元素按照排名映射为 1 ...</span></span><br><span class="line">    <span class="comment">// 这种离散方式, 离散化前后并不需要保留元素的绝对大小, 只关心元素的相对大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = lower_bound(temp.begin(), temp.end(), nums[i]) - temp.begin() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res.push_back(bit.getsum(nums[i] - <span class="number">1</span>));</span><br><span class="line">        bit.add(nums[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对</a></h5><blockquote>
<p>  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个<strong>数组中的逆序对的总数</strong>。</p>
<p>  <strong>示例:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bit(<span class="keyword">int</span> _n) : n(_n), bit(n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 本题原数组相当于全 0 数组, 不需要创建 bit</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.size(); i++)</span></span><br><span class="line">        <span class="comment">//     add(i + 1, nums[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt;= n) &#123;</span><br><span class="line">            bit[pos] += val;</span><br><span class="line">            pos += lowbit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += bit[pos];</span><br><span class="line">            pos -= lowbit(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化树状数组 (具体思想参考官方题解)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums)</span></span>;</span><br><span class="line">    sort(temp.begin(), temp.end());</span><br><span class="line">    <span class="comment">// 离散化数组的另一种方式, 通常需要保留原数组中元素大小时采用, 这里最然不需要</span></span><br><span class="line">    <span class="comment">// 将每个数按次序映射到数组中的对应的位置</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : temp) &#123;</span><br><span class="line">        mapping[num] = i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Bit <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res += bit.getsum(mapping[nums[i]] - <span class="number">1</span>);</span><br><span class="line">        bit.add(mapping[nums[i]], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = data.size();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 提前分配空间优化构造析构函数效率</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(n/<span class="number">2</span>+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 合并闭区间 [lo, mi] 和 [mi + 1, hi] 的子数组</span></span><br><span class="line">    <span class="keyword">auto</span> merge = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mi + <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">            helper[i - mi - <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = mi;</span><br><span class="line">        <span class="keyword">int</span> j = hi - mi - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = hi;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= lo &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &gt; helper[j]) &#123;</span><br><span class="line">                data[k--] = data[i--];</span><br><span class="line">                <span class="comment">// 就增加这一行</span></span><br><span class="line">                cnt += j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                data[k--] = helper[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            data[k--] = helper[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; mergeSort = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(lo, mi);</span><br><span class="line">        mergeSort(mi + <span class="number">1</span>, hi);</span><br><span class="line">        merge(lo, mi, hi);</span><br><span class="line">    &#125;;</span><br><span class="line">    mergeSort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR"></a><a href="https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" target="_blank" rel="noopener">1442. Count Triplets That Can Form Two Arrays of Equal XOR</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>。</p>
<p>  现需要从数组中取三个下标<code>i</code>、<code>j</code>和<code>k</code>，其中<code>(0 &lt;= i &lt; j &lt;= k &lt; nums.size())</code>。</p>
<p>  <code>a</code>和<code>b</code>定义如下：</p>
<ul>
<li><p><code>a = nums[i] ^ nums[i + 1] ^ ... ^ nums[j - 1]</code></p>
</li>
<li><p><code>b = nums[j] ^ nums[j + 1] ^ ... ^ nums[k]</code></p>
<p>请返回能够令<code>a == b</code>成立的三元组<code>(i, j , k)</code>的数目。</p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀异或数组 + 三重循环枚举 i, j, k</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n3), 空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] ^ nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; n; k++)</span><br><span class="line">                <span class="keyword">if</span>(prefix[j] ^ prefix[i] == prefix[k + <span class="number">1</span>] ^ prefix[j])</span><br><span class="line">                    res++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意到如果 a == b</span></span><br><span class="line"><span class="comment">// 那么就有 nums[i] ^ ... ^ nums[j] ^ ... ^ nums[k] == 0</span></span><br><span class="line"><span class="comment">// 也就是说有 prefix[k + 1] == prefix[i]</span></span><br><span class="line"><span class="comment">// 此时对于 (i, k] 中的每一个 j 都是满足的</span></span><br><span class="line"><span class="comment">// 前缀异或数组 + 二重循环枚举 i, k</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n2), 空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] ^ nums[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">            <span class="keyword">if</span>(prefix[i] == prefix[k + <span class="number">1</span>])</span><br><span class="line">                res += k - i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表 + 一重循环</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] ^ nums[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt, total;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(prefix[k + <span class="number">1</span>]))</span><br><span class="line">            res += cnt[prefix[k + <span class="number">1</span>]] * k - total[prefix[k + <span class="number">1</span>]];</span><br><span class="line">        </span><br><span class="line">        cnt[prefix[k]]++;</span><br><span class="line">        total[prefix[k]] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="421-Maximum-XOR-of-Two-Numbers-in-an-Array"><a href="#421-Maximum-XOR-of-Two-Numbers-in-an-Array" class="headerlink" title="421. Maximum XOR of Two Numbers in an Array"></a><a href="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">421. Maximum XOR of Two Numbers in an Array</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>，返回<code>nums[i] ^ nums[j]</code>的最大运算结果，其中<code>0 ≤ i ≤ j &lt; n</code>。</p>
<p>  <strong>进阶</strong>：你可以在<code>O(n)</code>的时间解决这个问题吗？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Trie* child[<span class="number">2</span>] = &#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Trie* root = <span class="keyword">new</span> Trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie* cur = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;child[a])</span><br><span class="line">            cur-&gt;child[a] = <span class="keyword">new</span> Trie;</span><br><span class="line">        cur = cur-&gt;child[a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie* cur = root;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span> - a;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;child[b])</span><br><span class="line">        &#123;</span><br><span class="line">            res |= (b &lt;&lt; i);</span><br><span class="line">            cur = cur-&gt;child[b];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res |= (a &lt;&lt; i);</span><br><span class="line">            cur = cur-&gt;child[a];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(num);</span><br><span class="line">        res = max(res, num ^ check(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1707-Maximum-XOR-With-an-Element-From-Array"><a href="#1707-Maximum-XOR-With-an-Element-From-Array" class="headerlink" title="1707. Maximum XOR With an Element From Array"></a><a href="https://leetcode.com/problems/maximum-xor-with-an-element-from-array/" target="_blank" rel="noopener">1707. Maximum XOR With an Element From Array</a></h5><blockquote>
<p>  给你一个由非负整数组成的数组<code>nums</code>。另有一个查询数组<code>queries</code>，其中<code>queries[i] = [xi, mi]</code>。</p>
<p>  第<code>i</code>个查询的答案是<code>xi</code>和任何<code>nums</code>数组中不超过<code>mi</code>的元素按位异或得到的最大值。换句话说，答案是<code>max(nums[j] XOR xi)</code>，其中所有<code>j</code>均满足<code>nums[j] &lt;= mi</code>。如果<code>nums</code>中的所有元素都大于<code>mi</code>，最终答案就是<code>-1</code>。</p>
<p>  返回一个整数数组<code>answer</code>作为查询的答案，其中<code>answer.length == queries.length</code>且<code>answer[i]</code>是第<code>i</code>个查询的答案。</p>
<p>  <strong>题解</strong>：<a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/solution/yu-shu-zu-zhong-yuan-su-de-zui-da-yi-huo-7erc/" target="_blank" rel="noopener">与数组中元素的最大异或值 - 与数组中元素的最大异或值 - 力扣（LeetCode）</a></p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,2,3,4], queries &#x3D; [[3,1],[1,3],[5,6]]</span><br><span class="line">Output: [3,3,7]</span><br><span class="line">Explanation:</span><br><span class="line">1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 &#x3D; 3 and 1 XOR 3 &#x3D; 2. The larger of the two is 3.</span><br><span class="line">2) 1 XOR 2 &#x3D; 3.</span><br><span class="line">3) 5 XOR 2 &#x3D; 7.</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length, queries.length &lt;= 10^5</code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>0 &lt;= nums[j], xi, mi &lt;= 10^9</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maximizeXor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) insert(num);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.reserve(queries.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> query : queries)</span><br><span class="line">            res.push_back(getVal(query[<span class="number">0</span>], query[<span class="number">1</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> minVal = INT_MAX;</span><br><span class="line">        Trie* child[<span class="number">2</span>] = &#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Trie* root = <span class="keyword">new</span> Trie;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        root-&gt;minVal = min(root-&gt;minVal, num);</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;child[bit])</span><br><span class="line">                cur-&gt;child[bit] = <span class="keyword">new</span> Trie;</span><br><span class="line">            cur-&gt;child[bit]-&gt;minVal = min(cur-&gt;child[bit]-&gt;minVal, num);</span><br><span class="line">            cur = cur-&gt;child[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getVal</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; root-&gt;minVal)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[bit ^ <span class="number">1</span>] &amp;&amp; cur-&gt;child[bit ^ <span class="number">1</span>]-&gt;minVal &lt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                bit = bit ^ <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;child[bit];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1074-Number-of-Submatrices-That-Sum-to-Target"><a href="#1074-Number-of-Submatrices-That-Sum-to-Target" class="headerlink" title="1074. Number of Submatrices That Sum to Target"></a><a href="https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/" target="_blank" rel="noopener">1074. Number of Submatrices That Sum to Target</a></h5><blockquote>
<p>  给出矩阵<code>matrix</code>和目标值<code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>  如果<code>(x1, y1, x2, y2)</code>和<code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code>两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p>
<p>  <strong>题解</strong>：<a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/solution/gong-shui-san-xie-you-hua-mei-ju-de-ji-b-uttw/" target="_blank" rel="noopener">【宫水三叶】优化枚举的基本思路与进阶内容 - 元素和为目标值的子矩阵数量 - 力扣（LeetCode）</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀子矩阵和 + 暴力枚举</span></span><br><span class="line"><span class="comment">// 从「点」上来确定一个子矩阵, 在 n 和 m 同阶的情况下, 时间复杂度是 O(n^4)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">prefixsumOfSubMatrix</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            prefixsumOfSubMatrix[i][j] = matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + prefixsumOfSubMatrix[i - <span class="number">1</span>][j] + prefixsumOfSubMatrix[i][j - <span class="number">1</span>] - prefixsumOfSubMatrix[i - <span class="number">1</span>][ j - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> rl = <span class="number">1</span>; rl &lt;= m; rl++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cu = <span class="number">1</span>; cu &lt;= n; cu ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> rr = rl; rr &lt;= m; rr++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> cd = cu; cd &lt;= n; cd++)</span><br><span class="line">                    <span class="keyword">if</span>(prefixsumOfSubMatrix[rr][cd] - prefixsumOfSubMatrix[rr][cu - <span class="number">1</span>] - prefixsumOfSubMatrix[rl - <span class="number">1</span>][cd] + prefixsumOfSubMatrix[rl - <span class="number">1</span>][cu - <span class="number">1</span>] == target)</span><br><span class="line">                        res++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从「边」上来确定一个子矩阵, 通过枚举三条边</span></span><br><span class="line"><span class="comment">// 使用哈希表 + 前缀和来加速查找第四条边</span></span><br><span class="line"><span class="comment">// 在 n 和 m 同阶的情况下, 时间复杂度可降到 O(n3)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 枚举上边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 枚举下边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新每列的元素和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c) sum[c] += matrix[j][c];</span><br><span class="line">            <span class="comment">// 遍历 sum 子数组的和</span></span><br><span class="line">            res += sumsOfSubArrayEqualTarget(sum, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算数组中和等于 target 的子数组个数</span></span><br><span class="line"><span class="comment">// 前缀和 + 哈希表优化 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumsOfSubArrayEqualTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="comment">// 表示以首元素开头的子数组的和等于 target</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, preSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        preSum += num;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(preSum - target))</span><br><span class="line">            res += mapping[preSum - target];</span><br><span class="line">        ++mapping[preSum];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1738-Find-Kth-Largest-XOR-Coordinate-Value"><a href="#1738-Find-Kth-Largest-XOR-Coordinate-Value" class="headerlink" title="1738. Find Kth Largest XOR Coordinate Value"></a><a href="https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/" target="_blank" rel="noopener">1738. Find Kth Largest XOR Coordinate Value</a></h5><blockquote>
<p>  给你一个二维矩阵<code>matrix</code>和一个整数<code>k</code>，矩阵大小为<code>m x n</code>由非负整数组成。矩阵中坐标<code>(a, b)</code>的值可由对所有满足<code>0 &lt;= i &lt;= a &lt; m</code>且<code>0 &lt;= j &lt;= b &lt; n</code>的元素<code>matrix[i][j]</code>（下标从<code>0</code>开始计数）执行异或运算得到。</p>
<p>  请你找出<code>matrix</code>的所有坐标中第<code>k</code>大的值（<code>k</code>的值从<code>1</code>开始计数）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀子矩阵异或 + 小顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subMatrixXors</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            subMatrixXors[i][j] = subMatrixXors[i - <span class="number">1</span>][j - <span class="number">1</span>] ^ subMatrixXors[i][j - <span class="number">1</span>] ^ subMatrixXors[i - <span class="number">1</span>][j] ^ matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            pq.push(subMatrixXors[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k)</span><br><span class="line">                pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀子矩阵异或 + 快速选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subMatrixXors</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    temp.reserve(m * n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            subMatrixXors[i][j] = subMatrixXors[i - <span class="number">1</span>][j - <span class="number">1</span>] ^ subMatrixXors[i][j - <span class="number">1</span>] ^ subMatrixXors[i - <span class="number">1</span>][j] ^ matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            temp.push_back(subMatrixXors[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nth_element(temp.begin(), prev(temp.end(), k), temp.end());</span><br><span class="line">    <span class="keyword">return</span> temp[m * n - k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="581-Shortest-Unsorted-Continuous-Subarray"><a href="#581-Shortest-Unsorted-Continuous-Subarray" class="headerlink" title="581. Shortest Unsorted Continuous Subarray"></a><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. Shortest Unsorted Continuous Subarray</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>，你需要找出一个连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的最短子数组，并输出它的长度。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,6,4,8,10,9,15]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先排序 + 再比较</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums)</span></span>;</span><br><span class="line">    sort(temp.begin(), temp.end());</span><br><span class="line">    <span class="comment">// 初始化为 -1 和 -2 方便处理数组已经是升序的情况</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>, right = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != temp[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="number">-1</span>) &#123;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">            right = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双层循环暴力法</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n2)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, left = INT_MAX, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                left = min(left, i);</span><br><span class="line">                right = max(right, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left == INT_MAX ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正序和逆序分别遍历</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// 初始化为 -1 和 -2 方便处理数组已经是升序的情况</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>, right = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">int</span> maximun = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; maximun) &#123;</span><br><span class="line">            right = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            maximun = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minimum = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; minimum) &#123;</span><br><span class="line">            left = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minimum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">48. Rotate Image</a></h5><blockquote>
<p>  给定一个<code>n × n</code>的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转<code>90</code>度。你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>  <strong>示例 1：</strong></p>
  <img src="mat2.jpg" alt="img" style="zoom:50%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用额外空间就比较容易了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(matrix)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = res[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用额外空间</span></span><br><span class="line"><span class="comment">// 用翻转实现旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">    <span class="comment">// 上下翻转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            swap(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5777-使数组元素相等的减少操作次数"><a href="#5777-使数组元素相等的减少操作次数" class="headerlink" title="5777. 使数组元素相等的减少操作次数"></a><a href="https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal/" target="_blank" rel="noopener">5777. 使数组元素相等的减少操作次数</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>，你的目标是令<code>nums</code>中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p>
<ul>
<li><p>找出<code>nums</code>中的最大值。记这个值为<code>largest</code>并取其下标<code>i</code>（下标从<code>0</code>开始计数）。如果有多个元素都是最大值，则取最小的<code>i</code>。</p>
</li>
<li><p>找出<code>nums</code>中的下一个最大值，这个值严格小于<code>largest</code>，记为<code>nextLargest</code>。</p>
</li>
<li><p>将<code>nums[i]</code>减少到<code>nextLargest</code>。</p>
<p>返回使<code>nums</code>中的所有元素相等的操作次数。</p>
</li>
</ul>
<p>  <strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal/solution/shi-shu-zu-yuan-su-xiang-deng-de-jian-sh-lt55/" target="_blank" rel="noopener">使数组元素相等的减少操作次数 - 使数组元素相等的减少操作次数 - 力扣（LeetCode）</a></p>
<p>  <strong>示例 1：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,1,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：需要 3 次操作使 nums 中的所有元素相等：</span><br><span class="line"></span><br><span class="line">1. largest &#x3D; 5 下标为 0 。nextLargest &#x3D; 3 。将 nums[0] 减少到 3 。nums &#x3D; [3,1,3] 。</span><br><span class="line">2. largest &#x3D; 3 下标为 0 。nextLargest &#x3D; 1 。将 nums[0] 减少到 1 。nums &#x3D; [1,1,3] 。</span><br><span class="line">3. largest &#x3D; 3 下标为 2 。nextLargest &#x3D; 1 。将 nums[2] 减少到 1 。nums &#x3D; [1,1,1] 。</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 3：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,2,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：需要 4 次操作使 nums 中的所有元素相等：</span><br><span class="line"></span><br><span class="line">1. largest &#x3D; 3 下标为 4 。nextLargest &#x3D; 2 。将 nums[4] 减少到 2 。nums &#x3D; [1,1,2,2,2] 。</span><br><span class="line">2. largest &#x3D; 2 下标为 2 。nextLargest &#x3D; 1 。将 nums[2] 减少到 1 。nums &#x3D; [1,1,1,2,2] 。 </span><br><span class="line">3. largest &#x3D; 2 下标为 3 。nextLargest &#x3D; 1 。将 nums[3] 减少到 1 。nums &#x3D; [1,1,1,1,2] 。 </span><br><span class="line">4. largest &#x3D; 2 下标为 4 。nextLargest &#x3D; 1 。将 nums[4] 减少到 1 。nums &#x3D; [1,1,1,1,1] 。</span><br></pre></td></tr></table></figure>

<p>  <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li>
<li><code>1 &lt;= nums[i] &lt;= 5 * 10^4</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序排序做法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reductionOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// 总操作次数</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 每个元素操作次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        res += cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 降序排序做法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reductionOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = nums.size();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> max_value = nums[i];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; nums[i] == max_value) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        count.push_back(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    count.pop_back();</span><br><span class="line">    partial_sum(count.begin(), count.end(), count.begin());</span><br><span class="line">    <span class="keyword">return</span> accumulate(count.begin(), count.end(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a><a href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" rel="noopener">645. 错误的集合</a></h5><blockquote>
<p>  集合<code>s</code>包含从<code>1</code>到<code>n</code>的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制成了集合里面的另外一个数字的值，导致集合丢失了一个数字并且有一个数字重复。</p>
<p>  给定一个数组<code>nums</code>代表了集合<code>s</code>发生错误后的结果。请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>
<p>  <strong>示例 1</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,2,4]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure>

<p>  <strong>提示</strong>：</p>
<ul>
<li>2 &lt;= nums.length &lt;= 1e4</li>
<li>1 &lt;= nums[i] &lt;= 1e4</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法一：哈希表</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; existed;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(existed.count(num)) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        existed.insert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(existed.count(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            res[<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法二：下标索引原地哈希</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(nums[num - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            a = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[num - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法三：数学</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum_1 = <span class="number">0</span>, sum_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">sets</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum_1 += num;</span><br><span class="line">        <span class="keyword">if</span>(!sets[num]) &#123;</span><br><span class="line">            sum_2 += num;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[num] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;sum_1 - sum_2, sum - sum_2&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 法四：位运算</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findErrorNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> xors = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        xors = xors ^ (i + <span class="number">1</span>) ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lowbit = xors &amp; (-xors);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &amp; lowbit) &#123;</span><br><span class="line">            a = a ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            b = b ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((i + <span class="number">1</span>) &amp; lowbit) &#123;</span><br><span class="line">            a = a ^ (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            b = b ^ (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;b, a&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="462-最少移动次数使数组元素相等-II"><a href="#462-最少移动次数使数组元素相等-II" class="headerlink" title="462. 最少移动次数使数组元素相等 II"></a><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/" target="_blank" rel="noopener">462. 最少移动次数使数组元素相等 II</a></h5><blockquote>
<p>  给定一个非空整数数组，找到使所有数组元素相等所需的最小操作数，其中每次操作可将选定的一个元素加<code>1</code>或减<code>1</code>。</p>
<p>  <strong>参考题解</strong>：</p>
<p>  <a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/solution/czhong-wei-shu-jian-dan-zheng-ming-by-ke-a2v9/?um_chnnl=huawei?um_from_appkey=5fcda41c42348b56d6f8e8d5" target="_blank" rel="noopener">C++｜中位数｜简单证明 - 最少移动次数使数组元素相等 II</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使得操作数最小, 最终的值一定是中位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// nth_element(nums.begin(), next(nums.begin(), n/2), nums.end());</span></span><br><span class="line">    _nth_element(nums, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> midVal = nums[n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        res += <span class="built_in">abs</span>(num - midVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速选择算法，使得 k 索引处的元素就位</span></span><br><span class="line"><span class="keyword">void</span> _nth_element(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 对 [lo, hi] 区间内的元素进行洗牌算法</span></span><br><span class="line">    <span class="keyword">auto</span> shuffle = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = rand() % (hi - i + <span class="number">1</span>) + i;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 以首元素为轴点，对 [lo, hi] 区间内元素进行划分</span></span><br><span class="line">    <span class="keyword">auto</span> partition = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">        shuffle(lo, hi);</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = lo;</span><br><span class="line">        <span class="keyword">while</span>(++j &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[lo]) &#123;</span><br><span class="line">                swap(nums[++i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[lo], nums[i]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="keyword">int</span>(nums.size()) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + ((hi - lo) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> p = partition(lo, hi);</span><br><span class="line">        <span class="keyword">if</span>(p == k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p &lt; k) &#123;</span><br><span class="line">            lo = p + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = p - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></h5><blockquote>
<p>  实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>  必须原地修改，只允许使用额外常数空间。</p>
<p>  <strong>参考链接</strong>：<a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/" target="_blank" rel="noopener">下一个排列算法详解：思路+推导+步骤，看不懂算我输</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_permutation(nums.begin(), nums.end());</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> left = n - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; nums[left] &gt;= nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; nums[right] &lt;= nums[left]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[left], nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(next(nums.begin(), left + <span class="number">1</span>), nums.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a></h5><blockquote>
<p>  给定一个未排序的整数数组<code>nums</code>，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>  请你设计并实现时间复杂度为<code>O(n)</code>的算法解决此问题。</p>
<p>  <strong>示例 1：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序 + 去重 + 计数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    unique(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = max(res, cnt);</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(res, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; existed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        existed.insert(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : existed) &#123;</span><br><span class="line">        <span class="keyword">if</span>(existed.count(num - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxVal = num;</span><br><span class="line">            <span class="keyword">while</span>(existed.count(maxVal + <span class="number">1</span>)) &#123;</span><br><span class="line">                maxVal++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, maxVal - num + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h5><blockquote>
<p>  你这个学期必须选修<code>n</code>门课程，记为<code>0</code>到<code>n - 1</code>。在选修某些课程之前需要一些先修课程。 先修课程按数组<code>p</code>给出，其中<code>p[i] = [ai, bi]</code>，表示如果要学习课程<code>ai</code>则必须先学习课程<code>bi</code>。例如，先修课程对<code>[0, 1]</code>表示：想要学习课程<code>0</code>，你需要先完成课程<code>1</code>。</p>
<p>  请你判断是否可能完成所有课程的学习？如果可以，返回<code>true</code>；否则，返回<code>false</code>。</p>
<p>  <strong>示例：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 2, p &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">adj</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">in</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; v : p) &#123;</span><br><span class="line">        adj[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">        in[v[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        res.push_back(from);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> to : adj[from]) &#123;</span><br><span class="line">            in[to]--;</span><br><span class="line">            <span class="keyword">if</span>(in[to] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size() == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1462-课程表-IV"><a href="#1462-课程表-IV" class="headerlink" title="1462. 课程表 IV"></a><a href="https://leetcode-cn.com/problems/course-schedule-iv/" target="_blank" rel="noopener">1462. 课程表 IV</a></h5><blockquote>
<p>  你总共需要上<code>n</code>门课，课程编号依次为<code>0</code>到<code>n-1</code>。有的课会有直接的先修课程，比如如果想上课程<code>0</code>，你必须先上课程<code>1</code>，那么会以<code>[1, 0]</code>数对的形式给出先修课程数对。</p>
<p>  给你课程总数<code>n</code>和一个直接先修课程数对列表<code>p</code>和一个查询对列表<code>q</code>。</p>
<p>  对于每个查询对<code>q[i]</code>，请判断<code>q[i][0]</code>是否是<code>q[i][1]</code>的先修课程。请返回一个布尔值列表，列表中每个元素依次分别对应<code>q</code>每个查询对的判断结果。</p>
<p>  注意：如果课程<code>a</code>是课程<code>b</code>的先修课程且课程<code>b</code>是课程<code>c</code>的先修课程，那么课程<code>a</code>也是课程<code>c</code>的先修课程。</p>
<p>  <strong>参考链接</strong>：<a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd" target="_blank" rel="noopener">图最短路径算法之弗洛伊德算法（Floyd） | Echo Blog</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">adj</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; v : p) &#123;</span><br><span class="line">        adj[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                adj[i][j] = adj[i][j] || (adj[i][k] &amp;&amp; adj[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; v : q) &#123;</span><br><span class="line">        res.push_back(adj[v[<span class="number">0</span>]][v[<span class="number">1</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/submissions/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h5><blockquote>
<p>  给定一个<code>m x n</code>整数矩阵<code>matrix</code>，找出其中最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到 边界外（即不允许环绕）。</p>
<p>  <img src="grid1.jpg" alt="img"></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 建图: 对于每一个点, 都有一个指向比其大的方向的路径</span></span><br><span class="line"><span class="comment">// 2. 从所有入度为 0 的点出发分别进行 dfs</span></span><br><span class="line"><span class="comment">// 3. 相当于是找到以各个出发节点为根的树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">adj</span><span class="params">(m * n)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">in</span><span class="params">(m * n)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> getId = [n](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">return</span> i * n + j;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(m * n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; dfs, <span class="keyword">int</span> from) &#123;</span><br><span class="line">        <span class="keyword">if</span>(adj[from].empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[from] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[from];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> to : adj[from]) &#123;</span><br><span class="line">            len = max(len, <span class="number">1</span> + dfs(dfs, to));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[from] = len;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m &amp;&amp; matrix[i][j] &lt; matrix[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                adj[getId(i, j)].push_back(getId(i + <span class="number">1</span>, j));</span><br><span class="line">                in[getId(i + <span class="number">1</span>, j)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; matrix[i][j] &lt; matrix[i][j + <span class="number">1</span>]) &#123;</span><br><span class="line">                adj[getId(i, j)].push_back(getId(i, j + <span class="number">1</span>));</span><br><span class="line">                in[getId(i, j + <span class="number">1</span>)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j] &lt; matrix[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                adj[getId(i, j)].push_back(getId(i - <span class="number">1</span>, j));</span><br><span class="line">                in[getId(i - <span class="number">1</span>, j)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j] &lt; matrix[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                adj[getId(i, j)].push_back(getId(i, j - <span class="number">1</span>));</span><br><span class="line">                in[getId(i, j - <span class="number">1</span>)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m * n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            res = max(res, dfs(dfs, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="444-序列重建"><a href="#444-序列重建" class="headerlink" title="444. 序列重建"></a><a href="https://leetcode-cn.com/problems/sequence-reconstruction/" target="_blank" rel="noopener">444. 序列重建</a></h5><blockquote>
<p>  验证原始的序列<code>org</code>是否可以从序列集<code>seqs</code>中唯一地重建。序列<code>org</code>是<code>1</code>到<code>n</code>整数的排列，其中<code>1 ≤ n ≤ 10^4</code>。重建是指在序列集<code>seqs</code>中构建最短的公共超序列。（即使得所有<code>seqs</code>中的序列都是该最短序列的子序列）。确定是否只可以从<code>seqs</code>重建唯一的序列，且该序列就是<code>org</code>。</p>
<p>  <strong>示例 1</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">org: [1,2,3], seqs: [[1,2],[1,3]]</span><br><span class="line">输出：false</span><br><span class="line">解释：[1,2,3] 不是可以被重建的唯一的序列，因为 [1,3,2] 也是一个合法的序列。</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 2</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：org: [1,2,3], seqs: [[1,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：可以重建的序列只有 [1,2]。</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 3</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：org: [1,2,3], seqs: [[1,2],[1,3],[2,3]]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列 [1,2], [1,3] 和 [2,3] 可以被唯一地重建为原始的序列 [1,2,3]。</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 4</strong>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：org: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; org, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; seqs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seqs.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = org.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">in</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">adj</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; all_set;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; seq : seqs) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = seq.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i] &lt;= <span class="number">0</span> || seq[i] &gt; n) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                all_set.insert(seq[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> from = seq[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = seq[i];</span><br><span class="line">            adj[from].push_back(to);</span><br><span class="line">            in[to]++;</span><br><span class="line">            all_set.insert(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> from = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        res.push_back(from);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> to : adj[from]) &#123;</span><br><span class="line">            in[to]--;</span><br><span class="line">            <span class="keyword">if</span>(in[to] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> org == res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/rakjPpyIOCsd0MoJ/" rel="prev" title="面试知识点详细解读之僵尸进程和孤儿进程">
      <i class="fa fa-chevron-left"></i> 面试知识点详细解读之僵尸进程和孤儿进程
    </a></div>
      <div class="post-nav-item">
    <a href="/ZUdtS6UUmrVCKLed/" rel="next" title="牛客2021年4月15号模拟笔试题">
      牛客2021年4月15号模拟笔试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80OTQ0NS8yNTkzNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#167-两数之和-II-输入有序数组"><span class="nav-number">1.</span> <span class="nav-text">167. 两数之和 II - 输入有序数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-两数之和"><span class="nav-number">2.</span> <span class="nav-text">1. 两数之和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#560-Subarray-Sum-Equals-K"><span class="nav-number">3.</span> <span class="nav-text">560. Subarray Sum Equals K</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#724-Find-Pivot-Index"><span class="nav-number">4.</span> <span class="nav-text">724. Find Pivot Index</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#523-Continuous-Subarray-Sum"><span class="nav-number">5.</span> <span class="nav-text">523. Continuous Subarray Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1089-复写零"><span class="nav-number">6.</span> <span class="nav-text">1089. 复写零</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#941-Valid-Mountain-Array"><span class="nav-number">7.</span> <span class="nav-text">941. Valid Mountain Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#448-Find-All-Numbers-Disappeared-in-an-Array"><span class="nav-number">8.</span> <span class="nav-text">448. Find All Numbers Disappeared in an Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#442-Find-All-Duplicates-in-an-Array"><span class="nav-number">9.</span> <span class="nav-text">442. Find All Duplicates in an Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1744-Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day"><span class="nav-number">10.</span> <span class="nav-text">1744. Can You Eat Your Favorite Candy on Your Favorite Day?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#710-黑名单中的随机数"><span class="nav-number">11.</span> <span class="nav-text">710. 黑名单中的随机数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#528-Random-Pick-with-Weight"><span class="nav-number">12.</span> <span class="nav-text">528. Random Pick with Weight</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-Container-With-Most-Water"><span class="nav-number">13.</span> <span class="nav-text">11. Container With Most Water</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#42-Trapping-Rain-Water"><span class="nav-number">14.</span> <span class="nav-text">42. Trapping Rain Water</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1395-Count-Number-of-Teams"><span class="nav-number">15.</span> <span class="nav-text">1395. Count Number of Teams</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#480-Sliding-Window-Median"><span class="nav-number">16.</span> <span class="nav-text">480. Sliding Window Median</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#239-Sliding-Window-Maximum"><span class="nav-number">17.</span> <span class="nav-text">239. Sliding Window Maximum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1834-Single-Threaded-CPU"><span class="nav-number">18.</span> <span class="nav-text">1834. Single-Threaded CPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#912-排序数组"><span class="nav-number">19.</span> <span class="nav-text">912. 排序数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="nav-number">20.</span> <span class="nav-text">34. Find First and Last Position of Element in Sorted Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#240-Search-a-2D-Matrix-II"><span class="nav-number">21.</span> <span class="nav-text">240. Search a 2D Matrix II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#162-Find-Peak-Element"><span class="nav-number">22.</span> <span class="nav-text">162. Find Peak Element</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#658-Find-K-Closest-Elements"><span class="nav-number">23.</span> <span class="nav-text">658. Find K Closest Elements</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#719-Find-K-th-Smallest-Pair-Distance"><span class="nav-number">24.</span> <span class="nav-text">719. Find K-th Smallest Pair Distance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#373-Find-K-Pairs-with-Smallest-Sums"><span class="nav-number">25.</span> <span class="nav-text">373. Find K Pairs with Smallest Sums</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#209-Minimum-Size-Subarray-Sum"><span class="nav-number">26.</span> <span class="nav-text">209. Minimum Size Subarray Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><span class="nav-number">27.</span> <span class="nav-text">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#220-Contains-Duplicate-III"><span class="nav-number">28.</span> <span class="nav-text">220. Contains Duplicate III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#498-Diagonal-Traverse"><span class="nav-number">29.</span> <span class="nav-text">498. Diagonal Traverse</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1424-Diagonal-Traverse-II"><span class="nav-number">30.</span> <span class="nav-text">1424. Diagonal Traverse II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#54-Spiral-Matrix"><span class="nav-number">31.</span> <span class="nav-text">54. Spiral Matrix</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1288-Remove-Covered-Intervals"><span class="nav-number">32.</span> <span class="nav-text">1288. Remove Covered Intervals</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#56-Merge-Intervals"><span class="nav-number">33.</span> <span class="nav-text">56. Merge Intervals</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#57-Insert-Interval"><span class="nav-number">34.</span> <span class="nav-text">57. Insert Interval</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#986-Interval-List-Intersections"><span class="nav-number">35.</span> <span class="nav-text">986. Interval List Intersections</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#435-Non-overlapping-Intervals"><span class="nav-number">36.</span> <span class="nav-text">435. Non-overlapping Intervals</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons"><span class="nav-number">37.</span> <span class="nav-text">452. Minimum Number of Arrows to Burst Balloons</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#436-Find-Right-Interval"><span class="nav-number">38.</span> <span class="nav-text">436. Find Right Interval</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#713-Subarray-Product-Less-Than-K"><span class="nav-number">39.</span> <span class="nav-text">713. Subarray Product Less Than K</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#525-Contiguous-Array"><span class="nav-number">40.</span> <span class="nav-text">525. Contiguous Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-四数之和"><span class="nav-number">41.</span> <span class="nav-text">18. 四数之和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-17-10-主要元素"><span class="nav-number">42.</span> <span class="nav-text">面试题 17.10. 主要元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#253-Meeting-Rooms-II"><span class="nav-number">43.</span> <span class="nav-text">253. Meeting Rooms II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1094-Car-Pooling"><span class="nav-number">44.</span> <span class="nav-text">1094. Car Pooling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1840-Maximum-Building-Height"><span class="nav-number">45.</span> <span class="nav-text">1840. Maximum Building Height</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1838-Frequency-of-the-Most-Frequent-Element"><span class="nav-number">46.</span> <span class="nav-text">1838. Frequency of the Most Frequent Element</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1011-Capacity-To-Ship-Packages-Within-D-Days"><span class="nav-number">47.</span> <span class="nav-text">1011. Capacity To Ship Packages Within D Days</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#875-Koko-Eating-Bananas"><span class="nav-number">48.</span> <span class="nav-text">875. Koko Eating Bananas</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1760-Minimum-Limit-of-Balls-in-a-Bag"><span class="nav-number">49.</span> <span class="nav-text">1760. Minimum Limit of Balls in a Bag</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array"><span class="nav-number">50.</span> <span class="nav-text">153. Find Minimum in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#154-Find-Minimum-in-Rotated-Sorted-Array-II"><span class="nav-number">51.</span> <span class="nav-text">154. Find Minimum in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#33-Search-in-Rotated-Sorted-Array"><span class="nav-number">52.</span> <span class="nav-text">33. Search in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#81-Search-in-Rotated-Sorted-Array-II"><span class="nav-number">53.</span> <span class="nav-text">81. Search in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1004-Max-Consecutive-Ones-III"><span class="nav-number">54.</span> <span class="nav-text">1004. Max Consecutive Ones III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#391-数飞机"><span class="nav-number">55.</span> <span class="nav-text">391. 数飞机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#218-The-Skyline-Problem"><span class="nav-number">56.</span> <span class="nav-text">218. The Skyline Problem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Median-of-Two-Sorted-Arrays"><span class="nav-number">57.</span> <span class="nav-text">4. Median of Two Sorted Arrays</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#457-Circular-Array-Loop"><span class="nav-number">58.</span> <span class="nav-text">457. Circular Array Loop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#41-First-Missing-Positive"><span class="nav-number">59.</span> <span class="nav-text">41. First Missing Positive</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1482-Minimum-Number-of-Days-to-Make-m-Bouquets"><span class="nav-number">60.</span> <span class="nav-text">1482. Minimum Number of Days to Make m Bouquets</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1109-Corporate-Flight-Bookings"><span class="nav-number">61.</span> <span class="nav-text">1109. Corporate Flight Bookings</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-64-995-Minimum-Number-of-K-Consecutive-Bit-Flips"><span class="nav-number">62.</span> <span class="nav-text">1.64 995. Minimum Number of K Consecutive Bit Flips</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#307-Range-Sum-Query-Mutable"><span class="nav-number">63.</span> <span class="nav-text">307. Range Sum Query - Mutable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1310-XOR-Queries-of-a-Subarray"><span class="nav-number">64.</span> <span class="nav-text">1310. XOR Queries of a Subarray</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#315-Count-of-Smaller-Numbers-After-Self"><span class="nav-number">65.</span> <span class="nav-text">315. Count of Smaller Numbers After Self</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#剑指-Offer-51-数组中的逆序对"><span class="nav-number">66.</span> <span class="nav-text">剑指 Offer 51. 数组中的逆序对</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR"><span class="nav-number">67.</span> <span class="nav-text">1442. Count Triplets That Can Form Two Arrays of Equal XOR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#421-Maximum-XOR-of-Two-Numbers-in-an-Array"><span class="nav-number">68.</span> <span class="nav-text">421. Maximum XOR of Two Numbers in an Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1707-Maximum-XOR-With-an-Element-From-Array"><span class="nav-number">69.</span> <span class="nav-text">1707. Maximum XOR With an Element From Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1074-Number-of-Submatrices-That-Sum-to-Target"><span class="nav-number">70.</span> <span class="nav-text">1074. Number of Submatrices That Sum to Target</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1738-Find-Kth-Largest-XOR-Coordinate-Value"><span class="nav-number">71.</span> <span class="nav-text">1738. Find Kth Largest XOR Coordinate Value</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#581-Shortest-Unsorted-Continuous-Subarray"><span class="nav-number">72.</span> <span class="nav-text">581. Shortest Unsorted Continuous Subarray</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#48-Rotate-Image"><span class="nav-number">73.</span> <span class="nav-text">48. Rotate Image</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5777-使数组元素相等的减少操作次数"><span class="nav-number">74.</span> <span class="nav-text">5777. 使数组元素相等的减少操作次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#645-错误的集合"><span class="nav-number">75.</span> <span class="nav-text">645. 错误的集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#462-最少移动次数使数组元素相等-II"><span class="nav-number">76.</span> <span class="nav-text">462. 最少移动次数使数组元素相等 II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#31-下一个排列"><span class="nav-number">77.</span> <span class="nav-text">31. 下一个排列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#128-最长连续序列"><span class="nav-number">78.</span> <span class="nav-text">128. 最长连续序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#207-课程表"><span class="nav-number">79.</span> <span class="nav-text">207. 课程表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1462-课程表-IV"><span class="nav-number">80.</span> <span class="nav-text">1462. 课程表 IV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#329-矩阵中的最长递增路径"><span class="nav-number">81.</span> <span class="nav-text">329. 矩阵中的最长递增路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#444-序列重建"><span class="nav-number">82.</span> <span class="nav-text">444. 序列重建</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>