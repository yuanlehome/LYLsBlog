<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章是leetcode刷题系列的第7部分——数据结构设计。 leetcode刷题系列其它文章组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 8. 刷题小知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题系列之数据结构设计">
<meta property="og:url" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="这篇文章是leetcode刷题系列的第7部分——数据结构设计。 leetcode刷题系列其它文章组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 8. 刷题小知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/dtter.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/2341123.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/dfgdf.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/8c5d16af06b2bbf15ac75dad30898e99c0b19b83d433b303a4f0fb8ac885387b.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/2.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/title.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/an_illustration_of_the_dining_philosophers_problem.png">
<meta property="og:image" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/formu1.png">
<meta property="article:published_time" content="2021-07-10T13:35:42.000Z">
<meta property="article:modified_time" content="2021-07-10T13:35:42.000Z">
<meta property="article:author" content="Liu Y.L.">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/dtter.jpg">

<link rel="canonical" href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode刷题系列之数据结构设计 | LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode刷题系列之数据结构设计
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-10 21:35:42" itemprop="dateCreated datePublished" datetime="2021-07-10T21:35:42+08:00">2021-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>36k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章是<code>leetcode</code>刷题系列的第<code>7</code>部分——数据结构设计。</p>
<p><code>leetcode</code>刷题系列其它文章组织如下：</p>
<p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p>
<p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p>
<p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p>
<a id="more"></a>

<h5 id="622-Design-Circular-Queue"><a href="#622-Design-Circular-Queue" class="headerlink" title="622. Design Circular Queue"></a><a href="https://leetcode.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. Design Circular Queue</a></h5><blockquote>
<p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于<code>FIFO</code>（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue(k)</span><br><span class="line">构造器, 设置队列长度为 k</span><br><span class="line">Front</span><br><span class="line">从队首获取元素, 如果队列为空，返回 -1</span><br><span class="line">Rear</span><br><span class="line">获取队尾元素, 如果队列为空，返回 -1</span><br><span class="line">enQueue(value)</span><br><span class="line">向循环队列插入一个元素, 如果成功插入则返回真</span><br><span class="line">deQueue()</span><br><span class="line">从循环队列中删除一个元素, 如果成功删除则返回真</span><br><span class="line">isEmpty()</span><br><span class="line">检查循环队列是否为空</span><br><span class="line">isFull()</span><br><span class="line">检查循环队列是否已满</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简单起见, 使用头尾两个索引变量和一个大小变量</span></span><br><span class="line"><span class="comment">// _head 永远指向头元素的前一个位置</span></span><br><span class="line"><span class="comment">// _tail 永远指向尾元素</span></span><br><span class="line"><span class="comment">// _size 指示队列中的元素数</span></span><br><span class="line"><span class="comment">// 队列方向为 _head &lt;----------- _tail</span></span><br><span class="line"><span class="comment">// _head 和 _tail 只加不减, 循环</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _head;</span><br><span class="line">    <span class="keyword">int</span> _tail;</span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化时, 头尾索引为 -1 表示无效, 大小为 0</span></span><br><span class="line">    MyCircularQueue(<span class="keyword">int</span> k) : _head(<span class="number">-1</span>), _tail(<span class="number">-1</span>), _size(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 vector 容量扩充到指定大小, 默认以 0 填充</span></span><br><span class="line">        _data.resize(k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入队时, 判断是否已满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尾指针当前指向尾元素, 添加元素时需要 ++</span></span><br><span class="line">        <span class="comment">// 如果超过 vector 索引范围, 直接回到 0</span></span><br><span class="line">        <span class="keyword">if</span>(++_tail == _data.size()) &#123;</span><br><span class="line">            _tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _data[_tail] = value;</span><br><span class="line">        _size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 出队时先判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为 _head 当前指向首元素前一个位置</span></span><br><span class="line">        <span class="comment">// 需要先 ++ 再赋值</span></span><br><span class="line">        _head++;</span><br><span class="line">        <span class="comment">// 如果超过 vector 索引范围, 直接回到 0</span></span><br><span class="line">        <span class="keyword">if</span>(_head == _data.size()) &#123;</span><br><span class="line">            _head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _head + <span class="number">1</span> == _data.size() ? _data[<span class="number">0</span>] : _data[_head + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ? <span class="number">-1</span> : _data[_tail];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size == _data.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache</a></h5><blockquote>
<p>运用你所掌握的数据结构，设计和实现一个<code>LRU</code>(最近最少使用) 缓存机制 。</p>
<p><strong>参考链接</strong>：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNDQ3MzgxMw==&mid=2247483929&idx=1&sn=fda81057c47d376917ed142b2661f63a&chksm=e8f49223df831b35deb2e5316caddc241b4aa4bb58e8c66c906bdacfd695aca53aca86a5b173&mpshare=1&scene=23&srcid=0316bjmcFhe5xBzFM5mVMehZ&sharer_sharetime=1622459011412&sharer_shareid=7cbdd205bcb5ea7a7912ce1a62c48cda#rd" target="_blank" rel="noopener">从 LRU Cache 带你看面试的本质</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzk0NTE5MTcxNQ==&mid=2247483722&idx=1&sn=4f5ff638f9e020ad7ee8a3ba2595b8e6&chksm=c3186f06f46fe610a98fcc65e397f22d6d39a25ed32715ae313ec45a0f7f19368c36ec3175bb&mpshare=1&scene=23&srcid=0303Bs1lcVsbvfREx8q7YaqB&sharer_sharetime=1622459025098&sharer_shareid=7cbdd205bcb5ea7a7912ce1a62c48cda#rd" target="_blank" rel="noopener">缓存淘汰算法的实现与应用介绍（LRU、LFU）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647523909&idx=1&sn=fc26b334afcd3b12a130905043e58f20&chksm=87d1bd46b0a634505a619566b7cd56c4f69bec7793d3f6794cef1207c3c40bdc6916da608089&mpshare=1&scene=23&srcid=1226uXTA9n8lmyoSP4zAxDly&sharer_sharetime=1622459037018&sharer_shareid=7cbdd205bcb5ea7a7912ce1a62c48cda#rd" target="_blank" rel="noopener">我竟然跪在了LRU，好亏奥！</a></li>
</ul>
<p>实现<code>LRUCache</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LRUCache(int capacity)</span><br><span class="line">以正整数作为容量 capacity 初始化 LRU 缓存</span><br><span class="line">int get(int key)</span><br><span class="line">如果关键字 key 存在于缓存中，则返回关键字的值, 否则返回 -1</span><br><span class="line">void put(int key, int value)</span><br><span class="line">如果关键字已经存在, 则变更其数据值: 如果关键字不存在, 则插入该组「关键字-值」, 当缓存容量达到上限时, 它应该在写入新数据之前删除最久未使用的数据值, 从而为新的数据值留出空间</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="dtter.jpg" alt="Image" style="zoom:50%;" />

<img src="2341123.jpg" alt="Image" style="zoom:50%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> key_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">list</span>&lt;pair&lt;key_type, value_type&gt;&gt;::iterator iterator_to_node;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;key_type, iterator_to_node&gt; _key2item;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;key_type, value_type&gt;&gt; _items;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">size_t</span> capacity) : _capacity(capacity) &#123;&#125;;</span><br><span class="line">    ~LRUCache() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">value_type <span class="title">get</span><span class="params">(key_type key)</span> </span>&#123;</span><br><span class="line">        value_type value;</span><br><span class="line">        <span class="keyword">if</span>(_key2item.count(key)) &#123;</span><br><span class="line">            value = _key2item[key]-&gt;second;</span><br><span class="line">            _items.splice(_items.begin(), _items, _key2item[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(key_type key, value_type value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_key2item.count(key)) &#123;</span><br><span class="line">            _key2item[key]-&gt;second = value;</span><br><span class="line">            _items.splice(_items.begin(), _items, _key2item[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(_capacity &lt;= _items.size()) &#123;</span><br><span class="line">                _key2item.erase(_items.back().first);</span><br><span class="line">                _items.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">             _items.emplace_front(key, value);</span><br><span class="line">            _key2item[key] = _items.begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashmap + list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> key_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">list</span>&lt;pair&lt;key_type, value_type&gt;&gt;::iterator iterator_to_node;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;key_type, iterator_to_node&gt; _keyToItem;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;key_type, value_type&gt;&gt; _itemList;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">size_t</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line">    ~LRUCache() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">value_type <span class="title">get</span><span class="params">(key_type key)</span> </span>&#123;</span><br><span class="line">        value_type value;</span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key)) &#123;</span><br><span class="line">            value = _keyToItem[key]-&gt;second;</span><br><span class="line">            <span class="comment">// 如果 key 存在, 则在 LRUcache 中重新添加这个 key</span></span><br><span class="line">        	put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 key 对应的值</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(key_type key, value_type val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 key 已经存在, 则直接删掉链表中对应的条目</span></span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key)) &#123;</span><br><span class="line">            _itemList.erase(_keyToItem[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(_capacity &lt;= _itemList.size()) &#123;</span><br><span class="line">            <span class="comment">// 如果容量已经满, 则删除链表尾部的条目以及 hashmap 中对应的 key</span></span><br><span class="line">            _keyToItem.erase(_itemList.back().first);</span><br><span class="line">            _itemList.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新 key 加入链表首部并在 hashmap 中更新/添加 key</span></span><br><span class="line">        _itemList.emplace_front(key, val);</span><br><span class="line">        _keyToItem[key] = _itemList.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己实现双向链表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    T _value;</span><br><span class="line">    Node* _prev;</span><br><span class="line">    Node* _next;</span><br><span class="line">    Node(<span class="keyword">const</span> T&amp; value) : _value(value), _prev(<span class="literal">nullptr</span>), _next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Node&lt;value_type&gt;* link_type;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    link_type _node;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DoubleLinkedList() : _node(<span class="literal">nullptr</span>), _size(<span class="number">0</span>) &#123;</span><br><span class="line">        _node = <span class="keyword">new</span> Node&lt;value_type&gt;(value_type());</span><br><span class="line">        _node-&gt;_next = _node;</span><br><span class="line">        _node-&gt;_prev = _node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~DoubleLinkedList() &#123;</span><br><span class="line">        <span class="keyword">while</span>(_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> _node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">link_type <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _node-&gt;_next; &#125;</span><br><span class="line">    <span class="function">link_type <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _node; &#125;</span><br><span class="line">    <span class="function">value_type&amp; <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _node-&gt;_next-&gt;_value; &#125;</span><br><span class="line">    <span class="function">value_type&amp; <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _node-&gt;_prev-&gt;_value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(link_type node)</span> </span>&#123;</span><br><span class="line">        _size--;</span><br><span class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</span><br><span class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; erase(_node-&gt;_next); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; erase(_node-&gt;_prev); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(link_type pos, value_type value)</span> </span>&#123;</span><br><span class="line">        _size++;</span><br><span class="line">        link_type node = <span class="keyword">new</span> Node&lt;value_type&gt;(value);</span><br><span class="line">        pos-&gt;_prev-&gt;_next = node;</span><br><span class="line">        node-&gt;_prev = pos-&gt;_prev;</span><br><span class="line">        pos-&gt;_prev = node;</span><br><span class="line">        node-&gt;_next = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(value_type value)</span> </span>&#123; insert(_node-&gt;_next, value); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(value_type value)</span> </span>&#123; insert(_node, value); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> DoubleLinkedList&lt;pair&lt;<span class="keyword">int</span>, value_type&gt;&gt;::link_type iterator_to_node;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, iterator_to_node&gt; _keyToItem;</span><br><span class="line">    DoubleLinkedList&lt;pair&lt;<span class="keyword">int</span>, value_type&gt;&gt; _itemList;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line">    ~LRUCache() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">value_type <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value_type res = _keyToItem[key]-&gt;_value.second;</span><br><span class="line">        <span class="comment">// 如果 key 存在, 则在 LRUcache 中重新添加这个 key</span></span><br><span class="line">        put(key, res);</span><br><span class="line">        <span class="comment">// 返回 key 对应的值</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, value_type val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 key 已经存在, 则直接删掉链表中对应的条目</span></span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key)) &#123;</span><br><span class="line">            _itemList.erase(_keyToItem[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(_capacity &lt;= _itemList.size()) &#123;</span><br><span class="line">            <span class="comment">// 如果容量已经满, 则删除链表尾部的条目以及 hashmap 中对应的 key</span></span><br><span class="line">            _keyToItem.erase(_itemList.back().first);</span><br><span class="line">            _itemList.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新 key 加入链表首部并在 hashmap 中更新/添加 key</span></span><br><span class="line">        _itemList.push_front(make_pair(key, val));</span><br><span class="line">        _keyToItem[key] = _itemList.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="460-LFU-Cache"><a href="#460-LFU-Cache" class="headerlink" title="460. LFU Cache"></a><a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">460. LFU Cache</a></h5><blockquote>
<p>请你为最不经常使用（<code>LFU</code>）缓存算法设计并实现数据结构。</p>
<p>实现<code>LFUCache</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LFUCache(int capacity)</span><br><span class="line">用数据结构的容量 capacity 初始化对象</span><br><span class="line">int get(int key)</span><br><span class="line">如果键存在于缓存中, 则获取键的值, 否则返回 -1</span><br><span class="line">void put(int key, int value)</span><br><span class="line">如果键已存在, 则变更其值; 如果键不存在, 请插入键值对, 当缓存达到其容量时, 则应该在插入新项之前, 使最不经常使用的项无效, 在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键</span><br></pre></td></tr></table></figure>


<p>注意「项的使用次数」就是自插入该项以来对其调用<code>get</code>和<code>put</code>函数的次数之和。使用次数会在对应项被移除后置为<code>0</code>。</p>
<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个使用计数器 。使用计数最小的键是最久未使用的键。当一个键首次插入到缓存中时，它的使用计数器被设置为<code>1</code> (由于<code>put</code>操作)。对缓存中的键执行<code>get</code>或<code>put</code>操作，使用计数器的值将会递增。</p>
</blockquote>
<img src="dfgdf.jpg" alt="Image" style="zoom:50%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双 hashmap + list 方法, 实现的 get 和 put 的操作时间复杂度都为 O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">int</span> _key;</span><br><span class="line">    value_type _value;</span><br><span class="line">    <span class="keyword">size_t</span> _freq;</span><br><span class="line">    Node(<span class="keyword">int</span> key, value_type value, <span class="keyword">size_t</span> freq) : _key(key), _value(value), _freq(freq) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">list</span>&lt;Node&lt;value_type&gt;&gt;::iterator iterator_to_node;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">    <span class="keyword">size_t</span> _minFreq;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, iterator_to_node&gt; _keyToItem;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">list</span>&lt;Node&lt;value_type&gt;&gt;&gt; _freqToKeys;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">size_t</span> capacity) : _capacity(capacity), _minFreq(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    ~LFUCache() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">value_type <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value_type();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 key 对应的 _freq + 1</span></span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span> _keyToItem[key]-&gt;_value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, value_type value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 key 已经存在，则更新对应的 _value, 然后将 key 对应的 _freq + 1</span></span><br><span class="line">        <span class="keyword">if</span>(_keyToItem.count(key)) &#123;</span><br><span class="line">            _keyToItem[key]-&gt;_value = value;</span><br><span class="line">            increaseFreq(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果容量已满, 则删除 _minFreq 对应的最久未使用的条目</span></span><br><span class="line">        <span class="keyword">if</span>(_capacity &lt;= _keyToItem.size()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lfu_key = _freqToKeys[_minFreq].back()._key;</span><br><span class="line">            _freqToKeys[_minFreq].pop_back();</span><br><span class="line">            _keyToItem.erase(lfu_key);</span><br><span class="line">            <span class="comment">// 如果 _minFreq 对应的 _key 链表已空, 则删除这个 _minFreq 对应的映射</span></span><br><span class="line">            <span class="keyword">if</span>(_freqToKeys[_minFreq].empty()) &#123;</span><br><span class="line">                _freqToKeys.erase(_minFreq);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此处不需要更新 _minFreq 的值, 因为接下来添加新条目后会将 _minFreq 设为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 腾出空间后, 添加 _freq 为 1 的键值对</span></span><br><span class="line">        _freqToKeys[<span class="number">1</span>].push_front(Node&lt;value_type&gt;(key, value, <span class="number">1</span>));</span><br><span class="line">        _keyToItem[key] = _freqToKeys[<span class="number">1</span>].begin();</span><br><span class="line">        <span class="comment">// 更新目前最小 freq, 因为新添加了一个条目, 所以就是 1</span></span><br><span class="line">        _minFreq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将 key 对应的 freq + 1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先缓存一下当前 key 对应的 _freq 和 _value</span></span><br><span class="line">        <span class="keyword">size_t</span> theFreq = _keyToItem[key]-&gt;_freq;</span><br><span class="line">        value_type theValue = _keyToItem[key]-&gt;_value;</span><br><span class="line">        <span class="comment">// 在当前 _freq 所对应的条目列表中删除当前 key 对应的条目并将其添加到 _freq + 1 对应的链表里</span></span><br><span class="line">        _freqToKeys[theFreq].erase(_keyToItem[key]);</span><br><span class="line">        _freqToKeys[theFreq + <span class="number">1</span>].push_front(Node&lt;value_type&gt;(key, theValue, theFreq + <span class="number">1</span>));</span><br><span class="line">        _keyToItem[key] = _freqToKeys[theFreq + <span class="number">1</span>].begin();</span><br><span class="line">        <span class="comment">// 如果当前 _freq 对应的链表为空了, 则删除 _freq 对应的映射</span></span><br><span class="line">        <span class="keyword">if</span>(_freqToKeys[theFreq].empty()) &#123;</span><br><span class="line">            _freqToKeys.erase(theFreq);</span><br><span class="line">            <span class="comment">// 如果删除的这个 key 的 _freq 正好是 _minFreq, 则更新 _minFreq</span></span><br><span class="line">            <span class="keyword">if</span>(theFreq == _minFreq) &#123;</span><br><span class="line">                _minFreq++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree)</a></h5><blockquote>
<p><code>Trie</code>或者说前缀树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现<code>Trie</code>类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串<code>word</code>。</li>
<li><code>boolean search(String word)</code> 如果字符串<code>word</code>在前缀树中，返回<code>true</code>（即，在检索之前已经插入）；否则，返回<code>false</code>。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串<code>word</code>的前缀之一为<code>prefix</code>，返回<code>true</code>；否则，返回<code>false</code>。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Trie*&gt; child;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie() : child(<span class="number">26</span>), isEnd(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    ~Trie() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node : child) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node) &#123;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;child[c - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                node-&gt;child[c] = <span class="keyword">new</span> Trie;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;child[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie* node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : prefix) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;child[c - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;child[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295. Find Median from Data Stream"></a><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. Find Median from Data Stream</a></h5><blockquote>
<p>  The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.</p>
<ul>
<li><p>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</p>
</li>
<li><p>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</p>
<p>Implement the <code>MedianFinder</code> class:</p>
</li>
<li><p><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</p>
</li>
<li><p><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</p>
</li>
<li><p><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10-5</code> of the actual answer will be accepted.</p>
</li>
</ul>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MedianFinder medianFinder &#x3D; new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    &#x2F;&#x2F; arr &#x3D; [1]</span><br><span class="line">medianFinder.addNum(2);    &#x2F;&#x2F; arr &#x3D; [1, 2]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 1.5 (i.e., (1 + 2) &#x2F; 2)</span><br><span class="line">medianFinder.addNum(3);    &#x2F;&#x2F; arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 2.0</span><br></pre></td></tr></table></figure>

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>-10^5 &lt;= num &lt;= 10^5</code></li>
<li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li>
<li>At most <code>5 * 10^4</code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li>
</ul>
<p>  <strong>Follow up:</strong></p>
<ul>
<li>If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>
<li>If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; maxTop;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minTop;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minTop.empty() || minTop.top() &lt;= num)</span><br><span class="line">            minTop.push(num);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            maxTop.push(num);</span><br><span class="line">        <span class="comment">// 放完后 balance</span></span><br><span class="line">        balance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minTop.size() == maxTop.size())</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>(minTop.top()) + <span class="keyword">double</span>(maxTop.top())) * <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">return</span> minTop.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">balance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minTop.size() &lt; maxTop.size())</span><br><span class="line">        &#123;</span><br><span class="line">            minTop.push(maxTop.top());</span><br><span class="line">            maxTop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minTop.size() &gt; maxTop.size() + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxTop.push(minTop.top());</span><br><span class="line">            minTop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化了下逻辑, 减少代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; small;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; large;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MedianFinder() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 巧妙实现交替放</span></span><br><span class="line">        <span class="keyword">if</span>(small.size() == large.size()) &#123;</span><br><span class="line">            large.push(num);</span><br><span class="line">            small.push(large.top());</span><br><span class="line">            large.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            small.push(num);</span><br><span class="line">            large.push(small.top());</span><br><span class="line">            small.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(small.size() != large.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> small.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>(small.top()) + <span class="keyword">double</span>(large.top())) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="170-两数之和-III-数据结构设计"><a href="#170-两数之和-III-数据结构设计" class="headerlink" title="170. 两数之和 III - 数据结构设计"></a><a href="https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/" target="_blank" rel="noopener">170. 两数之和 III - 数据结构设计</a></h5><blockquote>
<p>设计一个<code>TwoSum</code>类，拥有两个<code>API</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span></span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">&gt;<span class="comment">// 向数据结构中添加一个数 number</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">&gt;<span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此种解法适用于频繁 add 的情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向数据结构中添加一个数 number</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        mapping[number]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; [first, _] : mapping) &#123;</span><br><span class="line">            <span class="keyword">long</span> second = <span class="keyword">long</span>(value) - first;</span><br><span class="line">            <span class="comment">// 两个相同的数相加等于 value</span></span><br><span class="line">            <span class="keyword">if</span>(second == first &amp;&amp; mapping[first] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不同的两个数相加为 value</span></span><br><span class="line">            <span class="keyword">if</span>(second != first &amp;&amp; mapping.count(second) &amp;&amp; mapping[second] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此种解法适用于频繁 find 的情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; allSum;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向数据结构中添加一个数 number</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录所有可能的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            allSum.insert(num + number);</span><br><span class="line">        &#125;</span><br><span class="line">        nums.push_back(number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allSum.count(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">155. Min Stack</a></h5><blockquote>
<p>  设计一个支持<code>push</code>，<code>pop</code>，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p>
<p>  <code>push(x)</code> —— 将元素<code>x</code>推入栈中。<br>  <code>pop()</code> —— 删除栈顶的元素。<br>  <code>top()</code> —— 获取栈顶元素。<br>  <code>getMin()</code> —— 检索栈中的最小元素。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// &#123;value, value 入栈的时候栈中的最小值&#125;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; _data;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data.empty()) &#123;</span><br><span class="line">            _data.push(&#123;x, x&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	_data.push(&#123;x, min(x, _data.top().second)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.top().first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.top().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="895-Maximum-Frequency-Stack"><a href="#895-Maximum-Frequency-Stack" class="headerlink" title="895. Maximum Frequency Stack"></a><a href="https://leetcode.com/problems/maximum-frequency-stack/" target="_blank" rel="noopener">895. Maximum Frequency Stack</a></h5><blockquote>
<p>  实现<code>FreqStack</code>，模拟类似栈的数据结构的操作的一个类。</p>
<p>  <code>FreqStack</code>有两个函数：</p>
<ul>
<li><p><code>push(int x)</code>，将整数<code>x</code>推入栈中。</p>
</li>
<li><p><code>pop()</code>，它移除并返回栈中出现最频繁的元素。</p>
<p>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</p>
<p>提示：</p>
</li>
<li><p>对<code>FreqStack.push(int x)</code>的调用中<code>0 &lt;= x &lt;= 10^9</code>。</p>
</li>
<li><p>如果栈的元素数目为<code>0</code>，则保证不会调用<code>FreqStack.pop()</code>。</p>
</li>
</ul>
<p>  <strong>示例</strong>：</p>
  <img src="8c5d16af06b2bbf15ac75dad30898e99c0b19b83d433b303a4f0fb8ac885387b.jpg" alt="img" style="zoom:50%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">比如执行六次 push 操作后，栈自底向上为 [5,7,5,7,4,5]</span><br><span class="line">然后:</span><br><span class="line">pop() -&gt; 返回 5，因为 5 是出现频率最高的</span><br><span class="line">栈变成 [5,7,5,7,4]</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶</span><br><span class="line">栈变成 [5,7,5,4]</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 5</span><br><span class="line">栈变成 [5,7,4]</span><br><span class="line"></span><br><span class="line">pop() -&gt; 返回 4</span><br><span class="line">栈变成 [5,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> _maxFreq;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; _valToFreq;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>, <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&gt; _freqToVals;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FreqStack() : _maxFreq(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        _valToFreq[val]++;</span><br><span class="line">        <span class="keyword">int</span> freq = _valToFreq[val];</span><br><span class="line">        <span class="keyword">if</span>(_maxFreq &lt; freq) &#123;</span><br><span class="line">            _maxFreq = freq;</span><br><span class="line">        &#125;</span><br><span class="line">        _freqToVals[freq].push(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = _freqToVals[_maxFreq].top();</span><br><span class="line">        _freqToVals[_maxFreq].pop();</span><br><span class="line">        _valToFreq[res]--;</span><br><span class="line">        <span class="keyword">if</span>(_valToFreq[res] == <span class="number">0</span>) &#123;</span><br><span class="line">            _valToFreq.erase(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(_freqToVals[_maxFreq].empty()) &#123;</span><br><span class="line">            _freqToVals.erase(_maxFreq);</span><br><span class="line">            _maxFreq--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. Implement Queue using Stacks</a></h5><blockquote>
<p>  请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作：</p>
<p>  实现<code>MyQueue</code>类：</p>
<p>  <code>void push(int x)</code>：将元素x推到队列的末尾；<br>  <code>int pop()</code>：从队列的开头移除并返回元素；<br>  <code>int peek()</code>：返回队列开头的元素；<br>  <code>bool empty()</code>：如果队列为空，返回<code>true</code>；否则，返回<code>false</code>。</p>
  <img src="2.jpg" alt="img" style="zoom: 33%;" />
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如上图, 将两个栈这样放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _front;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _back;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入栈的时候直接放进右边的栈即可</span></span><br><span class="line">        _back.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 出栈的时候从左边出</span></span><br><span class="line">        <span class="comment">// 如果为空, 需要把右边栈的元素搬过来</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) &#123;</span><br><span class="line">            moveData();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬过来之后直接 pop 左边的栈即可</span></span><br><span class="line">        <span class="keyword">int</span> res = _front.top();</span><br><span class="line">        _front.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取的时候和 pop 的情况一样</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) &#123;</span><br><span class="line">            moveData();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只是不出栈, 只取元素</span></span><br><span class="line">        <span class="keyword">return</span> _front.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _front.empty() &amp;&amp; _back.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搬移数据就是简单的将右边栈出栈</span></span><br><span class="line">        <span class="comment">// 左边栈接收元素压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(!_back.empty()) &#123;</span><br><span class="line">            _front.push(move(_back.top()));</span><br><span class="line">            _back.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. Implement Stack using Queues</a></h5><blockquote>
<p>  请你仅使用两个队列实现一个后入先出的栈，并支持普通队列的全部四种操作。</p>
<p>  实现<code>MyStack</code>类：</p>
<p>  <code>void push(int x)</code>：将元素<code>x</code>压入栈顶；<br>  <code>int pop()</code>：移除并返回栈顶元素；<br>  <code>int top()</code>：返回栈顶元素；<br>  <code>bool empty()</code>：如果栈是空的，返回<code>true</code>；否则，返回<code>false</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个复杂点，push 复杂度为 O(1)，pop 复杂度为 O(n)</span></span><br><span class="line"><span class="comment">// 入栈操作很简单, 调用队列的 push 即可</span></span><br><span class="line"><span class="comment">// 出栈麻烦点, 因为队列只能从队头出列, 队头相当于栈的栈底</span></span><br><span class="line"><span class="comment">// 但我们是想 pop 掉队尾元素</span></span><br><span class="line"><span class="comment">// 这时很暴力, 直接把队列中除了队尾之外的所有元素依次出队并依次入队即可</span></span><br><span class="line"><span class="comment">// 这时对头就是原队尾元素了, 再出队就行</span></span><br><span class="line"><span class="comment">// 获取栈顶元素的话, 为了实现 O(1) 复杂度</span></span><br><span class="line"><span class="comment">// 使用一个变量实时记录队尾 (栈顶) 元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line">    <span class="keyword">int</span> _top;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入队的时候要更新栈顶变量</span></span><br><span class="line">        _top = x;</span><br><span class="line">        _queue.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _queue.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            _top = _queue.front();</span><br><span class="line">            _queue.pop();</span><br><span class="line">            _queue.push(_top);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = _queue.front();</span><br><span class="line">        _queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个更简单，只是 push 复杂度为 O(n)，pop 复杂度为 O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _queue.size();</span><br><span class="line">        _queue.push(x);</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _queue.push(_queue.front());</span><br><span class="line">            _queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = _queue.front();</span><br><span class="line">        _queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _queue.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="432-All-O-one-Data-Structure-https-leetcode-com-problems-all-oone-data-structure"><a href="#432-All-O-one-Data-Structure-https-leetcode-com-problems-all-oone-data-structure" class="headerlink" title="[432. All O`one Data Structure](https://leetcode.com/problems/all-oone-data-structure/)"></a>[432. All O`one Data Structure](<a href="https://leetcode.com/problems/all-oone-data-structure/" target="_blank" rel="noopener">https://leetcode.com/problems/all-oone-data-structure/</a>)</h5><blockquote>
<p>  请你实现一个数据结构支持以下操作：</p>
<ul>
<li><code>Inc(key)</code> 插入一个新的值为<code>1</code>的<code>key</code>。或者使一个存在的<code>key</code>增加<code>1</code>，保证<code>key</code>不为空字符串。</li>
<li><code>Dec(key)</code> 如果这个<code>key</code>的值是<code>1</code>，那么把他从数据结构中移除掉。否则使一个存在的<code>key</code>值减<code>1</code>。如果这个<code>key</code>不存在，这个函数不做任何事情。<code>key</code>保证不为空字符串。</li>
<li><code>GetMaxKey()</code> 返回<code>key</code>中值最大的任意一个。如果没有元素存在，返回一个空字符串<code>&quot;&quot;</code>。</li>
<li><code>GetMinKey()</code> 返回<code>key</code>中值最小的任意一个。如果没有元素存在，返回一个空字符串<code>&quot;&quot;</code>。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashmap + 双向 list</span></span><br><span class="line"><span class="comment">// 值相同的 key 共用一个 node, keys 用 hashset 存储</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllOne</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span> key_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> value_type;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;key_type, <span class="built_in">list</span>&lt;pair&lt;value_type, <span class="built_in">unordered_set</span>&lt;key_type&gt;&gt;&gt;::iterator&gt; _keyToNode;</span><br><span class="line">    <span class="comment">// 根据 value 的大小从首到尾递增</span></span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;value_type, <span class="built_in">unordered_set</span>&lt;key_type&gt;&gt;&gt; _nodes;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AllOne() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_keyToNode.count(key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = _keyToNode[key];</span><br><span class="line">            <span class="keyword">auto</span> next_it = next(it);</span><br><span class="line">            <span class="keyword">if</span>(next_it == _nodes.end() || next_it-&gt;first != (it-&gt;first + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                _keyToNode[key] = _nodes.insert(next_it, &#123;it-&gt;first + <span class="number">1</span>, &#123;key&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                next_it-&gt;second.insert(key);</span><br><span class="line">                _keyToNode[key] = next_it;</span><br><span class="line">            &#125;</span><br><span class="line">            it-&gt;second.erase(key);</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second.empty())</span><br><span class="line">                _nodes.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(_nodes.empty() || _nodes.begin()-&gt;first != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _keyToNode[key] = _nodes.insert(_nodes.begin(), &#123;<span class="number">1</span>, &#123;key&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _nodes.begin()-&gt;second.insert(key);</span><br><span class="line">                _keyToNode[key] = _nodes.begin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="built_in">string</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_keyToNode.count(key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = _keyToNode[key];</span><br><span class="line">            <span class="keyword">auto</span> prev_it = prev(it);</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;first &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(it == _nodes.begin() || prev_it-&gt;first != (it-&gt;first - <span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    _keyToNode[key] = _nodes.insert(it, &#123;it-&gt;first - <span class="number">1</span>, &#123;key&#125;&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    prev_it-&gt;second.insert(key);</span><br><span class="line">                    _keyToNode[key] = prev_it;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _keyToNode.erase(key);</span><br><span class="line">            &#125;</span><br><span class="line">            it-&gt;second.erase(key);</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second.empty())</span><br><span class="line">                _nodes.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getMaxKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _nodes.empty() ? <span class="string">""</span> : *(_nodes.rbegin()-&gt;second.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getMinKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _nodes.empty() ? <span class="string">""</span> : *(_nodes.begin()-&gt;second.begin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a><a href="https://leetcode.com/problems/design-linked-list/" target="_blank" rel="noopener">707. Design Linked List</a></h5><blockquote>
<p>  设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<code>val</code>和<code>next</code>。<code>val</code>是当前节点的值，<code>next</code>是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性<code>prev</code>以指示链表中的上一个节点。假设链表中的所有节点都是<code>0 - index</code>的。</p>
<p>  在链表类中实现这些功能：</p>
<ul>
<li><code>get(index)</code>：获取链表中第<code>index</code>个节点的值。如果索引无效，则返回<code>-1</code>。</li>
<li><code>addAtHead(val)</code>：在链表的第一个元素之前添加一个值为<code>val</code>的节点。插入后，新节点将成为链表的第一个节点。</li>
<li><code>addAtTail(val)</code>：将值为<code>val</code>的节点追加到链表的最后一个元素。</li>
<li><code>addAtIndex(index,val)</code>：在链表中的第<code>index</code>个节点之前添加值为<code>val</code>的节点。如果<code>index</code>等于链表的长度，则该节点将附加到链表的末尾。如果<code>index</code>大于链表长度，则不会插入节点。如果<code>index</code>小于<code>0</code>，则在头部插入节点。</li>
<li><code>deleteAtIndex(index)</code>：如果索引<code>index</code>有效，则删除链表中的第<code>index</code>个节点。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* head_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> val_, ListNode* next_ = <span class="literal">nullptr</span>) : val(val_), next(next_) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    MyLinkedList() : head_(<span class="literal">nullptr</span>), size_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size_)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head_;</span><br><span class="line">        <span class="keyword">while</span>(index--) p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        head_ = <span class="keyword">new</span> ListNode(val, head_);</span><br><span class="line">        size_++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size_ == <span class="number">0</span>) addAtHead(val);</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head_;</span><br><span class="line">        <span class="keyword">int</span> size = size_;</span><br><span class="line">        <span class="keyword">while</span>(--size) p = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        size_++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size_)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index == size_)</span><br><span class="line">        &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = head_;</span><br><span class="line">        ListNode* q = p;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q-&gt;next = <span class="keyword">new</span> ListNode(val, p);</span><br><span class="line">        size_++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size_)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head_ = head_-&gt;next;</span><br><span class="line">            size_--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head_;</span><br><span class="line">        ListNode* q = p;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        size_--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="380-Insert-Delete-GetRandom-O-1-和381-Insert-Delete-GetRandom-O-1-Duplicates-allowed"><a href="#380-Insert-Delete-GetRandom-O-1-和381-Insert-Delete-GetRandom-O-1-Duplicates-allowed" class="headerlink" title="380. Insert Delete GetRandom O(1)和381. Insert Delete GetRandom O(1) - Duplicates allowed"></a><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">380. Insert Delete GetRandom O(1)</a>和<a href="https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">381. Insert Delete GetRandom O(1) - Duplicates allowed</a></h5><blockquote>
<p><img src="title.jpg" alt="title"></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是集合中元素唯一的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了使得能够以 O(1) 的复杂度随机访问元素, 用于存储数据的结构必须为 vector</span></span><br><span class="line"><span class="comment">// 为了使得删除元素的复杂度为 O(1), 可以通过将被删除元素与末尾元素互换, 再 pop_back()</span></span><br><span class="line"><span class="comment">// 但这必须能够知道每个元素对应的索引</span></span><br><span class="line"><span class="comment">// 所以, 使用一个哈希表来记录 (元素) 和其 (索引)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedSet() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        mapping[val] = nums.size();</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = mapping[val];</span><br><span class="line">        <span class="comment">// 先更新映射, 再操作数据</span></span><br><span class="line">        <span class="comment">// 接下来两条语句的顺序不可颠倒</span></span><br><span class="line">        <span class="comment">// 防止待删除的值就位于尾元素, 即 val == nums.back()</span></span><br><span class="line">        mapping[nums.back()] = i;</span><br><span class="line">        mapping.erase(val);</span><br><span class="line">        </span><br><span class="line">        swap(nums[i], nums.back());</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % nums.size();</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是集合中元素允许重复的情况</span></span><br><span class="line"><span class="comment">// 由于要记录所有重复元素的索引, 就就不能采用 1 对 1 映射了</span></span><br><span class="line"><span class="comment">// 需要采用 1 对 多 映射, 所以使用一个 unordered_map&lt;int, unordered_set&lt;int&gt;&gt;</span></span><br><span class="line"><span class="comment">// 为什么映射到的是一个 unordered_set&lt;int&gt; 而不是 vector&lt;int&gt; 呢?</span></span><br><span class="line"><span class="comment">// 原因是, 交换后, 需要 O(1) 删除末尾元素所对应的索引, 而这个索引值不一定存储在最后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; mapping;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedCollection() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) &gt; <span class="number">0</span>) res = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        mapping[val].insert(nums.size());</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = *(mapping[val].begin()); <span class="comment">// 这个 i 相当于随机选的其中一个</span></span><br><span class="line">        <span class="keyword">if</span>(val == nums.back())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果要删除的值正好位于末元素的话</span></span><br><span class="line">            <span class="comment">// 直接在索引集合中删掉索引即可</span></span><br><span class="line">            <span class="comment">// 这是防止执行 else 中的 mapping[nums.back()].insert(i); 语句</span></span><br><span class="line">            <span class="comment">// 插入另一个和尾元素值相等的位于其他位置的索引</span></span><br><span class="line">            mapping[nums.back()].erase(nums.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 比如说数组中元素为 [2, 2, 2], 索引 set 中为 [0, 1, 2]</span></span><br><span class="line">            <span class="comment">// 现在删除 val == 2, 此时 i 为 0, nums.back() == val, 执行下面三条语句</span></span><br><span class="line">            <span class="comment">// 语句 1 --&gt; set 变为 [0, 1]</span></span><br><span class="line">            <span class="comment">// 语句 2 --&gt; set 变为 [0, 0, 1] --&gt; [0, 1]</span></span><br><span class="line">            <span class="comment">// 语句 3 --&gt; set 变为 [1]</span></span><br><span class="line">            <span class="comment">// 但显然预期的结果为 [0, 1]</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则, 需要删除末元素原本对应的索引, 插入新索引</span></span><br><span class="line">        	mapping[nums.back()].erase(nums.size() - <span class="number">1</span>);</span><br><span class="line">        	mapping[nums.back()].insert(i);</span><br><span class="line">            <span class="comment">// 删掉待删除元素的索引之一</span></span><br><span class="line">            mapping[val].erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果待删除元素只有一个, 还要删除整个映射项</span></span><br><span class="line">        <span class="keyword">if</span>(mapping[val].empty()) mapping.erase(val);</span><br><span class="line">        </span><br><span class="line">        swap(nums[i], nums.back());</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % nums.size();</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1114-按序打印"><a href="#1114-按序打印" class="headerlink" title="1114. 按序打印"></a><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">1114. 按序打印</a></h5><blockquote>
<p>  三个不同的线程<code>A</code>、<code>B</code>、<code>C</code>将会共用一个<code>Foo</code>实例。</p>
<ul>
<li><p>一个将会调用<code>first()</code>方法</p>
</li>
<li><p>一个将会调用<code>second()</code>方法</p>
</li>
<li><p>还有一个将会调用<code>third()</code>方法</p>
<p>请设计修改程序，以确保<code>second()</code>方法在<code>first()</code>方法之后被执行，<code>third()</code>方法在<code>second()</code>方法之后被执行。</p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">    mutex _mutex;</span><br><span class="line">    condition_variable _cond2b;</span><br><span class="line">    condition_variable _cond2c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() : counter(<span class="number">1</span>), _mutex(), _cond2b(), _cond2c() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        counter = <span class="number">2</span>;</span><br><span class="line">        _cond2b.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        _cond2b.wait(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;counter == <span class="number">2</span>; &#125;);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        counter = <span class="number">3</span>;</span><br><span class="line">        _cond2c.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        _cond2c.wait(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;counter == <span class="number">3</span>; &#125;);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"third"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">thread <span class="title">A</span><span class="params">(bind(Foo::first, &amp;foo))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">B</span><span class="params">(bind(Foo::second, &amp;foo))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">C</span><span class="params">(bind(Foo::third, &amp;foo))</span></span>;</span><br><span class="line">    A.join();</span><br><span class="line">    B.join();</span><br><span class="line">    C.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1115-交替打印FooBar"><a href="#1115-交替打印FooBar" class="headerlink" title="1115. 交替打印FooBar"></a><a href="https://leetcode-cn.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">1115. 交替打印FooBar</a></h5><blockquote>
<p>  两个不同的线程将会共用一个<code>FooBar</code>实例。其中一个线程将会调用<code>foo()</code>方法，另一个线程将会调用<code>bar()</code>方法。</p>
<p>  请设计修改程序，以确保<code>&quot;foobar&quot;</code>被输出<code>n</code>次。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用互斥锁 + 两个条件变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">bool</span> counter;</span><br><span class="line">    mutex _mutex;</span><br><span class="line">    condition_variable _cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooBar(<span class="keyword">int</span> n) : counter(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            _cond.wait(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;counter; &#125;);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"foo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            counter = <span class="literal">false</span>;</span><br><span class="line">            _cond.notify_one();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            _cond.wait(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;counter; &#125;);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"bar"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            counter = <span class="literal">true</span>;</span><br><span class="line">            _cond.notify_one();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">FooBar <span class="title">foobar</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">foo</span><span class="params">(bind(FooBar::foo, &amp;foobar))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">bar</span><span class="params">(bind(FooBar::bar, &amp;foobar))</span></span>;</span><br><span class="line">    foo.join();</span><br><span class="line">    bar.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1116-打印零与奇偶数"><a href="#1116-打印零与奇偶数" class="headerlink" title="1116. 打印零与奇偶数"></a><a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">1116. 打印零与奇偶数</a></h5><blockquote>
<p>  相同的一个<code>ZeroEvenOdd</code>类实例将会传递给三个不同的线程：</p>
<ul>
<li><p>线程<code>A</code>将调用<code>zero()</code>，它只输出<code>0</code>。</p>
</li>
<li><p>线程<code>B</code>将调用<code>even()</code>，它只输出偶数。</p>
</li>
<li><p>线程<code>C</code>将调用<code>odd(</code>)，它只输出奇数。</p>
<p>每个线程都有一个<code>printNumber</code>方法来输出一个整数。请修改给出的代码以输出整数序列 <code>010203040506...</code>，其中序列的长度必须为<code>2n</code>。</p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    mutex lockZero;</span><br><span class="line">    mutex lockOdd;</span><br><span class="line">    mutex lockEven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZeroEvenOdd(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        lockOdd.lock();</span><br><span class="line">        lockEven.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lockZero.lock();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                lockOdd.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lockEven.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">even</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            lockEven.lock();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            lockZero.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">odd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            lockOdd.lock();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            lockZero.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ZeroEvenOdd <span class="title">zero</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(bind(ZeroEvenOdd::zero, &amp;zero))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(bind(ZeroEvenOdd::even, &amp;zero))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(bind(ZeroEvenOdd::odd, &amp;zero))</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1188-设计有限阻塞队列"><a href="#1188-设计有限阻塞队列" class="headerlink" title="1188. 设计有限阻塞队列"></a><a href="https://leetcode-cn.com/problems/design-bounded-blocking-queue/" target="_blank" rel="noopener">1188. 设计有限阻塞队列</a></h5><blockquote>
<p>  实现一个拥有如下方法的线程安全有限阻塞队列：</p>
<ul>
<li><p><code>BoundedBlockingQueue(int capacity)</code>构造方法初始化队列，其中<code>capacity</code>代表队列长度上限。</p>
</li>
<li><p><code>void enqueue(int element)</code>在队首增加一个<code>element</code>。如果队列满，调用线程被阻塞直到队列非满。</p>
</li>
<li><p><code>int dequeue()</code>返回队尾元素并从队列中将其删除。如果队列为空，调用线程被阻塞直到队列非空。</p>
</li>
<li><p><code>int size()</code>返回当前队列元素个数。</p>
<p>你的实现将会被多线程同时访问进行测试。每一个线程要么是一个只调用<code>enqueue</code>方法的生产者线程，要么是一个只调用<code>dequeue</code>方法的消费者线程。<code>size</code>方法将会在每一个测试用例之后进行调用。</p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁 + 两个条件变量 + 使用 notify_one()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _capacity;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">    mutex _mutex;</span><br><span class="line">    condition_variable _notEmpty;</span><br><span class="line">    condition_variable _notFull;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BoundedBlockingQueue(<span class="keyword">int</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(_data.size() &gt;= _capacity) &#123;</span><br><span class="line">            _notFull.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        _data.push(element);</span><br><span class="line">        _notEmpty.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(_data.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            _notEmpty.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = _data.front();</span><br><span class="line">        _data.pop();</span><br><span class="line">        _notFull.notify_one();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> _data.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁 + 一个条件变量 + 使用 notify_all()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _capacity;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">    mutex _mutex;</span><br><span class="line">    condition_variable _cond;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BoundedBlockingQueue(<span class="keyword">int</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(_data.size() &gt;= _capacity) &#123;</span><br><span class="line">            _cond.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        _data.push(element);</span><br><span class="line">        _cond.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(_data.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            _cond.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = _data.front();</span><br><span class="line">        _data.pop();</span><br><span class="line">        _cond.notify_all();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> _data.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1226-哲学家进餐"><a href="#1226-哲学家进餐" class="headerlink" title="1226. 哲学家进餐"></a><a href="https://leetcode-cn.com/problems/the-dining-philosophers/" target="_blank" rel="noopener">1226. 哲学家进餐</a></h5><blockquote>
<p>  <code>5</code>个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（<code>5</code> 个哲学家，<code>5</code>根叉子）</p>
<p>  所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。</p>
<p>  假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。</p>
<p>  设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。</p>
  <img src="an_illustration_of_the_dining_philosophers_problem.png" alt="an_illustration_of_the_dining_philosophers_problem" style="zoom:50%;" />

<p>  哲学家从<code>0</code>到<code>4</code>按顺时针编号。请实现函数<code>void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)</code>：</p>
<ul>
<li><p><code>philosopher</code>哲学家的编号。</p>
</li>
<li><p><code>pickLeftFork</code>和<code>pickRightFork</code>表示拿起左边或右边的叉子。</p>
</li>
<li><p><code>eat</code>表示吃面。</p>
</li>
<li><p><code>putLeftFork</code>和<code>putRightFork</code>表示放下左边或右边的叉子。</p>
</li>
<li><p>由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。</p>
<p>给你<code>5</code>个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。</p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制哲学家必须同时拿起左右的叉子后才能就餐</span></span><br><span class="line"><span class="comment">// 否则，不允许持有任何一只叉子</span></span><br><span class="line"><span class="comment">// 使用 C++11 的 lock 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">array</span>&lt;mutex, 5&gt; mutexs;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiningPhilosophers() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = philosopher;</span><br><span class="line">        <span class="keyword">int</span> right = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        lock(mutexs[left], mutexs[right]);</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock_left</span><span class="params">(mutexs[left], adopt_lock)</span></span>;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock_right</span><span class="params">(mutexs[right], adopt_lock)</span></span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ID: "</span> &lt;&lt; philosopher &lt;&lt; <span class="string">" eatting"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiningPhilosophers dining;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t5</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">4</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">    t5.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个额外的 互斥锁 充当门禁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">array</span>&lt;mutex, 5&gt; mutexs;</span><br><span class="line">    mutex door;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiningPhilosophers() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wantsToEat</span><span class="params">(<span class="keyword">int</span> philosopher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = philosopher;</span><br><span class="line">        <span class="keyword">int</span> right = (philosopher + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        door.lock();</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock_left</span><span class="params">(mutexs[left])</span></span>;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock_right</span><span class="params">(mutexs[right])</span></span>;</span><br><span class="line">        door.unlock();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ID "</span> &lt;&lt; philosopher &lt;&lt; <span class="string">" is eatting"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiningPhilosophers dining;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t5</span><span class="params">(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), <span class="number">4</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">    t5.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Undetermined</code></p>
<h5 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a><a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">343. Integer Break</a></h5><blockquote>
<p>给定一个整数<code>n</code>，将其分解为<code>k</code>个正整数之和，其中<code>k &gt;= 2</code>，并使这些整数的乘积最大化。返回你可以获得的最大乘积。</p>
<p>说明: 你可以假设<code>n</code>不小于<code>2</code>且不大于<code>58</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 枚举划分出第一段的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 划分出第一段之后，剩下部分有两种选择</span></span><br><span class="line">            <span class="comment">// 不划分的话长度为 j * (i - j)</span></span><br><span class="line">            <span class="comment">// 划分的话长度为 j * dp[i - j]</span></span><br><span class="line">            <span class="comment">// 两者取较大者</span></span><br><span class="line">            dp[i] = max(&#123;dp[i], j * (i - j), j * dp[i - j]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心算法</span></span><br><span class="line"><span class="comment">// 使用均值不等式可以证明当这 k 个整数相等时，乘积最大</span></span><br><span class="line"><span class="comment">// 使用求导求极大值可以得出 k = 3 时乘积最大 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * <span class="built_in">pow</span>(<span class="number">3</span>, a - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">pow</span>(<span class="number">3</span>, a - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="509-Fibonacci-Number"><a href="#509-Fibonacci-Number" class="headerlink" title="509. Fibonacci Number"></a><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. Fibonacci Number</a></h5><blockquote>
<p>  斐波那契数，通常用<code>F(n)</code>表示，形成的序列称为斐波那契数列 。该数列由<code>0</code>和<code>1</code>开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>  <code>F(0) = 0，F(1) = 1</code><br>  <code>F(n) = F(n - 1) + F(n - 2)</code>，其中<code>n &gt; 1</code></p>
<p>  给你<code>n</code>，请计算<code>F(n)</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>; <span class="comment">// 防止溢出</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_0 + dp_1;</span><br><span class="line">        dp_0 = dp_1;</span><br><span class="line">        dp_1 = temp % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归 + 备忘录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> recur = [&amp;](<span class="keyword">auto</span>&amp;&amp; recur, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[n] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[n] = recur(recur, n - <span class="number">1</span>) + recur(recur, n - <span class="number">2</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> recur(recur, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/shenmingxueIT/article/details/117332922?spm=1001.2014.3001.5501" target="_blank" rel="noopener">从小白到大神都会遇到的经典面试题 —— 斐波那契数列_0 error(s)-CSDN博客</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵幂次方</span></span><br></pre></td></tr></table></figure>

<h5 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h5><blockquote>
<p>  实现<code>pow(x, n)</code>，即计算<code>x</code>的<code>n</code>次幂函数（即 x^n^ ）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> myPow(<span class="number">1.0</span> / x, -n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * myPow(x, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myPow(x * x, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1.0</span> / x;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="372-Super-Pow"><a href="#372-Super-Pow" class="headerlink" title="372. Super Pow"></a><a href="https://leetcode.com/problems/super-pow/" target="_blank" rel="noopener">372. Super Pow</a></h5><blockquote>
<p>  你的任务是计算 a^b^ 对<code>1337</code>取模，<code>a</code>是一个正整数，<code>b</code>是一个非常大的正整数且会以数组形式给出。</p>
  <img src="formu1.png" alt="img" style="zoom: 67%;" />

<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= a &lt;= 231 - 1</code></li>
<li><code>1 &lt;= b.length &lt;= 2000</code></li>
<li><code>0 &lt;= b[i] &lt;= 9</code></li>
<li><code>b</code> doesn’t contain leading zeros.</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 2, b &#x3D; [1,0]</span><br><span class="line">Output: 1024</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 1, b &#x3D; [4,3,3,8,5,2]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 2147483647, b &#x3D; [2,0,0]</span><br><span class="line">Output: 1198</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模运算技巧 (a * b) % n = (a % n) * (b % n) % n</span></span><br><span class="line"><span class="comment">// 就是说对乘积的结果求模, 等价于先对每个因子都求模, 再对因子求模的结果的乘积再求模</span></span><br><span class="line"><span class="comment">// 可防止 a * b 过大导致溢出</span></span><br><span class="line"><span class="comment">// 这题主要是学会如何处理指数部分以数组的形式给出</span></span><br><span class="line"><span class="comment">// 处理办法就是找到规律, 利用递归将大问题分解为一个个子问题</span></span><br><span class="line"><span class="comment">// 规律看上面给出的图片</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b.empty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> back = b.back();</span><br><span class="line">    b.pop_back();</span><br><span class="line">    <span class="keyword">return</span> mypow(a, back) * mypow(superPow(a, b), <span class="number">10</span>) % <span class="number">1337</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这题比较特殊, 因子都相同, 就是 a</span></span><br><span class="line">    <span class="comment">// 对每一个因子求模</span></span><br><span class="line">    a %= <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求每个因子求模结果的乘积</span></span><br><span class="line">        res *= a;</span><br><span class="line">        <span class="comment">// 将乘积结果再求模</span></span><br><span class="line">        res %= <span class="number">1337</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求幂运算可通过判断 n 的奇偶性大幅度优化效率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    a %= <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a * mypow(a, n - <span class="number">1</span>) % <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">return</span> mypow(a * a % <span class="number">1337</span>, n / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="779-K-th-Symbol-in-Grammar"><a href="#779-K-th-Symbol-in-Grammar" class="headerlink" title="779. K-th Symbol in Grammar"></a><a href="https://leetcode.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">779. K-th Symbol in Grammar</a></h5><blockquote>
<p>  在第一行我们写上一个<code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p>
<p>  给定行数<code>N</code>和序数<code>K</code>，返回第<code>N</code>行中第<code>K</code>个字符。</p>
<p>  <strong>Note:</strong></p>
<ol>
<li><p><code>N</code> will be an integer in the range <code>[1, 30]</code>.</p>
</li>
<li><p><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">Input: N &#x3D; 1, K &#x3D; 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N &#x3D; 2, K &#x3D; 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N &#x3D; 2, K &#x3D; 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: N &#x3D; 4, K &#x3D; 5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row 1: 0</span><br><span class="line">row 2: 01</span><br><span class="line">row 3: 0110</span><br><span class="line">row 4: 01101001</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(K == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">2</span>, N - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(K &gt; n) <span class="keyword">return</span> <span class="number">1</span> - kthGrammar(N - <span class="number">1</span>, K - n);</span><br><span class="line">    <span class="keyword">return</span> kthGrammar(N - <span class="number">1</span>, K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/LZqUbK3Z1CXKja4I/" rel="prev" title="leetcode刷题系列之字符串">
      <i class="fa fa-chevron-left"></i> leetcode刷题系列之字符串
    </a></div>
      <div class="post-nav-item">
    <a href="/MK80vfKBcuYfGiyp/" rel="next" title="leetcode刷题系列之小知识点">
      leetcode刷题系列之小知识点 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80OTQ0NS8yNTkzNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#622-Design-Circular-Queue"><span class="nav-number">1.</span> <span class="nav-text">622. Design Circular Queue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#146-LRU-Cache"><span class="nav-number">2.</span> <span class="nav-text">146. LRU Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#460-LFU-Cache"><span class="nav-number">3.</span> <span class="nav-text">460. LFU Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree"><span class="nav-number">4.</span> <span class="nav-text">208. Implement Trie (Prefix Tree)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#295-Find-Median-from-Data-Stream"><span class="nav-number">5.</span> <span class="nav-text">295. Find Median from Data Stream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#170-两数之和-III-数据结构设计"><span class="nav-number">6.</span> <span class="nav-text">170. 两数之和 III - 数据结构设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#155-Min-Stack"><span class="nav-number">7.</span> <span class="nav-text">155. Min Stack</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#895-Maximum-Frequency-Stack"><span class="nav-number">8.</span> <span class="nav-text">895. Maximum Frequency Stack</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#232-Implement-Queue-using-Stacks"><span class="nav-number">9.</span> <span class="nav-text">232. Implement Queue using Stacks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#225-Implement-Stack-using-Queues"><span class="nav-number">10.</span> <span class="nav-text">225. Implement Stack using Queues</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#432-All-O-one-Data-Structure-https-leetcode-com-problems-all-oone-data-structure"><span class="nav-number">11.</span> <span class="nav-text">[432. All O&#96;one Data Structure](https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;all-oone-data-structure&#x2F;)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#707-Design-Linked-List"><span class="nav-number">12.</span> <span class="nav-text">707. Design Linked List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#380-Insert-Delete-GetRandom-O-1-和381-Insert-Delete-GetRandom-O-1-Duplicates-allowed"><span class="nav-number">13.</span> <span class="nav-text">380. Insert Delete GetRandom O(1)和381. Insert Delete GetRandom O(1) - Duplicates allowed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1114-按序打印"><span class="nav-number">14.</span> <span class="nav-text">1114. 按序打印</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1115-交替打印FooBar"><span class="nav-number">15.</span> <span class="nav-text">1115. 交替打印FooBar</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1116-打印零与奇偶数"><span class="nav-number">16.</span> <span class="nav-text">1116. 打印零与奇偶数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1188-设计有限阻塞队列"><span class="nav-number">17.</span> <span class="nav-text">1188. 设计有限阻塞队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1226-哲学家进餐"><span class="nav-number">18.</span> <span class="nav-text">1226. 哲学家进餐</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#343-Integer-Break"><span class="nav-number">19.</span> <span class="nav-text">343. Integer Break</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#509-Fibonacci-Number"><span class="nav-number">20.</span> <span class="nav-text">509. Fibonacci Number</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#50-Pow-x-n"><span class="nav-number">21.</span> <span class="nav-text">50. Pow(x, n)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#372-Super-Pow"><span class="nav-number">22.</span> <span class="nav-text">372. Super Pow</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#779-K-th-Symbol-in-Grammar"><span class="nav-number">23.</span> <span class="nav-text">779. K-th Symbol in Grammar</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>