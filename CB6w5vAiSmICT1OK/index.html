<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做内存管理。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统之内存管理">
<meta property="og:url" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做内存管理。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325190827823.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325191522172.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325192023851.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325152953062.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325154011859.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325154456738.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325154511633.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325214215830.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325214238480.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325214616001.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325214950642.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325215417101.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325220947686.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325221118176.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/1356672578_8600.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210326150018056.png">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/20170112101815302.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/20160901214930068.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/20160901214948512.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/20160901215111055.jpg">
<meta property="article:published_time" content="2021-03-12T13:35:42.000Z">
<meta property="article:modified_time" content="2021-03-12T13:35:42.000Z">
<meta property="article:author" content="Liu Y.L.">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/image-20210325190827823.png">

<link rel="canonical" href="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统之内存管理 | LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/CB6w5vAiSmICT1OK/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统之内存管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 21:35:42" itemprop="dateCreated datePublished" datetime="2021-03-12T21:35:42+08:00">2021-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做<strong>内存管理</strong>。</p>
<a id="more"></a>

<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="加载和链接"><a href="#加载和链接" class="headerlink" title="加载和链接"></a>加载和链接</h5><table>
<thead>
<tr>
<th>地址绑定时间</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>程序设计时</td>
<td>程序员直接在程序中确定所有实际的物理地址</td>
</tr>
<tr>
<td>编译或汇编时</td>
<td>程序包含符号地址访问，由编译器在加载程序时把它们转换为实际的绝对地址</td>
</tr>
<tr>
<td>加载时</td>
<td>编译器或汇编器产生相对地址，加载器在加载程序时把它们转换为实际的绝对地址</td>
</tr>
<tr>
<td>运行时</td>
<td>被加载的程序保持相对地址，处理器硬件在执行时把它们动态的转换为绝对地址</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>链接时间</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>程序设计时</td>
<td>不允许外部程序或数据访问。程序员必须把所有引用到的子程序源代码放入程序中</td>
</tr>
<tr>
<td>编译或汇编时</td>
<td>汇编器必须取到每个引用的子程序的源代码，并把它们作为一个部件来进行汇编</td>
</tr>
<tr>
<td>加载模块产生时</td>
<td>所有目标模块都使用相对地址汇编。这些模块被链接在一起，所有访问都相对于最后加载的模块的地点重新声明</td>
</tr>
<tr>
<td>加载时</td>
<td>直到加载模块被加载到内存时才解析外部访问，此时被访问的动态链接模块附加到加载模块后，整个软件包被加载到内存或虚存</td>
</tr>
<tr>
<td>运行时</td>
<td>直到处理器执行外部调用时才解析外部访问，此时该进程被中断，需要的模块被链接到调用程序中</td>
</tr>
</tbody></table>
<h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><p>创建活动进程的第一步是把程序装入内存，并创建一个进程映像。应用程序由许多已编译过或汇编过的模块组成，这些模块以目标代码的形式存在，并被链接起来以解析模块间的任何访问和对库例程的访问。库例程可以合并到程序中，或作为操作系统在运行时提供的共享访问代码。</p>
<p><img src="image-20210325190827823.png" alt="image-20210325190827823"></p>
<p>加载器把加载的模块放置在内存中从<code>x</code>开始的位置。一般而言，可以采用三种方法:</p>
<ul>
<li><p>绝对加载</p>
<p>  绝对加载器要求给定加载模块总被加载到内存中的同一位置。因此，在提供给加载器的加载模块中，所有的地址访问必须是确定的，或者说是绝对的内存地址。给程序中的内存访问指定具体的地址值既可以由程序员完成，也可以在编译时或汇编时完成，</p>
<p>  这种方法存在许多缺点：首先，程序员必须知道在内存中放置模块时预定的分配策略；其次，如果在程序的模块体中进行了任何涉及插入或删除的修改，则所有地址都需要更改。</p>
<p>  因此，更可取的方法是允许用符号表示程序中的内存访问，然后在编译或汇编时解析这些符号引用。对指令或数据项的引用最初被表示成一个符号。在准备输入到一个绝对加载器的模块时，汇编器或编译器将把所有这些引用转换为具体地址。</p>
</li>
<li><p>可重定位加载</p>
<p>  在加载之前就把内存访问绑定到具体的地址的缺点是，会使得加载模块只能放置到内存中的一个区域。但是，当多个程序共享内存时，不可能事先确定哪块区域用于加载哪个特定的模块，最好是在加载时确定。因此，需要一个可分配到内存中任何地方的加载模块。</p>
<p>  为满足这个新需求，汇编器或编译器不产生实际的内存地址（绝对地址），而是使用相对于某些已知点的地址，如相对于程序的起点。加载模块中的所有其他内存访问都用与该模块起点的相对值来表示。</p>
<p>  既然所有内存访问都以相对形式表示，那么加载器就可以很容易地把模块放置在期望的位置。如果该模块要加载到从<code>x</code>位置开始的地方，则当加载器把该模块加载到内存中时，只需简单地给每个内存访问都加上<code>x</code>。为完成这一任务，加载模块必须包含一些需要告诉加载器的信息，如地址访问在哪里、如何解释它们（通常相对于程序的起点）。由编译器或汇编器准备这些信息，通常称这些信息为重定位地址库。</p>
  <img src="image-20210325191522172.png" alt="image-20210325191522172" style="zoom: 67%;" />
</li>
<li><p>动态运行时加载</p>
<p>  动态运行时加载可重定位加载器非常普遍，且相对于绝对加载器具有明显的优点。但是，在多道程序设计环境中，即使不依赖于虚存，可重定位的加载方案仍是不够的。由于需要把进程换入或换出内存来增大处理器的利用率，而为最大程度地利用内存，又希望能在不同的时刻把一个进程映像换回到不同的位置，因此，程序被加载后，可能被换出到磁盘，然后又被换回到内存中不同的位置。如果在开始加载时，内存访问就被绑足到绝对地址，那么前面提到的情况是不可能实现的。</p>
<p>  一种替代方案是在运行时真正在使用某个绝对地址时再计算它。为达到这一目的，加载模块被加载到内存中时，其所有内存访问都以相对形式表示，一条指令只有在真正被执行时才计算其绝对地址。为确保该功能不会降低性能，这些工作必须由特殊的处理器硬件完成，而不用软件实现。</p>
<p>  动态地址计算提供了很大的灵活性。一个程序可以加载到内存中的任何区域，程序的执行可以中断，程序还可换出内存，以后再换回到不同的位置。</p>
</li>
</ul>
<h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><p>链接器的功能是把一组目标模块作为输入，产生一个包含完整程序和数据模块的加载模块，并传递给加载器。在每个目标模块中，可能有到其他模块的地址访问，每个这样的访问可以在未链接的目标模块中用符号表示。链接器会创建一个单独的加载模块，它把所有目标模块逐个链接起来。每个模块内的引用必须从符号地址转换为对整个加载模块中的一个位置的引用。</p>
<img src="image-20210325192023851.png" alt="image-20210325192023851" style="zoom:67%;" />

<p>产生可重定位加载模块的链接器通常称为<strong>链接编辑程序</strong>。地址链接的性质取决于链接发生时要创建的加载模块的类型。通常情况下需要可重定位的加载模块，然后链接按以下方式完成：同时创建每个已编译或汇编的目标模块及相对于该目标模块开始处的引用。所有这些模块，连同相对于该加载模块起点的所有引用，一起放进一个可重定位的加载模块中。该模块可以作为可重定位加载或动态运行时加载的输入。</p>
<p>像加载一样，可以推迟某些链接功能。<strong>动态链接</strong>是指把某些外部模块的链接推迟到创建加载模块之后。因此，加载模块包含到其他程序的未解析的引用，这些引用可以在加载时或运行时解析。</p>
<p>加载时的动态链接分为如下步骤：</p>
<ol>
<li>待加载的加载模块（应用模块）读入内存。</li>
<li>应用模块中到一个外部模块（目标模块）的任何引用都将导致加载程序查找目标模块，加载它，并把这些引用修改为相对于应用程序模块开始处的相对地址。</li>
</ol>
<p>该方法与静态加载相比，有以下优点：</p>
<ul>
<li>能更容易地并入已改变或已升级的目标模块，如操作系统工具，或某些其他的通用例程。而对于静态链接，这类支持模块的变化需要重新链接全部应用程序模块。</li>
<li>在动态链接文件中的目标代码可以很方便的进行共享。因为操作系统加载并链接了该代码，所以可以识别出有多个应用程序使用相同的目标代码。操作系统可以使用此信息，然后只加载目标代码的一个副本，并把这个被加载的目标副本链接到所有使用该目标代码的应用程序，而不是为每个应用程序都分别加载一个副本。</li>
</ul>
<p>使用运行时动态链接时，某些链接工作被推迟到执行时。这样一些对目标模块的外部引用保留在被加载的程序中，当调用的模块不存在时，操作系统定位该模块，加载它，并把它链接到调用模块中。这些模块一般是共享的。在 <code>Windows</code>环境下，这些模块称为动态链接库（<code>DLL</code>）。也就是说，如果一个进程已使用动态链接共享模块，该模块就位于内存中，新的进程就可以简单地链接上已加载好的模块。</p>
<h5 id="内存管理的需求"><a href="#内存管理的需求" class="headerlink" title="内存管理的需求"></a>内存管理的需求</h5><p>操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做<strong>内存管理</strong>。</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>页框</td>
<td>内存中固定长度的块</td>
</tr>
<tr>
<td>页</td>
<td>固定长度的数据块。一般和页框的长度相等，数据页可临时复制到内存的页框中</td>
</tr>
<tr>
<td>段</td>
<td>变长的数据块。整个段可以临时复制到内存中的一个可用区域中，或者将一个段划分为许多页，然后将每页单独复制到内存中（分段和分页相结合）</td>
</tr>
</tbody></table>
<p>内存管理的需求如下：</p>
<ol>
<li><p>重定位</p>
<p> 可用的有限内存空间通常被多个进程共享。程序换出到磁盘后，下次换入内存时并不一定被放回原来的区域。也就是说我们需要把进程重定位到不同的内存区域。同时，我们必须允许程序通过交换技术在内存中移动，所以处理器硬件和操作系统软件必须能够以某种方式将程序代码中写死的内存访问地址转换为实际的物理内存地址。</p>
<p> 首次加载一个进程时，重定位将代码中的相对内存访问被绝对内存地址代替，这个绝对地址由进程被加载到的基地址确定。</p>
<p> 一个进程在其生命周期中可能占据不同的分区。首次创建一个进程映像时，它被装入内存中的某个分区。以后，该进程可能被换出，当它再次被换入时，可能被指定到与上一次不同的分区中。</p>
<p> 进程被换入或在内存中移动时，指令和数据单元的位置会发生改变。为解决这个问题，需要区分几种地址类型。<strong>逻辑地址</strong>是指与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须把它转换为物理地址。<strong>相对地址</strong>是逻辑地址的一个特例，它是相对于某些已知点（通常是程序的开始处）的存储单元。物理地址或绝对地址是数据在内存中的实际位置。</p>
<p> 进程处于运行态时，有一个特殊处理器寄存器（称为基址寄存器），其内容是程序在内存中的起始地址。还有一个界限寄存器指明程序的终止位置。当程序被装入内存或当该进程的映像被换入时，必须设置这两个寄存器。在进程的执行过程中会遇到相对地址，包括指令寄存器的内容、跳转或调用指令中的指令地址，以及加载和存储指令中的数据地址。每个这样的相对地址都经过处理器的两步操作。首先，基址寄存器中的值加上相对地址产生一个绝对地址；然后，将得到的结果与界限寄存器的值进行比较，如果这个地址在界限范围内，则继续该指令的执行；否则，向操作系统发出一个中断信号，操作系统必须以某种方式对这个错误做出响应。</p>
</li>
<li><p>保护</p>
<p> 一个进程的内存空间不能被其它进程未经授权的访问，满足重定位的需求增大了满足保护需求的难度。由于程序在内存中的位置通常会变化，因此，不可能通过在编译时检查绝对地址来保护。必须在运行时检查进程的所有内存访问，以确保它们只访问分配给自己的内存空间。</p>
<p> 注意，内存保护必须由硬件（处理器）而非软件（操作系统）来满足。</p>
</li>
<li><p>共享</p>
<p> 例如，多个进程在执行同一个程序时，允许每个进程访问该程序的同一个副本，以节省内存空间。这意味着操作系统允许进程对共享内存区域的受控访问。</p>
</li>
<li><p>逻辑组织</p>
<p> 计算机系统中的内存总是被组织成线性(或一维）的地址空间，且地址空间由一系列字节或字组成。然而，大多数程序被组织成模块，某些模块是不可修改的（只读、只执行），某些模块包含可以修改的数据。若操作系统和计算机硬件能够有效地处理以某种模块形式组织的用户程序与数据，则会带来很多好处：</p>
<ul>
<li><p>可以独立地编写和编译模块，系统在运行时解析从一个模块到其他模块的所有引用。</p>
</li>
<li><p>通过适度的额外开销，可以为不同的模块提供不同的保护级别。</p>
</li>
<li><p>可以引入某种机制，使得模块可被多个进程共享。</p>
<p>最易于满足这些需求的工具是分段。</p>
</li>
</ul>
</li>
<li><p>物理组织</p>
<p> 计算机存储器至少要组织成两级，即内存和外存。内存提供快速的访问，成本也相对较高。此外，内存是易失性的，即它不能提供永久性存储。外存比内存慢而且便宜，且通常是非易失性的。因此，大容量的外存可用于长期存储程序和数据，而较小的内存则用于保存当前使用的程序和数据。</p>
<p> 在两级存储器间移动信息的任务应由系统负责。这一任务恰好是<strong>存储管理的本质</strong>。</p>
</li>
</ol>
<h5 id="固定分区和动态分区"><a href="#固定分区和动态分区" class="headerlink" title="固定分区和动态分区"></a>固定分区和动态分区</h5><p>内存管理的主要操作是处理器把程序装入内存中执行。虚存基于分页和分段两种技术。</p>
<table>
<thead>
<tr>
<th align="center">内存管理技术</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">固定分区</td>
<td align="left">在系统生成阶段，内存被划分成许多静态分区。进程可装入大于等于自身大小的分区中</td>
</tr>
<tr>
<td align="center">动态分区</td>
<td align="left">分区是动态创建的，因而每个进程可装入与自身大小正好相等的分区中</td>
</tr>
<tr>
<td align="center">简单分页</td>
<td align="left">内存被划分成许多大小相等的页框；每个进程被划分成许多大小与页框相等的页；要装入一个进程,需要把进程包含的所有页都装入内存内不一定连续的某些页框中</td>
</tr>
<tr>
<td align="center">简单分段</td>
<td align="left">每个进程被划分成许多段；要装入一个进程，需要把进程包含的所有段都装入内存内不一定连续的某些动态分区中</td>
</tr>
<tr>
<td align="center">虚存分页</td>
<td align="left">除了不需要装入一个进程的所有页外，与简单分页一样；非驻留页在以后需要时自动调入内存</td>
</tr>
<tr>
<td align="center">虚存分段</td>
<td align="left">除了不需要装入一个进程的所有段外，与简单分段一样；非驻留段在以后需要时自动调入内存</td>
</tr>
</tbody></table>
<p><strong>固定分区</strong></p>
<p>使用大小相等的分区：</p>
<ol>
<li>程序可能太大而不能放到一个分区中，此时必须使用覆盖技术。</li>
<li>内存的利用率很低。会产生大量内部碎片。</li>
</ol>
<p>使用大小不等的分区可缓解这两个问题。</p>
<p>对于大小相等的分区，<strong>放置算法</strong>将进程放入内存的哪个分区都没有关系。</p>
<p>对于大小不等的分区，放置算法将每个进程分配到能够容纳它的最小分区中。每个分区需要维护一个调度队列，用于保存从这个分区换出的进程。</p>
<p><strong>动态分区</strong></p>
<p>对于动态分区，分区长度和数量是可变的。进程装入内存时，系统会给它分配一块与其所需容量完全相等的内存空间。动态分区方法最初不错，但它最终在内存中形成了许多小空洞。随着时间的推移，内存中形成了越来越多的外部碎片，内存的利用率随之下降。</p>
<p><strong>放置算法</strong>把一个进程装入或换入内存时，如果内存中有多个足够大的空闲块，那么操作系统必须确定要为此进程分配哪个空闲块。可供考虑的放置算法有三种：最佳适配、首次适配和下次适配。<strong>首次适配算法</strong>是最简单，最好和最快的。</p>
<p><strong>置换算法</strong>使得操作系统将一个阻塞的进程换出内存，给新进程或处于就绪-挂起态的进程让出空间。因此,操作系统必须选择要替换哪个进程。</p>
<p><strong><em>伙伴系统</em></strong></p>
<img src="image-20210325152953062.png" alt="image-20210325152953062" style="zoom:67%;" />

<h5 id="简单分页"><a href="#简单分页" class="headerlink" title="简单分页"></a>简单分页</h5><p>大小不等的固定分区和大小可变的分区技术在内存的使用上都是低效的，前者会产生内部碎片，后者会产生外部碎片。但是，如果内存被划分成大小固定、相等的块，且块相对比较小，每个进程也被分成同样大小的小块，那么进程中称为页的块可以分配到内存中称为页框的可用块。使用分页技术时，每个进程在内存中浪费的空间，仅是进程最后一页的一小部分形成的内部碎片，没有任何外部碎片。</p>
<p>在某个给定时刻，内存中的某些页框正被使用，某些页框是空闲的，操作系统维护空闲页框的列表。</p>
<p>这时仅有一个简单的基址寄存器是不够的，<strong>操作系统需要为每个进程维护一个页表</strong>。<strong>页表给出了该进程的每页所对应页框的位置。在程序中，每个逻辑地址包括一个页号和在该页中的偏移量</strong>。在简单分区的情况下，逻辑地址是一个字相对于程序开始处的位置，处理器把它转换为一个物理地址。在分页中，逻辑地址到物理地址的转换仍然由处理器硬件完成，且处理器必须知道如何访问当前进程的页表。给出逻辑地址（页号，偏移量）后，处理器使用页表产生物理地址（页框号，偏移量）。</p>
<img src="image-20210325154011859.png" alt="image-20210325154011859" style="zoom:67%;" />

<img src="image-20210325154456738.png" alt="image-20210325154456738" style="zoom:67%;" />

<p>进程的每页在页表中都有一项，因此页表很容易按页号对进程的所有页进行索引（从<code>0</code>页开始）。每个页表项包含内存中用于保存相应页的页框的页框号。此外，操作系统为当前内存中未被占用、可供使用的所有页框维护一个空闲页框列表。</p>
<p>总之，采用简单的分页技术，内存可分成许多大小相等且很小的页框，每个进程可划分成同样大小的页；较小的进程需要较少的页，较大的进程需要较多的页；装入一个进程时，其所有页都装入可用页框中，并建立一个页表。</p>
<h5 id="简单分段"><a href="#简单分段" class="headerlink" title="简单分段"></a>简单分段</h5><p>把程序和与其相关的数据划分到几个段中。并不要求所有程序的所有段的长度都相等。和分页一样，采用分段技术时的逻辑地址也由两部分组成：段号和偏移量。</p>
<p>一般情况下，程序员或编译器会把程序和数据指定到不同的段。为了实现模块化程序设计的目的，程序或数据可能会进一步分成多个段。</p>
<p>采用大小不等的段的另一个结果是，逻辑地址和物理地址间不再是简单的对应关系。类似于分页，在简单的分段方案中，每个进程都有一个段表，系统也会维护一个内存中的空闲块列表。每个段表项必须给出相应段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效地址。当进程进入运行状态时，系统会把其段表的地址装载到一个寄存器中，由内存管理硬件来使用这个寄存器。</p>
<img src="image-20210325154511633.png" alt="image-20210325154511633" style="zoom:67%;" />

<p>总之，采用简单的分段技术，进程可划分为许多段，段的大小无须相等；调入一个进程时，其所有段都装入内存的可用区域，并建立一个段表。</p>
<h5 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h5><table>
<thead>
<tr>
<th>术语</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟内存</td>
<td>被定义成一个连续完整的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换</td>
</tr>
<tr>
<td>虚拟地址</td>
<td>在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主内的一部分那样</td>
</tr>
<tr>
<td>虚拟地址空间</td>
<td>分配给进程的虚拟存储</td>
</tr>
<tr>
<td>地址空间</td>
<td>用于某进程的内存地址范围</td>
</tr>
<tr>
<td>实地址</td>
<td>内存中存储位置的地址</td>
</tr>
</tbody></table>
<p>分页和分段的两个特点：</p>
<ol>
<li>进程中的所有内存访问都是逻辑地址，这些逻辑地址会在运行时动态的转换为物理地址。这意味着一个进程可被换入和换出内存，进程可在执行过程中占据不同时刻内存中的不同区域。</li>
<li>一个进程可被划分为许多块（页和段），在执行过程中，这些快不需要连续的位于内存中。</li>
</ol>
<p>假设需要把一个新进程放入内存，此时操作系统仅读取包含程序开始处的一个或几个块。进程执行的任何时候都在内存的部分称为<strong>进程的常驻集</strong>。进程执行时，只要所有内存访问都是访问常驻集中的单元，执行就可以顺利进行；使用段表或页表，处理器总可以确定是否如此。</p>
<p>处理器需要访问一个不在内存中的逻辑地址时，会产生一个中断，这表明出现了内存访问故障（缺页故障）。操作系统会把被中断的进程置于阻塞态。要继续执行这个进程，操作系统必须把包含引发访问故障的逻辑地址的进程块（所在的页）读入内存。为此，操作系统产生一个磁盘<code>IO</code>读请求。产生<code>I/O</code>请求后，在执行磁盘<code>IO</code>期间，操作系统可以调度另一个进程运行。需要的块读入内存后，产生一个<code>I/O</code>中断，控制权交回给操作系统，而操作系统则把由于缺少该块而被阻塞的进程置为就绪态。</p>
<ol>
<li><p>在内存中保留多个进程。</p>
<p> 由于对任何特定的进程都仅装入它的某些块，因此有足够的空间来放置更多的进程。这样，在任何时刻这些进程中至少有一个处于就绪态，于是处理器得到了更有效的利用。</p>
</li>
<li><p>进程可以比内存的全部空间还大。</p>
<p> 操作系统在需要时会自动地把进程块装入内存。</p>
</li>
</ol>
<p>由于进程只能在内存中执行，因此这个存储器称为实存储器，简称实存。但程序员或用户感觉到的是一个更大的内存，且通常分配在磁盘上，这称为虚拟内存，简称虚存。虚存支持更有效的系统并发度，并能解除用户与内存之间没有必要的紧密约束。</p>
<p>考虑一个由很长的程序和多个数据数组组成的大进程。在任何一段很短的时间内，执行可能会局限在很小的一段程序中（如一个子程序），且可能仅会访问一个或两个数据数组。因此，若在程序被挂起或被换出前仅使用了一部分进程块，则为该进程给内存装入太多的块显然会带来巨大的浪费。仅装入这一小部分块可更好地使用内存。然后，若程序转移到或访问到不在内存中的某个块中的指令或数据，就会引发一个错误，告诉操作系统读取需要的块。</p>
<p>当操作系统读取一块时，它必须把另一块换出。如果一块正好在将要用到之前换出，操作系统就不得不很快地把它取回。这类操作通常被称为<strong>系统抖动</strong>。</p>
<p><strong>局部性原理</strong>表明虚拟内存方案是可行的。要使虚存比较实用并且有效，需要两方面的因素：</p>
<ul>
<li>首先，必须有对所采用分页或分段方案的硬件支持；</li>
<li>其次，操作系统必须有管理页或段在内存和辅助存储器之间移动的软件。</li>
</ul>
<h5 id="虚拟分页"><a href="#虚拟分页" class="headerlink" title="虚拟分页"></a>虚拟分页</h5><p>每个进程都有自己的页表，当它的所有页都装入内存时，将创建页表并装入内存。<strong>页表项（<code>Page Table Entry</code>，<code>PTE</code>）包含有与内存中的页框相对应的页框号</strong>。由于一个进程可能只有一些页在内存中，因而每个页表项需要有一位<code>P</code>来表示它所对应的页当前是否在内存中。若这一位表示该页在内存中，则这个页表项还包括该页的页框号。</p>
<p>页表项中所需要的另一个控制位是修改位<code>M</code>，它表示相应页的内容从上次装入内存到现在是否已改变。若未改变，则在需要把该页换出时，无须用页框中的内容更新该页。页表项还须提供其他一些控制位，例如，保护位和共享位。</p>
<img src="image-20210325214215830.png" alt="image-20210325214215830" style="zoom:67%;" />

<h6 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h6><p>从内存中读取一个字的基本机制包括使用页表从虚拟地址到物理地址的转换。虚拟地址又称为逻辑地址，它由页号和偏移量组成，而物理地址由页框号和偏移量组成。由于页表的长度可基于进程的长度而变化，因而不能期望在寄存器中保存它，它须在内存中且可以访问。当某个特定的进程正运行时，一个寄存器保存该进程页表的起始地址。虚拟地址的页号用于检索页表、查找相应的页框号，并与虚拟地址的偏移量结合起来形成需要的实地址。一般来说，页号域长于页框号域（<code>n &gt; m</code>）。</p>
<img src="image-20210325214238480.png" alt="image-20210325214238480" style="zoom:67%;" />

<p>每个进程可以占据大量的虚存空间，因而一个进程会有大量的页表项，这会导致保存页表的内存空间太大。大多数虚拟内存方案都在虚存而非实存中保存页表。这意味着页表和其他页一样都服从分页管理。一个进程正在运行时，它的页表至少有一部分须在内存中，这一部分包括正在运行的页的页表项。一些处理器使用<strong>两级方案</strong>来组织大型页表。在这类方案中有一个页目录，其中的每项指向一个页表。</p>
<img src="image-20210325214616001.png" alt="image-20210325214616001" style="zoom: 80%;" />

<p>假设采用字节级的寻址，页尺寸为<code>4KB</code>(2^12^)，则<code>4GB</code>(2^32^)虚拟地址空间由2^20^页组成。若这些页中的每页都由一个<code>4</code>字节的页表项映射，则可创建由2^20^个页表项组成的一个页表，这时需要<code>4MB</code>(2^22^)的内存空间。这个由2^10^页组成的巨大用户页表可以保留在虚存中，并由一个包括2^10^个页表项的根页表映射，根页表占据的内存为<code>4KB</code>(2^12^)。</p>
<img src="image-20210325214950642.png" alt="image-20210325214950642" style="zoom:67%;" />

<h6 id="转换检测缓冲区TLB"><a href="#转换检测缓冲区TLB" class="headerlink" title="转换检测缓冲区TLB"></a>转换检测缓冲区<code>TLB</code></h6><p>原则上，每次虚存访问都可能会引起两次物理内存访问：一次取相应的页表项，另一次取需要的数据（进程页）。因此，虚拟内存方案都为页表项使用了一个特殊的高速缓存，通常称为转换检测缓冲区（<code>Translation Lookaside Buffer</code>，<code>TLB</code>）。<code>TLB</code>中包含有最近用过的<strong>页号和完整的页表项</strong>。给定一个虚拟地址，处理器首先检查<code>TLB</code>，若需要的页表项在其中（<code>TLB</code>命中），则检索页框号并形成实地址。若未找到需要的页表项（<code>TLB</code>未命中）,则处理器用页号检索进程页表，并检查相应的页表项。若“存在位”已置位，则该页在内存中，处理器从页表项中检索页框号以形成实地址。处理器同时更新<code>TLB</code>，使其包含这个新页表项。最后，若“存在位”未置位，则表示需要的页不在内存中，这时会产生一次内存访问故障，称为缺页（<code>page fault</code>）故障。此时离开硬件作用范围，调用操作系统，由操作系统负责装入所需要的页，并更新页表。</p>
<img src="image-20210325215417101.png" alt="image-20210325215417101" style="zoom:67%;" />

<p>页尺寸对缺页中断发生概率的影响使得这些问题变得更为复杂。一般而言，基于局部性原理，如果页尺寸非常小，那么每个进程在内存中就有较多数量的页。一段时间后，内存中的页都包含有最近访问的部分，因此缺页率较低。当页尺寸增加时，每页包含的单元和任何一个最近访问过的单元越来越远。因此局部性原理的影响被削弱，缺页率开始增长。</p>
<p>更为复杂的是，缺页率还取决于分配给一个进程的页框的数量。对固定的页尺寸，当内存中的页数量增加时，缺页率会下降。因此，软件策略（分配给每个进程的内存总量）影响着硬件设计决策（页尺寸)。</p>
<h5 id="虚拟分段和段页式"><a href="#虚拟分段和段页式" class="headerlink" title="虚拟分段和段页式"></a>虚拟分段和段页式</h5><p>分段允许程序员把内存视为由多个地址空间或段组成，段的大小不等，并且是动态的。内存访问以段号和偏移量的形式组成地址。其优点：</p>
<ol>
<li>允许程序独立地改变或重新编译，而不要求整个程序集重新链接和重新加载。同样，这也是使用多个段实现的。</li>
<li>有助于进程间的共享。程序员可以在段中放置一个实用工具程序或一个有用的数据表，供其他进程访问。</li>
<li>有助于保护。由于一个段可被构造成包含一个明确定义的程序或数据集，因而程序员或系统管理员可以更方便地指定访问权限。</li>
</ol>
<p>从内存中读一个字的基本机制，涉及使用段表来将段号和偏移量组成的虚拟地址（或逻辑地址）转换为物理地址。根据进程的大小，段表长度可变，无法在寄存器中保存，因此访问段表时它必须在内存中。当某个特定的进程正在运行时，有一个寄存器为该进程保存段表的起始地址。虚拟地址中的段号用于检索这个表，并查找该段起点的相应内存地址。这个地址加上虚拟地址中的偏移量部分，就形成了需要的实地址。</p>
<p><strong>段页式系统</strong></p>
<p>在段页式系统中，用户的地址空间被程序员划分为许多段。每段依次划分为许多固定大小的页，页的长度等于内存中的页框大小。若某段的长度小于一页，则该段只占据一页。从程序员的角度看，逻辑地址仍然由段号和段偏移量组成：从系统的角度看，段偏移量可视为指定段中的一个页号和页偏移量。</p>
<p>每个进程都使用一个段表和一些页表，且每个进程段使用一个页表。某个特定的进程运行时，使用一个寄存器记录该进程段表的起始地址。对每个虚拟地址，处理器使用段号部分来检索进程段表以寻找该段的页表。然后虚拟地址的页号部分用于检索页表并查找相应的页框号。这种方式结合虚拟地址的偏移部分，就形成了需要的实地址。</p>
<img src="image-20210325220947686.png" alt="image-20210325220947686" style="zoom:67%;" />

<p><strong>分段有助于实现保护与共享机制</strong>。实际上，操作系统要求的保护和共享功能通常在段一级处理。由于每个段表项包括一个长度和一个基地址，因而程序不会不经意地访问超出该段的内存单元。为实现共享，一个段可能会在多个进程的段表中引用。</p>
<img src="image-20210325221118176.png" alt="image-20210325221118176" style="zoom:67%;" />

<h5 id="操作系统软件的支持"><a href="#操作系统软件的支持" class="headerlink" title="操作系统软件的支持"></a>操作系统软件的支持</h5><p><strong>这里主要涉及的是操作系统为虚存方案提供的算法</strong>。在段页式虚存系统中，操作系统所面临的内存管理问题大多数都<strong>与分页有关</strong>。</p>
<p>在各种情况下，最重要的都是<strong>与性能相关</strong>的问题：由于缺页中断会带来巨大的软件开销，所以希望使缺页中断发生的频率最小。这类开销至少包括决定置换哪个或哪些驻留页，以及交换这些页所需要的<code>IO</code>操作。此外，在这个页<code>IO</code>操作的过程中，操作系统还须调度另一个进程运行，即导致一次进程切换。因此，希望能通过适当的安排，使得在一个进程正在执行时，访问一个未命中的页中的字的概率最小。</p>
<h6 id="读取策略和清除策略"><a href="#读取策略和清除策略" class="headerlink" title="读取策略和清除策略"></a>读取策略和清除策略</h6><p><strong>读取策略</strong></p>
<p>当一个进程首次启动时，会在一段时间出现大量的缺页故障；取入越来越多的页后，局部性原理表明大多数将来访问的页都是最近读取的页。因此，在一段时间后错误会逐渐减少，缺页率会降到很低。</p>
<p>读取策略决定某页何时取入内存，常用的两种方法是<strong>请求分页</strong>和<strong>预先分页</strong>。</p>
<p>对于请求分页，只有当访问到某页中的一个单元时才将该页取入内存。对于预先分页，读取的页并不是缺页中断请求的页。若一个进程的页连续存储在辅存中，则<strong>一次读取许多连续的页</strong>要比隔一段时间读取一页有效。</p>
<p>进程首先启动时或者发生缺页中断时，都可采用预先分配策略。</p>
<p>某个进程被换出内存并置于挂起态时，它的所有驻留页都会被换出。当该进程被唤醒时，所有以前在内存中的页都会被重新读回内存。</p>
<p><strong>清除策略</strong></p>
<p>与读取策略相反，清除策略用于确定何时将已修改的一页写回辅存。通常有两种选择：<strong>请求式清除和预约式清除</strong>。</p>
<p>对于请求式清除，只有当一页被选择用于置换时才被写回辅存；而预约式清除策略则将这些已修改的多页在需要使用它们所占据的页框之前成批写回辅存。</p>
<p>一种较好的方法是结合下一节介绍的<strong>页缓冲</strong>技术，这种技术允许采用下面的策略：只清除可用于置换的页。通过页缓冲，被置换页可放置在两个链表中：修改链表和未修改链表。修改链表中的页可以周期性地成批写出，并移到未修改链表中。未修改链表中的一页要么因为被访问到而被回收，要么在其页框分配给另一页时被淘汰。</p>
<h6 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h6><p>放置策略决定一个进程块驻留在实存中的什么位置。在段页式系统中，此策略无关紧要，<strong>因为地址转换硬件和内存访问硬件能以相同的效率为任何页框组合执行相应的功能</strong>。</p>
<h6 id="置换策略和页缓冲"><a href="#置换策略和页缓冲" class="headerlink" title="置换策略和页缓冲"></a>置换策略和页缓冲</h6><p>置换策略决定在必须读取一个新页时，应该置换内存中的哪一页。需要明确三个问题：</p>
<ol>
<li>给每个活动进程分配多少页框。</li>
<li>计划被置换的页集局限于那些产生缺页故障的进程，还是局限于所有页框都在内存中的进程。</li>
</ol>
<p>上面两个问题属于<strong>驻留集管理</strong>。置换策略专指第三个问题。</p>
<ol start="3">
<li>在计划被置换的页集，选择换出哪一页。</li>
</ol>
<p><strong>所有置换策略的目标都是移出最近最不可能访问的页</strong>。根据局部性原理，最近的访问历史和最近将要访问的模式间有很大的相关性。因此，大多数策略都基于过去的行为来预测将来的行为。</p>
<p><strong>页框锁定</strong></p>
<p>内存中的某些页框可能是被锁定的。被锁定的页框中的页不能被置换。操作系统内核和重要的控制结构就需要保存在被锁定的页框中。锁定是通过给每个页框关联一个“锁定”位实现的，这一位可以包含在页框表和当前页表中。</p>
<p><strong>基本算法</strong></p>
<ul>
<li><p>最近最少使用（<code>LRU</code>，<code>Least Recently Used</code>）</p>
<p>  该策略选择置换内存中最长时间未被引用的页。根据局部性原理，这也是最近最不可能访问到的页。</p>
<p>  这种方法的问题是比较难以实现。一种实现方法是给每页添加一个最后一次访问的时间戳，并在每次访问内存时更新这个时间戳。另一种方法是维护一个关于访问页的栈，但开销同样很大。</p>
</li>
<li><p>先进先出（<code>FIFO</code>，<code>First In First Out</code>）</p>
<p>  FIFO 策略把分配给进程的页框视为一个循环缓冲区，并按循环方式移动页。它需要的只是一个指针，该指针在进程的页框中循环。</p>
<p>  这种方法所隐含的逻辑是置换驻留在内存中时间最长的页：很久以前取入内存的页，现在可能不会再用到。这一推断通常是错误的，因为经常会出现一部分程序或数据在整个程序的生命周期中使用频率都很高的情况，若使用 FIFO算法，则这些页需要被反复地换入和换出。</p>
</li>
<li><p>时钟（<code>Clock</code>）</p>
</li>
</ul>
<p><strong><em>页缓冲</em></strong>（<code>Page Cache</code>）</p>
<p>页缓冲能够提高分页的性能并允许使用较简单的页面置换策略。</p>
<p>使用页缓冲的置换算法不丢弃置换出的页。若该页未被修改，则将它分配到空闲页链表中；若已被修改，则分配到修改页链表中。<strong>注意，该页在内存中并不会物理性移动，移动的只是该页所对应的页表项，移动后的页表项放置在空闲页链表中或修改页链表中</strong>。</p>
<p>空闲页链表中包含有可被置换页的一系列页框，需要从磁盘中读取一页到内存中时，都将其放到空闲页链表头节点所指向的页框中，随后将头节点移除。注意，系统记录的被置换的页并不是链表头节点所指向的页。</p>
<p><strong>比如说，头节点当前指向内存中的页<code>a</code>，系统通过置换策略决定出要用磁盘中的页<code>b</code>置换内存中的页<code>c</code>。实际执行的操作是，将页<code>b</code>放置在页<code>a</code>中，如果页<code>c</code>未被修改，就将其加入到空闲页链表尾部，如果页<code>c</code>已被修改，就将其加入到修改页链表中</strong>。</p>
<p>这一骚操作的一个重要特点是，被置换的页仍然留在内存中。因此，若进程访问该页，则可迅速返回该进程的驻留集，且代价很小。实际上，空闲页链表和修改页链表充当着页的高速缓存的角色。</p>
<p>修改页链表还有另外―种很有用的功能：已修改的页按簇写回，而不是一次只写一页，因此大大减少了<code>I/O</code>操作的数量，进而减少了磁盘访问时间。</p>
<p><strong><em><code>Page Cache</code>和块缓冲（<code>Buffer Cache</code>）的区别</em></strong></p>
<p>首先要明确一点，<code>cache</code>是位于内存中的，是为了提高磁盘设备的<code>IO</code>性能。程序读磁盘设备中的数据时，首先把需要访问的数据页及其相邻页面统一读到内存（预读取策略），然后从内存中读取数据。程序向磁盘设备中的文件写数据时，先将数据写入内存，然后再将内存中的脏数据页定时统一的刷新到磁盘中。</p>
<p>这个用作磁盘数据缓存的内存就是所谓的<code>Buffer Cache</code>。主要是针对写数据场景的性能优化。也就是说<code>Buffer Cache</code>是作为磁盘数据读写而存在的。</p>
<p>然而，文件系统层为了提高文件读写的性能，也提供了文件系统级别的<code>Page Cache</code>。更多的是针对读数据场景的性能优化。也就是说<code>Page Cache</code>是作为文件读写而存在的。</p>
<p>其实针对的都是磁盘中的数据，有两个缓存显得没有必要了，因此，现有的<code>linux</code>系统版本已经将二者合并了，统称为<code>Page Cache</code>。其是通过<code>radix</code>树（基数树）数据结构实现的。</p>
<h6 id="驻留集管理"><a href="#驻留集管理" class="headerlink" title="驻留集管理"></a>驻留集管理</h6><p>驻留集是指一个进程被读取到内存中的页集。</p>
<ol>
<li>分配给一个进程的内存越少，在任何时候驻留在内存中的进程数就越多。这增加了操作系统至少找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间。</li>
<li>若一个进程在内存中的页数较少，尽管有局部性原理，缺页率仍相对较高。</li>
<li>然而，给进程分配的内存空间大到一定程度时，由于局部性原理，缺页率也不会有明显的降低。</li>
</ol>
<p><strong>固定分配策略</strong>为一个进程分配固定数量的页框，以供执行时使用。这个数量由进程创建时确定。对于这种策略，一旦在进程的执行过程中发生缺页中断，该进程的一页就必须被它所需要的页面置换。</p>
<p><strong>可变分配策略</strong>允许分配给一个进程的页框在该进程的生命周期中不断地发生变化。<strong>其大小可根据当前进程的缺页率大小来实时调整</strong>。理论上，若一个进程的缺页率一直比较高，则表明在该进程中局部性原理表现较弱，应给它多分配一些页框以减小缺页率；而若一个进程的缺页率特别低，则表明从局部性的角度看该进程的表现非常好，可在不明显增大缺页率的前提下减少分配给它的页框。</p>
<p><strong>置换范围</strong></p>
<p><strong>局部置换策略</strong>在产生这次缺页的进程的驻留页中选择，而<strong>全局置换策略</strong>则把内存中所有未被锁定的页都作为置换的候选页，而不管它们属于哪个进程。</p>
<h5 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a><code>Linux</code>内存管理</h5><p><img src="1356672578_8600.jpg" alt="1356672578_8600"></p>
<p><strong>虚存寻址</strong></p>
<p><img src="%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE.jpg" alt="虚拟地址访问"></p>
<p><code>Linux</code>使用三级页表结构（<strong>最新版本已经使用四级页表了</strong>），它由下面几种类型的表组成（每个表的大小都是一页）：</p>
<ul>
<li>顶级页表是页全局目录（<code>PGD</code>），它包含了一个<code>pgd_t</code>类型数组，多数体系结构中<code>pgd_t</code>类型等同于无符号长整型类型。<code>PGD</code>中的表项指向二级页目录中的表项：<code>PMD</code>。每个活动进程的页目录都必须在内存中。</li>
<li>二级页表是中间页目录（<code>PMD</code>），它是个<code>pmd_t</code>类型数组，其中的表项指向<code>PTE</code>中的表项。页中间目录可能跨越多个页。页中间目录中的每项指向页表中的一页。</li>
<li>最后一级的页表简称页表，其中包含了<code>pte_t</code>类型的页表项，该页表项指向物理页面。页表也可跨越多个页。每个页表项指向该进程的一个虚拟页。</li>
</ul>
<img src="image-20210326150018056.png" alt="image-20210326150018056" style="zoom:67%;" />

<p><strong>页面分配</strong></p>
<p>页面分配为提升向内存中读入和从内存中写出页的效率，<code>Linux</code>定义了一种机制，用于把连续的页映射到连续的页框中。基于这一目的，它使用了<strong>伙伴系统</strong>。内核维护一系列大小固定的连续页框组，一组可以包含<code>1、2、4、8、16、32</code>个页框。当一页在内存中被分配或被解除分配时，可用的页框组使用伙伴算法来分裂或合并。</p>
<p><code>Linux</code>引入了一种新的分割<code>LRU</code>算法。</p>
<p>新算法给每个页表项添加了两个有效位：<code>PG_active</code>和<code>PG_referenced</code>。<code>Linux</code>的所有物理内存均基于它们的地址分配到两块“区域”，“激活”和“非激活”两个链表通过内存管理器来进行各区域的页面回收。内核驻留进程<code>kswapd</code>在后台周期性地执行各区域的页面回收，它扫描那些与系统页框对应的页表项。对于所有标记为访问过的页表项，启用<code>PG_referenced</code>有效位。处理器首次访问一个页面时，会启用这个标志位。<code>kswapd</code>每次迭代时，都会检查页表项中的页面访问过标志位是否被启用。<code>kswapd</code>在每次读取页面访问有效位后即将其清除。具体步骤如下：</p>
<ol>
<li>访问非激活链表中的一页时，<code>PG_referenced</code>有效位启用。</li>
<li>页面下次被访问时，<code>PG_active</code>被置位，并将其移动到激活链表。也就是说，页面经访问两次后被声明为激活。更准确地讲，两次不同扫描的访问才使得一个页面变为激活状态。</li>
<li>若第二次访问并未很快发生，则重置<code>PG_referenced</code>。</li>
<li>同样，激活的页面在两次超时之后也需要移动到非激活链表中。</li>
</ol>
<p>非激活链表中的页面然后可通过<code>LRU</code>算法被置换。</p>
<h6 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（<code>page</code>）</h6><p>内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字，但是，内存管理单元（<code>MMU</code>，管理内存并把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理。正因为如此，<code>MMU</code>以页大小为单位来管理系统中的页表。从虚拟内存的角度来看，页就是最小单位。</p>
<p>内核用<code>struct page</code>结构来表示系统中的每一个物理页，该结构位于<code>&lt;linux/mm_types.h&gt;</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">atomic_t</span> _count;</span><br><span class="line">    <span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="keyword">pgoff_t</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">virtual</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flag</code>域用来存放页的状态。这些状态包括页是不是脏的，是不是被锁定在内存中等。这些标志被定义在<code>&lt;linux/page-flags.h&gt;</code>中。</p>
<p><code>count</code>域存放页的引用计数——也就是这一页被引用了多少次。当计数值变为<code>-1</code>时，就说明当前内核并没有引用这一页，于是，在新的分配中就可以使用它。内核代码不应当直接检查该域，而是调用<code>page_count()</code>函数进行检查，该函数唯一的参数就是<code>page</code>结构。当页空闲时，尽管该结构内部的<code>_count</code>值是负的，但是对<code>page_count()</code>函数而言，返回<code>0</code>表示页空闲，返回一个正整数表示页在使用。一个页可以由页缓存使用（这时，<code>mapping</code>域指向和这个页关联的<code>addresss_space</code>对象），或者作为私有数据（由<code>private</code>指向），或者作为进程页表中的映射。</p>
<p><code>virtual</code>域是页的虚拟地址。通常情况下，它就是页在虚拟内存中的地址。</p>
<p>必须要理解的一点是<code>page</code>结构与物理页相关，而并非与虚拟页相关。因此，该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，它们也可能并不再和同一个<code>page</code>结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关的物理页中存放的东西。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。</p>
<p>内核用这一结构来管理系统中所有的页，系统中的每个物理页都要分配一个这样的结构体。因为内核需要知道一个页是否空闲（也就是页有没有被分配）。如果页已经被分配，内核还需要知道谁拥有这个页。拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或页高速缓存（<code>Page Cache</code>）等。</p>
<h6 id="区（zone）"><a href="#区（zone）" class="headerlink" title="区（zone）"></a>区（<code>zone</code>）</h6><p>有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区。内核使用区对具有相似特性的页进行分组。</p>
<p><code>Linux</code>主要使用了三种区:</p>
<ul>
<li><code>ZONE_DMA</code>：这个区包含的页能用来执行<code>DMA</code>操作。</li>
<li><code>ZONE_NORMAL</code>：这个区包含的都是能正常映射的页。</li>
<li><code>ZONE_HIGHEM</code>：这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间。</li>
</ul>
<p>这些区在<code>&lt;linux/mmzone.h&gt;</code>中定义。</p>
<p><strong>区的实际使用和分布是与体系结构相关的</strong>。例如，某些体系结构在内存的任何地址上执行<code>DMA</code>都没有问题。在这些体系结构中，<code>ZONE_DMA</code>为空，<code>ZONE_NORMAL</code>就可以直接用于分配。与此相反，在<code>x86</code>体系结构上，<code>ISA</code>设备就不能在整个<code>32</code>位的地址空间中执行<code>DMA</code>，因为<code>ISA</code>设备只能访问物理内存的前<code>16MB</code>。因此，<code>ZONE_DMA</code>在<code>x86</code>上包含的页都在<code>0-16MB</code>的内存范围里。</p>
<p><code>Linux</code>把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。例如，<code>ZONE_DMA</code>内存池让内核有能力为<code>DMA</code>分配所需的内存。如果需要这样的内存，那么，内核就可以从<code>ZONE_DMA</code>中按照请求的数目取出页。</p>
<p>有些<code>64</code>位的体系结构，如<code>Intel</code>的<code>x86-64</code>体系结构可以映射和处理<code>64</code>位的内存空间，所以<code>x86-64</code>没有<code>ZONE_HIGHMEM</code>区，所有的物理内存都处于<code>ZONE_DMA</code>和<code>ZONE_NORMAL</code>区。</p>
<p>注意，区的划分没有任何物理意义，这只不过是内核为了管理页而采取的一种逻辑上的分组。</p>
<p>每个区都用<code>struct zone</code>表示，在<code>&lt;linux/mmzone.h&gt;</code>中定义。</p>
<p>这个结构体很大，但是，系统中只有三个区，因此，也只有三个这样的结构。</p>
<p><code>lock</code>域是一个自旋锁，它防止该结构被并发访问。注意，这个域只保护结构，而不保护驻留在这个区中的所有页。没有特定的锁来保护单个页。<code>watermark</code>数组持有该区的最小值、最低和最高水位值。内核使用水位为每个内存区设置合适的内存消耗基准。该水位随空闲内存的多少而变化。<code>name</code>域是一个以<code>NULL</code>结束的字符串表示这个区的名字。内核启动期间初始化这个值，其代码位于<code>mm/page_alloc.c</code>中。分别为“<code>DMA</code>“，“<code>Normal</code>”和“<code>HighMem</code>”。</p>
<h6 id="获得与释放页"><a href="#获得与释放页" class="headerlink" title="获得与释放页"></a>获得与释放页</h6><table>
<thead>
<tr>
<th align="left">内核接口</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>struct page* alloc_pages(gfp_t gfp_mask, unsigned int order)</code></td>
<td>该函数分配2^order^ (<code>1 &lt;&lt; order</code>）个连续的物理页，并返回一个指针，该指针指向第一个页的<code>page</code>结构体，如果出错，就返回<code>NULL</code>。</td>
</tr>
<tr>
<td align="left"><code>void free_pages(unsigned long addr, unsigned int order)</code></td>
<td>释放页，释放页时要谨慎，只能释放属于你的页。传递了错误的<code>struct page</code>或地址，用了错误的<code>order</code>值，这些都可能导致系统崩溃。</td>
</tr>
<tr>
<td align="left"><code>void kmalloc(size_t size, gfp_t flags)</code></td>
<td>这个函数返回一个指向以字节为单位内存块的指针。所分配的内存区在物理上是连续的。出错，返回<code>NULL</code>。它确保页在物理地址上是连续的。</td>
</tr>
<tr>
<td align="left"><code>void kfree(const void *ptr)</code></td>
<td>释放由<code>kmalloc()</code>分配出来的内存块。如果释放的内存不是由<code>kmalloc()</code>分配的，或者释放的内存早就被释放了，调用这个函数就会导致严重的后果。调用<code>kfree(NULL)</code>是安全的。</td>
</tr>
<tr>
<td align="left"><code>void* vmalloc(unsigned long size)</code></td>
<td>分配的内存虚拟地址是连续的，而物理地址则无须连续。它通过分配非连续的物理内存块，再“修正”页表，把内存映射到逻辑地址空间的连续区域中。</td>
</tr>
<tr>
<td align="left"><code>void vfree(const void* addr)</code></td>
<td>要释放通过<code>vmalloc()</code>获得的内存。</td>
</tr>
</tbody></table>
<p>大多数情况下，只有硬件设备需要得到物理地址连续的内存。在很多体系结构上，硬件设备存在于内存管理单元以外，它根本不理解什么是虚拟地址。因此，硬件设备用到的任何内存区都必须是物理上连续的块，而不仅仅是虚拟地址连续上的块。而仅供软件使用的内存块（例如与进程相关的缓冲区）就可以使用只有虚拟地址连续的内存块。对内核而言，所有内存看起来都是逻辑上连续的。</p>
<h5 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h5><p>内核除了管理本身的内存外，还必须管理用户空间中进程的内存。我们称这个内存为进程地址空间，也就是系统中每个用户空间进程所看到的内存。<code>Linux</code>系统中的所有进程之间以虚拟方式共享内存。对一个进程而言，它好像都可以访问整个系统的所有物理内存。即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。</p>
<p>进程地址空间由进程可寻址的虚拟内存组成，内核允许进程使用这种虚拟内存中的地址。每个进程都有一个<code>32</code>位或<code>64</code>位的平坦地址空间。术语“平坦”指的是地址空间范围是一个独立的连续区间。一个进程的地址空间与另一个进程的地址空间即使有相同的内存地址，实际上也彼此互不相干。这样的进程也就是<code>Linux</code>中所谓的线程。</p>
<p>内存地址是一个给定的值，它要在地址空间范围之内，比如<code>4021F000</code>。这个值表示的是进程32位地址空间中的一个特定的字节。尽管一个进程可以寻址<code>4GB</code>的虚拟内存（在32位的地址空间中)，但这并不代表它就有权访问所有的虚拟地址。在地址空间中，我们更为关心的是一些虚拟内存的地址区间，比如<code>08048000 - 0804C000</code>，它们可被进程访问。这些可被访问的合法地址空间称为内存区域。<strong>通过内核，进程可以给自己的地址空间动态地添加或减少内存区域</strong>。</p>
<p>进程只能访问有效内存区域内的内存地址。每个内存区域也具有相关权限如对相关进程有可读、可写、可执行属性。<strong>如果一个进程访问了不在有效范围中的内存区域，或以不正确的方式访向了有效地址</strong>，那么内核就会终止该进程，并返回“<strong>段错误</strong>”信息。</p>
<h6 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h6><p><code>Linux</code>内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由<code>mm_struct</code>结构体表示，下面给出内存描述符结构中各个域的描述，请大家结合前面的进程内存段布局图一起看：</p>
<p><img src="20170112101815302.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span> <span class="comment">/* 内存区域组织成链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span> <span class="comment">/* 内存区域组织成红黑树 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">/* 最近使用的内存区域 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_area_cache; <span class="comment">/* 地址空间第一个空洞 */</span></span><br><span class="line">    <span class="keyword">pgd_t</span> *pgd; <span class="comment">/* 页全局目录 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_users; <span class="comment">/* 使用地址空间的用户数 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_count; <span class="comment">/* 主使用计数器 */</span></span><br><span class="line">    <span class="keyword">int</span> map_count; <span class="comment">/* 内存区域的个数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span> <span class="comment">/* 内存区域的信号量 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> page_table_lock; <span class="comment">/* 页表锁 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span> <span class="comment">/* 所有 mm_struct 形成的链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rss; <span class="comment">/* 所分配的物理页 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm; <span class="comment">/* 全部页面数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm; <span class="comment">/* 上锁的页面数据 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pinned_vm; <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shared_vm; <span class="comment">/* 共享页面数目 Shared pages (files) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm; <span class="comment">/* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm; <span class="comment">/* 栈区页面数目 VM_GROWSUP/DOWN */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</span><br><span class="line">    <span class="comment">/* 代码段、数据段 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;	<span class="comment">/* 堆区起始地址和结束地址, 进程栈区的起始地址 */</span></span><br><span class="line">    <span class="comment">/* 命令行参数 和 环境变量的 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="keyword">mm_context_t</span> context; <span class="comment">/* 体系结构特殊数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* 状态标志位 */</span></span><br><span class="line">    <span class="comment">/* Coredumping and NUMA and HugePage 相关结构体 */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>mm_count</code>代表了对<code>mm_strcut</code>本身的引用，而<code>mm_users</code>代表对<code>mm_struct</code>相关资源的引用，分了两个层次。<code>mm_count</code>类似于以进程为单位。 <code>mm_users</code>类似于以线程为单位。内核线程在运行时会借用其他进程的<code>mm_struct</code>，这样的线程叫<code>anonymous users</code>，因为他们不关心<code>mm_struct</code>指向的用户空间，也不会去访问这个用户空间，他们只是临时借用（比如说当进程执行系统调用陷入到内核中，内核会借用该进程的地址空间）。<code>mm_count</code>记录这样的进程数。<code>mm_users</code>是对<code>mm_struct</code>所指向的用户空间进行共享的所有进程的计数。也就是说，会有多个进程共享同一个用户空间， 这些进程也就是所谓的线程。</p>
<p><code>mmap</code>和<code>mm_rb</code>这两个不同数据结构体描述的对象是相同的：该地址空间中的全部内存区域。但是前者以链表形式存放而后者以红黑树的形式存放。<code>mmap</code>结构体作为链表，利于简单、高效地遍历所有元素；而<code>mm_rb</code>结构体作为红黑树，更适合搜索定位指定元素。</p>
<p>所有的<code>mm_struct</code>结构体都通过自身的<code>mmlist</code>域连接在一个双向链表中，该链表的首元素是<code>init_mm</code>内存描述符，它代表<code>init</code>进程的地址空间。另外要注意，操作该链表的时候需要使用<code>mmlist_lock</code>锁来防止并发访问，该锁定义在文件<code>kernel/fork.c</code>中。</p>
<p>每个进程都有自己的页表（当然，线程会共享页表）。内存描述符的<code>pgd</code>域指向的就是进程的页全局目录。</p>
<h6 id="内存描述符的分配与撤销"><a href="#内存描述符的分配与撤销" class="headerlink" title="内存描述符的分配与撤销"></a>内存描述符的分配与撤销</h6><p>在进程的进程描述符（即<code>task_struct</code>结构体）中，<code>mm</code>域存放着该进程使用的内存描述符，所以<code>current-&gt;mm</code>便指向当前进程的内存描述符。<code>fork()</code>函数利用<code>copy_mm()</code>函数复制父进程的内存描述符，也就是<code>current-&gt;mm</code>域给其子进程，而子进程中的<code>mm_struct</code>结构体实际是通过文件<code>kernel/fork.c</code>中的<code>allocate_mm()</code>宏从<code>mm_cachep slab</code>缓存中分配得到的。通常，每个进程都有唯一的<code>mm_struct</code>结构体，即唯一的进程地址空间。</p>
<p>如果父进程希望和其子进程共享地址空间，可以在调用<code>clone()</code>时，设置<code>CLONE_VM</code>标志。我们把这样的进程称作线程。当<code>CLONE_VM</code>被指定后，内核就不再需要调用<code>allocate_mm()</code>函数了，而仅仅需要调用<code>copy_mm()</code>函数中将<code>mm</code>域指向其父进程的内存描述符就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(clone_flags &amp; CLONE_vM)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// current 是父进程而 tsk 在 fork(）执行期间是子进程</span></span><br><span class="line">    atomic_inc(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">    tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进程退出时，内核会调用定义在<code>kernel/exit.c</code>中的<code>exit_mm()</code>函数，该函数执行一些常规的撤销工作，同时更新一些统计量。其中，该函数会调用<code>mmput()</code>函数减少内存描述符中的<code>mm_users</code>用户计数，如果用户计数降到零，将调用<code>mmdrop()</code>函数，减少<code>mm_count</code>使用计数。如果<code>mm_count</code>也等于零了，说明该内存描述符不再有任何使用者了，那么调用<code>free_mm()</code>宏通过<code>kmem_cache_free()</code>函数将<code>mm_struct</code>结构体归还到<code>mm_cachep slab</code>缓存中。</p>
<p>内核线程没有进程地址空间，也没有相关的内存描述符。所以内核线程对应的进程描述符中<code>mm</code>域为空。事实上，这也正是内核线程的真实含义——它们没有用户上下文。当一个进程被调度时，该进程的<code>mm</code>域指向的地址空间被装载到内存，进程描述符中的<code>active_mm</code>域会被更新，指向新的地址空间。内核线程没有地址空间，所以<code>mm</code>域为<code>NULL</code>。于是，当一个内核线程被调度时，内核发现它的<code>mm</code>域为<code>NULL</code>，就会保留前一个进程的地址空间，随后内核更新内核线程对应的进程描述符中的<code>active_mm</code>域，使其指向前一个进程的内存描述符。</p>
<p>所以在需要时，内核线程便可以使用前一个进程的页表。因为内核线程不访问用户空间的内存，所以它们仅仅使用地址空间中和内核内存相关的信息，这些信息的含义和普通进程完全相同（要知道用户进程的地址空间是包含分配给内核的那<code>1G</code>的空间的，只不过是不允许访问而已，所以内核线程借用前一个进程的地址空间是用来访问属于内核的那<code>1G</code>空间的）。</p>
<h6 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h6><p>每个和进程相关的内存区域都对应于一个<code>vm_area_struct</code>结构体。<code>vm_area_struct</code>结构体描述了指定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都拥有一致的属性，比如访问权限等，另外，相应的操作也都一致。按照这样的方式，每一个<code>VMA</code>就可以代表不同类型的内存区域（比如内存映射文件或者进程用户空间栈），下面给出该结构定义和各个域的描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>        <span class="comment">// 相关的 mm_struct 结构体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;         <span class="comment">// 区间的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;           <span class="comment">// 区间的尾地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span> <span class="comment">// VMA 链表</span></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;          <span class="comment">// 访问控制权限</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags; <span class="comment">//标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span> <span class="comment">//树上该 VMA 的节点</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 或者是关联于 address_space-&gt;i_mmap 字段</span></span><br><span class="line">        <span class="comment">// 或者是关联于 address_space-&gt;i_mmap_nonlinear 字段</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="keyword">void</span> *parent;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_truct</span> <span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span>      <span class="comment">// anon_vma 项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>           <span class="comment">//匿名VMA对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">vin_ops</span>;</span> <span class="comment">// 相关的操作表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="number">1</span>ong vm_pgoff;              <span class="comment">// 文件中的偏移量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">vm_file</span>;</span>                <span class="comment">// 被映射的文件（如果存在)</span></span><br><span class="line">    <span class="keyword">void</span> *vm_private_data;               <span class="comment">// 私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个内存描述符都对应于进程地址空间中的唯一区间。<code>vm_start</code>域指向区间的首地址（最低地址），<code>vm_end</code>域指向区间的尾地址（最高地址）之后的第一个字节。注意，在同一个地址空间内的不同内存区间不能重叠。</p>
<p><code>vm_mm</code>域指向和<code>VMA</code>相关的<code>mm_struct</code>结构体，注意，每个<code>VMA</code>对其相关的<code>mm_struct</code>结构体来说都是唯一的，所以即使两个独立的进程将同一个文件映射到各自的地址空间，它们分别都会有一个<code>vm_area_struct</code>结构体来标志自己的内存区域；反过来，如果两个线程共享一个地址空间，那么它们也同时共享其中的所有<code>vm_area_struct</code>结构体。</p>
<p>上文讨论过，可以通过内存描述符中的<code>mmap</code>和<code>mm_rb</code>域之一访问内存区域。<code>mmap</code>域使用单独链表连接所有的内存区域对象。每一个<code>vm_area_struet</code>结构体通过自身的<code>vm_next</code>域被连入链表，所有的区域按地址增长的方向排序，<code>mmap</code>域指向链表中第一个内存区域，链中最后一个结构体指针指向空。<code>mm_rb</code>域使用红黑树连接所有的内存区域对象。<code>mm_rb</code>域指向红黑树的根节点，地址空间中每一个<code>vm_area_struct</code>结构体通过自身的<code>vm_rb</code>域连接到树中。</p>
<h6 id="创建和删除地址空间"><a href="#创建和删除地址空间" class="headerlink" title="创建和删除地址空间"></a>创建和删除地址空间</h6><p>内核使用<code>do_mmap()</code>函数创建一个新的线性地址区间。如果创建的地址区间和一个已存在的地址区间相邻，并且它们具有相同的访问权限的话，两个区间将合并为一个。映射时，从<code>vm_area_cachep</code>长字节（<code>slab</code>）缓存中分配一个<code>vm_area_struct</code>结构体，并且使用<code>vma_link()</code>函数将新分配的内存区域添加到地址空间的内存区域链表和红黑树中，随后还要更新内存描述符中的<code>total_vm</code>域，然后才返回新分配的地址区间的初始地址。</p>
<p><code>do_mmap()</code>函数定义在文件<code>&lt;linux/mm.h&gt;</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数映射由<code>file</code>指定的文件，具体映射的是文件中从偏移<code>offset</code>处开始，长度为<code>len</code>字节的范围内的数据。如果<code>file</code>参数是<code>NULL</code>并且<code>offset</code>参数也是<code>0</code>，那么就代表这次映射没有和文件相关，该情况称作匿名映射（<code>anonymous mapping</code>）。如果指定了文件名和偏移量，那么该映射称为文件映射（<code>file-backed mapping</code>）。</p>
<p><code>addr</code>是可选参数，它指定搜索空闲区域的起始位置。<code>prot</code>参数指定内存区域中页面的访问权限。访问权限标志定义在文件<code>&lt;asm/mman.h&gt;</code>中。</p>
<p>在用户空间可以通过<code>mmap()</code>系统调用获取内核函数<code>do_mmap()</code>的功能。<code>mmap()</code>系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap2</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> pgoff)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由于该系统调用是<code>mmap()</code>调用的第二种变种，所以起名为<code>mmap2()</code>。最原始的<code>mmap()</code>调用中最后一个参数是字节偏移量，而目前这个<code>mmap2()</code>使用页面偏移作最后一个参数。使用页面偏移量可以映射更大的文件和更大的偏移位置。原始的<code>mmap()</code>调用由<code>POSIX</code>定义，仍然在<code>C</code>库中作为<code>mmap()</code>方法使用，但是内核中已经没有对应的实现了，而实现的是新方法<code>mmap2()</code>。虽然<code>C</code>库仍然可以使用原始版本的映射方法，但是它其实还是基于函数<code>mmap2</code>进行的，对原始<code>mmap()</code>方法的调用是通过将字节偏移转化为页面偏移，从而转化为对<code>mmap2()</code>函数的调用来实现的。</p>
<p><code>do_mummap()</code>函数从特定的进程地址空间中删除指定地址区间，该函数定义在文件<code>&lt;linux/mm.h&gt;</code>中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_mummap</span><span class="params">(struct mm_struct *mm , <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数指定要删除区域所在的地址空间，删除从地址<code>start</code>开始，长度为<code>len</code>字节的地址区间。如果成功，返回零。否则，返回负的错误码。</p>
<p>系统调用<code>munmap</code>()给用户空间程序提供了一种从自身地址空间中删除指定地址区间的方法，它和系统调用<code>mmap()</code>的作用相反，该系统调用定义在文件<code>mm/mmap.c</code>中，它是对<code>do_mummap()</code>函数的一个简单的封装。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="进程用户栈、线程栈、进程内核栈、中断栈"><a href="#进程用户栈、线程栈、进程内核栈、中断栈" class="headerlink" title="进程用户栈、线程栈、进程内核栈、中断栈"></a>进程用户栈、线程栈、进程内核栈、中断栈</h5><p><strong>进程用户栈</strong></p>
<p>进程栈是属于用户态栈，和进程虚拟地址空间 (<code>Virtual Address Space</code>) 密切相关。那我们先了解下什么是虚拟地址空间：在<code>32</code>位机器下，虚拟地址空间大小为<code>4G</code>。这些虚拟地址通过页表 (<code>Page Table</code>) 映射到物理内存，页表由操作系统维护，并被处理器的内存管理单元 (<code>MMU</code>) 硬件引用。每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。</p>
<p><code>Linux</code>内核将这<code>4G</code>字节的空间分为两部分，将最高的<code>1G</code>字节（<code>0xC0000000</code>- <code>0xFFFFFFFF</code>）供内核使用，称为内核空间。而将较低的<code>3G</code>字节（<code>0x00000000</code> - <code>0xBFFFFFFF</code>）供各个进程使用，称为用户空间。每个进程可以通过系统调用陷入内核态，因此内核空间是由所有进程共享的。虽然说内核和用户态进程占用了这么大地址空间，但是并不意味它们使用了这么多物理内存，仅表示它可以支配这么大的地址空间。它们是根据需要，将物理内存映射到虚拟地址空间中使用。</p>
<img src="20160901214930068.jpg" alt="Linux虚拟地址空间" style="zoom:150%;" />

<p><code>Linux</code>对进程地址空间有个标准布局，地址空间中由各个不同的内存段组成 (<code>Memory Segment</code>)，主要的内存段如下：</p>
<ul>
<li>程序段 (<code>Text Segment</code>)：可执行文件代码的内存映射。</li>
<li>数据段 (<code>Data Segment</code>)：可执行文件的已初始化全局变量的内存映射。</li>
<li><code>BSS</code>段 (<code>BSS Segment</code>)：未初始化的全局变量或者静态变量（<strong><u>映射到零页</u></strong>）。</li>
<li>堆区 (<code>Heap</code>) : 存储动态内存分配，匿名的内存映射（<code>malloc</code>分配的内存区域）。</li>
<li>栈区 (<code>Stack</code>) : 进程用户空间栈，由编译器自动分配释放，存放函数的参数值、局部变量的值等。</li>
<li>映射段（<code>Memory Mapping Segment</code>）：任何内存映射文件，如每一个诸如C库或动态连接程序等共享库的代码段、数据段和<code>BSS</code>也会被载入进程的地址空间。</li>
</ul>
<p><u><strong>可执行文件的<code>BSS</code>段未存储在磁盘上，内核将零页面映射到<code>BSS</code>范围</strong></u>。</p>
<p>因为在创建新进程时预期<code>BSS</code>段将被初始化为零，并且仅在可执行文件中存储一堆零浪费了空间，所以可执行文件仅指示<code>BSS</code>段应从何处开始以及应该从多大。</p>
<p>当内核从可执行文件构建新进程时，它将为<code>BSS</code>范围创建到零页面的映射，该页面是全零的静态（虚拟）页面。该映射设置有<strong>写时复制</strong>功能，因此，新进程首次向其中一个<code>BSS</code>页进行写入时，在允许写入完成之前，静态零页的实际副本将分配到另一个内存页中。 这样做有如下几点好处：</p>
<ol>
<li>节省了可执行文件中的空间。</li>
<li>避免了实际分配可能永远不会被该进程触及的<code>BSS</code>页面，从而节省了内存使用量。</li>
<li>同时仍然提供了确保每个进程中的<code>BSS</code>段看起来都是零初始化的保证。</li>
</ol>
<p><img src="20160901214948512.jpg" alt="20160901214948512"></p>
<p>而上面进程虚拟地址空间中的栈区，正指的是我们所说的进程栈。进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，<code>Linux</code>内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制<code>RLIMIT_STACK</code>（一般为<code>8M</code>），我们可以通过<code>ulimit</code>来查看或更改<code>RLIMIT_STACK</code>的值。</p>
<p><strong>如何确认进程栈的大小</strong></p>
<p>我们要知道栈的大小，那必须得知道栈的起始地址和结束地址。栈起始地址获取很简单，只需要嵌入汇编指令获取栈指针<code>esp</code>寄存器的值即可。栈结束地址的获取有点麻烦，我们需要先利用递归函数把栈搞溢出了，然后再<code>GDB</code>中把栈溢出的时候把栈指针<code>esp</code>寄存器的值打印出来即可。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file name: stacksize.c */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *orig_stack_pointer;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blow_stack</span><span class="params">()</span> </span>&#123; blow_stack(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">"movl %esp, orig_stack_pointer"</span>);</span><br><span class="line"></span><br><span class="line">    blow_stack();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ g++ -g stacksize.c -o ./stacksize</span><br><span class="line">$ gdb ./stacksize</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/home/misc-code/setrlimit</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">blow_stack () at setrlimit.c:<span class="number">4</span></span><br><span class="line"><span class="number">4</span>       blow_stack();</span><br><span class="line">(gdb) print (<span class="keyword">void</span> *)$esp</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0xffffffffff7ff000</span></span><br><span class="line">(gdb) print (<span class="keyword">void</span> *)orig_stack_pointer</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">void</span> *) <span class="number">0xffffc800</span></span><br><span class="line">(gdb) print <span class="number">0xffffc800</span><span class="number">-0xff7ff000</span></span><br><span class="line">$<span class="number">3</span> = <span class="number">8378368</span>	<span class="comment">// Current Process Stack Size is 8M</span></span><br></pre></td></tr></table></figure>

<p><strong>进程栈的动态增长实现</strong></p>
<p>进程在运行的过程中，通过不断向栈区压入数据，当超出栈区容量时，就会耗尽栈所对应的内存区域，这将触发一个 缺页异常 (<code>page fault</code>）。通过异常陷入内核态后，异常会被内核的<code>expand_stack()</code>函数处理，进而调用 <code>acct_stack_growth()</code>来检查是否还有合适的地方用于栈的增长。</p>
<p>如果栈的大小低于<code>RLIMIT_STACK</code>（通常为<code>8MB</code>），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情，这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会发生栈溢出（<code>stack overflow</code>），进程将会收到内核发出的段错误（<code>segmentation fault</code>）信号。</p>
<p>动态栈增长是唯一一种访问未映射内存区域而被允许的情形，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。</p>
<p><strong>线程栈</strong></p>
<p>从<code>Linux</code>内核的角度来说，其实它并没有线程的概念。<code>Linux</code>把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了<code>task_struct</code>中。线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和<code>Linux</code>中所谓线程的唯一区别。线程创建的时候，加上了<code>CLONE_VM</code>标记，这样 线程的内存描述符 将直接指向父进程的内存描述符。</p>
<p>虽然线程的地址空间和进程一样，但是对待其地址空间的栈<code>stack</code>还是有些区别的。对于<code>Linux</code>进程或者说主线程，其<code>stack</code>是在<code>fork</code>的时候生成的，实际上就是复制了父亲的<code>stack</code>空间地址，然后写时拷贝 (<code>cow</code>) 以及动态增长。然而对于主线程生成的子线程而言，其<code>stack</code>将不再是这样的了，而是事先固定下来的，使用<code>mmap</code>系统调用，它不带有<code>VM_STACK_FLAGS</code>标记。</p>
<p>这个可以从<code>glibc</code>的<code>nptl/allocatestack.c</code>中的<code>allocate_stack()</code>函数中看到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem = mmap (<span class="literal">NULL</span>, size, prot, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>由于线程的<code>mm-&gt;start_stack</code>栈地址和所属进程相同，所以线程栈的起始地址并没有存放在<code>task_struct</code>中，应该是使用<code>pthread_attr_t</code>中的<code>stackaddr</code>来初始化<code>task_struct-&gt;thread-&gt;sp</code>（<code>sp</code>指向<code>struct pt_regs</code>对象，该结构体用于保存用户进程或者线程的寄存器现场）。这些都不重要，重要的是，线程栈不能动态增长，一旦用尽就没了，这是和生成进程的<code>fork</code>不同的地方。由于线程栈是从进程的地址空间中<code>map</code>出来的一块内存区域，原则上是线程私有的。</p>
<p><strong>进程内核栈</strong></p>
<p>在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作进程内核栈。进程内核栈在进程创建的时候，通过<code>slab</code>分配器从<code>thread_info_cache</code>缓存池中分配出来，其大小为<code>THREAD_SIZE</code>，一般来说是一个页大小<code>4K</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>thread_union</code>进程内核栈和<code>task_struct</code>进程描述符有着紧密的联系。由于内核经常要访问<code>task_struct</code>，高效获取当前进程的描述符是一件非常重要的事情。因此内核将进程内核栈的头部一段空间，用于存放<code>thread_info</code>结构体，而此结构体中则记录了对应进程的描述符，两者关系如下图：</p>
<img src="20160901215111055.jpg" alt="img" style="zoom:150%;" />

<p>有了上述关联结构后，内核可以先获取到栈顶指针<code>esp</code>，然后通过<code>esp</code>来获取<code>thread_info</code>。这里有一个小技巧，直接将<code>esp</code>的地址与上<code>~(THREAD_SIZE - 1)</code>后即可直接获得<code>thread_info</code>的地址。由于<code>thread_union</code>结构体是从<code>thread_info_cache</code>的<code>Slab</code>缓存池中申请出来的，而<code>thread_info_cache</code>在<code>kmem_cache_create</code>创建的时候，保证了地址是<code>THREAD_SIZE</code>对齐的。因此只需要对栈指针进行<code>THREAD_SIZE</code>对齐，即可获得<code>thread_union</code>的地址。成功获取到<code>thread_info</code>后，直接取出它的<code>task</code>成员就成功得到了<code>task_struct</code>。其实上面这段描述，也就是<code>current</code>宏的实现方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> current_stack_pointer <span class="title">asm</span> <span class="params">(<span class="string">"sp"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_current() (current_thread_info()-&gt;task)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> current get_current()</span></span><br></pre></td></tr></table></figure>

<p><strong>中断栈</strong></p>
<p>进程陷入内核态的时候，需要内核栈来支持内核函数调用。中断也是如此，当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关。</p>
<p><code>x86</code>上中断栈就是独立于内核栈的；独立的中断栈所在内存空间的分配发生在<code>arch/x86/kernel/irq_32.c</code>的<code>irq_ctx_init()</code>函数中（如果是多处理器系统，那么每个处理器都会有一个独立的中断栈），函数使用<code>__alloc_pages</code>在低端内存区分配<code>2</code>个物理页面，也就是<code>8KB</code>大小的空间。有趣的是，这个函数还会为<code>softirq</code>分配一个同样大小的独立堆栈。如此说来，<code>softirq</code>将不会在<code>hardirq</code>的中断栈上执行，而是在自己的上下文中执行。</p>
<p><strong>为什么需要单独的进程内核栈？</strong></p>
<p>（<strong>为什么需要单独的线程栈？进程和线程是否共享一个内核栈？</strong>）</p>
<p>所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程<code>A</code>陷入内核态执行的时候，需要等待读取网卡的数据，主动调用<code>schedule()</code>让出<code>CPU</code>；此时调度器唤醒了另一个进程<code>B</code>，碰巧进程<code>B</code>也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程<code>B</code>进入内核态的时候产生的压栈操作，必然会破坏掉进程<code>A</code>已有的内核栈数据；一但进程<code>A</code>的内核栈数据被破坏，很可能导致进程<code>A</code>的内核态无法正确返回到对应的用户态了。</p>
<p>**这三个问题很好理解，只要可被调度执行的对象之间共用一个栈（无论进程栈，内核栈还是线程栈），那必然会有出错的机会，所以不能共用。进程和同一个进程的线程都是可被调度执行的对象！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/29s2fW7i8PsxWCiK/" rel="prev" title="操作系统之并发与同步">
      <i class="fa fa-chevron-left"></i> 操作系统之并发与同步
    </a></div>
      <div class="post-nav-item">
    <a href="/wF5qv4uNKgDG1SUa/" rel="next" title="操作系统之malloc底层原理">
      操作系统之malloc底层原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80OTQ0NS8yNTkzNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存管理"><span class="nav-number">1.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#加载和链接"><span class="nav-number">1.1.</span> <span class="nav-text">加载和链接</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#加载"><span class="nav-number">1.1.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#链接"><span class="nav-number">1.1.2.</span> <span class="nav-text">链接</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存管理的需求"><span class="nav-number">1.2.</span> <span class="nav-text">内存管理的需求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#固定分区和动态分区"><span class="nav-number">1.3.</span> <span class="nav-text">固定分区和动态分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简单分页"><span class="nav-number">1.4.</span> <span class="nav-text">简单分页</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简单分段"><span class="nav-number">1.5.</span> <span class="nav-text">简单分段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟内存概念"><span class="nav-number">1.6.</span> <span class="nav-text">虚拟内存概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟分页"><span class="nav-number">1.7.</span> <span class="nav-text">虚拟分页</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#页表结构"><span class="nav-number">1.7.1.</span> <span class="nav-text">页表结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#转换检测缓冲区TLB"><span class="nav-number">1.7.2.</span> <span class="nav-text">转换检测缓冲区TLB</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚拟分段和段页式"><span class="nav-number">1.8.</span> <span class="nav-text">虚拟分段和段页式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作系统软件的支持"><span class="nav-number">1.9.</span> <span class="nav-text">操作系统软件的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#读取策略和清除策略"><span class="nav-number">1.9.1.</span> <span class="nav-text">读取策略和清除策略</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#放置策略"><span class="nav-number">1.9.2.</span> <span class="nav-text">放置策略</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#置换策略和页缓冲"><span class="nav-number">1.9.3.</span> <span class="nav-text">置换策略和页缓冲</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#驻留集管理"><span class="nav-number">1.9.4.</span> <span class="nav-text">驻留集管理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux内存管理"><span class="nav-number">1.10.</span> <span class="nav-text">Linux内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#页（page）"><span class="nav-number">1.10.1.</span> <span class="nav-text">页（page）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#区（zone）"><span class="nav-number">1.10.2.</span> <span class="nav-text">区（zone）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#获得与释放页"><span class="nav-number">1.10.3.</span> <span class="nav-text">获得与释放页</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程地址空间"><span class="nav-number">1.11.</span> <span class="nav-text">进程地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#内存描述符"><span class="nav-number">1.11.1.</span> <span class="nav-text">内存描述符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#内存描述符的分配与撤销"><span class="nav-number">1.11.2.</span> <span class="nav-text">内存描述符的分配与撤销</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#虚拟内存区域"><span class="nav-number">1.11.3.</span> <span class="nav-text">虚拟内存区域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建和删除地址空间"><span class="nav-number">1.11.4.</span> <span class="nav-text">创建和删除地址空间</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程用户栈、线程栈、进程内核栈、中断栈"><span class="nav-number">1.12.</span> <span class="nav-text">进程用户栈、线程栈、进程内核栈、中断栈</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

      <!-- 音乐播放器 -->
      <div>
      
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=300 height="400" src="//music.163.com/outchain/player?type=0&id=6679290542&auto=1&height=400"></iframe>
      
      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>