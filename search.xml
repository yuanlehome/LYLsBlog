<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>重要知识点详细解读之僵尸进程和孤儿进程</title>
      <link href="/rakjPpyIOCsd0MoJ/"/>
      <url>/rakjPpyIOCsd0MoJ/</url>
      
        <content type="html"><![CDATA[<h4 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h4><h5 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h5><p>简单的说，僵尸进程就是子进程先于父进程退出，并且父进程并没有调用<code>wait</code>系统调用，即使其进程映像中占用的系统资源（比如内存，页表等）都会被释放回收，但这时子进程的进程描述符（<code>PCB</code>）结构仍然存在于系统中得不到释放，就称这样的进程为僵尸进程（<code>Zombie</code>）。</p><a id="more"></a><h5 id="为什么会产生僵尸进程？"><a href="#为什么会产生僵尸进程？" class="headerlink" title="为什么会产生僵尸进程？"></a>为什么会产生僵尸进程？</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* status)</span></span>;</span><br></pre></td></tr></table></figure><p>首先，如果一个进程不成为僵尸进程的话，就要请求内核来回收它最后遗留的<code>PCB</code>。而内核给出了<code>exit</code>和<code>wait</code>系统调用来提供回收进程<code>PCB</code>的途径。进程到最后或者是主动调用<code>exit</code>结束运行，或者是通过<code>return</code>语句使得编译器安插<code>exit</code>调用代码，目的都是向父进程传递一个“退出状态值”（这个状态值就是<code>exit</code>函数的那个参数，或者是<code>return</code>语句后面那个整数），我们就叫它临终遗言吧。这个遗言就保存在进程遗留的<code>PCB</code>中，等待着父进程调用<code>wait</code>系统调用去取它的遗言，也就是内核会把这个遗言放在<code>wait</code>函数的参数所指向的内存，取完之后，内核就会回收这块<code>PCB</code>资源。这些都是在执行系统调用期间发生的，也就是说调用了这两个系统调用，给了内核机会来回收遗留的<code>PCB</code>。</p><p>如果父进程在派生出子进程后并没有调用<code>wait</code>等待接收子进程的返回值，这时某个子进程调用<code>exit</code>退出了，自然没人来接收返回值了。因此其<code>PCB</code>所占的空间不能释放，没人为其“收尸”，自然就成了“僵 尸”。</p><h5 id="僵尸进程有什么危害以及如何处理？"><a href="#僵尸进程有什么危害以及如何处理？" class="headerlink" title="僵尸进程有什么危害以及如何处理？"></a>僵尸进程有什么危害以及如何处理？</h5><p>虽然进程的退出状态未被父进程取出前，除了<code>PCB</code>以外，其他所有资源都可以释放。但由于<code>PCB</code>不释放，它原本的<code>pid</code>也会继续被占用，当僵尸进程数量很大时，系统将无可用<code>pid</code>分配给新进程，从而加载进程失败。</p><p>既然产生了僵尸进程，就说明父进程违背了和内核的约定，不想回收子进程。那么，内核也提供了毫不客气的办法来处理，那就是直接<code>kill</code>掉父进程，在<code>Linux</code>中可以利用<code>ps –ef</code>查看所有任务的<code>pid</code>和<code>ppid</code>，找到状态为<code>Z</code>的进程，查看其<code>ppid</code>，跟着向<code>pid</code>为<code>ppid</code>的进程发送<code>kill -9</code>。</p><h5 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h5><p>在子进程提交给父进程返回值的时候，有这样一种情况，当父进程提前退出时，它所有的子进程还在运行，没有一个执行了<code>exit</code>，因为它们的生命周期尚未结束，还在运行中，个个都拥有“全尸”（完整的进程映像）， 这些进程就称为孤儿进程。这时候所有的子进程会被<code>pid</code>为<code>1</code>的<code>init</code>进程收养，<code>init</code>进程会成为这些子进程的新父亲，当子进程退出时会由<code>init</code>负责为其“收尸”。<code>init</code>进程是所有进程的祖先进程，所有进程最初都是通过它派生出来的。</p><p>对系统而言，有了<code>init</code>进程的“收养“，孤儿进程并没有什么危害，<code>init</code>会很好地为其善后，因此并不会额外占用资源，它和普通的进程一样，原理上对系统不会产生不良影响。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>exit</code>是由子进程调用的，表面上功能是使子进程结束运行并传递返回值给内核，本质上是内核在幕后会将进程除<code>PCB</code>以外的所有资源都回收。<code>wait</code>是父进程调用的，表面上功能是使父进程阻塞自己，直到子进程调用<code>exit</code>结束运行，然后获得子进程的返回值，本质上是内核在幕后将子进程的返回值传递给父进程并会唤醒父进程，然后将子进程的<code>PCB</code>回收。</p><h5 id="其它可参考链接"><a href="#其它可参考链接" class="headerlink" title="其它可参考链接"></a>其它可参考链接</h5><p><a href="https://blog.csdn.net/Eunice_fan1207/article/details/81387417" target="_blank" rel="noopener">孤儿进程与僵尸进程产生及其处理_Eunice_fan1207的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_44489823/article/details/103260332" target="_blank" rel="noopener">Linux下僵尸进程的处理回收详解_CSer-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之进程间通信（含内核实现）</title>
      <link href="/tRettVqCkfzWbulf/"/>
      <url>/tRettVqCkfzWbulf/</url>
      
        <content type="html"><![CDATA[<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><ul><li><p><code>IPC</code>对象</p><p>内核中用于进程间通信的数据结构，全局可见，如消息队列的<code>msg_queue</code>结构体、信号量的<code>sem_array</code>结构体，共享内存的<code>shmid_kernel</code>结构体。类似于普通文件是通过文件名（文件描述符）进行读写操作，通过<code>IPC key</code>和<code>IPC</code>标识符进行<code>IPC</code>对象的读写操作。</p></li><li><p><code>IPC</code>标识符<code>ID</code></p><p>类似于文件描述符<code>fd</code>，可以用一个<code>IPC</code>标识符来引用一个<code>IPC</code>对象，是一个<code>32</code>位整数，是<code>IPC</code>对象的外部名字。返回给用户进程的。</p></li><li><p><code>IPC key</code>（魔数）<br><code>IPC</code>对象的内部名，是一个独一无二的整数，用来确保<code>IPC</code>对象的唯一性。该整数类型为<code>key_t</code>，在<code>sys/types.h</code>中被定义为长整型。<br>类似于普通文件通过文件名<code>open</code>一个文件，获得文件描述符；<code>IPC</code>对象是<code>get</code>函数根据给定的<code>key</code>去创建一个<code>IPC</code>对象，并返回<code>IPC</code>标识符<code>ID</code>。根据新资源是信号量、消息队列还是共享内存，分别调用<code>semget()</code>、<code>msgget()</code>或者<code>shmget()</code>函数创建<code>IPC</code>资源。</p><p>这三个函数的主要目的都是从<code>IPC key</code>（作为第一个参数传递）中导出相应的<code>IPC</code>标识符<code>ID</code>，进程以后就可以使用这个标识符对资源进行访问。如果还没有<code>IPC</code>资源和<code>IPC</code>关键字相关联，就创建一个新的资源。如果一切都顺利，那么函数就返回一个正的<code>IPC</code>标识符，否则，就返回一个错误码。</p></li></ul><a id="more"></a><p>在各个独立进程能够访问<strong><code>IPC</code>对象</strong>之前，<code>IPC</code>对象必须在系统内唯一标识。为此，每种<code>IPC</code>结构在创建时分配了一个<code>IPC key</code>（程序员自由分配）。凡知道这个<strong><code>IPC key</code></strong>的各个程序，都能够通过它得到一个标识符<code>ID</code>，进而访问对应的<code>IPC</code>对象。如果独立的应用程序需要彼此通信，则通常需要将该魔数永久地编译到程序中。</p><p>在访问<code>IPC</code>对象时，操作系统采用了基于文件访问权限的一个权限系统。每个<code>IPC</code>对象都有一个用户<code>ID</code>和一个组<code>ID</code>，依赖于产生<code>IPC</code>对象的程序在何种<code>UID/GID</code>之下运行。读写权限在初始化时分配。类似于普通的文件，这些控制了<code>3</code>种不同用户类别的访问：所有者、组、其他。</p><p><code>IPC</code>在内核中的默认命名空间通过<code>ipc_namespace</code>的静态实例<code>init_ipc_ns</code>实现，每个命名空间都包含如下信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span>* <span class="title">ids</span>[3];</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体中我们更感兴趣的是数组<code>ids</code>。每个数组元素对应于一种<code>IPC</code>机制：共享内存、信号量、消息队列。每个数组项指向一个<code>struct ipc_ids</code>实例，该结构用于跟踪各类别现存的<code>IPC</code>对象。比如，索引<code>0</code>对应的是信号量，其后是消息队列，最后是共享内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipc/util.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> in_use;</span><br><span class="line">    <span class="keyword">unsigned</span> short seq;</span><br><span class="line">    <span class="keyword">unsigned</span> short seq_max;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rw_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">ipcs_idr</span>;</span> <span class="comment">// 通过类似于基数树的方式管理 内核内部 ID 到指向 kern_ipc_perm 的指针的映射</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前几个成员保存了有关<code>IPC</code>对象状态的一般信息。</p><ul><li><code>in_use</code>保存了当前使用中<code>IPC</code>对象的数目。</li><li><code>seq</code>和<code>seq_max</code>用于连续产生用户空间<code>IPC</code>标识符<code>ID</code>。<del>计算方式为<code>ID = seq * M + id</code>。<code>M</code>是固定的宏，值为<code>32768</code>，<code>seq</code>被初始化为<code>0</code>，每次产生一个<code>ID</code>后加<code>1</code>，<code>id</code>为内核内部使用的一个数。</del></li><li><code>rw_mutex</code>是一个内核信号量。它用于实现信号量操作，避免用户空间中的竞态条件。该互斥量有效地保护了包含信号量值的数据结构。</li></ul><p>每个<code>IPC</code>对象都由<code>kern_ipc_perm</code>的一个实例表示，并且都有一个<code>IPC</code>标识符<code>ID</code>，<code>ipcs_idr</code>用于将<code>ID</code>关联到指向对应的<code>kern_ipc_perm</code>实例的指针。</p><p><code>kern_ipc_perm</code>的成员保存了有关<code>IPC</code>对象的所有者和访问权限等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*int id;*/</span></span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">uid_t</span> uid;</span><br><span class="line">    <span class="keyword">gid_t</span> gid;</span><br><span class="line">    <span class="keyword">uid_t</span> cuid;</span><br><span class="line">    <span class="keyword">gid_t</span> cgid;</span><br><span class="line">    <span class="keyword">mode_t</span> mode;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>key</code>保存了用户程序用来标识<code>IPC</code>对象的<code>IPC key</code>，<del><code>id</code>就是前面用来计算标识符<code>ID</code>的公式中的<code>id</code></del>。</li><li><code>uid</code>和<code>gid</code>分别指定了所有者的用户<code>ID</code>和组<code>ID</code>。<code>cuid</code>和<code>cgid</code>保存了产生信号量的进程的用户<code>ID</code>和组<code>ID</code>。</li><li><code>seq</code>是一个序号，在分配<code>IPC</code>对象时使用，和<code>ipc_ids</code>结构中意思相同，为创建该资源是使用的<code>seq</code>。</li><li><code>mode</code>保存了位掩码，指定了所有者、组、其他用户的访问权限。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p><strong>数据传输</strong>：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</p></li><li><p><strong>共享数据</strong>：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</p></li><li><p><strong>通知事件</strong>：一个进程需要向另一个或一组进程发送消息，通知它发生了某种事件（如进程终止时要通知父进程）。</p></li><li><p><strong>资源共享</strong>：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</p></li><li><p><strong>进程控制</strong>：有些进程希望完全控制另一个进程的运行（如<code>Debug</code>进程）模式，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p></li></ul><p>每个进程的用户地址空间都是独立的，但是内核空间是共享的，所以，进程之间要想相互通信都要经过内核。<code>Linux</code>提供的几种进程间通信方式有管道、消息队列、信号量、信号、共享内存和本地套接字</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道只能单向传输数据，如果要想双向传输数据，需要创建两个管道。管道分为命名管道和匿名管道。</p><p><strong>命名管道</strong>的可通过<code>mkfifo</code>命令来创建，并且指定管道名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkfifo mypipe</span></span><br></pre></td></tr></table></figure><p>命名管道是以文件的方式存在于文件系统中，类型为<code>p</code>。进程之间可以通过这个文件进行通信。它是为了解决下面将要介绍的匿名管道只能用于具有亲缘关系的进程间通信的局限性的。</p><p><strong>匿名管道</strong>通过<code>pipe</code>系统调用创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>该函数通过传出参数返回两个文件描述符，<a href="https://mp.weixin.qq.com/s/hLq7Pp8CkJD9B-Xqym50dA" target="_blank" rel="noopener">如果不清楚文件描述符的概念，参考这篇文章</a>。一个是管道读取端描述符<code>fd[0]</code>，一个是管道的写入端描述符<code>fd[1]</code>。匿名管道是只存在内存中的特殊文件，实际上就是内核中的一块缓存。管道传输的数据是无格式的字节流且大小受限。</p><img src="641.jpg" alt="Image" style="zoom:50%;" /><p>通过<code>fork</code>系统调用创建子进程，创建的子进程会复制父进程的文件描述符，这样两个进程就可以通过各自的<code>fd</code>写入和读取同一个管道文件实现跨进程通信了。</p><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：</p><ul><li>父进程关闭读取的<code>fd[0]</code>，只保留写入的<code>fd[1]</code>；</li><li>子进程关闭写入的<code>fd[1]</code>，只保留读取的<code>fd[0]</code>；</li></ul><img src="dfsgdfg.jpg" alt="dfsgdfg" style="zoom:50%;" /><p>在<code>shell</code>里面执行<code>A | B</code>命令的时候，<code>A</code>进程和<code>B</code>进程都是<code>shell</code>创建出来的子进程，<code>A</code>和<code>B</code>之间不存在父子关系，它俩的父进程都是<code>shell</code>。</p><img src="asdfsd.jpg" alt="asdfsd" style="zoom:50%;" /><p>当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。</p><p>在<code>Linux</code>中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的<code>file</code>结构和<code>VFS</code>的索引节点<code>inode</code>。通过将两个<code>file</code>结构指向同一个临时的<code>VFS</code>索引节点，而这个<code>VFS</code>索引节点又指向一个物理页面而实现的。</p><img src="image-20210412111846194.png" alt="image-20210412111846194" style="zoom: 50%;" /><p>管道是个环形缓冲区，对环形缓冲区的维护，主要是协调好数据读写的两个指针，以及生产者、消费者的休眠时机。环形缓冲区中一个指针用于读数据，另一个用于写数据。当缓冲区已满时，生产者要睡眠，并在睡眠前唤醒消费者，当缓冲区为空时，消费者要睡眠，并在睡眠前唤醒生产者。当缓冲区满或空时，使一方休眠，这是保证数据不丢失的方法。管道其实就是典型的生产者和消费者问题。</p><p>管道写函数通过将字节复制到<code>VFS</code>索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，内核必须利用一定的机制同步对管道的访问，为此，内核使用了锁、等待队列和信号。</p><p>当写进程向管道中写入时，它利用标准的库函数<code>write()</code>，系统根据库函数传递的文件描述符，可找到该文件的<code>file</code>结构。<code>file</code>结构中指定了用来进行管道专门写操作的函数<code>pipe_write</code>地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查<code>VFS</code>索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：</p><ul><li>内存中有足够的空间可容纳所有要写入的数据；</li><li>内存没有被读程序锁定。</li></ul><p>如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在<code>VFS</code>索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。</p><p>管道的读取过程和写入过程类似，通过read系统调用转调用管道专用读操作函数<code>pipe_read</code>。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。</p><p><strong>可以说管道适用于具有亲缘关系的进程间通信</strong>。无论是命名管道还是匿名管道，进程写入的数据都是缓存在内核的内存缓冲区中，读取的时候自然也是从内核的内存缓冲区中读取，因此需要在用户态和内核态之间转换。<strong>因此，管道的通信方式是低效率的，不适合进程间频繁地、大块地交换数据。</strong></p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p><strong>消息队列</strong>的通信模式比如说，<code>A</code>进程要给<code>B</code>进程发送消息，<code>A</code>进程把数据放在对应的消息队列后就可以正常返回了，<code>B</code>进程需要的时候再去读取数据就可以了。同理，<code>B</code>进程要给<code>A</code>进程发送消息也是如此。</p><p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>消息队列生命周期根随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。发送者和接收者通过消息队列通信时，无需同时运行，例如，发送进程可以打开一个队列，写入消息，然后结束工作，接收进程在发送者结束之后启动，仍然可以访问队列并（根据消息编号）获取消息。中间的一段时间内消息由内核维护。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，<strong>每个消息都至少分配一个内存页</strong>，同时所有队列所包含的全部消息体的总长度也是有上限。在<code>Linux</code>内核中，会有两个宏定义<code>MSGMAX</code>和<code>MSGMNB</code>，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时或者另一进程读取内核中的消息数据时，会发生从内核缓冲区拷贝数据到用户缓冲区的过程。</p><p><strong>消息队列的实现</strong>：</p><p>消息队列使用名为<code>msg_queue</code>的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> q_stime; <span class="comment">// 上一次调用 sgsnd 送消息的时</span></span><br><span class="line">    <span class="keyword">time_t</span> q_rtime; <span class="comment">// 上一次调用 msgrcv 接收消息的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> q_ctime; <span class="comment">// 上一次修改的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes; <span class="comment">/*队列上当前字节数目*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum; <span class="comment">/*队列中的消息数目*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes; <span class="comment">/*队列上最大字节数目*/</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lspid; <span class="comment">/*上一次调用 msgsnd 的 pid */</span></span><br><span class="line">    <span class="keyword">pid_t</span> q_lrpid; <span class="comment">/*上一次接收消息的 pid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span> <span class="comment">// 消息体链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span> <span class="comment">// 睡眠的接收者链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span> <span class="comment">// 睡眠的发送者链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>q_messages</code>中的各个消息都封装在<code>msg_msg</code>结构体中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type; <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="keyword">int</span> m_ts; <span class="comment">/*消息正文长度*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span>* <span class="title">next</span>;</span><span class="comment">// 如果保存的消息超过一个内存页的长度</span></span><br><span class="line">    <span class="comment">/*接下来是实际的消息*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/*接下来是消息的下一部分*/</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><img src="image-20210412120217377.png" alt="image-20210412120217377" style="zoom: 50%;" /><p>消息正文紧接着该数据结构的实例之后存储。使用next，可以使消息分布到任意数目的页上。在通过消息队列通信时，发送进程和接收进程都可以进入睡眠：如果消息队列已经达到最大容量，则发送者在试图写入消息时会进入睡眠；如果队列中没有消息，那么接收者在试图获取消息时会进入睡眠。</p><p>睡眠的发送者放置在<code>msg_queue</code>的<code>q_senders</code>链表中，睡眠的接收者放置在<code>q_receivers</code>链表中，链表元素使用下列数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_sender</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">tsk</span>;</span> <span class="comment">// 指向休眠进程的进程描述符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_receiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">r_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">r_tsk</span>;</span> <span class="comment">// 指向休眠进程的进程描述符</span></span><br><span class="line">    <span class="keyword">int</span> r_mode;</span><br><span class="line">    <span class="keyword">long</span> r_msgtype;</span><br><span class="line">    <span class="keyword">long</span> r_maxsize;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">volatile</span> <span class="title">r_msg</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="image-20210412120755697.png" alt="image-20210412120755697" style="zoom: 50%;" /><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>操作系统内存管理采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程<code>A</code>和进程<code>B</code>的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p>但是共享内存通信方式带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><img src="3333rtewrfg.jpg" alt="Image" style="zoom: 50%;" /><p><strong>共享内存的实现</strong>：</p><img src="image-20210412121016593.png" alt="image-20210412121016593" style="zoom:50%;" /><p>同样，在<code>smd_ids</code>全局变量的<code>entries</code>数组中保存了<code>kern_ipc_perm</code>和<code>shmid_kernel</code>的组合，以便管理<code>IPC</code>对象的访问权限。对每个共享内存对象都创建一个伪文件，通过<code>shm_file</code>连接到<code>shmid_kernel</code>的实例。内核使用<code>shm_file-&gt;f_mapping</code>指针访问地址空间对象（<code>struct address_space</code>），用于创建匿名映射。还需要设置所涉及各进程的页表，使得各个进程都能够访问与该<code>IPC</code>对象相关的内存区域。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，程序对其访问都是原子操作，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是<strong><code>P</code>操作</strong>，这个操作会把信号量减去<code>-1</code>，相减后如果信号量<code>&lt; 0</code>，则表明资源已被占用，进程需阻塞等待；相减后如果信号量<code>&gt;= 0</code>，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是<strong><code>V</code>操作</strong>，这个操作会把信号量加上<code>1</code>，相加后如果信号量<code>&lt;= 0</code>，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量<code>&gt; 0</code>，则表明当前没有阻塞中的进程；</li></ul><p><code>P</code>操作是用在进入共享资源之前，<code>V</code>操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p><p>信号量初始化为<code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。信号初始化为<code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程<code>A</code>应在进程<code>B</code>之前执行。</p><p><strong>信号量的实现</strong>：</p><p><code>sem_queue</code>是一个数据结构，用于将信号量与睡眠进程关联起来，该进程想要执行信号量操作，但目前不允许执行。换句话说，信号量的待决操作列表中，每一项都是该数据结构的实例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>* <span class="title">next</span>;</span> <span class="comment">/*队列中下一项*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>* <span class="title">prev</span>;</span> <span class="comment">/*队列中的前一项，对于第一项有 *(q-&gt;prev) == q*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">sleeper</span>;</span> <span class="comment">/*睡眠的进程*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span>* <span class="title">undo</span>;</span> <span class="comment">/*用于撤销的结构*/</span></span><br><span class="line">    <span class="keyword">int</span> pid; <span class="comment">/*请求信号量操作的进程 ID*/</span></span><br><span class="line">    <span class="keyword">int</span> status; <span class="comment">/*操作的完成状态*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span>* <span class="title">sma</span> ;</span><span class="comment">/*操作的信号量数组*/</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">/*内部信号量 ID*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>* <span class="title">sops</span>;</span> <span class="comment">/*待决操作数组*/</span></span><br><span class="line">    <span class="keyword">int</span> nsops; <span class="comment">/*操作数目*/</span></span><br><span class="line">    <span class="keyword">int</span> alter; <span class="comment">/*操作是否改变了数组?*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对每个信号量，都有一个队列管理与信号量相关的所有睡眠进程。该队列并未使用内核的标准设施实现（即<code>struct list_head</code>），而是通过<code>next</code>和<code>prev</code>指针手工实现的。</p><ul><li><code>sleeper</code>是一个指针，指向等待执行信号量操作进程的<code>task_struct</code>实例。</li><li><code>pid</code>指定了等待进程的<code>PID</code>。</li><li><code>id</code>保存了标识该信号量的<code>ID</code>。</li><li><code>sops</code>是一个指针，指向保存待决信号量操作的数组。操作数目（即，数组的长度）在<code>nsops</code>中定义。</li><li><code>alter</code>表明操作是否修改信号量的值（例如，状态查询不改变值）。</li><li><code>sma</code>保存了一个指针，指向用于管理信号量状态的数据结构的实例。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">/*权限，参见ipc.h*/</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_otime; <span class="comment">/*最后一次信号量操作的时间*/</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_ctime; <span class="comment">/*最后一次修改的时间*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span> <span class="comment">/*指向数组中第一个信号量的指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span> <span class="comment">/*需要处理的待决操作*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>* <span class="title">sem_pending_last</span>;</span> <span class="comment">/*上一个待决操作*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span> <span class="comment">/*该数组上的撤销请求*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sem_nsems; <span class="comment">/*数组中信号量的数目*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>系统中的每个信号量集合，都对应于该数据结构的一个实例。该实例用于管理集合中的所有信号量（这个信号量集合指的是，每个进程操作信号量时，信号量都有一个值，将这些值组合在这个集合中，由下面要介绍的<code>sem_base</code>指向的数组表示）。</p><ul><li><p>信号量访问权限保存在我们熟悉的<code>kern_ipc_perm</code>类型的<code>sem_perm</code>成员中。</p></li><li><p><code>sem_nsems</code>指定了一个用户信号量集合中信号量的数目。</p></li><li><p><code>sem_base</code>是一个数组，每个数组项描述了集合中的一个信号量。其中保存了当前的信号量值和上一次访问它的进程的<code>PID</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> semval; <span class="comment">// 当前值</span></span><br><span class="line">    <span class="keyword">int</span> sempid; <span class="comment">// 上一次操作进程的 pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>sem_otime</code>指定了上一次访问信号量的时间。<code>sem_ctime</code>指定了上次修改信号量值的时间。</p></li><li><p><code>sem_pending</code>指向待决信号量操作的链表。该链表由<code>sem_queue</code>实例组成。<code>sem_pending_last</code>用于快速访问该链表的最后一个元素，而<code>sem_pending</code>指向链表的起始。</p></li></ul><img src="image-20210412170936487.png" alt="image-20210412170936487" style="zoom: 80%;" /><p>从当前命名空间获得<code>sem_ids</code>实例开始，内核通过<code>ipcs_idr</code>找到<code>ID</code>到指针的映射，在其中查找所需的<code>kern_ipc_perm</code>实例。<code>kern_ipc_perm</code>项可以转换为<code>sem_array</code>的实例。信号量的当前状态需要通过与另外两个结构的联系获取。</p><ul><li>待决操作通过<code>sem_queue</code>实例的链表管理。等待操作执行的睡眠进程，也可以通过该链表确定。</li><li><code>struct sem</code>实例的数组用于保存集合中各个信号量的值。</li></ul><p><code>kern_ipc_perm</code>是用来管理<code>IPC</code>对象的数据结构的第一个成员，不止对信号量是这样，消息队列和共享内存对象也是如此。这使得内核可以使用同样的代码检查所有<code>3</code>种对象的访问权限。放在第一个位置还方便转换为<code>sem_array</code>。</p><p>每个<code>sem_queue</code>成员包含了一个指针<code>sops</code>，指向<code>sembuf</code>实例的数组，<code>sembuf</code>详细描述了在信号量上将要执行的操作。使用<code>sembuf</code>实例的数组，可以使用一个<code>semctl</code>调用，用于在信号量集合的各个信号量上执行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sem_num; <span class="comment">// 信号量在数组中的索引</span></span><br><span class="line">    short sem_op; <span class="comment">// 信号量操作</span></span><br><span class="line">    short semflg; <span class="comment">// 操作标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它不仅保存了信号量在信号量集合<code>struct sem[]</code>中的索引（<code>sem_num</code>），还有所要进行的操作（<code>sem_op</code>）和一些操作标志（<code>sem_flg</code>）。</p><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong>在<code>Linux</code>操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过<code>kill -l</code>命令，查看所有的信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p>运行在<code>shell</code>终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li><code>Ctrl + C</code>产生<code>SIGINT</code>信号，表示终止该进程；</li><li><code>Ctrl + Z</code>产生<code>SIGTSTP</code>信号，表示停止该进程，但还未结束；</li></ul><p>如果进程在后台运行，可以通过<code>kill</code>命令的方式给进程发送信号，但前提需要知道运行中的进程<code>PID</code>号，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kill <span class="number">-9</span> <span class="number">1050</span></span><br></pre></td></tr></table></figure><p>表示给<code>PID</code>为<code>1050</code>的进程发送<code>SIGKILL</code>信号，用来立即结束该进程。</p><p>所以，信号事件的来源主要有硬件来源（如键盘<code>Cltr + C</code>）和软件来源（如<code>kill</code>命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><ol><li><p><strong>执行默认操作</strong>。<code>Linux</code>对每种信号都规定了默认操作，例如，上面列表中的<code>SIGTERM</code>信号，就是终止进程的意思。<code>Core</code>的意思是<code>Core Dump</code>，也即终止进程后，通过<code>Core Dump</code>将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p></li><li><p><strong>捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p></li><li><p><strong>忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即<code>SIGKILL</code>和<code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p></li></ol><h4 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h4><p>我们先来看看创建<code>socket</code>的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocal)</span></span></span><br></pre></td></tr></table></figure><p>三个参数分别代表：</p><ul><li><code>domain</code>参数用来指定协议族，比如<code>AF_INET</code>用于<code>IPV4</code>、<code>AF_INET6</code>用于<code>IPV6</code>、<code>AF_LOCAL/AF_UNIX</code>用于本机；</li><li><code>type</code>参数用来指定通信特性，比如<code>SOCK_STREAM</code>表示的是字节流，对应<code>TCP</code>、<code>SOCK_DGRAM</code>表示的是数据报，对应<code>UDP</code>、<code>SOCK_RAW</code>表示的是原始套接字；</li><li><code>protocal</code>参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，<code>protocol</code>目前一般写成<code>0</code>即可；</li></ul><p>根据创建<code>socket</code>类型的不同，通信的方式也就不同：</p><ul><li>实现<code>TCP</code>字节流通信：<code>socket</code>类型是<code>AF_INET</code>和<code>SOCK_STREAM</code>；</li><li>实现<code>UDP</code>数据报通信：<code>socket</code>类型是<code>AF_INET</code>和<code>SOCK_DGRAM</code>；</li><li>实现<strong>本地进程间通信</strong>：「本地字节流<code>socket</code>」类型是<code>AF_LOCAL</code>和<code>SOCK_STREAM</code>，「本地数据报<code>socket</code>」类型是<code>AF_LOCAL</code>和<code>SOCK_DGRAM</code>。另外，<code>AF_UNIX</code>和<code>AF_LOCAL</code>是等价的。</li></ul><p>本地字节流<code>socket</code>和本地数据报<code>socket</code>在<code>bind</code>的时候，不像<code>TCP</code>和<code>UDP</code>要绑定<code>IP</code>地址和端口，而是<strong>绑定一个本地文件</strong>，这也是它们之间的最大区别。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之队列和栈</title>
      <link href="/fhQPnKWa9qDDelG3/"/>
      <url>/fhQPnKWa9qDDelG3/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>5</code>部分——队列和栈。这里把有代表性的题目发出来，共计<code>21</code>道。主要涉及<code>BFS</code>和<code>DFS</code>算法。</p><p>接下来这几个月，计划完成的<code>leetcode</code>刷题系列其组织如下：</p><p><code>1</code>. 数组</p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. 字符串</p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. 动态规划</p><p><code>7</code>. 数据结构设计</p><p>预计涉及题目至少<code>200</code>道！</p><a id="more"></a><h4 id="Queue-and-Stack"><a href="#Queue-and-Stack" class="headerlink" title="Queue and Stack"></a><code>Queue and Stack</code></h4><h5 id="1660-Correct-a-Binary-Tree"><a href="#1660-Correct-a-Binary-Tree" class="headerlink" title="1660. Correct a Binary Tree"></a><a href="https://leetcode.com/problems/correct-a-binary-tree/" target="_blank" rel="noopener">1660. Correct a Binary Tree</a></h5><blockquote><p>你有一棵二叉树，这棵二叉树有个小问题，其中有且只有一个无效节点，它的右子节点错误地指向了与其在同一层且在其右侧的一个其他节点。</p><p>给定一棵这样的问题二叉树的根节点<code>root</code>，将该无效节点及其所有子节点移除（不移除被错误指向的节点），然后返回新二叉树的根结点。</p><p><strong>示例:</strong></p><img src="ex2v3.png" alt="img" style="zoom: 33%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode &#x3D; 7, toNode &#x3D; 4</span><br><span class="line">输出: [8,3,1,null,null,9,4,null,null,5,6]</span><br><span class="line">解释: 值为 7 的节点是无效的，所以移除这个节点及其子节点 2。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助层序遍历的思想</span></span><br><span class="line"><span class="comment">// 如果遍历到某一个节点, 发现其右孩子已经访问过了</span></span><br><span class="line"><span class="comment">// 就说明当前节点就是无效节点</span></span><br><span class="line"><span class="comment">// 但此时需要记录已经访问过的节点</span></span><br><span class="line"><span class="comment">// 如果要把此无效节点删除, 还要知道当前节点的父节点</span></span><br><span class="line"><span class="comment">// 因此, 使用一个哈希表记录所有访问过的节点以及这些节点的父节点</span></span><br><span class="line"><span class="comment">// 哈希表的映射有点特殊, 因为我们想达到这样的效果 mapping[node] == node's parent</span></span><br><span class="line"><span class="comment">// 因此, 每次访问一个节点 node 时</span></span><br><span class="line"><span class="comment">// 以 node 为值, 分别以其左右孩子(如果存在的话)为键加入哈希表</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">correctBinaryTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 队列仅仅用于完成层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="comment">// 当前节点和其父亲的映射的哈希表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt; mapping;</span><br><span class="line">    <span class="keyword">if</span>(root) q.push(root);</span><br><span class="line">    <span class="comment">// 标记是否找到了无效节点, 可用于提前结束遍历</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty() &amp;&amp; !flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 以上都是标准的层序遍历迭代实现的固定框架</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前节点的右孩子已经遍历过了</span></span><br><span class="line">            <span class="comment">// 说明找到无效节点</span></span><br><span class="line">            <span class="keyword">if</span>(mapping.count(node-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mapping[node]-&gt;left == node)</span><br><span class="line">                    <span class="comment">// 如果当前节点是其父节点的左孩子</span></span><br><span class="line">                    mapping[node]-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 否则是右孩子</span></span><br><span class="line">                    mapping[node]-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 否则继续遍历就是了</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) </span><br><span class="line">                &#123;</span><br><span class="line">                    mapping[node-&gt;left] = node;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    mapping[node-&gt;right] = node;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="394-Decode-String"><a href="#394-Decode-String" class="headerlink" title="394. Decode String"></a><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener">394. Decode String</a></h5><blockquote><p>  给定一个经过编码的字符串，返回它解码后的字符串。</p><p>  编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的<code>encoded_string</code>正好重复<code>k</code>次。注意<code>k</code>保证为正整数。</p><p>  你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>  此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数<code>k</code> ，例如不会出现像<code>3a</code>或<code>2[4]</code>的输入。</p><p>  <strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.size() &lt;= 30</code></li><li><code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.</li><li><code>s</code> is guaranteed to be <strong>a valid</strong> input.</li><li>All the integers in <code>s</code> are in the range <code>[1, 300]</code>.</li></ul><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">Output: &quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeatString</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = str;</span><br><span class="line">    <span class="keyword">while</span>(--count) str = s + str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; isdigits&#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">']'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> substr;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() != <span class="string">"["</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                substr = s.top() + substr;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.pop(); <span class="comment">// pop 掉相匹配的那个 '['</span></span><br><span class="line">            <span class="comment">// 获取 [] 前面的那个数字, 注意可能是多位数</span></span><br><span class="line">            <span class="built_in">string</span> numstr;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; isdigits.count(s.top()))</span><br><span class="line">            &#123;</span><br><span class="line">                numstr = s.top() + numstr;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 [] 中的字串重复指定次</span></span><br><span class="line">            repeatString(substr, stoi(numstr));</span><br><span class="line">            <span class="comment">// 新串再次入栈</span></span><br><span class="line">            s.push(substr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> s.push(<span class="built_in">string</span>(<span class="number">1</span>, c));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这时从栈底到栈顶的所有串连在一起其实就是答案了</span></span><br><span class="line">    <span class="comment">// 但是要转为 string 返回</span></span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        res = s.top() + res;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="752-Open-the-Lock"><a href="#752-Open-the-Lock" class="headerlink" title="752. Open the Lock"></a><a href="https://leetcode.com/problems/open-the-lock/" target="_blank" rel="noopener">752. Open the Lock</a></h5><blockquote><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有<code>10</code>个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code>。每个拨轮可以自由旋转：例如把<code>&#39;9&#39;</code>变为<code>&#39;0&#39;</code>，<code>&#39;0&#39;</code>变为<code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为<code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p><p>列表<code>deadends</code>包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串<code>target</code>代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回<code>-1</code>。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target &#x3D; &quot;0202&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.</span><br><span class="line">Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,</span><br><span class="line">because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;8888&quot;], target &#x3D; &quot;0009&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宽度优先遍历 BFS 通常用来解决最小(距离)、最短(路径)、最少(步数)等问题</span></span><br><span class="line"><span class="comment">// 先给出 BFS 算法框架</span></span><br><span class="line"><span class="comment">// 计算从 [开始状态] 到 [目标状态]的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(STATE startState, STATE targetState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;STATE&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;STATE&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.push(startState); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.insert(startState);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有状态分别向其所有相邻状态转换 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            STATE curState = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 下面代码是需要你根据实际问题的逻辑做调整的</span></span><br><span class="line">            <span class="comment">/***************************************/</span></span><br><span class="line">            <span class="comment">/* 划重点: 这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (curState is targetState) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的所有相邻状态加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (STATE state : all adjacent states of curState )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (state <span class="keyword">not</span> in visited)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(state);</span><br><span class="line">                    visited.insert(state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***************************************/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点: 更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于我们这题打开密码锁的问题</span></span><br><span class="line"><span class="comment">// 就是穷举所有的密码组合, 直到到达目标密码</span></span><br><span class="line"><span class="comment">// 密码锁初始值(开始状态)为 "0000", 一共四个位置, 每个位置可以向上或向下拨动, 也就是有 8 个相邻状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; deads;</span><br><span class="line">    <span class="comment">// 将死亡密码加入哈希集合</span></span><br><span class="line">    <span class="comment">// 其实这里是可以直接用 visited, 就是说直接把死亡密码看作已经被访问过了, 一样的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : deadends)</span><br><span class="line">        deads.insert(elem);</span><br><span class="line"></span><br><span class="line">    q.push(<span class="string">"0000"</span>);</span><br><span class="line">    visited.insert(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> qSize = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从队列中取出一个状态访问</span></span><br><span class="line">            <span class="built_in">string</span> curLock = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 如果当前状态在死亡状态里面</span></span><br><span class="line">            <span class="comment">// 说明我们不能够到达这个状态</span></span><br><span class="line">            <span class="comment">// 因此也就不可能从这个状态向其它相邻状态转换</span></span><br><span class="line">            <span class="comment">// 继续取出队列中的下一个状态</span></span><br><span class="line">            <span class="keyword">if</span>(deads.count(curLock)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果当前状态是目标状态了</span></span><br><span class="line">            <span class="keyword">if</span>(curLock == target) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 否则, 向相邻的 8 个状态转换</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将第 j 个字符向上拨动</span></span><br><span class="line">                <span class="built_in">string</span> upRotate = rotate(curLock, j, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!visited.count(upRotate))</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(upRotate);</span><br><span class="line">                    visited.insert(upRotate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将第 j 个字符向下拨动</span></span><br><span class="line">                <span class="built_in">string</span> downRotate = rotate(curLock, j, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(!visited.count(downRotate))</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(downRotate);</span><br><span class="line">                    visited.insert(downRotate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// direction 为 1 向上拨动, 为 0 则向下拨动</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">rotate</span><span class="params">(<span class="built_in">string</span> theLock, <span class="keyword">int</span> position, <span class="keyword">bool</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(direction)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(theLock[position] == <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            theLock[position] = <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">return</span> theLock;</span><br><span class="line">        &#125;</span><br><span class="line">        theLock[position]++;</span><br><span class="line">        <span class="keyword">return</span> theLock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(theLock[position] == <span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            theLock[position] = <span class="string">'9'</span>;</span><br><span class="line">            <span class="keyword">return</span> theLock;</span><br><span class="line">        &#125;</span><br><span class="line">        theLock[position]--;</span><br><span class="line">        <span class="keyword">return</span> theLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. Sudoku Solver</a></h5><blockquote><p>编写一个程序，通过填充空格来解决数独问题。</p><p>一个数独的解法需遵循如下规则：</p><ol><li>数字<code>1-9</code>在每一行只能出现一次。</li><li>数字<code>1-9</code>在每一列只能出现一次。</li><li>数字<code>1-9</code>在每一个以粗实线分隔的<code>3x3</code>宫内只能出现一次。空白格用<code>&#39;.&#39;</code>表示。</li></ol><table><thead><tr><th align="center">一个数独</th><th align="center">红色为答案</th></tr></thead><tbody><tr><td align="center"><img src="250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></td><td align="center"><img src="250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是深度优先搜索算法应用的典型题目</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前行填写完了, 就到下一行</span></span><br><span class="line">    <span class="keyword">if</span>(col == board.size()) <span class="keyword">return</span> dfs(board, row + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果最后一行也填完了, 就说明找到了数独的一个解</span></span><br><span class="line">    <span class="keyword">if</span>(row == board.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果当前格子中已经有数了就跳过这个格子</span></span><br><span class="line">    <span class="keyword">if</span>(board[row][col] != <span class="string">'.'</span>) <span class="keyword">return</span> dfs(board, row, col + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 针对当前格子</span></span><br><span class="line">    <span class="comment">// 从数字 1 到 9 依次尝试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前格子放置这个数字不符合那 3 条规则就跳过</span></span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, row, col, c)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = c;</span><br><span class="line">        <span class="comment">// 这里的 if 语句可以在找到一组解的时候立即返回</span></span><br><span class="line">        <span class="comment">// 不至于找到所有可能的解</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(board, row, col + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前行不能有数字重复</span></span><br><span class="line">        <span class="keyword">if</span>(board[row][i] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当前列不能有数字重复</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][col] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当前格子所在的九宫格不能有数字重复</span></span><br><span class="line">        <span class="comment">// 这特么还真不好写, 看不懂就背下吧</span></span><br><span class="line">        <span class="keyword">if</span>(board[(row / <span class="number">3</span>) * <span class="number">3</span> + i / <span class="number">3</span>][(col / <span class="number">3</span>) * <span class="number">3</span> + i % <span class="number">3</span>] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">279. Perfect Squares</a></h5><blockquote><p>给定正整数<code>n</code>，找到若干个完全平方数（比如<code>1, 4, 9, 16, ...</code>）使得它们的和等于<code>n</code>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数<code>n</code> ，返回和为<code>n</code>的完全平方数的最少数量。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 12</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DP 递推式: numSquares(n) = min(numSquares(n - k)) + 1</span></span><br><span class="line"><span class="comment">// 有点 找零钱 那题的那味儿</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; squares;</span><br><span class="line">    <span class="comment">// 先计算出所有符合条件的完全平方数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)</span><br><span class="line">        squares.push_back(i * i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> square : squares)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - square &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            dp[i] = min(dp[i], dp[i - square]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 穷举所有完全平方数相加的组合, 直到一组的和等于目标数</span></span><br><span class="line"><span class="comment">// 因为要找用到的 [最少的] 完全平方数, 所以使用 BFS</span></span><br><span class="line"><span class="comment">// 第 1 轮: 搜索所有 1 位数字判断是否满足</span></span><br><span class="line"><span class="comment">// 将 0 + (1, 2, 4, 9, ...) 的数字依次放进队列中</span></span><br><span class="line"><span class="comment">// 第 2 轮: 搜索所有 2 位数字的和并判断是否满足</span></span><br><span class="line"><span class="comment">// 将 1 + (1, 2, 4, 9, ...) 的数字依次放进队列中</span></span><br><span class="line"><span class="comment">// 将 2 + (1, 2, 4, 0, ...) 的数字依次放进队列中</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 第 3 轮: 搜索所有 3 位数字和并判断是否满足</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 你会发现我们穷举的时候遇到了大量同样的数字组合, 因此使用一个哈希集合来跳过它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur == n) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 直到完全平方数大于目标数</span></span><br><span class="line">            <span class="comment">// 这里的循环相当于是找当前值的所有可能的邻居</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = cur + j * j;</span><br><span class="line">                <span class="comment">// 如果完全平方数的和还小于目标数</span></span><br><span class="line">                <span class="comment">// 或者这个和没有被访问, 才加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(temp &lt;= n &amp;&amp; !visited.count(temp))</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp);</span><br><span class="line">                    visited.insert(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">155. Min Stack</a></h5><blockquote><p>  设计一个支持<code>push</code>，<code>pop</code>，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p><p>  <code>push(x)</code> —— 将元素<code>x</code>推入栈中。<br>  <code>pop()</code> —— 删除栈顶的元素。<br>  <code>top()</code> —— 获取栈顶元素。<br>  <code>getMin()</code> —— 检索栈中的最小元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() : _minVal(INT_MIN) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; _minVal || _data.empty()) _minVal = x;</span><br><span class="line">        _data.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(_data.back() == _minVal)</span><br><span class="line">            _minVal = *min_element(_data.begin(), _data.end() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        _data.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _minVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">    <span class="keyword">int</span> _minVal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a><a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. Daily Temperatures</a></h5><blockquote><p>  请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用<code>0</code>来代替。</p><p>  例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题本质上就是找到当前元素的下一个比它大的元素</span></span><br><span class="line"><span class="comment">// 然后两者的索引相减即可</span></span><br><span class="line"><span class="comment">// 像这样和下一个更大元素有关的问题都需要使用一种单调栈的技巧</span></span><br><span class="line"><span class="comment">// 就是说维护一个栈, 使其中的元素保持单调的次序</span></span><br><span class="line"><span class="comment">// 下面的代码就是单调栈的模板</span></span><br><span class="line"><span class="comment">// 这里维护着从栈底到栈顶递减的次序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 倒着遍历入栈, 因此也就是正着出栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = T.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素比栈首元素大</span></span><br><span class="line">        <span class="comment">// 那么栈的首元素出栈让出位子</span></span><br><span class="line">        <span class="comment">// 直到首元素比当前元素大了才把当前元素压入栈</span></span><br><span class="line">        <span class="comment">// 注意这里栈内放的是索引</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; T[s.top()] &lt;= T[i])</span><br><span class="line">            s.pop();</span><br><span class="line">        <span class="comment">// 更新数组中第 i 个元素的下一个更大的元素</span></span><br><span class="line">        <span class="comment">// 就在栈首</span></span><br><span class="line">        res[i] = s.empty() ? <span class="number">0</span> : (s.top() - i);</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="496-Next-Greater-Element-I"><a href="#496-Next-Greater-Element-I" class="headerlink" title="496. Next Greater Element I"></a><a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. Next Greater Element I</a></h5><blockquote><p>  给你两个没有重复元素的数组<code>nums1</code>和<code>nums2</code>，其中<code>nums1</code>是<code>nums2</code>的子集。</p><p>  请你找出<code>nums1</code>中每个元素在<code>nums2</code>中的下一个比其大的值。</p><p>  <code>nums1</code>中数字<code>x</code>的下一个更大元素是指<code>x</code>在<code>nums2</code>中对应位置的右边的第一个比<code>x</code>大的元素。如果不存在，对应位置输出<code>-1</code> 。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2]</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接套用单调栈的模板</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里用哈希表来存放答案</span></span><br><span class="line">    <span class="comment">// 记录着 nums2 数组中的每个元素与其下一个更大的元素之间的映射</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums2.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt;= nums2[i])</span><br><span class="line">            s.pop();</span><br><span class="line">        mapping[nums2[i]] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line">    <span class="comment">// 直接从哈希表中获取 nums1 数组中元素的下一个更大元素即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">        res[i] = mapping[nums1[i]];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="503-Next-Greater-Element-II"><a href="#503-Next-Greater-Element-II" class="headerlink" title="503. Next Greater Element II"></a><a href="https://leetcode.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. Next Greater Element II</a></h5><blockquote><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字<code>x</code>的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出<code>-1</code>。</p><img src="2-1616932759606.jpeg" alt="2" style="zoom: 33%;" /><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: [1,2,1]</span><br><span class="line">&gt;Output: [2,-1,2]</span><br><span class="line">&gt;Explanation: The first 1&#39;s next greater number is 2; The number 2 can&#39;t find next greater number; The second 1&#39;s next greater number needs to search circularly, which is also 2.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里和 I 题的区别是, 数组可以循环</span></span><br><span class="line"><span class="comment">// 也就是说从当前位置一直向后看去, 直到找到下一个更大元素为止</span></span><br><span class="line"><span class="comment">// 如果找到了尾元素则从首元素开始继续找</span></span><br><span class="line"><span class="comment">// 可以看作在原始数组后面又接了一段原始数组(见上图)</span></span><br><span class="line"><span class="comment">// 你当然可以申请一段两倍的数组空间来这放元素</span></span><br><span class="line"><span class="comment">// 但是, 下面来学习一个循环遍历数组的技巧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先直接套用单调栈的模板</span></span><br><span class="line"><span class="comment">// 其中改动的地方就是能够循环遍历数组的技巧</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])</span><br><span class="line">            s.pop();</span><br><span class="line">        res[i % n] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="556-Next-Greater-Element-III"><a href="#556-Next-Greater-Element-III" class="headerlink" title="556. Next Greater Element III"></a><a href="https://leetcode.com/problems/next-greater-element-iii/" target="_blank" rel="noopener">556. Next Greater Element III</a></h5><blockquote><p>  给你一个正整数<code>n</code>，请你找出符合条件的最小整数，其由重新排列<code>n</code>中存在的每位数字组成，并且其值大于<code>n</code>。如果不存在这样的正整数，则返回<code>-1</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 320241</span><br><span class="line">Output: 320412</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 321</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要想到的是先把数字转成字符串, 方便处理</span></span><br><span class="line"><span class="comment">// 然后再试想一下, 影响数值前后发生大小变化的决定因素什么</span></span><br><span class="line"><span class="comment">// 不知道你脑子里有没有蹦出 [逆序对] 三个字</span></span><br><span class="line"><span class="comment">// 注意我这里的 [逆序对] 是指, 原本降序排列的数, 其中相邻的一对数字是升序</span></span><br><span class="line"><span class="comment">// 如果你想到了这个, 那问题就很简单了</span></span><br><span class="line"><span class="comment">// 对于数字其中的一个逆序对</span></span><br><span class="line"><span class="comment">// 如果你把这两个数字交换, 值是不是就变大了？</span></span><br><span class="line"><span class="comment">// 但这题要找变大之后的数中最小的数</span></span><br><span class="line"><span class="comment">// 那就只需要对最后边的一个逆序对操作嘛</span></span><br><span class="line"><span class="comment">// 但是还是不能简单的将逆序对的数字交换</span></span><br><span class="line"><span class="comment">// 需要将逆序对的前一个元素和它后面的最后一个比它大的数交换才行</span></span><br><span class="line"><span class="comment">// 交换完之后还要将逆序对后面的所有元素进行一次反转</span></span><br><span class="line"><span class="comment">// 因为此时后面的那些元素必定是降序排列的, 反转之后值会进一步变小</span></span><br><span class="line"><span class="comment">// 说起来太抽象了, 下面直接看代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(to_string(n))</span></span>;</span><br><span class="line">    <span class="comment">// 从后往前走</span></span><br><span class="line">    <span class="comment">// 定位到第一个逆序对, pivot 指向逆序对的第一个元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = s.size() - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(; pivot &gt;= <span class="number">0</span>; pivot--)</span><br><span class="line">        <span class="keyword">if</span>(s[pivot] &lt; s[pivot + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 如果没有逆序对, 说明不可能组合成比原来大的数</span></span><br><span class="line">    <span class="keyword">if</span>(pivot == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 从后往前走, 定位到第一个比 pivot 指向元素大的元素</span></span><br><span class="line">    <span class="keyword">int</span> larger = s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; larger &gt; pivot; larger--)</span><br><span class="line">        <span class="keyword">if</span>(s[pivot] &lt; s[larger]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 交换二者</span></span><br><span class="line">    swap(s[pivot], s[larger]);</span><br><span class="line">    <span class="comment">// 这时候 pivot 之后的所有元素肯定是降序排列的</span></span><br><span class="line">    <span class="comment">// 反转它们, 以求数值最小</span></span><br><span class="line">    reverse(s.begin() + pivot + <span class="number">1</span>, s.end());</span><br><span class="line">    <span class="comment">// 如果这个数比 int 类型数值范围, 就不符合题目要求了</span></span><br><span class="line">    <span class="keyword">if</span>(stol(s) &gt; INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> stoi(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="133-Clone-Graph"><a href="#133-Clone-Graph" class="headerlink" title="133. Clone Graph"></a><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">133. Clone Graph</a></h5><blockquote><p>  给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。</p><p>  图中的每个节点都包含它的值<code>val</code>（<code>int</code>）和其邻居的列表<code>list[Node]</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   <span class="built_in">vector</span>&lt;Node *&gt; neighbors;</span><br><span class="line">   Node(<span class="keyword">int</span> _val)</span><br><span class="line">   &#123;</span><br><span class="line">       val = _val;</span><br><span class="line">       neighbors = <span class="built_in">vector</span>&lt;Node *&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  <strong>Example:</strong></p>  <img src="133_clone_graph_question.png" alt="img" style="zoom: 25%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Output: [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Explanation: There are 4 nodes in the graph.</span><br><span class="line">1st node (val &#x3D; 1)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">2nd node (val &#x3D; 2)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br><span class="line">3rd node (val &#x3D; 3)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">4th node (val &#x3D; 4)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接深度优先搜索即可</span></span><br><span class="line"><span class="comment">// 只是需要使用一个哈希表来记录已经 new 过的节点</span></span><br><span class="line"><span class="comment">// 哈希表中记录的是原节点和拷贝节点之间的映射</span></span><br><span class="line"><span class="comment">// 下次通过某节点的邻居遍历到相同的节点直接从哈希表中取就可以了</span></span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; visited;</span><br><span class="line">    <span class="keyword">return</span> dfs(node, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node, <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果这个节点已经 被克隆过了</span></span><br><span class="line">    <span class="comment">// 直接从哈希表中返回其映射</span></span><br><span class="line">    <span class="keyword">if</span>(visited.count(node)) <span class="keyword">return</span> visited[node];</span><br><span class="line">    <span class="comment">// 克隆当前节点</span></span><br><span class="line">    Node* res = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">    <span class="comment">// 记录映射</span></span><br><span class="line">    visited[node] = res;</span><br><span class="line">    <span class="comment">// 深度遍历其所有邻居</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; neighbors = node-&gt;neighbors;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; neighbors.size(); i++)</span><br><span class="line">        <span class="comment">// 将其一一添加进拷贝节点的邻居中</span></span><br><span class="line">        res-&gt;neighbors.push_back(dfs(neighbors[i], visited));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">494. Target Sum</a></h5><blockquote><p>  给定一个非负整数数组，<code>a1, a2, ..., an</code>和一个目标数<code>S</code>。现在你有两个符号<code>+</code>和<code>-</code>。对于数组中的任意一个整数，你都可以从<code>+</code>或<code>-</code>中选择一个符号添加在前面。</p><p>  返回可以使最终数组和为目标数<code>S</code>的所有添加符号的方法数。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先上暴力搜索 (dfs)</span></span><br><span class="line"><span class="comment">// 注意这里用到的一个技巧是</span></span><br><span class="line"><span class="comment">// 等式左边的数相加或相减起来 = S, 等价于 S + 等式左边的那些数相加或相减 = 0</span></span><br><span class="line"><span class="comment">// 它们的个数肯定相等嘛</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs(nums, <span class="number">0</span>, S);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos, <span class="keyword">long</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="number">0</span>) count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// S += nums[pos]; // 做选择</span></span><br><span class="line">    <span class="comment">// dfs(nums, pos + 1, S);</span></span><br><span class="line">    <span class="comment">// S -= nums[pos]; // 撤销选择</span></span><br><span class="line">    dfs(nums, pos + <span class="number">1</span>, S + nums[pos]); <span class="comment">// 函数进入自动做选择, 返回自动撤销选择</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// S -= nums[pos]; // 做选择</span></span><br><span class="line">    <span class="comment">// dfs(nums, pos + 1, S);</span></span><br><span class="line">    <span class="comment">// S += nums[pos]; // 撤销选择</span></span><br><span class="line">    dfs(nums, pos + <span class="number">1</span>, S - nums[pos]); <span class="comment">// 函数进入自动做选择, 返回自动撤销选择</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再上动态规划</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. Implement Queue using Stacks</a></h5><blockquote><p>  请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作：</p><p>  实现<code>MyQueue</code>类：</p><p>  <code>void push(int x)</code>：将元素x推到队列的末尾；<br>  <code>int pop()</code>：从队列的开头移除并返回元素；<br>  <code>int peek()</code>：返回队列开头的元素；<br>  <code>bool empty()</code>：如果队列为空，返回<code>true</code>；否则，返回<code>false</code>。</p>  <img src="2.jpg" alt="img" style="zoom: 33%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如上图, 将两个栈这样放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 入栈的时候直接放进右边的栈即可</span></span><br><span class="line">        _back.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 出栈的时候从左边出</span></span><br><span class="line">        <span class="comment">// 如果为空, 需要把右边栈的元素搬过来</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) moveData();</span><br><span class="line">        <span class="comment">// 搬过来之后直接 pop 左边的栈即可</span></span><br><span class="line">        <span class="keyword">int</span> res = _front.top();</span><br><span class="line">        _front.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 取的时候和 pop 的情况一样</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) moveData();</span><br><span class="line">        <span class="comment">// 只是不出栈, 只取元素</span></span><br><span class="line">        <span class="keyword">return</span> _front.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _front.empty() &amp;&amp; _back.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _front;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _back;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 搬移数据就是简单的将右边栈出栈</span></span><br><span class="line">        <span class="comment">// 左边栈接收元素压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(!_back.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            _front.push(_back.top());</span><br><span class="line">            _back.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. Implement Stack using Queues</a></h5><blockquote><p>  请你仅使用两个队列实现一个后入先出的栈，并支持普通队列的全部四种操作。</p><p>  实现<code>MyStack</code>类：</p><p>  <code>void push(int x)</code>：将元素<code>x</code>压入栈顶；<br>  <code>int pop()</code>：移除并返回栈顶元素；<br>  <code>int top()</code>：返回栈顶元素；<br>  <code>bool empty()</code>：如果栈是空的，返回<code>true</code>；否则，返回<code>false</code>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列实现栈</span></span><br><span class="line"><span class="comment">// 入栈操作很简单, 调用队列的 push 即可</span></span><br><span class="line"><span class="comment">// 出栈麻烦点, 因为队列只能从对头出列, 对头相当于栈的栈底</span></span><br><span class="line"><span class="comment">// 但我们是想 pop 掉队尾元素</span></span><br><span class="line"><span class="comment">// 这时很暴力, 直接把队列中除了队尾之外的所有元素依次出队并依次入队即可</span></span><br><span class="line"><span class="comment">// 这时对头就是原队尾元素了, 再出队就行</span></span><br><span class="line"><span class="comment">// 获取栈顶元素的话, 为了实现 O(1) 复杂度</span></span><br><span class="line"><span class="comment">// 使用一个变量实时记录队尾 (栈顶) 元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 入队的时候要更新栈顶变量</span></span><br><span class="line">        _top = x;</span><br><span class="line">        _queue.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _queue.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _top = _queue.front();</span><br><span class="line">            _queue.pop();</span><br><span class="line">            _queue.push(_top);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = _queue.front();</span><br><span class="line">        _queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line">    <span class="keyword">int</span> _top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands</a></h5><blockquote><p>给定一个<code>m x n</code>字符栅格网格，该栅格网格表示<code>&#39;1&#39;</code>（土地）和<code>&#39;0&#39;</code>（水）的地图，请返回岛的数量。</p><p>一个岛屿被水包围，是通过水平或垂直连接相邻的土地而形成的。 您可以假设网格的所有四个边缘都被水包围。</p><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想是</span></span><br><span class="line"><span class="comment">// 1. 依次遍历网格中的每一个字符</span></span><br><span class="line"><span class="comment">// 2. 如果当前字符是 '1' 说明踏上了一座岛, 进行下一步, 如果为 '0'，回到步骤 1</span></span><br><span class="line"><span class="comment">// 3. 然后骚操作来了, 将当前字符赋值为 '0'</span></span><br><span class="line"><span class="comment">// 4. 然后遍历当前字符的上下左右四个邻居</span></span><br><span class="line"><span class="comment">// 5. 每到一个邻居重复对当前字符的操作</span></span><br><span class="line"><span class="comment">// 6. 直到某一个邻居 (可以是邻居的邻居) 的四个邻居都为'0'</span></span><br><span class="line"><span class="comment">// 7. 说明这座岛的每一个陆地都走过了, 此时岛数量 +1</span></span><br><span class="line"><span class="comment">// 8. 接下来再到下一个字符, 回到步骤 1</span></span><br><span class="line"><span class="comment">// 遍历邻居的时候有两种方法, dfs 和 bfs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs 借助队列的迭代实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中保存的是当前陆地的坐标</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                count++;</span><br><span class="line">                q.push(&#123;i, j&#125;);</span><br><span class="line">                <span class="comment">// while 循环的目的是把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                <span class="keyword">while</span>(!q.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = q.front().first;</span><br><span class="line">                    <span class="keyword">int</span> c = q.front().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size()</span><br><span class="line">                       || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 淹没陆地</span></span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="comment">// 判断左邻居</span></span><br><span class="line">                    q.push(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="comment">// 判断右邻居</span></span><br><span class="line">                    q.push(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="comment">// 判断上邻居</span></span><br><span class="line">                    q.push(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="comment">// 判断下邻居</span></span><br><span class="line">                    q.push(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="694-Number-of-Distinct-Islands"><a href="#694-Number-of-Distinct-Islands" class="headerlink" title="694. Number of Distinct Islands"></a><a href="https://leetcode.com/problems/number-of-distinct-islands/" target="_blank" rel="noopener">694. Number of Distinct Islands</a></h5><blockquote><p>  给定一个非空<code>01</code>二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的<code>1</code>组成，你可以认为网格的四周被海水包围。</p><p>  请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。</p><p>  <strong>示例 1：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00011</span><br><span class="line">00011</span><br><span class="line">给定上图，返回结果 1 。</span><br></pre></td></tr></table></figure><p>  <strong>示例 2：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11011</span><br><span class="line">10000</span><br><span class="line">00001</span><br><span class="line">11011</span><br><span class="line">给定上图，返回结果 3 。</span><br></pre></td></tr></table></figure><p>  注意：</p><p>  11<br>  1</p><p>  和</p><p>  1<br>  11<br>  是不同的岛屿，因为我们不考虑旋转、翻转操作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; setting;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                <span class="comment">// isLand 用于记录这座岛的所有陆地坐标</span></span><br><span class="line">                <span class="comment">// 实际记录的是相对陆地坐标, 即其他陆地相对于左上角的那块陆地</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; isLand;</span><br><span class="line">                <span class="comment">// 更新当前岛屿的相对坐标</span></span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, isLand, i, j);</span><br><span class="line">                <span class="comment">// set 有自动排序和去重的功能</span></span><br><span class="line">                setting.insert(isLand);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setting.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; isLand, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    isLand.push_back(&#123;r - x, c - y&#125;);</span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, isLand, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, isLand, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, isLand, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, isLand, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1254-Number-of-Closed-Islands"><a href="#1254-Number-of-Closed-Islands" class="headerlink" title="1254. Number of Closed Islands"></a><a href="https://leetcode.com/problems/number-of-closed-islands/" target="_blank" rel="noopener">1254. Number of Closed Islands</a></h5><blockquote><p>  有一个二维矩阵<code>grid</code>，每个位置要么是陆地（记号为<code>0</code>）要么是水域（记号为<code>1</code>）。</p><p>  我们从一块陆地出发，每次可以往上下左右<code>4</code>个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。</p><p>  如果一座岛屿完全由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。</p><p>  请返回封闭岛屿的数目。</p><p>  <strong>Example 1:</strong></p><p>  <img src="sample_3_1610.png" alt="img"></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Islands in gray are closed because they are completely surrounded by water (group of 1s).</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p><p>  <img src="sample_4_1610.png" alt="img"></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这题 1 代表水域而 0 代表陆地</span></span><br><span class="line"><span class="comment">// 和岛屿数量 I 题的区别在于边界上的岛屿不算岛屿</span></span><br><span class="line"><span class="comment">// 所以如果搜索出来的岛屿在边界上就不更新岛屿数</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">// 是否是封闭岛的标志</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowLength = grid.size();</span><br><span class="line">    <span class="keyword">int</span> colLength = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colLength; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                <span class="comment">// 看它是否是边界岛</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                <span class="keyword">if</span>(flag) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 能到达边界, 说明不是封闭岛</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(grid[r][c] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="695-Max-Area-of-Island"><a href="#695-Max-Area-of-Island" class="headerlink" title="695. Max Area of Island"></a><a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener">695. Max Area of Island</a></h5><blockquote><p>  给定一个包含了一些<code>0</code>和<code>1</code>的非 空二维数组<code>grid</code>。</p><p>  一个岛屿是由一些相邻的<code>1</code>(代表土地) 构成的组合，这里的「相邻」要求两个<code>1</code>必须在水平或者竖直方向上相邻。你可以假设<code>grid</code>的四个边缘都被<code>0</code>（代表水）包围着。</p><p>  找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为<code>0</code> )</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">[0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line">[0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line">[0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">Given the above grid, return &#96;6&#96;. Note the answer is not 11, because the island must be connected 4-directionally.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">Given the above grid, return &#96;0&#96;.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="keyword">int</span> area; <span class="comment">// 用于记录每个岛的面积</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛就把先前岛屿面积清零</span></span><br><span class="line">                area = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res = max(res, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    area++;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="733-Flood-Fill"><a href="#733-Flood-Fill" class="headerlink" title="733. Flood Fill"></a><a href="https://leetcode.com/problems/flood-fill/" target="_blank" rel="noopener">733. Flood Fill</a></h5><blockquote><p>  有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在<code>0</code>到<code>65535</code>之间。</p><p>  给你一个坐标<code>(sr, sc)</code>表示图像渲染开始的像素值（行 ，列）和一个新的颜色值<code>newColor</code>，让你重新上色这幅图像。</p><p>  为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>  最后返回经过上色渲染后的图像。</p><p>  <strong>Example:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected </span><br><span class="line">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class="line">to the starting pixel.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和前面那个岛屿数量 I 的题思路差不多</span></span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(image[sr][sc] != newColor)</span><br><span class="line">        dfs(image, sr, sc, image[sr][sc], newColor);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> srcColor, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == image.size() || c == image[<span class="number">0</span>].size() || image[r][c] != srcColor)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    image[r][c] = newColor;</span><br><span class="line">    dfs(image, r + <span class="number">1</span>, c, srcColor, newColor);</span><br><span class="line">    dfs(image, r - <span class="number">1</span>, c, srcColor, newColor);</span><br><span class="line">    dfs(image, r, c + <span class="number">1</span>, srcColor, newColor);</span><br><span class="line">    dfs(image, r, c - <span class="number">1</span>, srcColor, newColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> srcColor = image[sr][sc];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(&#123;sr, sc&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> c = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == image.size() || c == image[<span class="number">0</span>].size() || image[r][c] != srcColor)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            image[r][c] = newColor;</span><br><span class="line">            q.push(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">            q.push(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">            q.push(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">            q.push(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="542-01-Matrix"><a href="#542-01-Matrix" class="headerlink" title="542. 01 Matrix"></a><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 Matrix</a></h5><blockquote><p>给定一个由<code>0</code>和<code>1</code>组成的矩阵，找出每个元素到最近的<code>0</code>的距离。</p><p>两个相邻元素间的距离为<code>1</code>。矩阵中的元素只在四个方向上相邻：上、下、左、右。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[0,0,0]]</span><br><span class="line"></span><br><span class="line">&gt;Output:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[0,0,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[1,1,1]]</span><br><span class="line"></span><br><span class="line">&gt;Output:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[1,2,1]]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为要寻找 [最近] 距离, 所以显然使用 BFS</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rSize = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> cSize = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(rSize, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cSize))</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为要对矩阵中的所有元素进行寻找最近的 0</span></span><br><span class="line">    <span class="comment">// 所以外面的两层循环实际上是处理这个问题的</span></span><br><span class="line">    <span class="comment">// 如果只需要对一个元素进行寻找就不需要这两层循环, 和传统的 BFS 模板一样</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            step = <span class="number">0</span>;</span><br><span class="line">            q.push(&#123;i, j&#125;);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sz = q.size();</span><br><span class="line">                <span class="keyword">while</span>(sz--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 从当前位置出发, 遍历其所有邻居</span></span><br><span class="line">                    <span class="keyword">int</span> r = q.front().first;</span><br><span class="line">                    <span class="keyword">int</span> c = q.front().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    <span class="comment">// 如果 走到了 0, 那么它离 0 的最近距离就是已经走的 step</span></span><br><span class="line">                    <span class="keyword">if</span>(matrix[r][c] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res[i][j] = step;</span><br><span class="line">                        <span class="comment">// 更新完 step 之后还要将队列清空方便对下一位置进行搜索时使用</span></span><br><span class="line">                        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将其上下左右四个邻居入栈等待搜索</span></span><br><span class="line">                    <span class="keyword">if</span>(r + <span class="number">1</span> &lt; rSize) q.push(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(r - <span class="number">1</span> &gt;= <span class="number">0</span>) q.push(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(c + <span class="number">1</span> &lt; cSize) mq.push(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(c - <span class="number">1</span> &gt;= <span class="number">0</span>) q.push(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="841-Keys-and-Rooms"><a href="#841-Keys-and-Rooms" class="headerlink" title="841. Keys and Rooms"></a><a href="https://leetcode.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. Keys and Rooms</a></h5><blockquote><p>  有<code>N</code>个房间，开始时你位于<code>0</code>号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p><p>  在形式上，对于每个房间<code>i</code>都有一个钥匙列表<code>rooms[i]</code>，每个钥匙<code>rooms[i][j]</code>由<code>[0,1，...，N-1]</code>中的一个整数表示，其中<code>N = rooms.length</code>。 钥匙<code>rooms[i][j] = v</code>可以打开编号为<code>v</code>的房间。</p><p>  最初，除<code>0</code>号房间外的其余所有房间都被锁住。</p><p>  你可以自由地在房间之间来回走动。</p><p>  如果能进入每个房间返回<code>true</code>，否则返回<code>false</code>。</p><p>  <strong>Note:</strong></p><ol><li><code>1 &lt;= rooms.length &lt;= 1000</code></li><li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li><li>The number of keys in all rooms combined is at most <code>3000</code>.</li></ol><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&#39;t enter the room with number 2.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为最多就 1000 个房间</span></span><br><span class="line"><span class="comment">// 需要对已经访问过的房间进行标记</span></span><br><span class="line"><span class="comment">// 所以这里我们使用一个 bitset</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 所有房间初始化全未被访问</span></span><br><span class="line">    <span class="built_in">bitset</span>&lt;1000&gt; bits;</span><br><span class="line">    <span class="comment">// 从 0 号房间开始</span></span><br><span class="line">    <span class="keyword">return</span> dfs(rooms, <span class="number">0</span>, bits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为我们是想要搜索到一种可能满足的访问次序就可以</span></span><br><span class="line"><span class="comment">// 所以这里的 dfs 函数有 bool 返回值来提前结束搜索</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms, <span class="keyword">int</span> room, <span class="built_in">bitset</span>&lt;<span class="number">1000</span>&gt;&amp; bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 访问当前房间, 标记为已访问</span></span><br><span class="line">    bits.<span class="built_in">set</span>(room);</span><br><span class="line">    <span class="comment">// 如果访问的房间总数等于所有房间数</span></span><br><span class="line">    <span class="keyword">if</span>(bits.count() == rooms.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 否则, 从当前房间获取其它房间钥匙, 依次进行访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curRoom = rooms[room];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> key : curRoom)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果这把钥匙对应的房间已经被访问过, 就不过去了</span></span><br><span class="line">        <span class="keyword">if</span>(bits.test(key)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 否则去访问</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(rooms, key, bits)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之malloc底层原理</title>
      <link href="/wF5qv4uNKgDG1SUa/"/>
      <url>/wF5qv4uNKgDG1SUa/</url>
      
        <content type="html"><![CDATA[<h4 id="malloc、free底层原理"><a href="#malloc、free底层原理" class="headerlink" title="malloc、free底层原理"></a><code>malloc</code>、<code>free</code>底层原理</h4><p>先来了解一些背景知识。</p><p><strong>进程地址空间的组成</strong>：</p><ol><li>内核空间：这块区域包含两种数据，一种是对每个进程都一样的数据，如共享的内核代码和全局数据结构。另一种是每个进程都不一样的数据，如页表、内核在进程上下文中执行代码时使用的栈，以及记录该进程虚拟地址空间当前组织状态的各种数据结构。</li><li><code>BSS</code>（<code>Block Started by Symbol</code>）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。是可读写的。在程序执行之前<code>BSS</code>段会自动清<code>0</code>。所以，未初始的全局变量在程序执行之前已经成<code>0</code>了）。 </li><li>数据段（<code>data segment</code>）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 </li><li>代码段（<code>code segment/text  segment</code>）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 </li><li>堆（<code>heap</code>）是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用<code>malloc</code>函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用<code>free</code>函数释放内存时，被释放的内存从堆中被释放（堆被缩减） 。</li><li>栈（<code>stack</code>）又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数块中定义的变量（但不包括<code>static</code>声明的变量，<code>static</code>意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存<code>/</code>恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li><li>内存映射区：这块虚拟内存区域被映射到任何需要的对象身上，如共享库文件、磁盘上的普通文件和将要介绍的通过<code>malloc</code>分配的大块内存区域（大于<code>128K</code>）。</li></ol><a id="more"></a><p>注意这些区域实际上存在于进程的虚拟地址空间上，一开始并没有被装载到物理内存上，比如说<code>bss</code>段，理论上是被初始化为零值，但并不是说在物理内存区域的对应段被填入零值，实际上，是将其映射到了零页，等到<code>CPU</code>向这块区域内写数据时，通过引发缺页故障的形式，才被装载到物理内存，分配到初始化为零的页（所谓的写时复制）。</p><p><img src="20032_0.png" alt="进程虚拟内存布局图"></p><p><strong>操作系统提供的两个系统调用函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p><code>sbrk</code>函数的作用是移动<code>brk</code>指针扩展<code>heap</code>的上界。函数的参数指示<code>brk</code>指针移动的大小，返回申请之前的<code>brk</code>地址。注意申请的内存地址中的值是随机的，即不要求为零。</p><p><code>mmap</code>函数第一种用法是映射磁盘文件到内存中；而<code>malloc</code>使用的<code>mmap</code>函数的第二种用法，即<strong>匿名映射</strong>，匿名映射不映射磁盘文件，而是向映射区申请一块全零页内存，相应的虚拟页面是被初始化为零的。</p><p>如上面的进程虚拟内存布局图所示，<code>mmap</code>对应<code>Memory Mapping Segment</code>，<code>brk</code>对应<code>Heap</code>。<code>start_brk</code>是堆段的开始位置，<code>brk(program break)</code>则是堆段的结束位置。</p><p>下面开始介绍<code>malloc</code>的实现原理。</p><p>那么，既然<code>brk/mmap</code>提供了内存分配的功能，直接使用<code>brk/mmap</code>进行内存管理不是更简单吗，为什么需要<code>malloc</code>呢？</p><blockquote><p>  我们知道，系统调用本身会产生软中断，导致程序从用户态陷入内核态，比较消耗资源。试想，如果频繁分配回收小块内存区，那么将有很大的性能耗费在系统调用中。因此，为了减少系统调用带来的性能损耗，<code>malloc</code>采用了内存池的设计，增加了一个代理层，每次内存分配，都优先从内存池中寻找，如果内存池中无法提供，再向操作系统申请。</p></blockquote><p>当申请小于<code>128K</code>内存时，<code>malloc</code>使用<code>sbrk</code>分配内存，当申请大于<code>128K</code>内存时，使用<code>mmap</code>函数申请内存。</p><p>下面主要讨论对于小块内存的申请<code>malloc</code>所采用的内存池设计方案。<strong>分配器不但要管理已分配的内存块，还需要管理空闲的内存块</strong>。<code>malloc</code>利用<code>chunk</code>结构体来管理这些内存块，内存池就是由许多不同大小的<code>chunk</code>链表组成的。</p><p><img src="10681867-9c09c94096413f83.png" alt="img"></p><p>内存池保存在<code>bins</code>这个长<code>128</code>的数组中，每个元素都是一个双向链表。其中：</p><ul><li><code>bins[0]</code>目前没有使用。</li><li><code>bins[1]</code>的链表称为<code>unsorted_list</code>，用于维护<code>free</code>释放的<code>chunk</code>。</li><li><code>bins[2, 63)</code>的区间称为<code>small_bins</code>，用于维护<code>＜512</code>字节的内存块，其中每个元素对应的链表中的<code>chunk</code>大小相同，均为<code>index*8</code>。</li><li><code>bins[64,127)</code>称为<code>large_bins</code>，用于维护<code>&gt;512</code>字节的内存块，每个元素对应的链表中的<code>chunk</code>大小不同，<code>index</code>越大，链表中<code>chunk</code>的内存大小相差越大，例如: 下标为<code>64</code>的<code>chunk</code>大小介于<code>[512, 512+64)</code>，下标为<code>95</code>的<code>chunk</code>大小介于<code>[2k+1, 2k+512)</code>。同一条链表上的<code>chunk</code>，按照从小到大的顺序排列。</li></ul><p>结构体<code>malloc_chunk</code>来描述这些块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free).  */</span>  </span><br><span class="line">    INTERNAL_SIZE_T <span class="built_in">size</span>; <span class="comment">/* Size in bytes, including overhead. */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="10681867-ce8d3eeabf100d45.png" alt="img"></p><p><code>glibc</code>在内存池中查找合适的<code>chunk</code>时，采用了<strong>最佳适应</strong>的伙伴算法。举例如下：</p><ol><li>如果分配内存<code>&lt; 512</code>字节，则通过内存大小定位到<code>smallbins</code>对应的<code>index</code>上。<ul><li>如果<code>smallbins[index]</code>为空，进入步骤<code>3</code></li><li>如果<code>smallbins[index]</code>非空，直接返回第一个<code>chunk</code></li></ul></li><li>如果分配内存<code>&gt; 512</code>字节，则定位到<code>largebins</code>对应的<code>index</code>上。<ul><li>如果<code>largebins[index]</code>为空，进入步骤<code>3</code></li><li>如果<code>largebins[index]</code>非空，扫描链表，找到第一个大小最合适的<code>chunk</code>，如<code>size=12.5K</code>，则使用<code>chunk B</code>，剩下的<code>0.5k</code>放入<code>unsorted_list</code>中</li></ul></li><li>遍历<code>unsorted_list</code>，查找合适<code>size</code>的<code>chunk</code>，如果找到则返回；否则，将这些<code>chunk</code>都归类放到<code>smallbins</code>和<code>largebins</code>里面。</li><li><code>index++</code>从更大的链表中查找，直到找到合适大小的<code>chunk</code>为止，找到后将<code>chunk</code>拆分，并将剩余的加入到<code>unsorted_list</code>中。</li><li>如果还没有找到，那么使用<code>top chunk</code>。</li></ol><p><strong><code>top chunk</code></strong><br> 如下图示: <code>top chunk</code>是堆顶的<code>chunk</code>，堆顶指针<code>brk</code>位于<code>top chunk</code>的顶部。移动<code>brk</code>指针，即可扩充<code>top chunk</code>的大小。</p><p><img src="10681867-4b414b22810c9e9d.png" alt="img"></p><p><code>free</code>释放内存时，有两种情况：</p><ol><li><code>chunk</code>和<code>top chunk</code>相邻，则和<code>top chunk</code>合并。</li><li><code>chunk</code>和<code>top chunk</code>不相邻，则直接插入到<code>unsorted_list</code>中。</li></ol><p><strong>参考链接：</strong></p><ol><li><p><a href="https://www.jianshu.com/p/2fedeacfa797" target="_blank" rel="noopener">glibc内存管理那些事儿 - 简书</a></p></li><li><p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" target="_blank" rel="noopener">Understanding glibc malloc – sploitF-U-N</a></p></li><li><p>自己实现一个简单的<code>malloc</code>可参考</p><ul><li><a href="https://github.com/danluu/malloc-tutorial/blob/master/malloc.c" target="_blank" rel="noopener">malloc-tutorial/malloc.c at master · danluu/malloc-tutorial</a></li><li><a href="https://www.pengrl.com/p/18873/" target="_blank" rel="noopener">[译] 写一个简单的内存分配器（替换glibc中的malloc函数） | yoko blog</a></li></ul></li><li><p><a href="https://www.pengrl.com/p/20032/" target="_blank" rel="noopener">[译] malloc中的系统调用brk和mmap | yoko blog</a>。</p></li><li><p>[malloc的底层实现（ptmalloc）_牛客博客</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之内存管理</title>
      <link href="/CB6w5vAiSmICT1OK/"/>
      <url>/CB6w5vAiSmICT1OK/</url>
      
        <content type="html"><![CDATA[<p>操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做<strong>内存管理</strong>。</p><a id="more"></a><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="加载和链接"><a href="#加载和链接" class="headerlink" title="加载和链接"></a>加载和链接</h5><table><thead><tr><th>地址绑定时间</th><th>功能</th></tr></thead><tbody><tr><td>程序设计时</td><td>程序员直接在程序中确定所有实际的物理地址</td></tr><tr><td>编译或汇编时</td><td>程序包含符号地址访问，由编译器在加载程序时把它们转换为实际的绝对地址</td></tr><tr><td>加载时</td><td>编译器或汇编器产生相对地址，加载器在加载程序时把它们转换为实际的绝对地址</td></tr><tr><td>运行时</td><td>被加载的程序保持相对地址，处理器硬件在执行时把它们动态的转换为绝对地址</td></tr></tbody></table><table><thead><tr><th>链接时间</th><th>功能</th></tr></thead><tbody><tr><td>程序设计时</td><td>不允许外部程序或数据访问。程序员必须把所有引用到的子程序源代码放入程序中</td></tr><tr><td>编译或汇编时</td><td>汇编器必须取到每个引用的子程序的源代码，并把它们作为一个部件来进行汇编</td></tr><tr><td>加载模块产生时</td><td>所有目标模块都使用相对地址汇编。这些模块被链接在一起，所有访问都相对于最后加载的模块的地点重新声明</td></tr><tr><td>加载时</td><td>直到加载模块被加载到内存时才解析外部访问，此时被访问的动态链接模块附加到加载模块后，整个软件包被加载到内存或虚存</td></tr><tr><td>运行时</td><td>直到处理器执行外部调用时才解析外部访问，此时该进程被中断，需要的模块被链接到调用程序中</td></tr></tbody></table><h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><p>创建活动进程的第一步是把程序装入内存，并创建一个进程映像。应用程序由许多已编译过或汇编过的模块组成，这些模块以目标代码的形式存在，并被链接起来以解析模块间的任何访问和对库例程的访问。库例程可以合并到程序中，或作为操作系统在运行时提供的共享访问代码。</p><p><img src="image-20210325190827823.png" alt="image-20210325190827823"></p><p>加载器把加载的模块放置在内存中从<code>x</code>开始的位置。一般而言，可以采用三种方法:</p><ul><li><p>绝对加载</p><p>  绝对加载器要求给定加载模块总被加载到内存中的同一位置。因此，在提供给加载器的加载模块中，所有的地址访问必须是确定的，或者说是绝对的内存地址。给程序中的内存访问指定具体的地址值既可以由程序员完成，也可以在编译时或汇编时完成，</p><p>  这种方法存在许多缺点：首先，程序员必须知道在内存中放置模块时预定的分配策略；其次，如果在程序的模块体中进行了任何涉及插入或删除的修改，则所有地址都需要更改。</p><p>  因此，更可取的方法是允许用符号表示程序中的内存访问，然后在编译或汇编时解析这些符号引用。对指令或数据项的引用最初被表示成一个符号。在准备输入到一个绝对加载器的模块时，汇编器或编译器将把所有这些引用转换为具体地址。</p></li><li><p>可重定位加载</p><p>  在加载之前就把内存访问绑定到具体的地址的缺点是，会使得加载模块只能放置到内存中的一个区域。但是，当多个程序共享内存时，不可能事先确定哪块区域用于加载哪个特定的模块，最好是在加载时确定。因此，需要一个可分配到内存中任何地方的加载模块。</p><p>  为满足这个新需求，汇编器或编译器不产生实际的内存地址（绝对地址），而是使用相对于某些已知点的地址，如相对于程序的起点。加载模块中的所有其他内存访问都用与该模块起点的相对值来表示。</p><p>  既然所有内存访问都以相对形式表示，那么加载器就可以很容易地把模块放置在期望的位置。如果该模块要加载到从<code>x</code>位置开始的地方，则当加载器把该模块加载到内存中时，只需简单地给每个内存访问都加上<code>x</code>。为完成这一任务，加载模块必须包含一些需要告诉加载器的信息，如地址访问在哪里、如何解释它们（通常相对于程序的起点）。由编译器或汇编器准备这些信息，通常称这些信息为重定位地址库。</p>  <img src="image-20210325191522172.png" alt="image-20210325191522172" style="zoom: 67%;" /></li><li><p>动态运行时加载</p><p>  动态运行时加载可重定位加载器非常普遍，且相对于绝对加载器具有明显的优点。但是，在多道程序设计环境中，即使不依赖于虚存，可重定位的加载方案仍是不够的。由于需要把进程换入或换出内存来增大处理器的利用率，而为最大程度地利用内存，又希望能在不同的时刻把一个进程映像换回到不同的位置，因此，程序被加载后，可能被换出到磁盘，然后又被换回到内存中不同的位置。如果在开始加载时，内存访问就被绑足到绝对地址，那么前面提到的情况是不可能实现的。</p><p>  一种替代方案是在运行时真正在使用某个绝对地址时再计算它。为达到这一目的，加载模块被加载到内存中时，其所有内存访问都以相对形式表示，一条指令只有在真正被执行时才计算其绝对地址。为确保该功能不会降低性能，这些工作必须由特殊的处理器硬件完成，而不用软件实现。</p><p>  动态地址计算提供了很大的灵活性。一个程序可以加载到内存中的任何区域，程序的执行可以中断，程序还可换出内存，以后再换回到不同的位置。</p></li></ul><h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><p>链接器的功能是把一组目标模块作为输入，产生一个包含完整程序和数据模块的加载模块，并传递给加载器。在每个目标模块中，可能有到其他模块的地址访问，每个这样的访问可以在未链接的目标模块中用符号表示。链接器会创建一个单独的加载模块，它把所有目标模块逐个链接起来。每个模块内的引用必须从符号地址转换为对整个加载模块中的一个位置的引用。</p><img src="image-20210325192023851.png" alt="image-20210325192023851" style="zoom:67%;" /><p>产生可重定位加载模块的链接器通常称为<strong>链接编辑程序</strong>。地址链接的性质取决于链接发生时要创建的加载模块的类型。通常情况下需要可重定位的加载模块，然后链接按以下方式完成：同时创建每个已编译或汇编的目标模块及相对于该目标模块开始处的引用。所有这些模块，连同相对于该加载模块起点的所有引用，一起放进一个可重定位的加载模块中。该模块可以作为可重定位加载或动态运行时加载的输入。</p><p>像加载一样，可以推迟某些链接功能。<strong>动态链接</strong>是指把某些外部模块的链接推迟到创建加载模块之后。因此，加载模块包含到其他程序的未解析的引用，这些引用可以在加载时或运行时解析。</p><p>加载时的动态链接分为如下步骤：</p><ol><li>待加载的加载模块（应用模块）读入内存。</li><li>应用模块中到一个外部模块（目标模块）的任何引用都将导致加载程序查找目标模块，加载它，并把这些引用修改为相对于应用程序模块开始处的相对地址。</li></ol><p>该方法与静态加载相比，有以下优点：</p><ul><li>能更容易地并入已改变或已升级的目标模块，如操作系统工具，或某些其他的通用例程。而对于静态链接，这类支持模块的变化需要重新链接全部应用程序模块。</li><li>在动态链接文件中的目标代码可以很方便的进行共享。因为操作系统加载并链接了该代码，所以可以识别出有多个应用程序使用相同的目标代码。操作系统可以使用此信息，然后只加载目标代码的一个副本，并把这个被加载的目标副本链接到所有使用该目标代码的应用程序，而不是为每个应用程序都分别加载一个副本。</li></ul><p>使用运行时动态链接时，某些链接工作被推迟到执行时。这样一些对目标模块的外部引用保留在被加载的程序中，当调用的模块不存在时，操作系统定位该模块，加载它，并把它链接到调用模块中。这些模块一般是共享的。在 <code>Windows</code>环境下，这些模块称为动态链接库（<code>DLL</code>）。也就是说，如果一个进程已使用动态链接共享模块，该模块就位于内存中，新的进程就可以简单地链接上已加载好的模块。</p><h5 id="内存管理的需求"><a href="#内存管理的需求" class="headerlink" title="内存管理的需求"></a>内存管理的需求</h5><p>操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做<strong>内存管理</strong>。</p><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>页框</td><td>内存中固定长度的块</td></tr><tr><td>页</td><td>固定长度的数据块。一般和页框的长度相等，数据页可临时复制到内存的页框中</td></tr><tr><td>段</td><td>变长的数据块。整个段可以临时复制到内存中的一个可用区域中，或者将一个段划分为许多页，然后将每页单独复制到内存中（分段和分页相结合）</td></tr></tbody></table><p>内存管理的需求如下：</p><ol><li><p>重定位</p><p> 可用的有限内存空间通常被多个进程共享。程序换出到磁盘后，下次换入内存时并不一定被放回原来的区域。也就是说我们需要把进程重定位到不同的内存区域。同时，我们必须允许程序通过交换技术在内存中移动，所以处理器硬件和操作系统软件必须能够以某种方式将程序代码中写死的内存访问地址转换为实际的物理内存地址。</p><p> 首次加载一个进程时，重定位将代码中的相对内存访问被绝对内存地址代替，这个绝对地址由进程被加载到的基地址确定。</p><p> 一个进程在其生命周期中可能占据不同的分区。首次创建一个进程映像时，它被装入内存中的某个分区。以后，该进程可能被换出，当它再次被换入时，可能被指定到与上一次不同的分区中。</p><p> 进程被换入或在内存中移动时，指令和数据单元的位置会发生改变。为解决这个问题，需要区分几种地址类型。<strong>逻辑地址</strong>是指与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须把它转换为物理地址。<strong>相对地址</strong>是逻辑地址的一个特例，它是相对于某些已知点（通常是程序的开始处）的存储单元。物理地址或绝对地址是数据在内存中的实际位置。</p><p> 进程处于运行态时，有一个特殊处理器寄存器（称为基址寄存器），其内容是程序在内存中的起始地址。还有一个界限寄存器指明程序的终止位置。当程序被装入内存或当该进程的映像被换入时，必须设置这两个寄存器。在进程的执行过程中会遇到相对地址，包括指令寄存器的内容、跳转或调用指令中的指令地址，以及加载和存储指令中的数据地址。每个这样的相对地址都经过处理器的两步操作。首先，基址寄存器中的值加上相对地址产生一个绝对地址；然后，将得到的结果与界限寄存器的值进行比较，如果这个地址在界限范围内，则继续该指令的执行；否则，向操作系统发出一个中断信号，操作系统必须以某种方式对这个错误做出响应。</p></li><li><p>保护</p><p> 一个进程的内存空间不能被其它进程未经授权的访问，满足重定位的需求增大了满足保护需求的难度。由于程序在内存中的位置通常会变化，因此，不可能通过在编译时检查绝对地址来保护。必须在运行时检查进程的所有内存访问，以确保它们只访问分配给自己的内存空间。</p><p> 注意，内存保护必须由硬件（处理器）而非软件（操作系统）来满足。</p></li><li><p>共享</p><p> 例如，多个进程在执行同一个程序时，允许每个进程访问该程序的同一个副本，以节省内存空间。这意味着操作系统允许进程对共享内存区域的受控访问。</p></li><li><p>逻辑组织</p><p> 计算机系统中的内存总是被组织成线性(或一维）的地址空间，且地址空间由一系列字节或字组成。然而，大多数程序被组织成模块，某些模块是不可修改的（只读、只执行），某些模块包含可以修改的数据。若操作系统和计算机硬件能够有效地处理以某种模块形式组织的用户程序与数据，则会带来很多好处：</p><ul><li><p>可以独立地编写和编译模块，系统在运行时解析从一个模块到其他模块的所有引用。</p></li><li><p>通过适度的额外开销，可以为不同的模块提供不同的保护级别。</p></li><li><p>可以引入某种机制，使得模块可被多个进程共享。</p><p>最易于满足这些需求的工具是分段。</p></li></ul></li><li><p>物理组织</p><p> 计算机存储器至少要组织成两级，即内存和外存。内存提供快速的访问，成本也相对较高。此外，内存是易失性的，即它不能提供永久性存储。外存比内存慢而且便宜，且通常是非易失性的。因此，大容量的外存可用于长期存储程序和数据，而较小的内存则用于保存当前使用的程序和数据。</p><p> 在两级存储器间移动信息的任务应由系统负责。这一任务恰好是<strong>存储管理的本质</strong>。</p></li></ol><h5 id="固定分区和动态分区"><a href="#固定分区和动态分区" class="headerlink" title="固定分区和动态分区"></a>固定分区和动态分区</h5><p>内存管理的主要操作是处理器把程序装入内存中执行。虚存基于分页和分段两种技术。</p><table><thead><tr><th align="center">内存管理技术</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">固定分区</td><td align="left">在系统生成阶段，内存被划分成许多静态分区。进程可装入大于等于自身大小的分区中</td></tr><tr><td align="center">动态分区</td><td align="left">分区是动态创建的，因而每个进程可装入与自身大小正好相等的分区中</td></tr><tr><td align="center">简单分页</td><td align="left">内存被划分成许多大小相等的页框；每个进程被划分成许多大小与页框相等的页；要装入一个进程,需要把进程包含的所有页都装入内存内不一定连续的某些页框中</td></tr><tr><td align="center">简单分段</td><td align="left">每个进程被划分成许多段；要装入一个进程，需要把进程包含的所有段都装入内存内不一定连续的某些动态分区中</td></tr><tr><td align="center">虚存分页</td><td align="left">除了不需要装入一个进程的所有页外，与简单分页一样；非驻留页在以后需要时自动调入内存</td></tr><tr><td align="center">虚存分段</td><td align="left">除了不需要装入一个进程的所有段外，与简单分段一样；非驻留段在以后需要时自动调入内存</td></tr></tbody></table><p><strong>固定分区</strong></p><p>使用大小相等的分区：</p><ol><li>程序可能太大而不能放到一个分区中，此时必须使用覆盖技术。</li><li>内存的利用率很低。会产生大量内部碎片。</li></ol><p>使用大小不等的分区可缓解这两个问题。</p><p>对于大小相等的分区，<strong>放置算法</strong>将进程放入内存的哪个分区都没有关系。</p><p>对于大小不等的分区，放置算法将每个进程分配到能够容纳它的最小分区中。每个分区需要维护一个调度队列，用于保存从这个分区换出的进程。</p><p><strong>动态分区</strong></p><p>对于动态分区，分区长度和数量是可变的。进程装入内存时，系统会给它分配一块与其所需容量完全相等的内存空间。动态分区方法最初不错，但它最终在内存中形成了许多小空洞。随着时间的推移，内存中形成了越来越多的外部碎片，内存的利用率随之下降。</p><p><strong>放置算法</strong>把一个进程装入或换入内存时，如果内存中有多个足够大的空闲块，那么操作系统必须确定要为此进程分配哪个空闲块。可供考虑的放置算法有三种：最佳适配、首次适配和下次适配。<strong>首次适配算法</strong>是最简单，最好和最快的。</p><p><strong>置换算法</strong>使得操作系统将一个阻塞的进程换出内存，给新进程或处于就绪-挂起态的进程让出空间。因此,操作系统必须选择要替换哪个进程。</p><p><strong><em>伙伴系统</em></strong></p><img src="image-20210325152953062.png" alt="image-20210325152953062" style="zoom:67%;" /><h5 id="简单分页"><a href="#简单分页" class="headerlink" title="简单分页"></a>简单分页</h5><p>大小不等的固定分区和大小可变的分区技术在内存的使用上都是低效的，前者会产生内部碎片，后者会产生外部碎片。但是，如果内存被划分成大小固定、相等的块，且块相对比较小，每个进程也被分成同样大小的小块，那么进程中称为页的块可以分配到内存中称为页框的可用块。使用分页技术时，每个进程在内存中浪费的空间，仅是进程最后一页的一小部分形成的内部碎片，没有任何外部碎片。</p><p>在某个给定时刻，内存中的某些页框正被使用，某些页框是空闲的，操作系统维护空闲页框的列表。</p><p>这时仅有一个简单的基址寄存器是不够的，<strong>操作系统需要为每个进程维护一个页表</strong>。<strong>页表给出了该进程的每页所对应页框的位置。在程序中，每个逻辑地址包括一个页号和在该页中的偏移量</strong>。在简单分区的情况下，逻辑地址是一个字相对于程序开始处的位置，处理器把它转换为一个物理地址。在分页中，逻辑地址到物理地址的转换仍然由处理器硬件完成，且处理器必须知道如何访问当前进程的页表。给出逻辑地址（页号，偏移量）后，处理器使用页表产生物理地址（页框号，偏移量）。</p><img src="image-20210325154011859.png" alt="image-20210325154011859" style="zoom:67%;" /><img src="image-20210325154456738.png" alt="image-20210325154456738" style="zoom:67%;" /><p>进程的每页在页表中都有一项，因此页表很容易按页号对进程的所有页进行索引（从<code>0</code>页开始）。每个页表项包含内存中用于保存相应页的页框的页框号。此外，操作系统为当前内存中未被占用、可供使用的所有页框维护一个空闲页框列表。</p><p>总之，采用简单的分页技术，内存可分成许多大小相等且很小的页框，每个进程可划分成同样大小的页；较小的进程需要较少的页，较大的进程需要较多的页；装入一个进程时，其所有页都装入可用页框中，并建立一个页表。</p><h5 id="简单分段"><a href="#简单分段" class="headerlink" title="简单分段"></a>简单分段</h5><p>把程序和与其相关的数据划分到几个段中。并不要求所有程序的所有段的长度都相等。和分页一样，采用分段技术时的逻辑地址也由两部分组成：段号和偏移量。</p><p>一般情况下，程序员或编译器会把程序和数据指定到不同的段。为了实现模块化程序设计的目的，程序或数据可能会进一步分成多个段。</p><p>采用大小不等的段的另一个结果是，逻辑地址和物理地址间不再是简单的对应关系。类似于分页，在简单的分段方案中，每个进程都有一个段表，系统也会维护一个内存中的空闲块列表。每个段表项必须给出相应段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效地址。当进程进入运行状态时，系统会把其段表的地址装载到一个寄存器中，由内存管理硬件来使用这个寄存器。</p><img src="image-20210325154511633.png" alt="image-20210325154511633" style="zoom:67%;" /><p>总之，采用简单的分段技术，进程可划分为许多段，段的大小无须相等；调入一个进程时，其所有段都装入内存的可用区域，并建立一个段表。</p><h5 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h5><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>虚拟内存</td><td>被定义成一个连续完整的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换</td></tr><tr><td>虚拟地址</td><td>在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主内的一部分那样</td></tr><tr><td>虚拟地址空间</td><td>分配给进程的虚拟存储</td></tr><tr><td>地址空间</td><td>用于某进程的内存地址范围</td></tr><tr><td>实地址</td><td>内存中存储位置的地址</td></tr></tbody></table><p>分页和分段的两个特点：</p><ol><li>进程中的所有内存访问都是逻辑地址，这些逻辑地址会在运行时动态的转换为物理地址。这意味着一个进程可被换入和换出内存，进程可在执行过程中占据不同时刻内存中的不同区域。</li><li>一个进程可被划分为许多块（页和段），在执行过程中，这些快不需要连续的位于内存中。</li></ol><p>假设需要把一个新进程放入内存，此时操作系统仅读取包含程序开始处的一个或几个块。进程执行的任何时候都在内存的部分称为<strong>进程的常驻集</strong>。进程执行时，只要所有内存访问都是访问常驻集中的单元，执行就可以顺利进行；使用段表或页表，处理器总可以确定是否如此。</p><p>处理器需要访问一个不在内存中的逻辑地址时，会产生一个中断，这表明出现了内存访问故障（缺页故障）。操作系统会把被中断的进程置于阻塞态。要继续执行这个进程，操作系统必须把包含引发访问故障的逻辑地址的进程块（所在的页）读入内存。为此，操作系统产生一个磁盘<code>IO</code>读请求。产生<code>I/O</code>请求后，在执行磁盘<code>IO</code>期间，操作系统可以调度另一个进程运行。需要的块读入内存后，产生一个<code>I/O</code>中断，控制权交回给操作系统，而操作系统则把由于缺少该块而被阻塞的进程置为就绪态。</p><ol><li><p>在内存中保留多个进程。</p><p> 由于对任何特定的进程都仅装入它的某些块，因此有足够的空间来放置更多的进程。这样，在任何时刻这些进程中至少有一个处于就绪态，于是处理器得到了更有效的利用。</p></li><li><p>进程可以比内存的全部空间还大。</p><p> 操作系统在需要时会自动地把进程块装入内存。</p></li></ol><p>由于进程只能在内存中执行，因此这个存储器称为实存储器，简称实存。但程序员或用户感觉到的是一个更大的内存，且通常分配在磁盘上，这称为虚拟内存，简称虚存。虚存支持更有效的系统并发度，并能解除用户与内存之间没有必要的紧密约束。</p><p>考虑一个由很长的程序和多个数据数组组成的大进程。在任何一段很短的时间内，执行可能会局限在很小的一段程序中（如一个子程序），且可能仅会访问一个或两个数据数组。因此，若在程序被挂起或被换出前仅使用了一部分进程块，则为该进程给内存装入太多的块显然会带来巨大的浪费。仅装入这一小部分块可更好地使用内存。然后，若程序转移到或访问到不在内存中的某个块中的指令或数据，就会引发一个错误，告诉操作系统读取需要的块。</p><p>当操作系统读取一块时，它必须把另一块换出。如果一块正好在将要用到之前换出，操作系统就不得不很快地把它取回。这类操作通常被称为<strong>系统抖动</strong>。</p><p><strong>局部性原理</strong>表明虚拟内存方案是可行的。要使虚存比较实用并且有效，需要两方面的因素：</p><ul><li>首先，必须有对所采用分页或分段方案的硬件支持；</li><li>其次，操作系统必须有管理页或段在内存和辅助存储器之间移动的软件。</li></ul><h5 id="虚拟分页"><a href="#虚拟分页" class="headerlink" title="虚拟分页"></a>虚拟分页</h5><p>每个进程都有自己的页表，当它的所有页都装入内存时，将创建页表并装入内存。<strong>页表项（<code>Page Table Entry</code>，<code>PTE</code>）包含有与内存中的页框相对应的页框号</strong>。由于一个进程可能只有一些页在内存中，因而每个页表项需要有一位<code>P</code>来表示它所对应的页当前是否在内存中。若这一位表示该页在内存中，则这个页表项还包括该页的页框号。</p><p>页表项中所需要的另一个控制位是修改位<code>M</code>，它表示相应页的内容从上次装入内存到现在是否已改变。若未改变，则在需要把该页换出时，无须用页框中的内容更新该页。页表项还须提供其他一些控制位，例如，保护位和共享位。</p><img src="image-20210325214215830.png" alt="image-20210325214215830" style="zoom:67%;" /><h6 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h6><p>从内存中读取一个字的基本机制包括使用页表从虚拟地址到物理地址的转换。虚拟地址又称为逻辑地址，它由页号和偏移量组成，而物理地址由页框号和偏移量组成。由于页表的长度可基于进程的长度而变化，因而不能期望在寄存器中保存它，它须在内存中且可以访问。当某个特定的进程正运行时，一个寄存器保存该进程页表的起始地址。虚拟地址的页号用于检索页表、查找相应的页框号，并与虚拟地址的偏移量结合起来形成需要的实地址。一般来说，页号域长于页框号域（<code>n &gt; m</code>）。</p><img src="image-20210325214238480.png" alt="image-20210325214238480" style="zoom:67%;" /><p>每个进程可以占据大量的虚存空间，因而一个进程会有大量的页表项，这会导致保存页表的内存空间太大。大多数虚拟内存方案都在虚存而非实存中保存页表。这意味着页表和其他页一样都服从分页管理。一个进程正在运行时，它的页表至少有一部分须在内存中，这一部分包括正在运行的页的页表项。一些处理器使用<strong>两级方案</strong>来组织大型页表。在这类方案中有一个页目录，其中的每项指向一个页表。</p><img src="image-20210325214616001.png" alt="image-20210325214616001" style="zoom: 80%;" /><p>假设采用字节级的寻址，页尺寸为<code>4KB</code>(2^12^)，则<code>4GB</code>(2^32^)虚拟地址空间由2^20^页组成。若这些页中的每页都由一个<code>4</code>字节的页表项映射，则可创建由2^20^个页表项组成的一个页表，这时需要<code>4MB</code>(2^22^)的内存空间。这个由2^10^页组成的巨大用户页表可以保留在虚存中，并由一个包括2^10^个页表项的根页表映射，根页表占据的内存为<code>4KB</code>(2^12^)。</p><img src="image-20210325214950642.png" alt="image-20210325214950642" style="zoom:67%;" /><h6 id="转换检测缓冲区TLB"><a href="#转换检测缓冲区TLB" class="headerlink" title="转换检测缓冲区TLB"></a>转换检测缓冲区<code>TLB</code></h6><p>原则上，每次虚存访问都可能会引起两次物理内存访问：一次取相应的页表项，另一次取需要的数据（进程页）。因此，虚拟内存方案都为页表项使用了一个特殊的高速缓存，通常称为转换检测缓冲区（<code>Translation Lookaside Buffer</code>，<code>TLB</code>）。<code>TLB</code>中包含有最近用过的<strong>页号和完整的页表项</strong>。给定一个虚拟地址，处理器首先检查<code>TLB</code>，若需要的页表项在其中（<code>TLB</code>命中），则检索页框号并形成实地址。若未找到需要的页表项（<code>TLB</code>未命中）,则处理器用页号检索进程页表，并检查相应的页表项。若“存在位”已置位，则该页在内存中，处理器从页表项中检索页框号以形成实地址。处理器同时更新<code>TLB</code>，使其包含这个新页表项。最后，若“存在位”未置位，则表示需要的页不在内存中，这时会产生一次内存访问故障，称为缺页（<code>page fault</code>）故障。此时离开硬件作用范围，调用操作系统，由操作系统负责装入所需要的页，并更新页表。</p><img src="image-20210325215417101.png" alt="image-20210325215417101" style="zoom:67%;" /><p>页尺寸对缺页中断发生概率的影响使得这些问题变得更为复杂。一般而言，基于局部性原理，如果页尺寸非常小，那么每个进程在内存中就有较多数量的页。一段时间后，内存中的页都包含有最近访问的部分，因此缺页率较低。当页尺寸增加时，每页包含的单元和任何一个最近访问过的单元越来越远。因此局部性原理的影响被削弱，缺页率开始增长。</p><p>更为复杂的是，缺页率还取决于分配给一个进程的页框的数量。对固定的页尺寸，当内存中的页数量增加时，缺页率会下降。因此，软件策略（分配给每个进程的内存总量）影响着硬件设计决策（页尺寸)。</p><h5 id="虚拟分段和段页式"><a href="#虚拟分段和段页式" class="headerlink" title="虚拟分段和段页式"></a>虚拟分段和段页式</h5><p>分段允许程序员把内存视为由多个地址空间或段组成，段的大小不等，并且是动态的。内存访问以段号和偏移量的形式组成地址。其优点：</p><ol><li>允许程序独立地改变或重新编译，而不要求整个程序集重新链接和重新加载。同样，这也是使用多个段实现的。</li><li>有助于进程间的共享。程序员可以在段中放置一个实用工具程序或一个有用的数据表，供其他进程访问。</li><li>有助于保护。由于一个段可被构造成包含一个明确定义的程序或数据集，因而程序员或系统管理员可以更方便地指定访问权限。</li></ol><p>从内存中读一个字的基本机制，涉及使用段表来将段号和偏移量组成的虚拟地址（或逻辑地址）转换为物理地址。根据进程的大小，段表长度可变，无法在寄存器中保存，因此访问段表时它必须在内存中。当某个特定的进程正在运行时，有一个寄存器为该进程保存段表的起始地址。虚拟地址中的段号用于检索这个表，并查找该段起点的相应内存地址。这个地址加上虚拟地址中的偏移量部分，就形成了需要的实地址。</p><p><strong>段页式系统</strong></p><p>在段页式系统中，用户的地址空间被程序员划分为许多段。每段依次划分为许多固定大小的页，页的长度等于内存中的页框大小。若某段的长度小于一页，则该段只占据一页。从程序员的角度看，逻辑地址仍然由段号和段偏移量组成：从系统的角度看，段偏移量可视为指定段中的一个页号和页偏移量。</p><p>每个进程都使用一个段表和一些页表，且每个进程段使用一个页表。某个特定的进程运行时，使用一个寄存器记录该进程段表的起始地址。对每个虚拟地址，处理器使用段号部分来检索进程段表以寻找该段的页表。然后虚拟地址的页号部分用于检索页表并查找相应的页框号。这种方式结合虚拟地址的偏移部分，就形成了需要的实地址。</p><img src="image-20210325220947686.png" alt="image-20210325220947686" style="zoom:67%;" /><p><strong>分段有助于实现保护与共享机制</strong>。实际上，操作系统要求的保护和共享功能通常在段一级处理。由于每个段表项包括一个长度和一个基地址，因而程序不会不经意地访问超出该段的内存单元。为实现共享，一个段可能会在多个进程的段表中引用。</p><img src="image-20210325221118176.png" alt="image-20210325221118176" style="zoom:67%;" /><h5 id="操作系统软件的支持"><a href="#操作系统软件的支持" class="headerlink" title="操作系统软件的支持"></a>操作系统软件的支持</h5><p><strong>这里主要涉及的是操作系统为虚存方案提供的算法</strong>。在段页式虚存系统中，操作系统所面临的内存管理问题大多数都<strong>与分页有关</strong>。</p><p>在各种情况下，最重要的都是<strong>与性能相关</strong>的问题：由于缺页中断会带来巨大的软件开销，所以希望使缺页中断发生的频率最小。这类开销至少包括决定置换哪个或哪些驻留页，以及交换这些页所需要的<code>IO</code>操作。此外，在这个页<code>IO</code>操作的过程中，操作系统还须调度另一个进程运行，即导致一次进程切换。因此，希望能通过适当的安排，使得在一个进程正在执行时，访问一个未命中的页中的字的概率最小。</p><h6 id="读取策略和清除策略"><a href="#读取策略和清除策略" class="headerlink" title="读取策略和清除策略"></a>读取策略和清除策略</h6><p><strong>读取策略</strong></p><p>当一个进程首次启动时，会在一段时间出现大量的缺页故障；取入越来越多的页后，局部性原理表明大多数将来访问的页都是最近读取的页。因此，在一段时间后错误会逐渐减少，缺页率会降到很低。</p><p>读取策略决定某页何时取入内存，常用的两种方法是<strong>请求分页</strong>和<strong>预先分页</strong>。</p><p>对于请求分页，只有当访问到某页中的一个单元时才将该页取入内存。对于预先分页，读取的页并不是缺页中断请求的页。若一个进程的页连续存储在辅存中，则<strong>一次读取许多连续的页</strong>要比隔一段时间读取一页有效。</p><p>进程首先启动时或者发生缺页中断时，都可采用预先分配策略。</p><p>某个进程被换出内存并置于挂起态时，它的所有驻留页都会被换出。当该进程被唤醒时，所有以前在内存中的页都会被重新读回内存。</p><p><strong>清除策略</strong></p><p>与读取策略相反，清除策略用于确定何时将已修改的一页写回辅存。通常有两种选择：<strong>请求式清除和预约式清除</strong>。</p><p>对于请求式清除，只有当一页被选择用于置换时才被写回辅存；而预约式清除策略则将这些已修改的多页在需要使用它们所占据的页框之前成批写回辅存。</p><p>一种较好的方法是结合下一节介绍的<strong>页缓冲</strong>技术，这种技术允许采用下面的策略：只清除可用于置换的页。通过页缓冲，被置换页可放置在两个链表中：修改链表和未修改链表。修改链表中的页可以周期性地成批写出，并移到未修改链表中。未修改链表中的一页要么因为被访问到而被回收，要么在其页框分配给另一页时被淘汰。</p><h6 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h6><p>放置策略决定一个进程块驻留在实存中的什么位置。在段页式系统中，此策略无关紧要，<strong>因为地址转换硬件和内存访问硬件能以相同的效率为任何页框组合执行相应的功能</strong>。</p><h6 id="置换策略和页缓冲"><a href="#置换策略和页缓冲" class="headerlink" title="置换策略和页缓冲"></a>置换策略和页缓冲</h6><p>置换策略决定在必须读取一个新页时，应该置换内存中的哪一页。需要明确三个问题：</p><ol><li>给每个活动进程分配多少页框。</li><li>计划被置换的页集局限于那些产生缺页故障的进程，还是局限于所有页框都在内存中的进程。</li></ol><p>上面两个问题属于<strong>驻留集管理</strong>。置换策略专指第三个问题。</p><ol start="3"><li>在计划被置换的页集，选择换出哪一页。</li></ol><p><strong>所有置换策略的目标都是移出最近最不可能访问的页</strong>。根据局部性原理，最近的访问历史和最近将要访问的模式间有很大的相关性。因此，大多数策略都基于过去的行为来预测将来的行为。</p><p><strong>页框锁定</strong></p><p>内存中的某些页框可能是被锁定的。被锁定的页框中的页不能被置换。操作系统内核和重要的控制结构就需要保存在被锁定的页框中。锁定是通过给每个页框关联一个“锁定”位实现的，这一位可以包含在页框表和当前页表中。</p><p><strong>基本算法</strong></p><ul><li><p>最近最少使用（<code>LRU</code>，<code>Least Recently Used</code>）</p><p>  该策略选择置换内存中最长时间未被引用的页。根据局部性原理，这也是最近最不可能访问到的页。</p><p>  这种方法的问题是比较难以实现。一种实现方法是给每页添加一个最后一次访问的时间戳，并在每次访问内存时更新这个时间戳。另一种方法是维护一个关于访问页的栈，但开销同样很大。</p></li><li><p>先进先出（<code>FIFO</code>，<code>First In First Out</code>）</p><p>  FIFO 策略把分配给进程的页框视为一个循环缓冲区，并按循环方式移动页。它需要的只是一个指针，该指针在进程的页框中循环。</p><p>  这种方法所隐含的逻辑是置换驻留在内存中时间最长的页：很久以前取入内存的页，现在可能不会再用到。这一推断通常是错误的，因为经常会出现一部分程序或数据在整个程序的生命周期中使用频率都很高的情况，若使用 FIFO算法，则这些页需要被反复地换入和换出。</p></li><li><p>时钟（<code>Clock</code>）</p></li></ul><p><strong><em>页缓冲</em></strong>（<code>Page Cache</code>）</p><p>页缓冲能够提高分页的性能并允许使用较简单的页面置换策略。</p><p>使用页缓冲的置换算法不丢弃置换出的页。若该页未被修改，则将它分配到空闲页链表中；若已被修改，则分配到修改页链表中。<strong>注意，该页在内存中并不会物理性移动，移动的只是该页所对应的页表项，移动后的页表项放置在空闲页链表中或修改页链表中</strong>。</p><p>空闲页链表中包含有可被置换页的一系列页框，需要从磁盘中读取一页到内存中时，都将其放到空闲页链表头节点所指向的页框中，随后将头节点移除。注意，系统记录的被置换的页并不是链表头节点所指向的页。</p><p><strong>比如说，头节点当前指向内存中的页<code>a</code>，系统通过置换策略决定出要用磁盘中的页<code>b</code>置换内存中的页<code>c</code>。实际执行的操作是，将页<code>b</code>放置在页<code>a</code>中，如果页<code>c</code>未被修改，就将其加入到空闲页链表尾部，如果页<code>c</code>已被修改，就将其加入到修改页链表中</strong>。</p><p>这一骚操作的一个重要特点是，被置换的页仍然留在内存中。因此，若进程访问该页，则可迅速返回该进程的驻留集，且代价很小。实际上，空闲页链表和修改页链表充当着页的高速缓存的角色。</p><p>修改页链表还有另外―种很有用的功能：已修改的页按簇写回，而不是一次只写一页，因此大大减少了<code>I/O</code>操作的数量，进而减少了磁盘访问时间。</p><p><strong><em><code>Page Cache</code>和块缓冲（<code>Buffer Cache</code>）的区别</em></strong></p><p>首先要明确一点，<code>cache</code>是位于内存中的，是为了提高磁盘设备的<code>IO</code>性能。程序读磁盘设备中的数据时，首先把需要访问的数据页及其相邻页面统一读到内存（预读取策略），然后从内存中读取数据。程序向磁盘设备中的文件写数据时，先将数据写入内存，然后再将内存中的脏数据页定时统一的刷新到磁盘中。</p><p>这个用作磁盘数据缓存的内存就是所谓的<code>Buffer Cache</code>。主要是针对写数据场景的性能优化。也就是说<code>Buffer Cache</code>是作为磁盘数据读写而存在的。</p><p>然而，文件系统层为了提高文件读写的性能，也提供了文件系统级别的<code>Page Cache</code>。更多的是针对读数据场景的性能优化。也就是说<code>Page Cache</code>是作为文件读写而存在的。</p><p>其实针对的都是磁盘中的数据，有两个缓存显得没有必要了，因此，现有的<code>linux</code>系统版本已经将二者合并了，统称为<code>Page Cache</code>。其是通过<code>radix</code>树（基数树）数据结构实现的。</p><h6 id="驻留集管理"><a href="#驻留集管理" class="headerlink" title="驻留集管理"></a>驻留集管理</h6><p>驻留集是指一个进程被读取到内存中的页集。</p><ol><li>分配给一个进程的内存越少，在任何时候驻留在内存中的进程数就越多。这增加了操作系统至少找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间。</li><li>若一个进程在内存中的页数较少，尽管有局部性原理，缺页率仍相对较高。</li><li>然而，给进程分配的内存空间大到一定程度时，由于局部性原理，缺页率也不会有明显的降低。</li></ol><p><strong>固定分配策略</strong>为一个进程分配固定数量的页框，以供执行时使用。这个数量由进程创建时确定。对于这种策略，一旦在进程的执行过程中发生缺页中断，该进程的一页就必须被它所需要的页面置换。</p><p><strong>可变分配策略</strong>允许分配给一个进程的页框在该进程的生命周期中不断地发生变化。<strong>其大小可根据当前进程的缺页率大小来实时调整</strong>。理论上，若一个进程的缺页率一直比较高，则表明在该进程中局部性原理表现较弱，应给它多分配一些页框以减小缺页率；而若一个进程的缺页率特别低，则表明从局部性的角度看该进程的表现非常好，可在不明显增大缺页率的前提下减少分配给它的页框。</p><p><strong>置换范围</strong></p><p><strong>局部置换策略</strong>在产生这次缺页的进程的驻留页中选择，而<strong>全局置换策略</strong>则把内存中所有未被锁定的页都作为置换的候选页，而不管它们属于哪个进程。</p><h5 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a><code>Linux</code>内存管理</h5><p><img src="1356672578_8600.jpg" alt="1356672578_8600"></p><p><strong>虚存寻址</strong></p><p><img src="%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%AE%BF%E9%97%AE.jpg" alt="虚拟地址访问"></p><p><code>Linux</code>使用三级页表结构（<strong>最新版本已经使用四级页表了</strong>），它由下面几种类型的表组成（每个表的大小都是一页）：</p><ul><li>顶级页表是页全局目录（<code>PGD</code>），它包含了一个<code>pgd_t</code>类型数组，多数体系结构中<code>pgd_t</code>类型等同于无符号长整型类型。<code>PGD</code>中的表项指向二级页目录中的表项：<code>PMD</code>。每个活动进程的页目录都必须在内存中。</li><li>二级页表是中间页目录（<code>PMD</code>），它是个<code>pmd_t</code>类型数组，其中的表项指向<code>PTE</code>中的表项。页中间目录可能跨越多个页。页中间目录中的每项指向页表中的一页。</li><li>最后一级的页表简称页表，其中包含了<code>pte_t</code>类型的页表项，该页表项指向物理页面。页表也可跨越多个页。每个页表项指向该进程的一个虚拟页。</li></ul><img src="image-20210326150018056.png" alt="image-20210326150018056" style="zoom:67%;" /><p><strong>页面分配</strong></p><p>页面分配为提升向内存中读入和从内存中写出页的效率，<code>Linux</code>定义了一种机制，用于把连续的页映射到连续的页框中。基于这一目的，它使用了<strong>伙伴系统</strong>。内核维护一系列大小固定的连续页框组，一组可以包含<code>1、2、4、8、16、32</code>个页框。当一页在内存中被分配或被解除分配时，可用的页框组使用伙伴算法来分裂或合并。</p><p><code>Linux</code>引入了一种新的分割<code>LRU</code>算法。</p><p>新算法给每个页表项添加了两个有效位：<code>PG_active</code>和<code>PG_referenced</code>。<code>Linux</code>的所有物理内存均基于它们的地址分配到两块“区域”，“激活”和“非激活”两个链表通过内存管理器来进行各区域的页面回收。内核驻留进程<code>kswapd</code>在后台周期性地执行各区域的页面回收，它扫描那些与系统页框对应的页表项。对于所有标记为访问过的页表项，启用<code>PG_referenced</code>有效位。处理器首次访问一个页面时，会启用这个标志位。<code>kswapd</code>每次迭代时，都会检查页表项中的页面访问过标志位是否被启用。<code>kswapd</code>在每次读取页面访问有效位后即将其清除。具体步骤如下：</p><ol><li>访问非激活链表中的一页时，<code>PG_referenced</code>有效位启用。</li><li>页面下次被访问时，<code>PG_active</code>被置位，并将其移动到激活链表。也就是说，页面经访问两次后被声明为激活。更准确地讲，两次不同扫描的访问才使得一个页面变为激活状态。</li><li>若第二次访问并未很快发生，则重置<code>PG_referenced</code>。</li><li>同样，激活的页面在两次超时之后也需要移动到非激活链表中。</li></ol><p>非激活链表中的页面然后可通过<code>LRU</code>算法被置换。</p><h6 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（<code>page</code>）</h6><p>内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字，但是，内存管理单元（<code>MMU</code>，管理内存并把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理。正因为如此，<code>MMU</code>以页大小为单位来管理系统中的页表。从虚拟内存的角度来看，页就是最小单位。</p><p>内核用<code>struct page</code>结构来表示系统中的每一个物理页，该结构位于<code>&lt;linux/mm_types.h&gt;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">atomic_t</span> _count;</span><br><span class="line">    <span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="keyword">pgoff_t</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">virtual</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flag</code>域用来存放页的状态。这些状态包括页是不是脏的，是不是被锁定在内存中等。这些标志被定义在<code>&lt;linux/page-flags.h&gt;</code>中。</p><p><code>count</code>域存放页的引用计数——也就是这一页被引用了多少次。当计数值变为<code>-1</code>时，就说明当前内核并没有引用这一页，于是，在新的分配中就可以使用它。内核代码不应当直接检查该域，而是调用<code>page_count()</code>函数进行检查，该函数唯一的参数就是<code>page</code>结构。当页空闲时，尽管该结构内部的<code>_count</code>值是负的，但是对<code>page_count()</code>函数而言，返回<code>0</code>表示页空闲，返回一个正整数表示页在使用。一个页可以由页缓存使用（这时，<code>mapping</code>域指向和这个页关联的<code>addresss_space</code>对象），或者作为私有数据（由<code>private</code>指向），或者作为进程页表中的映射。</p><p><code>virtual</code>域是页的虚拟地址。通常情况下，它就是页在虚拟内存中的地址。</p><p>必须要理解的一点是<code>page</code>结构与物理页相关，而并非与虚拟页相关。因此，该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，它们也可能并不再和同一个<code>page</code>结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关的物理页中存放的东西。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。</p><p>内核用这一结构来管理系统中所有的页，系统中的每个物理页都要分配一个这样的结构体。因为内核需要知道一个页是否空闲（也就是页有没有被分配）。如果页已经被分配，内核还需要知道谁拥有这个页。拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或页高速缓存（<code>Page Cache</code>）等。</p><h6 id="区（zone）"><a href="#区（zone）" class="headerlink" title="区（zone）"></a>区（<code>zone</code>）</h6><p>有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区。内核使用区对具有相似特性的页进行分组。</p><p><code>Linux</code>主要使用了三种区:</p><ul><li><code>ZONE_DMA</code>：这个区包含的页能用来执行<code>DMA</code>操作。</li><li><code>ZONE_NORMAL</code>：这个区包含的都是能正常映射的页。</li><li><code>ZONE_HIGHEM</code>：这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间。</li></ul><p>这些区在<code>&lt;linux/mmzone.h&gt;</code>中定义。</p><p><strong>区的实际使用和分布是与体系结构相关的</strong>。例如，某些体系结构在内存的任何地址上执行<code>DMA</code>都没有问题。在这些体系结构中，<code>ZONE_DMA</code>为空，<code>ZONE_NORMAL</code>就可以直接用于分配。与此相反，在<code>x86</code>体系结构上，<code>ISA</code>设备就不能在整个<code>32</code>位的地址空间中执行<code>DMA</code>，因为<code>ISA</code>设备只能访问物理内存的前<code>16MB</code>。因此，<code>ZONE_DMA</code>在<code>x86</code>上包含的页都在<code>0-16MB</code>的内存范围里。</p><p><code>Linux</code>把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。例如，<code>ZONE_DMA</code>内存池让内核有能力为<code>DMA</code>分配所需的内存。如果需要这样的内存，那么，内核就可以从<code>ZONE_DMA</code>中按照请求的数目取出页。</p><p>有些<code>64</code>位的体系结构，如<code>Intel</code>的<code>x86-64</code>体系结构可以映射和处理<code>64</code>位的内存空间，所以<code>x86-64</code>没有<code>ZONE_HIGHMEM</code>区，所有的物理内存都处于<code>ZONE_DMA</code>和<code>ZONE_NORMAL</code>区。</p><p>注意，区的划分没有任何物理意义，这只不过是内核为了管理页而采取的一种逻辑上的分组。</p><p>每个区都用<code>struct zone</code>表示，在<code>&lt;linux/mmzone.h&gt;</code>中定义。</p><p>这个结构体很大，但是，系统中只有三个区，因此，也只有三个这样的结构。</p><p><code>lock</code>域是一个自旋锁，它防止该结构被并发访问。注意，这个域只保护结构，而不保护驻留在这个区中的所有页。没有特定的锁来保护单个页。<code>watermark</code>数组持有该区的最小值、最低和最高水位值。内核使用水位为每个内存区设置合适的内存消耗基准。该水位随空闲内存的多少而变化。<code>name</code>域是一个以<code>NULL</code>结束的字符串表示这个区的名字。内核启动期间初始化这个值，其代码位于<code>mm/page_alloc.c</code>中。分别为“<code>DMA</code>“，“<code>Normal</code>”和“<code>HighMem</code>”。</p><h6 id="获得与释放页"><a href="#获得与释放页" class="headerlink" title="获得与释放页"></a>获得与释放页</h6><table><thead><tr><th align="left">内核接口</th><th>解释</th></tr></thead><tbody><tr><td align="left"><code>struct page* alloc_pages(gfp_t gfp_mask, unsigned int order)</code></td><td>该函数分配2^order^ (<code>1 &lt;&lt; order</code>）个连续的物理页，并返回一个指针，该指针指向第一个页的<code>page</code>结构体，如果出错，就返回<code>NULL</code>。</td></tr><tr><td align="left"><code>void free_pages(unsigned long addr, unsigned int order)</code></td><td>释放页，释放页时要谨慎，只能释放属于你的页。传递了错误的<code>struct page</code>或地址，用了错误的<code>order</code>值，这些都可能导致系统崩溃。</td></tr><tr><td align="left"><code>void kmalloc(size_t size, gfp_t flags)</code></td><td>这个函数返回一个指向以字节为单位内存块的指针。所分配的内存区在物理上是连续的。出错，返回<code>NULL</code>。它确保页在物理地址上是连续的。</td></tr><tr><td align="left"><code>void kfree(const void *ptr)</code></td><td>释放由<code>kmalloc()</code>分配出来的内存块。如果释放的内存不是由<code>kmalloc()</code>分配的，或者释放的内存早就被释放了，调用这个函数就会导致严重的后果。调用<code>kfree(NULL)</code>是安全的。</td></tr><tr><td align="left"><code>void* vmalloc(unsigned long size)</code></td><td>分配的内存虚拟地址是连续的，而物理地址则无须连续。它通过分配非连续的物理内存块，再“修正”页表，把内存映射到逻辑地址空间的连续区域中。</td></tr><tr><td align="left"><code>void vfree(const void* addr)</code></td><td>要释放通过<code>vmalloc()</code>获得的内存。</td></tr></tbody></table><p>大多数情况下，只有硬件设备需要得到物理地址连续的内存。在很多体系结构上，硬件设备存在于内存管理单元以外，它根本不理解什么是虚拟地址。因此，硬件设备用到的任何内存区都必须是物理上连续的块，而不仅仅是虚拟地址连续上的块。而仅供软件使用的内存块（例如与进程相关的缓冲区）就可以使用只有虚拟地址连续的内存块。对内核而言，所有内存看起来都是逻辑上连续的。</p><h5 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h5><p>内核除了管理本身的内存外，还必须管理用户空间中进程的内存。我们称这个内存为进程地址空间，也就是系统中每个用户空间进程所看到的内存。<code>Linux</code>系统中的所有进程之间以虚拟方式共享内存。对一个进程而言，它好像都可以访问整个系统的所有物理内存。即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。</p><p>进程地址空间由进程可寻址的虚拟内存组成，内核允许进程使用这种虚拟内存中的地址。每个进程都有一个<code>32</code>位或<code>64</code>位的平坦地址空间。术语“平坦”指的是地址空间范围是一个独立的连续区间。一个进程的地址空间与另一个进程的地址空间即使有相同的内存地址，实际上也彼此互不相干。这样的进程也就是<code>Linux</code>中所谓的线程。</p><p>内存地址是一个给定的值，它要在地址空间范围之内，比如<code>4021F000</code>。这个值表示的是进程32位地址空间中的一个特定的字节。尽管一个进程可以寻址<code>4GB</code>的虚拟内存（在32位的地址空间中)，但这并不代表它就有权访问所有的虚拟地址。在地址空间中，我们更为关心的是一些虚拟内存的地址区间，比如<code>08048000 - 0804C000</code>，它们可被进程访问。这些可被访问的合法地址空间称为内存区域。<strong>通过内核，进程可以给自己的地址空间动态地添加或减少内存区域</strong>。</p><p>进程只能访问有效内存区域内的内存地址。每个内存区域也具有相关权限如对相关进程有可读、可写、可执行属性。<strong>如果一个进程访问了不在有效范围中的内存区域，或以不正确的方式访向了有效地址</strong>，那么内核就会终止该进程，并返回“<strong>段错误</strong>”信息。</p><h6 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h6><p><code>Linux</code>内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由<code>mm_struct</code>结构体表示，下面给出内存描述符结构中各个域的描述，请大家结合前面的进程内存段布局图一起看：</p><p><img src="20170112101815302.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span> <span class="comment">/* 内存区域组织成链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span> <span class="comment">/* 内存区域组织成红黑树 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">/* 最近使用的内存区域 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_area_cache; <span class="comment">/* 地址空间第一个空洞 */</span></span><br><span class="line">    <span class="keyword">pgd_t</span> *pgd; <span class="comment">/* 页全局目录 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_users; <span class="comment">/* 使用地址空间的用户数 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_count; <span class="comment">/* 主使用计数器 */</span></span><br><span class="line">    <span class="keyword">int</span> map_count; <span class="comment">/* 内存区域的个数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span> <span class="comment">/* 内存区域的信号量 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> page_table_lock; <span class="comment">/* 页表锁 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span> <span class="comment">/* 所有 mm_struct 形成的链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rss; <span class="comment">/* 所分配的物理页 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm; <span class="comment">/* 全部页面数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm; <span class="comment">/* 上锁的页面数据 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pinned_vm; <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shared_vm; <span class="comment">/* 共享页面数目 Shared pages (files) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm; <span class="comment">/* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm; <span class="comment">/* 栈区页面数目 VM_GROWSUP/DOWN */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</span><br><span class="line">    <span class="comment">/* 代码段、数据段 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;<span class="comment">/* 堆区起始地址和结束地址, 进程栈区的起始地址 */</span></span><br><span class="line">    <span class="comment">/* 命令行参数 和 环境变量的 起始地址和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="keyword">mm_context_t</span> context; <span class="comment">/* 体系结构特殊数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* 状态标志位 */</span></span><br><span class="line">    <span class="comment">/* Coredumping and NUMA and HugePage 相关结构体 */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mm_count</code>代表了对<code>mm_strcut</code>本身的引用，而<code>mm_users</code>代表对<code>mm_struct</code>相关资源的引用，分了两个层次。<code>mm_count</code>类似于以进程为单位。 <code>mm_users</code>类似于以线程为单位。内核线程在运行时会借用其他进程的<code>mm_struct</code>，这样的线程叫<code>anonymous users</code>，因为他们不关心<code>mm_struct</code>指向的用户空间，也不会去访问这个用户空间，他们只是临时借用（比如说当进程执行系统调用陷入到内核中，内核会借用该进程的地址空间）。<code>mm_count</code>记录这样的进程数。<code>mm_users</code>是对<code>mm_struct</code>所指向的用户空间进行共享的所有进程的计数。也就是说，会有多个进程共享同一个用户空间， 这些进程也就是所谓的线程。</p><p><code>mmap</code>和<code>mm_rb</code>这两个不同数据结构体描述的对象是相同的：该地址空间中的全部内存区域。但是前者以链表形式存放而后者以红黑树的形式存放。<code>mmap</code>结构体作为链表，利于简单、高效地遍历所有元素；而<code>mm_rb</code>结构体作为红黑树，更适合搜索定位指定元素。</p><p>所有的<code>mm_struct</code>结构体都通过自身的<code>mmlist</code>域连接在一个双向链表中，该链表的首元素是<code>init_mm</code>内存描述符，它代表<code>init</code>进程的地址空间。另外要注意，操作该链表的时候需要使用<code>mmlist_lock</code>锁来防止并发访问，该锁定义在文件<code>kernel/fork.c</code>中。</p><p>每个进程都有自己的页表（当然，线程会共享页表）。内存描述符的<code>pgd</code>域指向的就是进程的页全局目录。</p><h6 id="内存描述符的分配与撤销"><a href="#内存描述符的分配与撤销" class="headerlink" title="内存描述符的分配与撤销"></a>内存描述符的分配与撤销</h6><p>在进程的进程描述符（即<code>task_struct</code>结构体）中，<code>mm</code>域存放着该进程使用的内存描述符，所以<code>current-&gt;mm</code>便指向当前进程的内存描述符。<code>fork()</code>函数利用<code>copy_mm()</code>函数复制父进程的内存描述符，也就是<code>current-&gt;mm</code>域给其子进程，而子进程中的<code>mm_struct</code>结构体实际是通过文件<code>kernel/fork.c</code>中的<code>allocate_mm()</code>宏从<code>mm_cachep slab</code>缓存中分配得到的。通常，每个进程都有唯一的<code>mm_struct</code>结构体，即唯一的进程地址空间。</p><p>如果父进程希望和其子进程共享地址空间，可以在调用<code>clone()</code>时，设置<code>CLONE_VM</code>标志。我们把这样的进程称作线程。当<code>CLONE_VM</code>被指定后，内核就不再需要调用<code>allocate_mm()</code>函数了，而仅仅需要调用<code>copy_mm()</code>函数中将<code>mm</code>域指向其父进程的内存描述符就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(clone_flags &amp; CLONE_vM)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// current 是父进程而 tsk 在 fork(）执行期间是子进程</span></span><br><span class="line">    atomic_inc(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">    tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进程退出时，内核会调用定义在<code>kernel/exit.c</code>中的<code>exit_mm()</code>函数，该函数执行一些常规的撤销工作，同时更新一些统计量。其中，该函数会调用<code>mmput()</code>函数减少内存描述符中的<code>mm_users</code>用户计数，如果用户计数降到零，将调用<code>mmdrop()</code>函数，减少<code>mm_count</code>使用计数。如果<code>mm_count</code>也等于零了，说明该内存描述符不再有任何使用者了，那么调用<code>free_mm()</code>宏通过<code>kmem_cache_free()</code>函数将<code>mm_struct</code>结构体归还到<code>mm_cachep slab</code>缓存中。</p><p>内核线程没有进程地址空间，也没有相关的内存描述符。所以内核线程对应的进程描述符中<code>mm</code>域为空。事实上，这也正是内核线程的真实含义——它们没有用户上下文。当一个进程被调度时，该进程的<code>mm</code>域指向的地址空间被装载到内存，进程描述符中的<code>active_mm</code>域会被更新，指向新的地址空间。内核线程没有地址空间，所以<code>mm</code>域为<code>NULL</code>。于是，当一个内核线程被调度时，内核发现它的<code>mm</code>域为<code>NULL</code>，就会保留前一个进程的地址空间，随后内核更新内核线程对应的进程描述符中的<code>active_mm</code>域，使其指向前一个进程的内存描述符。</p><p>所以在需要时，内核线程便可以使用前一个进程的页表。因为内核线程不访问用户空间的内存，所以它们仅仅使用地址空间中和内核内存相关的信息，这些信息的含义和普通进程完全相同（要知道用户进程的地址空间是包含分配给内核的那<code>1G</code>的空间的，只不过是不允许访问而已，所以内核线程借用前一个进程的地址空间是用来访问属于内核的那<code>1G</code>空间的）。</p><h6 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h6><p>每个和进程相关的内存区域都对应于一个<code>vm_area_struct</code>结构体。<code>vm_area_struct</code>结构体描述了指定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都拥有一致的属性，比如访问权限等，另外，相应的操作也都一致。按照这样的方式，每一个<code>VMA</code>就可以代表不同类型的内存区域（比如内存映射文件或者进程用户空间栈），下面给出该结构定义和各个域的描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>        <span class="comment">// 相关的 mm_struct 结构体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;         <span class="comment">// 区间的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;           <span class="comment">// 区间的尾地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span> <span class="comment">// VMA 链表</span></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;          <span class="comment">// 访问控制权限</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags; <span class="comment">//标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span> <span class="comment">//树上该 VMA 的节点</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 或者是关联于 address_space-&gt;i_mmap 字段</span></span><br><span class="line">        <span class="comment">// 或者是关联于 address_space-&gt;i_mmap_nonlinear 字段</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="keyword">void</span> *parent;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_truct</span> <span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span>      <span class="comment">// anon_vma 项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>           <span class="comment">//匿名VMA对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">vin_ops</span>;</span> <span class="comment">// 相关的操作表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="number">1</span>ong vm_pgoff;              <span class="comment">// 文件中的偏移量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">vm_file</span>;</span>                <span class="comment">// 被映射的文件（如果存在)</span></span><br><span class="line">    <span class="keyword">void</span> *vm_private_data;               <span class="comment">// 私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个内存描述符都对应于进程地址空间中的唯一区间。<code>vm_start</code>域指向区间的首地址（最低地址），<code>vm_end</code>域指向区间的尾地址（最高地址）之后的第一个字节。注意，在同一个地址空间内的不同内存区间不能重叠。</p><p><code>vm_mm</code>域指向和<code>VMA</code>相关的<code>mm_struct</code>结构体，注意，每个<code>VMA</code>对其相关的<code>mm_struct</code>结构体来说都是唯一的，所以即使两个独立的进程将同一个文件映射到各自的地址空间，它们分别都会有一个<code>vm_area_struct</code>结构体来标志自己的内存区域；反过来，如果两个线程共享一个地址空间，那么它们也同时共享其中的所有<code>vm_area_struct</code>结构体。</p><p>上文讨论过，可以通过内存描述符中的<code>mmap</code>和<code>mm_rb</code>域之一访问内存区域。<code>mmap</code>域使用单独链表连接所有的内存区域对象。每一个<code>vm_area_struet</code>结构体通过自身的<code>vm_next</code>域被连入链表，所有的区域按地址增长的方向排序，<code>mmap</code>域指向链表中第一个内存区域，链中最后一个结构体指针指向空。<code>mm_rb</code>域使用红黑树连接所有的内存区域对象。<code>mm_rb</code>域指向红黑树的根节点，地址空间中每一个<code>vm_area_struct</code>结构体通过自身的<code>vm_rb</code>域连接到树中。</p><h6 id="创建和删除地址空间"><a href="#创建和删除地址空间" class="headerlink" title="创建和删除地址空间"></a>创建和删除地址空间</h6><p>内核使用<code>do_mmap()</code>函数创建一个新的线性地址区间。如果创建的地址区间和一个已存在的地址区间相邻，并且它们具有相同的访问权限的话，两个区间将合并为一个。映射时，从<code>vm_area_cachep</code>长字节（<code>slab</code>）缓存中分配一个<code>vm_area_struct</code>结构体，并且使用<code>vma_link()</code>函数将新分配的内存区域添加到地址空间的内存区域链表和红黑树中，随后还要更新内存描述符中的<code>total_vm</code>域，然后才返回新分配的地址区间的初始地址。</p><p><code>do_mmap()</code>函数定义在文件<code>&lt;linux/mm.h&gt;</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数映射由<code>file</code>指定的文件，具体映射的是文件中从偏移<code>offset</code>处开始，长度为<code>len</code>字节的范围内的数据。如果<code>file</code>参数是<code>NULL</code>并且<code>offset</code>参数也是<code>0</code>，那么就代表这次映射没有和文件相关，该情况称作匿名映射（<code>anonymous mapping</code>）。如果指定了文件名和偏移量，那么该映射称为文件映射（<code>file-backed mapping</code>）。</p><p><code>addr</code>是可选参数，它指定搜索空闲区域的起始位置。<code>prot</code>参数指定内存区域中页面的访问权限。访问权限标志定义在文件<code>&lt;asm/mman.h&gt;</code>中。</p><p>在用户空间可以通过<code>mmap()</code>系统调用获取内核函数<code>do_mmap()</code>的功能。<code>mmap()</code>系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap2</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> pgoff)</span></span>;</span><br></pre></td></tr></table></figure><p>由于该系统调用是<code>mmap()</code>调用的第二种变种，所以起名为<code>mmap2()</code>。最原始的<code>mmap()</code>调用中最后一个参数是字节偏移量，而目前这个<code>mmap2()</code>使用页面偏移作最后一个参数。使用页面偏移量可以映射更大的文件和更大的偏移位置。原始的<code>mmap()</code>调用由<code>POSIX</code>定义，仍然在<code>C</code>库中作为<code>mmap()</code>方法使用，但是内核中已经没有对应的实现了，而实现的是新方法<code>mmap2()</code>。虽然<code>C</code>库仍然可以使用原始版本的映射方法，但是它其实还是基于函数<code>mmap2</code>进行的，对原始<code>mmap()</code>方法的调用是通过将字节偏移转化为页面偏移，从而转化为对<code>mmap2()</code>函数的调用来实现的。</p><p><code>do_mummap()</code>函数从特定的进程地址空间中删除指定地址区间，该函数定义在文件<code>&lt;linux/mm.h&gt;</code>中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_mummap</span><span class="params">(struct mm_struct *mm , <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数指定要删除区域所在的地址空间，删除从地址<code>start</code>开始，长度为<code>len</code>字节的地址区间。如果成功，返回零。否则，返回负的错误码。</p><p>系统调用<code>munmap</code>()给用户空间程序提供了一种从自身地址空间中删除指定地址区间的方法，它和系统调用<code>mmap()</code>的作用相反，该系统调用定义在文件<code>mm/mmap.c</code>中，它是对<code>do_mummap()</code>函数的一个简单的封装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="进程用户栈、线程栈、进程内核栈、中断栈"><a href="#进程用户栈、线程栈、进程内核栈、中断栈" class="headerlink" title="进程用户栈、线程栈、进程内核栈、中断栈"></a>进程用户栈、线程栈、进程内核栈、中断栈</h5><p><strong>进程用户栈</strong></p><p>进程栈是属于用户态栈，和进程虚拟地址空间 (<code>Virtual Address Space</code>) 密切相关。那我们先了解下什么是虚拟地址空间：在<code>32</code>位机器下，虚拟地址空间大小为<code>4G</code>。这些虚拟地址通过页表 (<code>Page Table</code>) 映射到物理内存，页表由操作系统维护，并被处理器的内存管理单元 (<code>MMU</code>) 硬件引用。每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。</p><p><code>Linux</code>内核将这<code>4G</code>字节的空间分为两部分，将最高的<code>1G</code>字节（<code>0xC0000000</code>- <code>0xFFFFFFFF</code>）供内核使用，称为内核空间。而将较低的<code>3G</code>字节（<code>0x00000000</code> - <code>0xBFFFFFFF</code>）供各个进程使用，称为用户空间。每个进程可以通过系统调用陷入内核态，因此内核空间是由所有进程共享的。虽然说内核和用户态进程占用了这么大地址空间，但是并不意味它们使用了这么多物理内存，仅表示它可以支配这么大的地址空间。它们是根据需要，将物理内存映射到虚拟地址空间中使用。</p><img src="20160901214930068.jpg" alt="Linux虚拟地址空间" style="zoom:150%;" /><p><code>Linux</code>对进程地址空间有个标准布局，地址空间中由各个不同的内存段组成 (<code>Memory Segment</code>)，主要的内存段如下：</p><ul><li>程序段 (<code>Text Segment</code>)：可执行文件代码的内存映射。</li><li>数据段 (<code>Data Segment</code>)：可执行文件的已初始化全局变量的内存映射。</li><li><code>BSS</code>段 (<code>BSS Segment</code>)：未初始化的全局变量或者静态变量（<strong><u>映射到零页</u></strong>）。</li><li>堆区 (<code>Heap</code>) : 存储动态内存分配，匿名的内存映射（<code>malloc</code>分配的内存区域）。</li><li>栈区 (<code>Stack</code>) : 进程用户空间栈，由编译器自动分配释放，存放函数的参数值、局部变量的值等。</li><li>映射段（<code>Memory Mapping Segment</code>）：任何内存映射文件，如每一个诸如C库或动态连接程序等共享库的代码段、数据段和<code>BSS</code>也会被载入进程的地址空间。</li></ul><p><u><strong>可执行文件的<code>BSS</code>段未存储在磁盘上，内核将零页面映射到<code>BSS</code>范围</strong></u>。</p><p>因为在创建新进程时预期<code>BSS</code>段将被初始化为零，并且仅在可执行文件中存储一堆零浪费了空间，所以可执行文件仅指示<code>BSS</code>段应从何处开始以及应该从多大。</p><p>当内核从可执行文件构建新进程时，它将为<code>BSS</code>范围创建到零页面的映射，该页面是全零的静态（虚拟）页面。该映射设置有<strong>写时复制</strong>功能，因此，新进程首次向其中一个<code>BSS</code>页进行写入时，在允许写入完成之前，静态零页的实际副本将分配到另一个内存页中。 这样做有如下几点好处：</p><ol><li>节省了可执行文件中的空间。</li><li>避免了实际分配可能永远不会被该进程触及的<code>BSS</code>页面，从而节省了内存使用量。</li><li>同时仍然提供了确保每个进程中的<code>BSS</code>段看起来都是零初始化的保证。</li></ol><p><img src="20160901214948512.jpg" alt="20160901214948512"></p><p>而上面进程虚拟地址空间中的栈区，正指的是我们所说的进程栈。进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，<code>Linux</code>内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制<code>RLIMIT_STACK</code>（一般为<code>8M</code>），我们可以通过<code>ulimit</code>来查看或更改<code>RLIMIT_STACK</code>的值。</p><p><strong>如何确认进程栈的大小</strong></p><p>我们要知道栈的大小，那必须得知道栈的起始地址和结束地址。栈起始地址获取很简单，只需要嵌入汇编指令获取栈指针<code>esp</code>寄存器的值即可。栈结束地址的获取有点麻烦，我们需要先利用递归函数把栈搞溢出了，然后再<code>GDB</code>中把栈溢出的时候把栈指针<code>esp</code>寄存器的值打印出来即可。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file name: stacksize.c */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *orig_stack_pointer;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blow_stack</span><span class="params">()</span> </span>&#123; blow_stack(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">"movl %esp, orig_stack_pointer"</span>);</span><br><span class="line"></span><br><span class="line">    blow_stack();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ g++ -g stacksize.c -o ./stacksize</span><br><span class="line">$ gdb ./stacksize</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/home/misc-code/setrlimit</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">blow_stack () at setrlimit.c:<span class="number">4</span></span><br><span class="line"><span class="number">4</span>       blow_stack();</span><br><span class="line">(gdb) print (<span class="keyword">void</span> *)$esp</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">void</span> *) <span class="number">0xffffffffff7ff000</span></span><br><span class="line">(gdb) print (<span class="keyword">void</span> *)orig_stack_pointer</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">void</span> *) <span class="number">0xffffc800</span></span><br><span class="line">(gdb) print <span class="number">0xffffc800</span><span class="number">-0xff7ff000</span></span><br><span class="line">$<span class="number">3</span> = <span class="number">8378368</span><span class="comment">// Current Process Stack Size is 8M</span></span><br></pre></td></tr></table></figure><p><strong>进程栈的动态增长实现</strong></p><p>进程在运行的过程中，通过不断向栈区压入数据，当超出栈区容量时，就会耗尽栈所对应的内存区域，这将触发一个 缺页异常 (<code>page fault</code>）。通过异常陷入内核态后，异常会被内核的<code>expand_stack()</code>函数处理，进而调用 <code>acct_stack_growth()</code>来检查是否还有合适的地方用于栈的增长。</p><p>如果栈的大小低于<code>RLIMIT_STACK</code>（通常为<code>8MB</code>），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情，这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会发生栈溢出（<code>stack overflow</code>），进程将会收到内核发出的段错误（<code>segmentation fault</code>）信号。</p><p>动态栈增长是唯一一种访问未映射内存区域而被允许的情形，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。</p><p><strong>线程栈</strong></p><p>从<code>Linux</code>内核的角度来说，其实它并没有线程的概念。<code>Linux</code>把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了<code>task_struct</code>中。线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和<code>Linux</code>中所谓线程的唯一区别。线程创建的时候，加上了<code>CLONE_VM</code>标记，这样 线程的内存描述符 将直接指向父进程的内存描述符。</p><p>虽然线程的地址空间和进程一样，但是对待其地址空间的栈<code>stack</code>还是有些区别的。对于<code>Linux</code>进程或者说主线程，其<code>stack</code>是在<code>fork</code>的时候生成的，实际上就是复制了父亲的<code>stack</code>空间地址，然后写时拷贝 (<code>cow</code>) 以及动态增长。然而对于主线程生成的子线程而言，其<code>stack</code>将不再是这样的了，而是事先固定下来的，使用<code>mmap</code>系统调用，它不带有<code>VM_STACK_FLAGS</code>标记。</p><p>这个可以从<code>glibc</code>的<code>nptl/allocatestack.c</code>中的<code>allocate_stack()</code>函数中看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem = mmap (<span class="literal">NULL</span>, size, prot, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>由于线程的<code>mm-&gt;start_stack</code>栈地址和所属进程相同，所以线程栈的起始地址并没有存放在<code>task_struct</code>中，应该是使用<code>pthread_attr_t</code>中的<code>stackaddr</code>来初始化<code>task_struct-&gt;thread-&gt;sp</code>（<code>sp</code>指向<code>struct pt_regs</code>对象，该结构体用于保存用户进程或者线程的寄存器现场）。这些都不重要，重要的是，线程栈不能动态增长，一旦用尽就没了，这是和生成进程的<code>fork</code>不同的地方。由于线程栈是从进程的地址空间中<code>map</code>出来的一块内存区域，原则上是线程私有的。</p><p><strong>进程内核栈</strong></p><p>在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作进程内核栈。进程内核栈在进程创建的时候，通过<code>slab</code>分配器从<code>thread_info_cache</code>缓存池中分配出来，其大小为<code>THREAD_SIZE</code>，一般来说是一个页大小<code>4K</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>thread_union</code>进程内核栈和<code>task_struct</code>进程描述符有着紧密的联系。由于内核经常要访问<code>task_struct</code>，高效获取当前进程的描述符是一件非常重要的事情。因此内核将进程内核栈的头部一段空间，用于存放<code>thread_info</code>结构体，而此结构体中则记录了对应进程的描述符，两者关系如下图：</p><img src="20160901215111055.jpg" alt="img" style="zoom:150%;" /><p>有了上述关联结构后，内核可以先获取到栈顶指针<code>esp</code>，然后通过<code>esp</code>来获取<code>thread_info</code>。这里有一个小技巧，直接将<code>esp</code>的地址与上<code>~(THREAD_SIZE - 1)</code>后即可直接获得<code>thread_info</code>的地址。由于<code>thread_union</code>结构体是从<code>thread_info_cache</code>的<code>Slab</code>缓存池中申请出来的，而<code>thread_info_cache</code>在<code>kmem_cache_create</code>创建的时候，保证了地址是<code>THREAD_SIZE</code>对齐的。因此只需要对栈指针进行<code>THREAD_SIZE</code>对齐，即可获得<code>thread_union</code>的地址。成功获取到<code>thread_info</code>后，直接取出它的<code>task</code>成员就成功得到了<code>task_struct</code>。其实上面这段描述，也就是<code>current</code>宏的实现方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> current_stack_pointer <span class="title">asm</span> <span class="params">(<span class="string">"sp"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_current() (current_thread_info()-&gt;task)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> current get_current()</span></span><br></pre></td></tr></table></figure><p><strong>中断栈</strong></p><p>进程陷入内核态的时候，需要内核栈来支持内核函数调用。中断也是如此，当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关。</p><p><code>x86</code>上中断栈就是独立于内核栈的；独立的中断栈所在内存空间的分配发生在<code>arch/x86/kernel/irq_32.c</code>的<code>irq_ctx_init()</code>函数中（如果是多处理器系统，那么每个处理器都会有一个独立的中断栈），函数使用<code>__alloc_pages</code>在低端内存区分配<code>2</code>个物理页面，也就是<code>8KB</code>大小的空间。有趣的是，这个函数还会为<code>softirq</code>分配一个同样大小的独立堆栈。如此说来，<code>softirq</code>将不会在<code>hardirq</code>的中断栈上执行，而是在自己的上下文中执行。</p><p><strong>为什么需要单独的进程内核栈？</strong></p><p>（<strong>为什么需要单独的线程栈？进程和线程是否共享一个内核栈？</strong>）</p><p>所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程<code>A</code>陷入内核态执行的时候，需要等待读取网卡的数据，主动调用<code>schedule()</code>让出<code>CPU</code>；此时调度器唤醒了另一个进程<code>B</code>，碰巧进程<code>B</code>也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程<code>B</code>进入内核态的时候产生的压栈操作，必然会破坏掉进程<code>A</code>已有的内核栈数据；一但进程<code>A</code>的内核栈数据被破坏，很可能导致进程<code>A</code>的内核态无法正确返回到对应的用户态了。</p><p>**这三个问题很好理解，只要可被调度执行的对象之间共用一个栈（无论进程栈，内核栈还是线程栈），那必然会有出错的机会，所以不能共用。进程和同一个进程的线程都是可被调度执行的对象！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之并发与同步</title>
      <link href="/29s2fW7i8PsxWCiK/"/>
      <url>/29s2fW7i8PsxWCiK/</url>
      
        <content type="html"><![CDATA[<h5 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h5><p>在单处理器多道程序设计系统中，进程会被交替地执行，因而表现出一种并发执行的外部特征。支持并发进程的基本需求是加强互斥的能力。也就是说，当一个进程被授予互斥能力时，那么在其活动期间，它具有排斥所有其他进程的能力。</p><a id="more"></a><h4 id="并发与同步"><a href="#并发与同步" class="headerlink" title="并发与同步"></a>并发与同步</h4><h5 id="并发的概念-1"><a href="#并发的概念-1" class="headerlink" title="并发的概念"></a>并发的概念</h5><p>在单处理器多道程序设计系统中，进程会被交替地执行，因而表现出一种并发执行的外部特征。支持并发进程的基本需求是加强互斥的能力。也就是说，当一个进程被授予互斥能力时，那么在其活动期间，它具有排斥所有其他进程的能力。</p><p>并发包括很多设计问题，其中有进程间通信、资源共享与竞争（如内存、文件、<code>I/O</code>访问)、多个进程活动的同步以及给进程分配处理器时间等。并发问题源于多道程序设计系统的一个基本特性：进程的相对执行速度不可预测，它取决于其他进程的活动、操作系统处理中断的方式以及操作系统的调度策略。</p><table><thead><tr><th align="center">术语</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">临界区</td><td align="center">一段代码，在这段代码中进程将访问共享资源，当另外一个进程已在这段代码中运行时，这个进程就不能在这段代码中执行</td></tr><tr><td align="center">死锁</td><td align="center">两个或两个以上的进程因每个进程都在等待其他进程做完某些事情而不能继续执行的情形</td></tr><tr><td align="center">互斥</td><td align="center">当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源的情形</td></tr><tr><td align="center">竞争条件</td><td align="center">多个线程或进程在读写一个共享数据时，结果依赖于它们执行的相对时间的情形</td></tr><tr><td align="center">饥饿</td><td align="center">一个可运行进程尽管能继续执行，但被调度程序无限期地忽视，而不能被调度执行的情形</td></tr><tr><td align="center">原子操作</td><td align="center">保证指令序列要么作为一个组来执行，要么都不执行</td></tr></tbody></table><p>如果需要保护共享的全局变量（以及其他共享的全局资源），唯一的办法是控制访问该变量的代码。</p><p><strong><em>原子性和顺序性</em></strong></p><p>原子性确保指令执行期间不被打断，要么全部执行完，要么根本不执行。另一方面，顺序性确保即使两条或多条指令出现在独立的执行线程中，甚至独立的处理器上，它们本该的执行顺序却依然要保持。顺序性通过屏障（<code>barrier</code>）指令来实施。</p><h5 id="进程交互的分类"><a href="#进程交互的分类" class="headerlink" title="进程交互的分类"></a>进程交互的分类</h5><ul><li>进程之间互相不知道对方的存在，它们表现出<strong>竞争</strong>关系</li><li>进程间接知道对方的存在，但它们共享某些对象，表现出通过<strong>共享合作</strong>的关系</li><li>进程直接知道对方的存在，可以通过进程ID互相传递消息进行通信，表现出通过<strong>通信合作</strong>的关系</li></ul><p><strong>竞争进程</strong>面临三个控制问题：</p><ol><li><p>互斥</p><p> 假设两个或更多的进程需要访问一个不可共享的资源，如打印机。在执行过程中，每个进程都给该<code>IO</code>设备发命令，接收状态信息，发送数据和接收数据。我们把这类资源称为临界资源，使用临界资源的那部分程序称为程序的临界区。一次只允许有一个程序在临界区中，这一点非常重要。</p></li></ol><p>为了实现互斥则产生了下面两个问题：</p><ol start="2"><li><p>死锁</p><p> 考虑两个进程<code>P1</code>和<code>P2</code>，以及两个资源<code>R1</code>和<code>R2</code>，假设每个进程为执行部分功能都需要访问这两个资源，那么就有可能出现下列情况：操作系统把<code>R1</code>分配给<code>P2</code>，把<code>R2</code>分配给<code>P1</code>，每个进程都在等待另一个资源，且在获得其他资源并完成功能前，谁都不会释放自己已拥有的资源，此时这两个进程就会发生死锁。</p></li><li><p>饥饿</p><p> 假设有三个进程（<code>P1</code>、<code>P2</code>和<code>P3</code>），每个进程都周期性地访问资源<code>R</code>。假设操作系统把访问权轮流授予<code>P1</code>和<code>P3</code>，那么即使没有死锁，<code>P2</code>也可能被无限地拒绝访间资源。</p></li></ol><p><strong>合作进程</strong>和竞争进程的唯一区别是可以按两种不同的模式（读和写）访问数据项，并且<strong>只有写操作必须保证互斥</strong>。除了面临上面三个问题外，还有一个新的要求：<strong>数据一致性</strong>。</p><p>若使用临界区来保护数据的一致性，则没有确定的资源或变量可作为参数。此时，可以把参数视为一个在并发进程间共享的标识符，用于标识必须互斥的临界区。</p><h5 id="互斥的要求以及实现"><a href="#互斥的要求以及实现" class="headerlink" title="互斥的要求以及实现"></a>互斥的要求以及实现</h5><ol><li>必须强制实施互斥：在与相同资源或共享对象的临界区有关的所有进程中，一次只允许一个进程进入临界区。</li><li>没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入。</li><li>一个进程驻留在临界区中的时间必须是有限的。</li></ol><p><strong><em>硬件支持的实现</em></strong></p><ol><li><p>禁用中断</p><p> 为保证互斥，只需保证一个进程不被中断即可，这种能力可通过系统内核为启用和禁用中断定义的原语来提供。但代价非常高。</p></li><li><p>专用机器指令</p><p> 在硬件级别上，对存储单元的访问排斥对相同单元的其他访问。因此，处理器的设计者人员提出了一些机器指令，用于保证两个动作的原子性。</p></li></ol><p><strong><em>软件支持的实现</em></strong></p><table><thead><tr><th>并发机制</th><th align="left">解释</th></tr></thead><tbody><tr><td>信号量</td><td align="left">用于进程间传递信号的一个整数值。在信号量上只可进行三种操作，即初始化、递减和递增，它们都是原子操作。递减操作用于阻塞一个进程，递增操作用于解除一个进程的阻塞</td></tr><tr><td>二元信号量</td><td align="left">只取<code>0</code>值和<code>1</code>值的信号量</td></tr><tr><td>互斥量</td><td align="left">类似于二元信号量。关键区别在于为其加锁（设定值为<code>0</code>）的进程和为其解锁（设定值为<code>1</code>）的进程必须为同一个进程，一般被用在构造临界区上</td></tr><tr><td>条件变量</td><td align="left">一种数据类型，用于阻塞进程或线程，直到特定的条件为真</td></tr><tr><td>自旋锁</td><td align="left">一种互斥机制，进程在一个无条件循环中执行，等待锁变量的值可用</td></tr></tbody></table><h6 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h6><p><code>Linux</code>中的信号量是一种<strong>睡眠</strong>锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放）后，处于等待队列中的那个任务将被唤醒。</p><p>我们可以从信号量的睡眠特性得出一些有意思的结论：</p><ul><li>由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况。</li><li>相反，锁被短时间持有时，使用信号量就不太适宜了。因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁被占用的全部时间还要长。</li><li>面于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下文中是不能进行调度的。</li><li>你可以在持有信号量时去睡眠，因为当其他进程试图获得同一信号量时不会因此而死锁（因为该进程也只是去睡眠而已，而你最终会继续执行的）。</li></ul><p>为达到预期效果，可把信号量视为一个值为整数的变量，整数值上定义了三个操作：</p><ol><li>一个信号量可以初始化成非负数。</li><li><code>semWait</code>操作使信号量减<code>1</code>。若值变成负数，则阻塞执行<code>semWait</code>的进程，否则进程继续执行。</li><li><code>semSignal</code>操作使信号量加<code>1</code>。被<code>semWait</code>操作阻塞的进程之一（可能没有被阻塞的）解除阻塞。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 比较和交换指令 实现的信号量原语</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semwait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 把当前进程插入队列 */</span>;</span><br><span class="line">        <span class="comment">/* 阻塞当前进程 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(compare_and_swap(s.flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count &lt;= O)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 把进程 P 从队列中移除 */</span>;</span><br><span class="line">        <span class="comment">/* 把进程卫插入就绪队列 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>s.count ≥ 0</code>：<code>s.count</code>是可执行<code>semwait(s)</code>而不被阻塞的进程数。这种情形允许信号量支持同步与互斥。</li><li><code>s.count &lt; 0</code>：<code>s.count</code>的大小是阻塞在<code>s.queue</code>队列中的进程数。</li></ul><h6 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h6><ol><li>二元信号量可以初始化为<code>0</code>或<code>1</code>。</li><li><code>semWaitB</code>操作检查信号的值。若值为<code>0</code>，则进程执行<code>semwaitB</code>就会受阻。若值为<code>1</code>，则将值改为<code>0</code>，并继续执行该进程。</li><li><code>semSignalB</code>操作检查是否有任何进程在该信号上受阻。若有进程受阻，则通过<code>semWaitB</code>操作受阻的进程会被唤醒：若没有进程受阻，则值设置为<code>1</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;zero, one&#125; value;</span><br><span class="line">    qrueueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semwaitB</span><span class="params">(binary semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.value = one)</span><br><span class="line">        s.value = zero;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 把当前进程插入队列 */</span>;</span><br><span class="line">        <span class="comment">/* 阻塞当前进程 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignalB</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty())</span><br><span class="line">        s.value =one;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 把进程 P 从等待队列中移除 */</span>;</span><br><span class="line">        <span class="comment">/* 把进程卫插入就绪队列 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论是计数信号量还是二元信号量，都需要使用队列来保存于信号量上等待的进程。这就产生了一个问题，进程按什么顺序从队列中移出？最公平的策略是先进先出，被阻塞时间最久的进程最先从队列释放。采用这一策略定义的信号量称为强信号量，而没有规定进程从队列中移出顺序的信号量称为弱信号量。</p><p>强信号量保证不会饥饿，而弱信号量则无法保证。</p><h6 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h6><p>自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个被已经持有（即所谓的争用）的自旋锁，那么该线程就会一直进行忙循环一旋转，等待锁重新可用。要是锁未被争用，请求锁的执行线程便能立刻得到它，继续执行。在任意时间，自旋锁都可以防止多于一个的执行线程同时进入临界区。</p><p>自旋锁是不可递归的（不可重入的）。</p><p>自旋锁可以使用在中断处理程序中（此处不能使用信号量，因为它们会导致睡眠）。在中断处理程序中使用自旋锁时，一定要在获取锁之前，首先禁止本地中断（在当前处理器上的中断请求），否则，中断处理程序就会打断正持有锁的内核代码，有可能会试图去争用这个已经被持有的自旋锁。这样一来，中断处理程序就会自旋，等待该锁重新可用，但是锁的持有者在这个中断处理程序执行完毕前不可能运行。这正是我们在前面的内容中提到的双重请求死锁。注意，需要关闭的只是当前处理器上的中断。如果中断发生在不同的处理器上，即使中断处理程序在同一锁上自旋，也不会妨碍锁的持有者（在不同处理器上）最终释放锁。</p><h6 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量<code>mutex</code></h6><ul><li>任何时刻中只有一个任务可以持有<code>mutex</code>，也就是说，<code>mutex</code>的使用计数永远是<code>1</code>。</li><li>给<code>mutex</code>上锁者必须负责给其再解锁——你不能在一个上下文中锁定一个<code>mutex</code>，而在另一个上下文中给它解锁。这个限制使得<code>mutex</code>不适合内核同用户空间复杂的同步场景。最常使用的方式是：在同一上下文中上锁和解锁。</li><li>递归地上锁和解锁是不允许的。也就是说，你不能递归地持有同一个锁，同样你也不能再去解锁一个已经被解开的<code>mutex</code>。</li><li>当持有一个<code>mutex</code>时，进程不可以退出。</li><li><code>mutex</code>只能通过官方<code>API</code>管理，不可被拷贝、赋值、重复初始化。</li></ul><p><strong>除非<code>mutex</code>的某个约束妨碍你使用，否则相比信号量要优先使用<code>mutex</code>。在中断上下文中只能使用自旋锁，而在任务睡眠时只能使用<code>mutex</code></strong>。</p><h5 id="死锁原理"><a href="#死锁原理" class="headerlink" title="死锁原理"></a>死锁原理</h5><p>死锁定义为一组相互竞争系统资源或进行通信的进程间的“永久”阻塞。当一组进程中的每个进程都在等待某个事件（典型情况下是等待释放所请求的资源），而仅有这组进程中被阻塞的其他进程才可触发该事件时，就称这组进程发生了死锁。</p><p>资源通常分为两类：可重用资源和可消耗资源。<strong>可重用资源</strong>是指一次仅供一个进程安全使用且不因使用而耗尽的资源。可重用资源的例子包括处理器、<code>I/O</code>通道、内存和外存、设备，以及诸如文件、数据库和信号量之类的数据结构。<strong>可消耗资源</strong>是指可被创建（生产）和销毁（消耗）的资源。存在。可消耗资源的例子有中断、信号、消息和<code>I/O</code>缓冲区中的信息。</p><p>产生死锁有三个必要条件：</p><ol><li>互斥。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。</li><li>占有且等待。当一个进程等待其他进程时，继续占有已分配的资源。</li><li>不可抢占。不能强行抢占进程已占有的资源。</li></ol><p>要产生死锁，还需要第四个条件：</p><ol start="4"><li>循环等待。存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。</li></ol><p>第四个条件实际上是前三个条件的潜在结果，即假设前三个条件存在，那么可能发生的系列事件会导致不可解的循环等待。这个不可解的循环等待实际上就是死锁的定义。循环等待之所以不可解，是因为有前面三个条件的存在。因此，这四个条件一起构成 了死锁的充分必要条件。</p><h5 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h5><p>死锁预防方法分为两类。一类是间接死锁预防方法，即防止前面列出的三个必要条件中的任何一个条件的发生；另一类是直接死锁预防方法，即防止循环等待的发生。</p><ol><li><p>互斥</p><p> 不可能禁止。如果需要对资源进行互斥访问，那么操作系统就必须支持互斥。</p></li><li><p>占有且等待</p><p> 为预防占有且等待的条件，可以要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足。</p></li><li><p>不可抢占</p><p> 预防不可抢占的方法有几种。首先，占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放其最初占有的资源，必要时可再次申请这些资源和其他资源。其次，一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不同的条件下，后一种方案才能预防死锁。</p><p> 此外，只有在资源状态可以很容易地保存和恢复的情况下（如<code>CPU</code>上下文），这种方法才是实用的。</p></li><li><p>循环等待</p><p> 循环等待条件可通过定义资源类型的线性顺序来预防。若一个进程已分配了<code>R</code>类型的资源，则其接下来请求的资源只能是那些排在<code>R</code>类型之后的资源。</p></li></ol><h5 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h5><p>在死锁避免中，是否允许当前的资源分配请求是通过判断该请求是否可能导致死锁来决定的。因此，死锁避免需要知道未来进程资源请求的情况。</p><ol><li>进程启动拒绝。若一个进程的请求会导致死锁，则不启动该进程。</li><li>资源分配拒绝，又称<strong>银行家算法</strong>。若一个进程增加的资源请求会导致死锁，则不允许这一资源分配。</li></ol><p>死锁避免的优点是，无须死锁预防中的抢占和回滚进程，</p><h5 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h5><p>对于死锁检测来说，只要有可能，就会给进程分配其所请求的资源。操作系统周期性地执行一个算法来检测前面的循环等待条件。算法的策略是查找一个进程，使得可用资源能满足该进程的资源请求，然后假设同意这些资源，让该进程运行直到结束，再释放它的所有资源。然后，算法再寻找另一个可以满足资源请求的进程。</p><p><img src="image-20210410143441173.png" alt="image-20210410143441173"></p><p><strong>死锁恢复</strong>：</p><ol><li>取消所有的死锁进程。这是操作系统中最常采用的方法。</li><li>连续取消死锁进程直到不再存在死锁。所选取消进程的顺序应基于某种最小代价原则。每次取消后，必须重新调用检测算法，以测试是否仍存在死锁。</li><li>连续抢占资源直到不再存在死锁。</li></ol><p><strong>对于内存资源来说，基于抢占的死锁预防是最适合的策略</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之进程与线程管理</title>
      <link href="/DRLdCV5y4mc6kSqv/"/>
      <url>/DRLdCV5y4mc6kSqv/</url>
      
        <content type="html"><![CDATA[<h4 id="进程与线程管理"><a href="#进程与线程管理" class="headerlink" title="进程与线程管理"></a>进程与线程管理</h4><p><strong>任务、线程、进程三者关系</strong></p><p>任务是一个抽象的概念，即指软件完成的一个活动；而线程则是完成任务所需的动作；进程则指的是完成此动作所需资源的统称；关于三者的关系，有一个形象的比喻：</p><ul><li>任务 = 送货</li><li>线程 = 开送货车</li><li>系统调度 = 决定合适开哪部送货车</li><li>进程 = 道路 + 加油站 + 送货车 + 修车厂</li></ul><a id="more"></a><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><h6 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h6><p>操作系统为进程提供两种虚拟机制。虚拟处理器让进程觉得自己在独享<code>CPU</code>。虚拟内存让进程在分配和管理内存的时候觉得自己拥有全部内存资源。</p><p>进程就是处于执行期的程序和一组相关的系统资源的总称。这些资源包括，打开的文件描述符、挂起的信号、内核内部数据、处理器状态、映射了的内存地址空间、所有执行的线程以及存放全局变量的数据段。它的两个基本元素就是程序代码（可能被执行相同程序的其他进程共享）和与代码相关联的数据集。</p><p>进程最少必须包括一个或一组被执行的程序，而与这些程序相关联的是局部变量、全局变量和任何已定义常量的数据单元。因此，一个进程至少应有足够的内存空间来保存其<strong>程序和数据</strong>；此外，程序的执行通常涉及用于跟踪过程调用和过程间参数传递的<strong>栈帧</strong>。最后，还有与每个进程相关的许多属性，以便操作系统控制该进程。通常，属性集称为<strong>进程描述符</strong>。<strong>程序、数据、栈帧和属性的集合称为进程映像</strong>。下图表示了进程映像在虚存中的结构。</p><p><img src="image-20210319113140920.png" alt="image-20210319113140920"></p><h6 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h6><p>从<code>linux</code>内核的观点看，进程又被称为任务，<strong>内核将所有进程组织在叫做任务队列的一个双向循环链表中</strong>。链表中的每一项是类型为<code>task_struct</code>的结构体（定义在<code>&lt;linux/sched.h&gt;</code>文件中），称为<strong>进程描述符或进程控制块</strong>，它被用来定义和描述一个完整的进程。</p><p>进程描述符包含有一个具体进程的所有信息，主要包括：</p><ul><li>进程标识信息<ul><li>标识符：与进程相关的唯一标识符，用来区分其他进程。每个进程都有唯一的一个进程标识符<code>PID</code>，以及用户标识符<code>UID</code>和组标识符<code>GID</code>。组标识符用于给一组进程指定资源访问特权。</li></ul></li><li>进程状态信息<ul><li>程序计数器：程序中即将执行的下一条指令的地址。</li><li>栈指针：用于指向保存参数和过程调用或系统调用的地址的栈帧的栈顶指针。</li><li>上下文数据：进程执行时处理器的<strong>寄存器组</strong>中的数据。包括控制，状态寄存器等。</li></ul></li><li>进程控制信息<ul><li>状态：表示进程的执行状态，有执行态、就绪态、停止态、阻塞态和僵死态。</li><li>调度信息：<code>Linux</code>调度进程所需要的信息。一个进程可能是普通的或实时的，并具有优先级。实时进程在普通进程前调度，且在每类中使用相关的优先级。一个计数器会记录允许进程执行的时间量。</li><li>等待事件信息：进程继续执行前等待的事件标识。</li><li>地址空间信息：包括程序代码和进程相关数据的指针，以及与其他进程共享内存块的指针。</li><li>时间和计时器：包括进程创建的时刻和进程所消耗的处理器时间总量。一个进程可能还有一个或多个间隔计时器，进程通过系统调用来定义间隔计时器，计时器期满时，会给进程发送一个信号。计时器可以只用一次或周期性地使用。</li><li>链接：每个进程都有一个到其父进程的链接及到其兄弟进程（与它有相同的父进程）的链接，以及到其所有子进程的链接。</li><li>文件系统：包括指向被该进程打开的任何文件的指针和指向该进程当前目录与根目录的指针。</li></ul></li></ul><p><code>Linux</code>通过<code>slab</code>分配器动态地给<code>task_struct</code>的结构体分配内存空间，这样能达到对象复用（通过预先分配和重复使用<code>task_struct</code>，可以避免动态分配和释放带来的资源消耗）和缓存着色的目的。除此之外，还需要在内核栈的栈底创建一个类型为<code>thread_info</code>的结构体（定义在<code>&lt;asm/thread_info.h&gt;</code>文件中），结构中的<code>task</code>域存放有指向该任务的<code>task_struct</code>的指针。</p><p>对于<code>Linux</code>系统，进程描述符中的<code>state</code>域描述了当前进程的状态，也就是其行为特征，共分为<code>5</code>种：</p><ol><li><p><code>TASK_RUNNING</code></p><p> 表示进程是可执行的；要么是在运行队列中等待被调度执行（就绪态），要么是正在执行（运行态）。</p></li><li><p><code>TASK_INIERRUPTIBLE</code></p><p> 进程正在被阻塞（阻塞态），等待某些条件的满足。一旦条件满足或者接收到信号而提前被唤醒，会从当前状态转为<code>TASK_RUNNING</code>状态（就绪态）。</p></li><li><p><code>TASK_UNINIERRUPTIBLE</code></p><p> 和<code>TASK_INIERRUPTIBLE</code>状态相同，除了<strong>不响应任何信号</strong>。也就是执行<code>ps</code>命令后看到进程被标记为<code>D</code>状态的进程，不能通过发送<code>SIGKILL</code>信号杀死处于此状态的进程。比如内核态进程在等待某项资源，这时候是不允许被打断的，否则可能导致系统进入未知状态，或者引发严重的系统异常，所以对于这种操作，定义<code>D</code>状态进行保护。使其在完成本次操作之前，不可以被任何异步状态打断。</p></li><li><p><code>_TASK_TRACED</code></p><p> 表示此进程正在被其它进程跟踪，例如通过<code>ptrace</code>对调试程序进行跟踪。</p></li><li><p><code>_TASK_STOPPED</code></p><p> 进程处于终止状态（停止态）。并且只能由来自另一个进程的主动动作恢复，例如，在调试期间收到任何信号都会使进程进入此状态。</p></li><li><p>僵死态</p><p> 进程已被终止，但由于某些原因，在进程表中仍然有其<code>task_struct</code>。</p></li></ol><p><img src="image-20210319201039276.png" alt="image-20210319201039276"></p><p>可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行（用户态）。当一个程序调执行了系统调用或者触发了某个异常，它就陷入了内核空间（内核态）。此时，我们称内核“代表进程执行”并处于<strong>进程上下文</strong>中。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复到用户空间继续执行。</p><p>系统调用，异常处理程序和中断处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行——对内核的所有访问都必须通过这些接口。</p><p>在<code>Linux</code>系统中，所有的进程都是<code>PID</code>为<code>1</code>的<code>init</code>进程的后代。内核在系统启动的最后阶段启动<code>init</code>进程。该进程读取系统的初始化脚本并执行其他的相关程序，最终完成系统启动的整个过程。</p><h5 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h5><p>进程的创建将一个新进程添加到正被管理的进程集时，操作系统需要建立用于管理该进程的数据结构，并在内存中给它分配地址空间，这些行为构成了一个新进程的创建过程， 操作系统会按照如下步骤操作：</p><ol><li>为新进程分配一个唯一的进程描述符。此时，主进程表中会添加一个新表项，每个进程一个表项。</li><li>为进程分配空间。包括进程映像中的所有元素。</li><li>初始化进程控制块（进程描述符）。</li><li>设置正确的链接。即将其放入适当的任务队列中。</li><li>创建或扩充其它数据结构。例如，操作系统可因编制账单和/或评估性能，为每个进程维护一个记账文件。</li></ol><p><code>Linux</code>中的进程创建分为两步，首先，<code>fork()</code>通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于<code>PID</code>、<code>PPID</code>（子进程将其设置为被拷贝进程的<code>PID</code>）和某些资源和统计量（例如，挂起的信号，它没有必要被继承）。然后，在需要时，通过<code>exec()</code>函数族读取可执行文件并将其载入地址空间开始作为一个全新的进程运行。</p><p><code>fork()</code>使用写时拷贝（<code>copy-on-write</code>）页实现。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。</p><p><code>fork()</code>的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。如果进程创建后马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据。</p><p><code>fork()</code>通过<code>clone()</code>系统调用实现。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。<code>fork()</code>和<code>_clone()</code>库函数都根据各自需要的参数标志去调用<code>clone()</code>，然后由<code>clone()</code>去调用<code>do_fork()</code>。</p><p><code>do_fork</code>完成了创建中的大部分工作，它的定义在<code>kernel/fork.c</code>文件中。该函数调用<code>copy_process()</code>函数，然后让进程开始运行。<code>copy _process()</code>函数完成如下工作：</p><ol><li>调用<code>dup_task_struct()</code>为新进程创建一个内核栈、<code>thread_info</code>结构和<code>task_struct</code>，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同的。</li><li>检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制。</li><li>子进程着手使自己与父进程区别开来。进程描述符内的许多成员都要被清零或设为初始值。那些不是继承而来的进程描述符成员，主要是统计信息（文件引用计数等）。<code>task_struct</code>中的大多数数据都依然未被修改。</li><li>子进程的状态被设置为<code>TASK_UNINTERRUPTIBLE</code>，以保证它不会投入运行。</li><li><code>copy_process()</code>调用<code>copy_flags()</code>以更新<code>task_struct</code>的<code>flags</code>成员。表明进程是否拥有超级用户权限的<code>PF_SUPERPRIV</code>标志被清<code>0</code>。表明进程还没有调用<code>exec()</code>函数的<code>PF_FORKNOEXEC</code>标志被设置。</li><li>调用<code>alloc_pid()</code>为新进程分配一个有效的<code>PID</code>。</li><li>根据传递给<code>clone()</code>的参数标志，<code>copy_process()</code>拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。在一般情况下，这些资源会被给定进程的所有线程共享。</li><li>最后，<code>copy_process()</code>做扫尾工作并返回一个指向子进程的指针。</li></ol><p>再回到<code>do_fork()</code>函数，如果<code>copy_process()</code>函数成功返回，新创建的子进程被唤醒并让其投入运行。内核有意选择子进程首先执行。因为一般子进程都会马上调用<code>exec()</code>函数族，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。</p><h5 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h5><table><thead><tr><th align="center">原因</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">正常完成</td><td align="center">进程自行执行一个操作系统服务调用，表示它已经结束运行</td></tr><tr><td align="center">超出时限</td><td align="center">进程运行时间超过规定的时限</td></tr><tr><td align="center">无可用内存</td><td align="center">系统无法满足进程需要的内存空间</td></tr><tr><td align="center">保护错误</td><td align="center">进程试图使用不允许使用的资源或文件，如往只读文件中写或试图访问不允许访问的内存单元</td></tr><tr><td align="center"><code>I/O</code>失败</td><td align="center">在输入或输出期间发生错误，如找不到文件或某些无效操作</td></tr><tr><td align="center">父进程终止</td><td align="center">当一个父进程终止时，操作系统可能会自动终止该进程的所有子进程</td></tr><tr><td align="center">父进程请求</td><td align="center">父进程通常具有终止其任何子进程的权力</td></tr></tbody></table><p>进程的终结发生在调用<code>exit()</code>系统调用时，<code>exit()</code>又调用了<code>do_exit()</code>（定义在<code>&lt;kernel/exit.c&gt;</code>文件中）：</p><ol><li><p>将<code>tast_struct</code>中的标志成员设置为<code>PF_EXITING</code>。</p></li><li><p>调用<code>del_timer_sync()</code>删除任一内核定时器。根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。</p></li><li><p>然后调用<code>exit_mm()</code>函数释放进程占用的<code>mm_struct</code>，如果没有别的进程使用它们（也就是说，这个地址空间没有被共享)，就彻底释放它们。</p></li><li><p>接下来调用<code>sem__exit()</code>函数。如果进程排队等候<code>IPC</code>信号，它则离开队列。</p></li><li><p>调用<code>exit_files()</code>和<code>exit_fs()</code>，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为零，那么就代表没有进程在使用相应的资源，此时可以释放。</p></li><li><p>接着把存放在<code>task_struct</code>的<code>exit_code</code>成员中的任务退出代码置为由<code>exit()</code>提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。退出代码存放在这里供父进程随时检索。</p></li><li><p>调用<code>exit_notify()</code>向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为<code>init</code>进程，并把进程状态（存放在<code>task_struct</code>结构的<code>exit_state</code>中）设成<code>EXIT_ZOMBIE</code>。</p><p> 如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白地耗费内存。一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。<code>init</code>进程会例行调用<code>wait()</code>来检查其子进程，清除所有与其相关的僵死进程。</p></li><li><p><code>do_exit()</code>调用<code>schedule()</code>切换到新的进程。因为处于<code>EXIT_ZOMBIE</code>状态的进程不会再被调度，所以这是进程所执行的最后一段代码。<code>do_exit()</code>永不返回。</p></li></ol><p>至此，与进程相关联的所有资源都被释放掉了，还占用的所有内存就是内核栈、<code>thread_info</code>结构和<code>tast_struct</code>结构。此时进程存在的唯一目的就是向它的父进程提供信息。</p><p>这意味着，进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得已终结的子进程的信息后，通知内核它并不关注那些信息后，子进程的<code>task_struct</code>结构才被释放。</p><p><code>wait()</code>这一族函数都是通过唯一（但是很复杂）的一个系统调用<code>wait4()</code>来实现的。它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的<code>PID</code>。此外，调用该函数时提供的指针会包含子函数退出时的退出代码。</p><p>当最终需要释放进程描述符时，<code>release_task()</code>会被调用，用以完成以下工作：</p><ol><li>它调用<code>__exit_signal()</code>，该函数调用<code>_unhash process()</code>，后者又调用<code>detach_pid()</code>从<code>pidhash</code>上删除该进程，同时也要从任务列表中删除该进程。</li><li><code>_exit_signal()</code>释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。</li><li>如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么<code>release_task()</code>就要通知僵死的领头进程的父进程。</li><li><code>release_task()</code>调用<code>put_task_struct()</code>释放进程内核栈和<code>thread_info</code>结构所占的页，并释放<code>tast_struct</code>所占的<code>slab</code>高速缓存。</li></ol><p>至此，进程描述符和所有进程独享的资源就全部释放掉了。</p><h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><h6 id="进程间切换"><a href="#进程间切换" class="headerlink" title="进程间切换"></a>进程间切换</h6><p>进程切换可在操作系统从当前正在运行进程中获得控制权的任何时刻（即，当执行进程从用户态转移到内核态之后）发生。</p><table><thead><tr><th>机制</th><th>原因</th><th>用途</th></tr></thead><tbody><tr><td>中断</td><td>来自当前执行指令的外部</td><td>对异步外部事件的反应，如完成一次<code>I/O</code>操作</td></tr><tr><td>异常（陷阱）</td><td>与当前执行指令有关</td><td>处理一个错误或异常事件，如非法的内存或文件访问</td></tr><tr><td>系统调用</td><td>显示请求</td><td>调用系统函数，使用系统调用会将用户进程设为阻塞态</td></tr></tbody></table><p>涉及状态变化的完整的进程切换步骤如下：</p><ol><li>保存处理器的上下文，包括程序计数器和其他寄存器。</li><li>更新当前处于运行态进程的进程控制块，包括把进程的状态改变为另一状态（就绪态、阻塞态、退出态）。还须更新其他相关的字段，包括退出运行态的原因和记账信息。</li><li>把该进程的进程控制块移到相应的任务队列（就绪、阻塞）</li><li>选择另一个进程执行，详见进程调度。</li><li>更新所选进程的进程控制块，包括把进程的状态改为运行态。</li><li>更新内存管理数据结构。是否需要更新取决于管理地址转换的方式，详见内存管理。</li><li>载入程序计数器和其他寄存器先前的值，将处理器的上下文恢复为所选进程上次退出运行态时的上下文。</li></ol><p>与<strong>模式切换</strong>（指用户态和内核态间切换）的区别在于，模式切换可在不改变当前运行态进程的状态下出现（即不涉及状态变化），此时保存上下文并之后恢复上下文仅需很少的开销。</p><h6 id="线程间切换"><a href="#线程间切换" class="headerlink" title="线程间切换"></a>线程间切换</h6><p><strong>在<code>Linux</code>系统中</strong>，当<code>Linux</code>内核执行从一个进程到另一个进程的切换时，会检查当前进程的页目录地址是否与将被调度的进程的相同。若相同，则它们共享同一个地址空间（即同一个进程中的不同线程），所以此时上下文切换仅是从代码的处跳转到代码的另一处。</p><p>进程切换分两步：</p><ol><li>切换页目录以使用新的地址空间。</li><li>切换内核栈和硬件上下文。</li></ol><p>对于<code>Linux</code>来说，线程和进程的最大区别就在于地址空间。对于线程切换，第<code>1</code>步是不需要做的，第<code>2</code>步是进程和线程切换都要做的。 所以明显是进程切换代价大。</p><p>另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理器的页表缓冲（<code>TLB</code>）会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。</p><h5 id="线程和线程在Linux中的实现"><a href="#线程和线程在Linux中的实现" class="headerlink" title="线程和线程在Linux中的实现"></a>线程和线程在<code>Linux</code>中的实现</h5><p><strong>进程是资源分配的最小单元，享有资源所有权，线程是调度执行的具体对象，享有被调度执行权。</strong></p><p>线程是在进程中活动的可被内核调度的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。同一个进程中的所有线程可以共享虚拟内存，但拥有独立的虚拟处理器。<strong>进程中的所有线程共享该进程的状态和资源，所有线程都驻留在同一块地址空间中，并可访问相同的数据</strong>。</p><p><code>Linux</code>实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的<code>task_struct</code>，所以在内核中，它看起来就像是一个普通的进程，只是线程和其他一些进程共享某些资源，如地址空间。</p><p>也就是说，组成一个用户级进程的多个用户级线程被映射到<strong>共享同一个组<code>ID</code></strong>的多个<code>Linux</code>内核级进程上。因此，<strong>这些进程可以共享文件和内存等资源</strong>，使得同一个组中的进程调度切换时不需要切换上下文。</p><p>线程的创建和普通进程的创建类似，只不过在调用<code>clone()</code>的时候需要传递一些参数标志来指明需要共享的资源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>上面的代码产生的结果和调用<code>fork()</code>差不多，只是父子俩共享地址空间<code>CLONE_VM</code>、文件系统资源<code>CLONE_FS</code>、文件描述符<code>CLONE_FILES</code>和信号处理程序<code>CLONE_SIGHAND</code>。新建的进程和它的父进程就是所谓的线程，但它们都具有各自的用户栈，因为<code>clone()</code>系统调用会为每个进程创建独立的栈空间。</p><p>对比一下，一个普通的<code>fork()</code>的实现是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这些<code>clone()</code>用到的参数标志以及它们的作用，这些是在<code>&lt;linux/sched.h&gt;</code>中定义的。</p><h6 id="内核线程（进程）"><a href="#内核线程（进程）" class="headerlink" title="内核线程（进程）"></a><strong>内核线程（进程）</strong></h6><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程（独立运行在内核空间的标准进程，内核线程也只能由其他内核线程创建）完成。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的<code>mm</code>指针被设置为<code>NULL</code>）。它们只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。</p><h6 id="守护线程（进程）"><a href="#守护线程（进程）" class="headerlink" title="守护线程（进程）"></a><strong>守护线程（进程）</strong></h6><p><code>Linux Daemon</code>（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。<code>Linux</code>系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程<code>syslogd</code>、 <code>web</code>服务器<code>httpd</code>等。</p><p>守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（<code>root</code>）权限运行，因为它们要使用特殊的端口（<code>1-1024</code>）或访问某些特殊的资源。</p><p>一个守护进程的父进程是<code>init</code>进程，因为它真正的父进程在<code>fork</code>出子进程后就先于子进程<code>exit</code>退出了，所以它是一个由<code>init</code>继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备<code>stdout</code>还是标准出错设备<code>stderr</code>的输出都需要特殊处理。</p><p>首先我们要了解一些基本概念：</p><p>进程组 ：</p><ul><li>每个进程也属于一个进程组</li><li>每个进程主都有一个进程组号，该号等于该进程组组长的<code>PID</code>号 .</li><li>一个进程只能为它自己或子进程设置进程组<code>ID</code>号</li></ul><p>会话：会话（<code>session</code>）是一个或多个进程组的集合。</p><p><code>setsid()</code>函数可以建立一个会话：</p><p> 如果，调用<code>setsid</code>的进程不是一个进程组的组长，此函数创建一个新的会话期。</p><ol><li>此进程变成该对话期的首进程；</li><li>此进程变成一个新进程组的组长进程；</li><li>此进程没有控制终端，如果在调用<code>setsid</code>前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误；</li><li>为了保证这一点，我们先调用<code>fork()</code>然后父进程<code>exit()</code>，此时只有子进程在运行。</li></ol><p>现在我们来给出创建守护进程所需步骤：</p><p>编写守护进程的一般步骤步骤：</p><ol><li>在父进程中执行<code>fork</code>并让父进程<code>exit</code>退出；</li><li>在子进程中调用<code>setsid</code>函数创建新的会话；</li><li>在子进程中调用<code>chdir</code>函数，让根目录<code>/</code>成为子进程的工作目录；</li><li>在子进程中调用<code>umask</code>函数，设置进程的<code>umask</code>为<code>0</code>；</li><li>在子进程中关闭任何不需要的文件描述符。</li></ol><p>一些说明：</p><ol><li><p>在后台运行<br> 为避免挂起控制终端将<code>Daemon</code>放入后台执行。方法是在进程中调用<code>fork</code>使父进程终止，让<code>Daemon</code>在子进程中后台执行。</p></li><li><p>脱离控制终端，登录会话和进程组<br> 有必要先介绍一下<code>Linux</code>中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（<code>GID</code>）就是进程组长的进程号（<code>PID</code>）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。</p><p> 控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第<code>1</code>点的基础上，调用<code>setsid()</code>使进程成为会话组长，当进程是会话组长时<code>setsid()</code>调用失败。</p><p> 但第一点已经保证进程不是会话组长。<code>setsid()</code>调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。</p></li><li><p>禁止进程重新打开控制终端<br> 现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过再次<code>fork()</code>使进程不再成为会话组长来禁止进程重新打开控制终端。</p></li><li><p>关闭打开的文件描述符<br> 进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。</p></li><li><p>改变当前工作目录<br> 进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录。</p></li><li><p>重设文件创建掩码<br> 进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：<code>umask(0);</code>。</p></li><li><p>处理<code>SIGCHLD</code>信号<br> 处理<code>SIGCHLD</code>信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在<code>Linux</code>下可以简单地将<code>SIGCHLD</code>信号的操作设为<code>SIG_IGN</code>：<code>signal(SIGCHLD, SIG_IGN);</code>。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之memcpy、memset、strcpy、strcmp、strlen、string的实现</title>
      <link href="/fKh6HJGjVNfldP4P/"/>
      <url>/fKh6HJGjVNfldP4P/</url>
      
        <content type="html"><![CDATA[<ol><li><code>memcpy</code></li><li><code>memset</code></li><li><code>strcpy</code></li><li><code>strcmp</code></li><li><code>strlen</code></li><li>自己动手实现一个<code>string</code>类</li></ol><a id="more"></a><h4 id="memcpy、memset实现"><a href="#memcpy、memset实现" class="headerlink" title="memcpy、memset实现"></a><code>memcpy</code>、<code>memset</code>实现</h4><h5 id="memcpy实现"><a href="#memcpy实现" class="headerlink" title="memcpy实现"></a><code>memcpy</code>实现</h5><ul><li>此实现并没有考虑<code>dst</code>和<code>src</code>的内存重叠问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 const 修饰 src</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 验证 dst 和 src 的合法性</span></span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">void</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">char</span>*)dst = *(<span class="keyword">char</span>*)src;</span><br><span class="line">        dst = (<span class="keyword">char</span>*)dst + <span class="number">1</span>;</span><br><span class="line">        src = (<span class="keyword">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="memset实现"><a href="#memset实现" class="headerlink" title="memset实现"></a><code>memset</code>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memset</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">void</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">char</span>*)dst = (<span class="keyword">char</span>)ch;</span><br><span class="line">        dst = (<span class="keyword">char</span>*)dst + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回原 dst 指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="strcpy、strcmp、strlen实现"><a href="#strcpy、strcmp、strlen实现" class="headerlink" title="strcpy、strcmp、strlen实现"></a><code>strcpy</code>、<code>strcmp</code>、<code>strlen</code>实现</h4><h5 id="strcpy实现"><a href="#strcpy实现" class="headerlink" title="strcpy实现"></a><code>strcpy</code>实现</h5><ul><li>此实现并没有考虑<code>dst</code>和<code>src</code>的内存重叠问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 const 修饰 src</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 验证 dst 和 src 的合法性</span></span><br><span class="line">    assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>((*dst++ = *src++) != <span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回原 dst 指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="strcmp实现"><a href="#strcmp实现" class="headerlink" title="strcmp实现"></a><code>strcmp</code>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意将两个指针都用 const 修饰</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* rhs, <span class="keyword">const</span> <span class="keyword">char</span>* lhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判空测试</span></span><br><span class="line">    assert(rhs != <span class="literal">NULL</span>);</span><br><span class="line">    assert(lhs != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里必须是 unsigned char</span></span><br><span class="line">    <span class="comment">// 表示的范围为 0 ~ 255</span></span><br><span class="line">    <span class="comment">// 如果是 char 的话, 范围是 -128 ~ 127, 这个范围用来比较字符串是不对的</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = *rhs++;</span><br><span class="line">        c2 = *lhs++;</span><br><span class="line">        <span class="keyword">if</span>(c1 != c2)</span><br><span class="line">            <span class="keyword">return</span> c1 &lt; c2 ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="number">0</span>)</span><br><span class="line">            bresk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="strlen实现"><a href="#strlen实现" class="headerlink" title="strlen实现"></a><code>strlen</code>实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pc = str;</span><br><span class="line">    <span class="keyword">while</span>(*pc++ != <span class="string">'\0'</span>);</span><br><span class="line">    <span class="keyword">return</span> pc - str - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于标准库中的实现</strong>：通过减少数据从内存存取到寄存器的次数来提高效率，使用的手段是先字节对齐，然后每次读取一个<code>4/8</code>字节的多字节数据，对多字节数据遍历是否存在<code>\0</code>。</p><h4 id="自己动手实现一个string类"><a href="#自己动手实现一个string类" class="headerlink" title="自己动手实现一个string类"></a>自己动手实现一个<code>string</code>类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *_data;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *c_str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="keyword">char</span>[_size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_data, c_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String() : _data(<span class="literal">nullptr</span>), _size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    String(<span class="keyword">const</span> <span class="keyword">char</span> *c_str) : _size(<span class="built_in">strlen</span>(c_str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c_str)</span><br><span class="line">            init(c_str);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String(<span class="keyword">const</span> String &amp;str) : _size(str._size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str._data)</span><br><span class="line">            init(str._data);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String(String &amp;&amp;str) <span class="keyword">noexcept</span> : _data(str._data), _size(str._size)</span><br><span class="line">    &#123;</span><br><span class="line">        str._data = <span class="literal">nullptr</span>;</span><br><span class="line">        str._size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~String()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_data)</span><br><span class="line">            <span class="keyword">delete</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> *c_str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 copy and swap 技术, 可以处理自我赋值情况</span></span><br><span class="line">        String temp(c_str);</span><br><span class="line">        swap(temp);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> = str._data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(String &amp;&amp;str) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测自我赋值情况</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (_data)</span><br><span class="line">            <span class="keyword">delete</span> _data;</span><br><span class="line">        _data = <span class="literal">nullptr</span>;</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">        swap(str);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(String &amp;str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(_data, str._data);</span><br><span class="line">        swap(_size, str._size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">char</span> *c_str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(_data, c_str) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> == str._data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">size_t</span> i) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> String str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; str.c_str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之const关键字的实现</title>
      <link href="/cZUstnNRSXkgncRt/"/>
      <url>/cZUstnNRSXkgncRt/</url>
      
        <content type="html"><![CDATA[<h4 id="编译器是如何实现const关键字功能的"><a href="#编译器是如何实现const关键字功能的" class="headerlink" title="编译器是如何实现const关键字功能的"></a>编译器是如何实现<code>const</code>关键字功能的</h4><h5 id="const用于声明变量"><a href="#const用于声明变量" class="headerlink" title="const用于声明变量"></a><code>const</code>用于声明变量</h5><p><code>const</code>定义的变量只有类型为<strong>整数或枚举</strong>，且<strong>以常量表达式初始化</strong>时，在其它地方使用该变量的地方才会被以常量替换。其他情况下它只是一个<code>const</code>限定的变量。但它们都分配了内存地址，把它们统称为常量。</p><a id="more"></a><ul><li><p>修饰全局变量</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局</span></span><br><span class="line"><span class="keyword">const</span> Point p&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point *pp = (Point *)&amp;p;</span><br><span class="line">    pp-&gt;x = <span class="number">3</span>; <span class="comment">// error!</span></span><br><span class="line">    <span class="comment">// Exception has occurred. Segmentation fault</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  未被<code>const</code>修饰的全局变量默认为<code>extern</code>，不需要<code>extern</code>显式声明即可以在其它文件中访问！而全局<code>const</code>常量需要显式声明<code>extern</code>，并且需要做初始化，才能在其它文件中访问！<strong>因为常量在定义后就不能被修改，所以定义时必须初始化</strong>。</p><p>  虽然可以编译通过（骗过了编译器）。<strong>但上述全局<code>const</code>修饰的变量<code>p</code>会被编译器存放在<code>ELF</code>文件的<code>.rodata</code>分区（只读），程序默认不拥有写权限，故运行时不可更改</strong>。</p><p>  接下来，控制变量<code>p</code>的<code>const</code>功能就交给操作系统中内存分页机制了。操作系统会将<code>.rodata</code>所在的内存页的权限标记为只读。每当程序访问内存时，<code>CPU</code>都会检查内存地址对应的权限。如果权限不符，那么<code>CPU</code>就会产生中断并调用操作系统所设置的中断处理例程。在这个例子中，当<code>CPU</code>发现程序想要写一块只读内存时，就会产生中断。而<code>Linux</code>设置的默认动作是终止程序，并打印 “<code>Segmentation fault (core dumped)</code>”。</p></li><li><p>修饰局部变量</p><p>  这时只是编译器负责检查你有没有显式的通过<code>p</code>来修改<code>const</code>修饰的变量<code>p</code>的值。但是你可以通过其它技巧骗过编译器来修改。比如：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 局部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Point p&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    p.x = <span class="number">3</span>; <span class="comment">// error!</span></span><br><span class="line">    Point *pp = (Point *)&amp;p;</span><br><span class="line">    pp-&gt;x = <span class="number">3</span>; <span class="comment">// correct!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>编译器的实现为，函数内变量放在函数的栈帧里的，程序拥有对这个存储区自由读写的权限</strong>。</p></li><li><p>修饰类的成员变量</p><p>  编译器的实现和前面说的修饰函数内局部变量一样。但类中的<code>const</code>成员变量必须通过初始化列表进行初始化。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Point(<span class="keyword">int</span> x_, <span class="keyword">int</span> y_) : x(x_), y(y_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// p 对象中 x = 1, y = 2</span></span><br><span class="line">    <span class="keyword">int</span> *pi = (<span class="keyword">int</span> *)&amp;p;</span><br><span class="line">    *pi = <span class="number">3</span>; <span class="comment">// // p 对象中 x = 3, y = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过指针竟然可以修改类对象内声明为<code>const</code>的对象。细思极恐,，这其实就是指针的被广为诟病的地方了。</p></li><li><p>修饰函数形参</p><ul><li><p><code>value with const</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> val)</span></span>; <span class="comment">// 传递过来的参数不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> p)</span></span>; <span class="comment">// 指针本身不可变</span></span><br></pre></td></tr></table></figure><p>  编译器的实现跟前面讨论的修饰函数内局部变量一样。</p></li><li><p><code>reference or pointer with const</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>; <span class="comment">// 参数指针所指内容为常量不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> A &amp;a)</span> <span class="comment">// 参数为引用, 为了增加效率同时防止修改</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>修饰函数返回类型</p><ul><li><p><code>value with const</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point <span class="title">func1</span><span class="params">()</span></span>; <span class="comment">// 无意义, 因为参数返回本身就是赋值给其他的变量！</span></span><br></pre></td></tr></table></figure></li><li><p><code>reference or pointer with const</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point* <span class="title">func2</span><span class="params">()</span></span>; <span class="comment">// 指针指向内容不可变</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Point&amp; <span class="title">func2</span><span class="params">()</span></span>; <span class="comment">// 引用的内容不可变</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="const用于声明函数"><a href="#const用于声明函数" class="headerlink" title="const用于声明函数"></a><code>const</code>用于声明函数</h5><ul><li><p>修饰类的成员函数</p><p>  被<code>const</code>修饰的类对象，只能访问类中<code>const</code>成员函数。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Point(<span class="keyword">int</span> x_, <span class="keyword">int</span> y_) : x(x_), y(y_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  编译器会将被<code>const</code>修饰的成员函数<code>getX()</code>转化为：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化为下面这样</span></span><br><span class="line"><span class="comment">// 前面的那个 const_ 才是 const 修饰起到的作用, 后面的本身就有</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">(const_ Point* <span class="keyword">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样的调用</span></span><br><span class="line"><span class="function">Point <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">p.getX();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为下面这样</span></span><br><span class="line">getX(&amp;p);</span><br></pre></td></tr></table></figure><p>  也就是说，<code>const</code>修饰类成员函数时，修饰的只是传进来的<code>this</code>指针而已。</p></li></ul><h5 id="const-char-str、char-str、char-str-、const-char-str-的区别"><a href="#const-char-str、char-str、char-str-、const-char-str-的区别" class="headerlink" title="const char* str、char* str、char str[]、const char str[]的区别"></a><code>const char* str</code>、<code>char* str</code>、<code>char str[]</code>、<code>const char str[]</code>的区别</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注意, 下面的讨论都是把此定义放在 全局 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器都会将常量 "hello" 存放在只读数据段</span></span><br><span class="line"><span class="comment">// 而且这和前面是否使用 const 修饰没关系</span></span><br><span class="line"><span class="comment">// 程序持有的只是一个指针变量而已</span></span><br><span class="line"><span class="comment">// 所以, 通过指针修改这个串 "hello", 都会报错的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但如果这样定义</span></span><br><span class="line"><span class="comment">// 此时定义的是数组变量, 有 const 的话会放在只读数据段</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 const 的话就会放在可写段</span></span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *s2 = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">char</span> s3[] = <span class="string">"dfasd"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> s4[] = <span class="string">"asdfasdf"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s1 = <span class="string">'e'</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">char</span> *ps1 = (<span class="keyword">char</span> *)s1;</span><br><span class="line">    *ps1 = <span class="string">'d'</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    *s2 = <span class="string">'e'</span>; <span class="comment">// error</span></span><br><span class="line">    *s3 = <span class="string">'e'</span>; <span class="comment">// correct</span></span><br><span class="line"></span><br><span class="line">    *s4 = <span class="string">'r'</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">char</span> *ps4 = (<span class="keyword">char</span> *)s4;</span><br><span class="line">    *ps4 = <span class="string">'d'</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意, 下面的讨论都是把此定义放在 局部 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和定义在全局相同</span></span><br><span class="line"><span class="comment">// 编译器都会将常量 "hello" 存放在只读数据段</span></span><br><span class="line"><span class="comment">// 而且这和前面是否使用 const 修饰没关系</span></span><br><span class="line"><span class="comment">// 程序持有的只是一个指针变量而已</span></span><br><span class="line"><span class="comment">// 所以, 通过指针修改这个串 "hello", 都会报错的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但如果这样定义</span></span><br><span class="line"><span class="comment">// 此时定义的是数组变量, 有 const 的话 只会放在函数的栈帧上</span></span><br><span class="line"><span class="comment">// 编译器会负责检查, 不允许你显示修改 str 数组</span></span><br><span class="line"><span class="comment">// 可以通过前面介绍的 trick 骗过编译器来修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 const 的话, 放在函数的栈帧上, 访问就随意啦</span></span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *s2 = <span class="string">"world"</span>;</span><br><span class="line">    <span class="keyword">char</span> s3[] = <span class="string">"dfasd"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> s4[] = <span class="string">"asdfasdf"</span>;</span><br><span class="line"></span><br><span class="line">    *s1 = <span class="string">'e'</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">char</span> *ps1 = (<span class="keyword">char</span> *)s1;</span><br><span class="line">    *ps1 = <span class="string">'d'</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    *s2 = <span class="string">'e'</span>; <span class="comment">// error</span></span><br><span class="line">    *s3 = <span class="string">'e'</span>; <span class="comment">// correct</span></span><br><span class="line"></span><br><span class="line">    *s4 = <span class="string">'r'</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">char</span> *ps4 = (<span class="keyword">char</span> *)s4;</span><br><span class="line">    *ps4 = <span class="string">'d'</span>; <span class="comment">// correct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译器是如何实现强制类型转换的"><a href="#编译器是如何实现强制类型转换的" class="headerlink" title="编译器是如何实现强制类型转换的"></a>编译器是如何实现强制类型转换的</h4><p>关于强制类型转换的分类和使用参考《<code>Effective C++</code>》条款<code>27</code>。</p><p>进行强制类型转换后，内存空间里面<strong>原变量的内容是不会发生改变的</strong>，改变的是运算时产生的<strong>临时数据对象</strong>的类型，是你去读取这个内存空间时的解析方法。</p><p>从编译原理的角度去看，<code>C++</code>编译器会维护一份程序中所有变量的名称和其类型之间的一个映射表。通过变量名称去操作内存空间时，会查看这个映射表，获取变量所属的类型之后再决定操作的内存范围。当使用强制类型转换时，会首先改变这个<strong>临时数据对象</strong>的类型，再去操作内存。</p>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之智能指针</title>
      <link href="/DVejmy5owOXx5WKk/"/>
      <url>/DVejmy5owOXx5WKk/</url>
      
        <content type="html"><![CDATA[<h4 id="智能指针详解及源码分析"><a href="#智能指针详解及源码分析" class="headerlink" title="智能指针详解及源码分析"></a>智能指针详解及源码分析</h4><p>关于智能指针的<code>demo</code>，参见<code>C++ primer 12.1</code>。</p><h5 id="什么是智能指针"><a href="#什么是智能指针" class="headerlink" title="什么是智能指针"></a>什么是智能指针</h5><p>智能指针是使用<code>RAII</code>手法对裸指针进行的一个面向对象封装，即在构造函数中初始化资源地址，在析构函数中释放资源。智能指针保证当资源<strong>应当被释放的时候</strong>一定会释放它，这是利用了<strong>栈上的对象出作用域时自动析构</strong>这个特点。</p><a id="more"></a><h5 id="为什么引入智能指针"><a href="#为什么引入智能指针" class="headerlink" title="为什么引入智能指针"></a>为什么引入智能指针</h5><p>用以弥补裸指针的不足：</p><p>​        1）使用裸指针分配内存后，没有对指针释放资源会导致内存泄漏；</p><p>​        2）多个裸指针指向同一资源时，多次释放资源时，对空悬指针进行释放会导致不可预知的错误。</p><h5 id="如何知道是否存在内存泄漏"><a href="#如何知道是否存在内存泄漏" class="headerlink" title="如何知道是否存在内存泄漏"></a>如何知道是否存在内存泄漏</h5><p>在不借助其他检测工具的情况下，可以通过观察，即程序长时间运行后内存占用率一直不断的缓慢的上升，而实际上在你的逻辑中并没有这么多的内存需求。</p><h5 id="如何定位到内存泄漏点"><a href="#如何定位到内存泄漏点" class="headerlink" title="如何定位到内存泄漏点"></a>如何定位到内存泄漏点</h5><ul><li><code>review</code>代码，找到<code>new</code>和<code>delete</code>关键字的位置，先看看内存的申请和释放是否是成对的来进行初步的判断；</li><li>对于函数中申请的临时空间，认真检查是否存在提前跳出函数的地方而导致没有释放内存。</li></ul><h5 id="智能指针有哪些"><a href="#智能指针有哪些" class="headerlink" title="智能指针有哪些"></a>智能指针有哪些</h5><p>智能指针分为不带引用计数的<code>scoped_ptr</code>和<code>unique_ptr</code>，带引用计数的<code>shared_ptr</code>和<code>weak_ptr</code>。</p><h5 id="这些智能指针分别是如何实现的"><a href="#这些智能指针分别是如何实现的" class="headerlink" title="这些智能指针分别是如何实现的"></a>这些智能指针分别是如何实现的</h5><p><code>scoped_ptr</code>私有化了拷贝构造函数和赋值操作运算符，资源的所有权无法进行转移，也无法在容器中使用，这种方式杜绝了浅拷贝的发生。</p><p><code>unique_ptr</code>删除了拷贝构造函数和赋值函数，因此不支持普通的拷贝或赋值操作。但引入了移动构造函数和移动赋值运算符。所以它们保证了有唯一的智能指针持有此资源。<code>unique_ptr</code>还提供了<code>reset</code>重置资源，<code>swap</code>交换资源等函数，也经常会使用到。</p><p><code>shared_ptr</code>称为强智能指针，<strong>它的资源引用计数器在内存的<code>heap</code>堆上</strong>（这保证了，每个智能指针的引用计数变量会动态的变化）。通常用于管理对象的<strong>生命周期</strong>。只要有一个指向对象的<code>shared_ptr</code>存在，该对象就不会被析构。</p><p><code>weak_ptr</code>被称为弱智能指针，其对资源的引用<strong>不会引起资源的引用计数的变化</strong>，通常作为观察者，用于判断资源是否存在，并根据不同情况做出相应的操作。比如使用<code>weak_ptr</code>对资源进行弱引用，当调用<code>weak_ptr</code>的<code>lock()</code>方法时，若返回<code>nullptr</code>，则说明资源已经不存在，放弃对资源继续操作。否则，将返回一个<code>shared_ptr</code>对象，可以继续操作资源。另外，一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放。即使有<code>weak_ptr</code>指向对象，对象也还是会被释放。</p><p>当需要<strong>多个智能指针</strong>指向同一个资源时，使用带引用计数的智能指针。每增加一个智能指针指向同一资源，资源引用计数加<code>1</code>，反之减<code>1</code>。当引用计数为<code>0</code>时，由最后一个指向资源的智能指针将资源进行释放。</p><h5 id="如何避免循环引用"><a href="#如何避免循环引用" class="headerlink" title="如何避免循环引用"></a>如何避免循环引用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">// 前置声明类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; _ptrb; <span class="comment">// 指向B对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; _ptra; <span class="comment">// 指向A对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">// ptra指向A对象，A的引用计数为1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">// ptrb指向B对象，B的引用计数为1</span></span><br><span class="line">    ptra-&gt;_ptrb = ptrb;          <span class="comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为2</span></span><br><span class="line">    ptrb-&gt;_ptra = ptra;          <span class="comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印A的引用计数结果:2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印B的引用计数结果:2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span></span><br><span class="line"><span class="comment">B对象的引用计数从2减到1，达不到释放A和B的条件（释放的条件是</span></span><br><span class="line"><span class="comment">A和B的引用计数为0），因此造成两个new出来的A和B对象无法释放，</span></span><br><span class="line"><span class="comment">导致内存泄露，这个问题就是“强智能指针的交叉引用(循环引用)问题”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法，这也是强弱智能指针的一个重要应用规则：<strong>定义对象时，用强智能指针<code>shared_ptr</code>，在其它地方引用对象时，使用弱智能指针<code>weak_ptr</code></strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">// 前置声明类 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;B&gt; _ptrb; <span class="comment">// 指向 B 对象的弱智能指针。引用对象时，用弱智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;A&gt; _ptra; <span class="comment">// 指向 A 对象的弱智能指针。引用对象时，用弱智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义对象时，用强智能指针</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">// ptra 指向 A 对象，A 的引用计数为 1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">// ptrb 指向B 对象，B 的引用计数为 1</span></span><br><span class="line">    <span class="comment">// A 对象的成员变量 ptrb 也指向 B 对象，B 的引用计数为 1，因为是弱智能指针，引用计数没有改变</span></span><br><span class="line">    ptra-&gt;_ptrb = ptrb;</span><br><span class="line">    <span class="comment">// B 对象的成员变量 ptra 也指向 A 对象，A 的引用计数为 1，因为是弱智能指针，引用计数没有改变</span></span><br><span class="line">    ptrb-&gt;_ptra = ptra;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果: 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果: 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">出 main 函数作用域，ptra 和 ptrb 两个局部对象析构，分别给 A 对象和</span></span><br><span class="line"><span class="comment">B 对象的引用计数从 1 减到 0，达到释放 A 和 B 的条件，因此 new 出来的 A 和 B 对象</span></span><br><span class="line"><span class="comment">被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="什么情况下需要自定义deleter"><a href="#什么情况下需要自定义deleter" class="headerlink" title="什么情况下需要自定义deleter"></a>什么情况下需要自定义<code>deleter</code></h5><p>在管理的裸指针<strong>不是<code>new</code>出来的裸指针时</strong>需要自定义删除器，比如管理的指针为<strong>文件指针</strong>或<strong>由<code>malloc</code>获得的指针</strong>等。</p><h5 id="enable-shared-from-this机制"><a href="#enable-shared-from-this机制" class="headerlink" title="enable_shared_from_this机制"></a><code>enable_shared_from_this</code>机制</h5><p>当<code>class Widget</code>被<code>share_ptr</code>管理，且在<code>Widget</code>的成员函数里需要把当前类对象的智能指针作为参数传给其他函数时，就需要传递一个指向自身的<code>share_ptr</code>。</p><p>而当使用<code>shared_ptr</code>管理同一资源，调用<code>shared_ptr</code>的构造函数和拷贝构造函数是不一样的（构造函数新创建一份堆上的引用计数资源，拷贝构造函数修改原来堆上的引用计数资源），它们虽然使得不同<code>shared_ptr</code>指向同一资源，但<strong>管理引用计数资源的方式却不一样</strong>。这就造成了不能直接传递<code>shared_ptr&lt;Widget&gt;(this)</code>。因为这样会造成<code>2</code>个非共享的<code>share_ptr</code>指向同一个对象，引用计数资源相互独立导致对象被析构<code>2</code>次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">getptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Widget() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget::~Widget() called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 错误的示例, 每个 shared_ptr 都认为自己是对象仅有的所有者</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Widget;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; p2 = p1-&gt;getptr();</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 打印 p1 和 p2 的引用计数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count() = "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出为 1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2.use_count() = "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出为 1</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;  <span class="comment">// Widget 对象将会被删除两次</span></span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Widget&gt; <span class="comment">// 注意：继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">getptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">    ~Widget() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Widget::~Widget() called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Widget;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; p2 = p1-&gt;getptr();</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">// 打印 p1 和 p2 的引用计数</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count() = "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出为 2</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2.use_count() = "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出为 2</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;  <span class="comment">// // Widget 对象只会被删除一次</span></span></span></span><br></pre></td></tr></table></figure><p>实际使用场景：在异步调用中，存在一个保活机制，异步函数执行的时间点我们是无法确定的，然而异步函数可能会使用到异步调用之前就存在的变量。为了保证该变量在异步函数执期间一直有效，我们可以传递一个指向自身的<code>share_ptr</code>给异步函数，这样在异步函数执行期间<code>share_ptr</code>所管理的对象就不会析构，所使用的变量也会一直有效了（保活）。</p><h5 id="enable-shared-from-this是如何实现的"><a href="#enable-shared-from-this是如何实现的" class="headerlink" title="enable_shared_from_this是如何实现的"></a><code>enable_shared_from_this</code>是如何实现的</h5><p><code>enable_shared_from_this</code>类中包含一个作为观察者的成员变量，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">enable_shared_from_this</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    SetSharedPtr(<span class="built_in">shared_ptr</span>&lt;T&gt;* sp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(weak_this_.expired())</span><br><span class="line">        wp = sp; <span class="comment">// 标准库中并没有把 sp 直接赋值给 wp，而是使用了 shared_ptr 的别名构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __shared_ptr&lt;_Tp, _Lp&gt; shared_from_this()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_ptr&lt;_Tp, _Lp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __shared_ptr&lt;const _Tp, _Lp&gt; shared_from_this() const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_ptr&lt;<span class="keyword">const</span> _Tp, _Lp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt; _M_weak_this; <span class="comment">// 使用 weak_ptr 的目的正是为了避免循环引用!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当一个类继承了<code>enable_shared_from_this</code>类，就继承了<code>_M_weak_this</code>这个成员变量。</p><p>使用<code>shared_ptr&lt;Widget&gt;(new Widget())</code>第一次构造智能指针对象时，就会初始化一个作为观察者的弱智能指针<code>_M_weak_this</code>指向<code>Widget</code>对象资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>&lt;T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(T* w)</span><br><span class="line">    &#123;</span><br><span class="line">        SetSharedPtr(<span class="keyword">this</span>, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSharedPtr</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;T&gt;* sp, enable_shared_from_this&lt;T&gt;* w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        w-&gt;SetSharedPtr(sp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此重载函数的作用是为了处理 Widget 并没有继承 enable_shared_from_this 的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSharedPtr</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<code>shared_from_this()</code>方法代替<code>shared_ptr</code>的普通构造函数来返回一个<code>shared_ptr</code>对象，从而避免产生额外的引用计数资源对象。在<code>shared_from_this()</code>函数中，是通过<code>_M_weak_this</code>来构造并返回一个<code>shared_ptr</code>对象的。</p><h5 id="智能指针源码分析"><a href="#智能指针源码分析" class="headerlink" title="智能指针源码分析"></a>智能指针源码分析</h5><p><code>unique_ptr</code>的声明包含两个模板参数，第一个参数<code>_Tp</code>显然就是原生指针的类型。第二个模板参数<code>_Dp</code>是一个<code>deleter</code>，默认值为<code>default_delete&lt;_Tp&gt;</code>。<code>default_delete</code>是一个针对<code>delete operator</code>的函数对象。</p><p><code>unique_ptr</code>内部用<code>tuple&lt;pointer, _Dp&gt; _M_t;</code>变量保存数据，相当于原生指针和<code>deleter</code>对象组成的一个<code>pair</code>。</p><p>定义了构造函数和移动构造函数和移动赋值运算符，但是删除了拷贝构造函数和拷贝赋值运算符。</p><p><code>unqiue_ptr</code>还定义了两个很重要的函数：<code>reset(pointer)</code>和<code>release()</code>。<code>reset(pointer)</code>的功能是用一个新指针替换原来的指针，而<code>release()</code>则是是放弃原生指针的所有权。</p><p>到目前为止，<code>unique_ptr</code>还不像个指针，因为还缺少两个方法：<code>operator*</code>和<code>operator-&gt;</code>。</p><p>下面是<code>unique_ptr</code>的源码，有删减，但大体上不变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/// Default constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp *__ptr)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> __ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">uniq_ptr_impl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">    struct _Ptr</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> type = _Up *;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Ptr</span>&lt;_Up, _Ep, __void_t&lt;typename remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">using</span> type = <span class="keyword">typename</span> remove_reference&lt;_Ep&gt;::type::pointer;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> _Ptr&lt;_Tp, _Dp&gt;::type;</span><br><span class="line"></span><br><span class="line">    __uniq_ptr_impl() = <span class="keyword">default</span>;</span><br><span class="line">    __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del&gt;</span><br><span class="line">    __uniq_ptr_impl(pointer __p, _Del &amp;&amp;__d) : _M_t(__p, <span class="built_in">std</span>::forward&lt;_Del&gt;(__d)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    pointer &amp;_M_ptr() &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">    pointer _M_ptr() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">    _Dp &amp;_M_deleter() &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line">    <span class="keyword">const</span> _Dp &amp;_M_deleter() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    tuple&lt;pointer, _Dp&gt; _M_t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">unique_ptr</span></span><br><span class="line">&#123;</span><br><span class="line">    __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</span><br><span class="line">    <span class="keyword">using</span> element_type = _Tp;</span><br><span class="line">    <span class="keyword">using</span> deleter_type = _Dp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructors.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Default constructor, creates a unique_ptr that owns nothing.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> : _M_t()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Up&gt;&gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) <span class="keyword">noexcept</span> : _M_t(__p)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_ptr</span>(pointer __p, <span class="keyword">typename</span> remove_reference&lt;deleter_type&gt;::type &amp;&amp;__d) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_t(<span class="built_in">std</span>::move(__p), <span class="built_in">std</span>::move(__d))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move constructors.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Move constructor.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span> &amp;&amp;__u) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_t(__u.release(), <span class="built_in">std</span>::forward&lt;deleter_type&gt;(__u.get_deleter())) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Destructor, invokes the deleter if the stored pointer is not null.</span></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;__ptr = _M_t._M_ptr();</span><br><span class="line">        <span class="keyword">if</span> (__ptr != <span class="literal">nullptr</span>)</span><br><span class="line">            get_deleter()(__ptr);</span><br><span class="line">        __ptr = pointer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assignment.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span> &amp;<span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span> &amp;&amp;__u) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        reset(__u.release());</span><br><span class="line">        get_deleter() = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(__u.get_deleter());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Reset the %unique_ptr to empty, invoking the deleter if necessary.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span> &amp;<span class="keyword">operator</span>=(<span class="keyword">nullptr_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        reset();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Observers.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Dereference the stored pointer.</span></span><br><span class="line">    <span class="keyword">typename</span> add_lvalue_reference&lt;element_type&gt;::type</span><br><span class="line">    <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the stored pointer.</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return the stored pointer.</span></span><br><span class="line">    <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_t._M_ptr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return a reference to the stored deleter.</span></span><br><span class="line">    <span class="function">deleter_type &amp;<span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_t._M_deleter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return a reference to the stored deleter.</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> deleter_type &amp;<span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_t._M_deleter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Return @c true if the stored pointer is not null.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get() == pointer() ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Release ownership of any stored pointer.</span></span><br><span class="line">    <span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pointer __p = get();</span><br><span class="line">        _M_t._M_ptr() = pointer();</span><br><span class="line">        <span class="keyword">return</span> __p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(_M_t._M_ptr(), __p);</span><br><span class="line">        <span class="keyword">if</span> (__p != pointer())</span><br><span class="line">            get_deleter()(__p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Exchange the pointer and deleter with another object.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">unique_ptr</span> &amp;__u)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(_M_t, __u._M_t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable copy from lvalue.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> <span class="built_in">unique_ptr</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span> &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">unique_ptr</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是<code>shared_ptr</code>的类图。</p><p><img src="3725930-bdd744c1b57e7bea.jpg" alt="img"></p><p>如图，<code>shared_ptr</code>类几乎什么都没有做，它是继承了<code>__shared_ptr</code>，<code>__shared_ptr</code>内部有一个类型为<code>__shared_count</code>类型的成员，<code>__shared_count</code>内部有类型为<code>_Sp_counted_base*</code>的成员。</p><p><code>_Sp_counted_base</code>才是整个<code>shared_ptr</code>功能的核心，通过<code>_Sp_counted_base</code>控制引用计数来管理指向的内存，由图可见<code>_Sp_counted_base</code>内部不持有指向内存的指针，这里<code>__shared_count</code>内部的<code>_Sp_counted_base*</code>成员其实指向的是一个继承自<code>_Sp_counted_base</code>的<code>_Sp_counted_ptr</code>类型的派生类对象，<code>_Sp_counted_ptr</code>类型内部持有指向内存的指针<code>M_ptr</code>，这样<code>__shared_count</code>内部就既可以控制引用计数，又可以在最后根据指向对象的指针释放托管内存。</p><p>注意的是：为什么<code>_Sp_counted_ptr</code>和<code>__shared_ptr</code>内部都有指向对象的指针。实际上它们可以是不同的类型（只要它们之间存在隐式转换），这是<code>shared_ptr</code>的一大功能：</p><ol><li><p>无需虚析构。假设<code>Bar</code>是<code>Foo</code>的基类，但是<code>Bar</code>和<code>Foo</code>都没有虚析构。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Sp_counted_ptr._M_ptr 和 __shared_ptr._M_ptr 的类型都是 Foo*</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以赋值, __shared_ptr._M_ptr 自动向上转型 up-cast</span></span><br><span class="line"><span class="comment">// _Sp_counted_ptr._M_ptr 类型不变</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Bar&gt; sp2 = sp1;</span><br><span class="line"></span><br><span class="line">sp1.reset(); <span class="comment">// 这时 Foo 对象的引用计数降为 1</span></span><br></pre></td></tr></table></figure><p> 此后<code>sp2</code>仍然能安全地管理<code>Foo</code>对象的生命期，并安全完整地释放<code>Foo</code>，因为其<code>_Sp_counted_ptr._M_ptr</code>记住了<code>Foo</code>的实际类型。</p></li><li><p><code>shared_ptr&lt;void&gt;</code>可以指向并安全地管理（析构或防止析构）任何对象。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Sp_counted_ptr._M_ptr 和 __shared_ptr._M_ptr 的类型都是 Foo*</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以赋值, __shared_ptr._M_ptr 中的 Foo* 类型向 void* 自动转型</span></span><br><span class="line"><span class="comment">// _Sp_counted_ptr._M_ptr 类型不变</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; sp2 = sp1;</span><br><span class="line"></span><br><span class="line">sp1.reset(); <span class="comment">// 这时 Foo 对象的引用计数降为 1</span></span><br></pre></td></tr></table></figure><p> 此后<code>sp2</code>仍然能安全地管理<code>Foo</code>对象的生命期，并安全完整地释放<code>Foo</code>，不会出现<code>delete void*</code>的情况，因为<code>delete</code>的是<code>_Sp_counted_ptr._M_ptr</code>而不是<code>__shared_ptr._M_ptr</code>。</p></li><li><p>多继承。假设<code>Bar</code>是<code>Foo</code>的多个基类之一，那么：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时 sp1._M_ptr 和 sp2._M_ptr 可能指向不同的地址</span></span><br><span class="line"><span class="comment">// 因为 Bar subobject 在 Foo object 中的 offset 可能不为 0</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Bar&gt; sp2 = sp1;</span><br><span class="line"></span><br><span class="line">sp1.reset(); <span class="comment">// 此时 Foo 对象的引用计数降为 1</span></span><br></pre></td></tr></table></figure><p> 但是<code>sp2</code>仍然能安全地管理<code>Foo</code>对象的生命期，并安全完整地释放<code>Foo</code>，因为<code>delete</code>的不是<code>Bar*</code>，而是原来的 <code>Foo*</code>。换句话说，<code>sp1._M_ptr</code>和<code>sp2._M_ptr</code>可能具有不同的值（当然它们的类型也不同）。</p></li></ol><p><strong>这里称<code>_M_pi</code>为管理对象，它内部的<code>_M_ptr</code>为托管对象</strong>，管理同一块托管对象的多个<code>shared_ptr</code>内部共用一个管理对象,，这里的多个<code>shared_ptr</code>可能是通过第一个<code>shared_ptr</code>拷贝或者移动而来，管理对象内部有两个成员变量<code>_M_use_count</code>和<code>_M_weak_count</code>。</p><p><code>_M_use_count</code>表示托管对象的引用计数，控制托管对象什么时候析构和释放，当引用计数为<code>0</code>时调用托管对象的析构函数且释放内存。</p><p><code>_M_weak_count</code>表示管理对象的引用计数，它的初始值比<code>_M_use_count</code>大<code>1</code>，管理对象也是一个内存指针，<strong>这块指针是初始化第一个<code>shared_ptr</code>时<code>new</code>出来的</strong>，到最后也需要<code>delete</code>，所以使用<code>_M_weak_count</code>来控制管理对象什么时候析构，当<code>weak_ptr</code>析构时时，管理对象的引用计数<code>_M_weak_count</code>就会减<code>1</code>，当<code>_M_weak_count</code>为<code>0</code>时，管理对象<code>_M_pi</code>就会析构且释放内存。</p><p><strong><em><code>_M_use_count</code>是如何加减的</em></strong></p><p><em>M</em>use_count表示托管对象的引用计数，即当<code>shared_ptr</code>拷贝时会增加，当<code>shared_ptr</code>析构时会减少，看精简代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Yp&gt;</span><br><span class="line">__shared_ptr(<span class="keyword">const</span> __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r, element_type* __p) <span class="keyword">noexcept</span></span><br><span class="line">    : _M_ptr(__p), _M_refcount(__r._M_refcount)  <span class="comment">// never throws</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__shared_count(<span class="keyword">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span> : _M_pi(__r._M_pi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="number">0</span>) _M_pi-&gt;_M_add_ref_copy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy()</span><br><span class="line">&#123;</span><br><span class="line">    ++_M_use_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>拷贝时，内部<code>__shared_count</code>类型的<code>_M_refcount</code>会进行拷贝，<code>__shared_count</code>的拷贝构造函数会调用<code>_M_add_ref_copy()</code>方法，<code>_M_add_ref_copy()</code>方法中会将<code>_M_use_count</code>加<code>1</code>。</p><p>这里再看下<code>shared_ptr</code>的赋值构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Yp&gt;</span><br><span class="line">_Assignable&lt;<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;_Yp&gt;&amp;&gt; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;_Yp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__shared_ptr&lt;_Tp&gt;::<span class="keyword">operator</span>=(__r);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Yp&gt;</span><br><span class="line">_Assignable&lt;_Yp&gt; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _M_ptr = __r._M_ptr;</span><br><span class="line">    _M_refcount = __r._M_refcount;  <span class="comment">// __shared_count::op= doesn't throw</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__shared_count&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != _M_pi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__tmp != <span class="number">0</span>) __tmp-&gt;_M_add_ref_copy();</span><br><span class="line">        <span class="keyword">if</span> (_M_pi != <span class="number">0</span>) _M_pi-&gt;_M_release();</span><br><span class="line">        _M_pi = __tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可见，<code>shared_ptr</code>的<code>operator=</code>会调用<code>__shared_ptr</code>的<code>operator=</code>进而调用<code>__shared_count</code>的<code>operator=</code>，从这里可以看出管理同一块托管对象的<code>shared_ptr</code>共用的同一个管理对象的指针。</p><p><code>_M_use_count</code>是如何减为<code>0</code>的，可以猜想到<code>shared_ptr</code>析构时会调用<code>__shared_count</code>的析构函数，看精简代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~__shared_count() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>) _M_pi-&gt;_M_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--_M_use_count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _M_dispose();</span><br><span class="line">        <span class="keyword">if</span> (--_M_weak_count == <span class="number">0</span>) _M_destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span> &#123; <span class="keyword">delete</span> _M_ptr; &#125;</span><br></pre></td></tr></table></figure><p>在<code>shared_ptr</code>生命周期结束析构时会将引用计数减1，如果引用引用计数为<code>0</code>，会调用<code>_M_dispose()</code>函数进而释放托管对象内存。</p><p><strong><em><code>_M_weak_count</code>是如何加减的</em></strong></p><p>上面的代码中可以看见<code>_M_weak_count</code>为<code>0</code>时，会调用<code>_M_destroy()</code>函数，这里看看<code>_M_weak_count</code>是如何加减的。管理对象初始化时<code>_M_weak_count</code>的初始值为<code>1</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Sp_counted_base() <span class="keyword">noexcept</span> : _M_use_count(<span class="number">1</span>), _M_weak_count(<span class="number">1</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>注意当<code>shared_ptr</code>拷贝或者移动时<code>_M_weak_count</code>是不会增加的，它表示的是管理对象的计数，只有当<code>__M_use_count</code>为0时<code>_M_weak_count</code>才会减<code>1</code>，除此之外<code>_M_weak_count</code>的数值是由<code>weak_ptr</code>控制的。</p><p>由上面类图可以看见<code>weak_ptr</code>内部其实和<code>shared_ptr</code>内部持有的是同一个管理对象指针，即<code>_Sp_counted_base</code>的指针，当<code>weak_ptr</code>拷贝析构时候，<code>_Sp_counted_base</code>内部的<code>_M_weak_count</code>会相应加减。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__weak_count(<span class="keyword">const</span> __weak_count&amp; __r) <span class="keyword">noexcept</span> : _M_pi(__r._M_pi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>) _M_pi-&gt;_M_weak_add_ref();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_weak_add_ref() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    ++_M_weak_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~__weak_count() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>) _M_pi-&gt;_M_weak_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--_M_weak_count == <span class="number">0</span>) _M_destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> _M_destroy() <span class="keyword">noexcept</span> &#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，<code>weak_ptr</code>拷贝时<code>_M_weak_count</code>加<code>1</code>，析构时<code>_M_weak_count</code>减<code>1</code>，当<code>_M_weak_count</code>为<code>0</code>时，表示不再需要管理对象来控制托管对象，调用<code>_M_destroy()</code>的<code>delete this</code>来释放管理对象内存。</p><p><strong><em><code>weak_ptr</code>的<code>expired()</code>和<code>lock()</code>做了什么</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_refcount._M_get_use_count() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>weak_ptr</code>的<code>expired()</code>函数只是看了托管对象的引用计数是否为<code>0</code>，为<code>0</code>返回<code>true</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__shared_ptr&lt;_Tp, _Lp&gt; lock() const noexcept</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __shared_ptr&lt;element_type, _Lp&gt;(*<span class="keyword">this</span>, <span class="built_in">std</span>::nothrow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__shared_ptr(<span class="keyword">const</span> __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>)</span><br><span class="line">    : _M_refcount(__r._M_refcount, <span class="built_in">std</span>::nothrow)</span><br><span class="line">&#123;</span><br><span class="line">    _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>weak_ptr</code>的<code>lock()</code>函数是打算返回一个<code>shared_ptr</code>对象来延长托管对象的生命周期，这里返回后需要判断返回值是否为<code>nullptr</code>。</p><p><strong><em><code>shared_from_this()</code></em></strong>是如何实现的</p><p>精简代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __shared_ptr&lt;_Tp, _Lp&gt; shared_from_this()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_ptr&lt;_Tp, _Lp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __shared_ptr&lt;const _Tp, _Lp&gt; shared_from_this() const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __shared_ptr&lt;<span class="keyword">const</span> _Tp, _Lp&gt;(<span class="keyword">this</span>-&gt;_M_weak_this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt; _M_weak_this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>shared_from_this()</code>的类需要继承<code>enable_shared_from_this</code>类，<code>enable_shared_from_this</code>类中持有一个类型为<code>weak_ptr</code>的成员<code>_M_weak_this</code>，调用<code>shared_from_this()</code>就是将内部持有的<code>weak_ptr</code>转成了<code>shared_ptr</code>。</p><h5 id="为什么建议使用make-shared-函数"><a href="#为什么建议使用make-shared-函数" class="headerlink" title="为什么建议使用make_shared()函数"></a>为什么建议使用<code>make_shared()</code>函数</h5><p>我们已经看到了，<code>shared_ptr</code>内部维护了两个指针，如果你直接调用构造函数，就想这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>;</span></span><br><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Foo());</span><br></pre></td></tr></table></figure><p>这里实际分配了两次内存，第一次是调用<code>new Foo()</code>的时候，第二次则是在<code>shared_ptr</code>构造函数的内部构造<code>_Sp_counted_base</code>的时候。分配内存是很昂贵的操作，所以标准库提供了<code>make_shared()</code>函数，让你一次分配全部所需的内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> __shared_ptr&lt;_Tp, _Lp&gt;</span><br><span class="line">__make_shared(_Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_const&lt;_Tp&gt;::type _Tp_nc;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::__allocate_shared&lt;_Tp, _Lp&gt;</span><br><span class="line">        (<span class="built_in">std</span>::allocator&lt;_Tp_nc&gt;(), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在用<code>make_shared()</code>的话，可以一次分配一块足够大的内存，供<code>Foo</code>和<code>_Sp_counted_base</code>对象容身。</p><h5 id="智能指针的线程安全性分析"><a href="#智能指针的线程安全性分析" class="headerlink" title="智能指针的线程安全性分析"></a>智能指针的线程安全性分析</h5><ol><li><p>同一个的<code>shared_ptr</code>对象可以被多个线程同时读取（只读）</p><p> 对同一个对象的并发读，显然是线程安全的。</p></li><li><p>不同的<code>shared_ptr</code>对象可以被多个线程同时读写</p><p> 如果这不同的<code>shared_ptr</code>对象管理的是不同的对象资源，显然并发读写是线程安全的。</p><p> 若它们指向的是同一个对象，这需要它们共同维护一份在堆上的引用计数资源。而<code>shared_ptr</code>对象对于这份引用计数资源的读写使用了原子性操作，因此，也是线程安全的。</p><p> 容易出现问题的是，从<code>shared_ptr</code>构造<code>weak_ptr</code>或者从<code>weak_ptr</code>构造<code>shared_ptr</code>的情况。</p><ul><li><p>从<code>shared_ptr</code>构造<code>weak_ptr</code></p><p>  由于<code>weak_ptr</code>的构造过程中并不涉及引用计数资源的改变（实际上不改变的是<code>shared_ptr</code>对象计数变量<code>_M_use_count_</code>，只是改变了<code>weak_ptr</code>对象计数变量<code>_M_weak_count</code>），和前面的分析一样，使用了原子操作，也是线程安全的。</p></li><li><p>从<code>weak_ptr</code>构造<code>shared_ptr</code></p><p>  而这一过程，会改变引用计数资源（增加<code>shared_ptr</code>对象计数变量<code>_M_use_count</code>），但是实际上也实现了线程安全的修改。可以去参考源码的实现。</p></li></ul></li><li><p>同一个<code>shared_ptr</code>对象不可以被多个线程同时读写（有写）</p><p> <code>shared_ptr&lt;Foo&gt;</code>包含两个成员，一个是指向<code>Foo</code>的指针<code>_M_ptr</code>，另一个是<code>_Sp_counted_base*</code>指针，指向<strong>堆上的</strong><code>_Sp_counted_base</code>对象。因为这两个数据成员读写操作不是原子化，所以使用多个线程读写同一个<code>shared_ptr</code>对象需要加锁，也就是说不是线程安全的。</p></li></ol><h5 id="自己动手实现一个基本的shared-ptr"><a href="#自己动手实现一个基本的shared-ptr" class="headerlink" title="自己动手实现一个基本的shared_ptr"></a>自己动手实现一个基本的<code>shared_ptr</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Deleter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> DefaultFunc = <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(T *)&gt;;</span><br><span class="line">    Deleter() : func_(<span class="built_in">std</span>::bind(&amp;Deleter::defaultFunc, <span class="keyword">this</span>, <span class="built_in">std</span>::placeholders::_1))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleter::Deleter()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">Deleter</span>(<span class="title">D</span> <span class="title">func</span>) :</span> func_(func)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleter::Deleter(D func)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        func_(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DefaultFunc func_;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFunc</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Deleter::defaultFunc"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Ref_count_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    <span class="keyword">int</span> count_;</span><br><span class="line">    Deleter&lt;T&gt; deleter_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Ref_count_base(T *p) : ptr_(p), count_(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ref_count_base::Ref_count_base(T *p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">Ref_count_base</span>(<span class="title">T</span> *<span class="title">p</span>, <span class="title">D</span> <span class="title">deleter</span>) :</span> ptr_(p), count_(<span class="number">1</span>), deleter_(deleter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ref_count_base::Ref_count_base(T *p, D deleter)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Ref_count_base()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Ref_count_base::~Ref_count_base()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        deleter_(ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">increase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reduce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> --count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    Ref_count_base&lt;T&gt; *ref_count_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shared_ptr() : ptr_(<span class="literal">nullptr</span>), ref_count_(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Shared_ptr</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr(std::nullptr_t)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        Shared_ptr&lt;T&gt; temp;</span><br><span class="line">        swap(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    explicit Shared_ptr(T *p) : ptr_(p), ref_count_(new Ref_count_base&lt;T&gt;(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr(T *p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">explicit</span> <span class="title">Shared_ptr</span>(<span class="title">T</span> *<span class="title">p</span>, <span class="title">D</span> <span class="title">deleter</span>) :</span> ptr_(p), ref_count_(<span class="keyword">new</span> Ref_count_base&lt;T&gt;(p, deleter))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr(T *p, D deleter)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Shared_ptr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::~Shared_ptr()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (ref_count_ &amp;&amp; ref_count_-&gt;reduce() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">delete</span> ref_count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Shared_ptr(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp) : ptr_(sp.ptr_), ref_count_(sp.ref_count_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (ref_count_)</span><br><span class="line">            ref_count_-&gt;increase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Shared_ptr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::operator=(const Shared_ptr&lt;T&gt; &amp;sp)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="function">Shared_ptr&lt;T&gt; <span class="title">temp</span><span class="params">(sp)</span></span>;</span><br><span class="line">        swap(temp);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Shared_ptr &amp;<span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::operator=(std::nullptr_t)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        Shared_ptr&lt;T&gt; temp;</span><br><span class="line">        swap(temp);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_)</span><br><span class="line">            <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_)</span><br><span class="line">            <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">ptrdiff_t</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Shared_ptr&lt;T&gt; &amp;rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_ == rhs.ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_ != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ref_count_)</span><br><span class="line">            <span class="keyword">return</span> ref_count_-&gt;getCount();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Shared_ptr&lt;T&gt; &amp;sp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(ptr_, sp.ptr_);</span><br><span class="line">        swap(ref_count_, sp.ref_count_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">swap</span>(<span class="title">Shared_ptr</span>&lt;T&gt; &amp;<span class="title">lhs</span>, <span class="title">Shared_ptr</span>&lt;T&gt; &amp;<span class="title">rhs</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    lhs.swap(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下是测试代码 */</span></span><br><span class="line"><span class="comment">/* 以下是测试代码 */</span></span><br><span class="line"><span class="comment">/* 以下是测试代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span> : <span class="title">val</span><span class="params">(i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point(int i = 0)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Point()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Point()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point &amp;<span class="keyword">operator</span>=(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point::operator=(int i)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        val = i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDeleter1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Point *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDeleter2</span><span class="params">(Point *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myDeleter2(Point *p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> myDeleter3 = [](Point *p) &#123; <span class="keyword">delete</span>[] p; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Shared_ptr&lt;Point&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Point[<span class="number">2</span>], myDeleter3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1[<span class="number">0</span>].getVal() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p1[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1[<span class="number">0</span>].getVal() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Shared_ptr&lt;Point&gt; p2 = p1;</span><br><span class="line">    Shared_ptr&lt;Point&gt; p3;</span><br><span class="line">    p3 = p2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2.use_count: "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3.use_count: "</span> &lt;&lt; p3.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 == p2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 != p2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 为真"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p1)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 为假"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.use_count: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2.use_count: "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3.use_count: "</span> &lt;&lt; p3.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果为</span></span><br><span class="line"></span><br><span class="line">Point::Point(<span class="keyword">int</span> i = <span class="number">0</span>)</span><br><span class="line">Point::Point(<span class="keyword">int</span> i = <span class="number">0</span>)</span><br><span class="line">Deleter::Deleter(D func)</span><br><span class="line">Ref_count_base::Ref_count_base(T *p, D deleter)</span><br><span class="line">Shared_ptr::Shared_ptr(T *p, D deleter)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">Point::<span class="keyword">operator</span>=(<span class="keyword">int</span> i)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">p1.use_count: <span class="number">1</span></span><br><span class="line">Shared_ptr::Shared_ptr(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::Shared_ptr()</span><br><span class="line">Shared_ptr::<span class="keyword">operator</span>=(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::Shared_ptr(<span class="keyword">const</span> Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br><span class="line">p1.use_count: <span class="number">3</span></span><br><span class="line">p2.use_count: <span class="number">3</span></span><br><span class="line">p3.use_count: <span class="number">3</span></span><br><span class="line">p1 == p2</span><br><span class="line">p1 为真</span><br><span class="line">Shared_ptr::<span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>)</span><br><span class="line">Shared_ptr::Shared_ptr()</span><br><span class="line">Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)</span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br><span class="line">p1 为假</span><br><span class="line">p1.use_count: <span class="number">0</span></span><br><span class="line">p2.use_count: <span class="number">2</span></span><br><span class="line">p3.use_count: <span class="number">2</span></span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br><span class="line">Ref_count_base::~Ref_count_base()</span><br><span class="line">Point::~Point()</span><br><span class="line">Point::~Point()</span><br><span class="line">Shared_ptr::~Shared_ptr()</span><br></pre></td></tr></table></figure><h5 id="智能指针使用注意事项"><a href="#智能指针使用注意事项" class="headerlink" title="智能指针使用注意事项"></a>智能指针使用注意事项</h5><ol><li><p>尽量用<code>make_shared/make_unique</code></p><p> <code>std::shared_ptr</code>在实现的时候使用的<code>ref count</code>技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行<code>std::shared_ptr&lt;Widget&gt; p2(new Widget)</code>的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而<code>std::make_shared&lt;Widget&gt;()</code>则是只执行一次内存申请，将数据和控制块的申请放到一起。</p></li><li><p>不要使用相同的内置指针来初始化（或者<code>reset</code>）多个智能指针</p></li><li><p>不要<code>delete get()</code>返回的指针</p></li><li><p>不要用<code>get()</code>初始化或<code>reset</code>另一个智能指针</p></li><li><p>智能指针管理的资源它只会默认删除<code>new</code>分配的内存，如果不是<code>new</code>分配的则要传递给其一个删除器</p><p> 以下代码试图将<code>malloc</code>产生的动态内存交给<code>shared_ptr</code>管理，显然是有问题的，所以我们需要自定义删除器传递给<code>shared_ptr</code>。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>* pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(pi)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>* pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(pi， [](<span class="keyword">int</span>* p)&#123; <span class="built_in">free</span>(p); &#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要把一个原生指针给多个<code>shared_ptr</code>或者多个<code>unique_ptr</code>管理</p><p> 在使用原生指针对智能指针初始化的时候，智能指针对象都视原生指针为自己管理的资源。换句话意思就说：初始化多个智能指针之后，这些智能指针都担负起释放内存的作用。那么就会导致该原生指针会被释放多次！！</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p1, p2 析构的时候都会释放 ptr, 同一内存被释放多次!</span></span><br><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重要知识点 </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之排序算法实现及效率分析</title>
      <link href="/cuQpjpPOQ0qnpSE2/"/>
      <url>/cuQpjpPOQ0qnpSE2/</url>
      
        <content type="html"><![CDATA[<ol><li>快速排序</li><li>归并排序</li><li>计数排序</li><li>堆排序</li></ol><a id="more"></a><h4 id="排序算法实现及效率分析"><a href="#排序算法实现及效率分析" class="headerlink" title="排序算法实现及效率分析"></a>排序算法实现及效率分析</h4><p><img src="%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png" alt="排序算法总结"></p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 洗牌算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = rand() % ((n - <span class="number">1</span>) - i + <span class="number">1</span>) + i; <span class="comment">// 返回 [i, n - 1] 内的随机数</span></span><br><span class="line">        swap(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左闭右闭区间, 以首元素作为轴点 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本一, 数据结构视频 9.1.5 节</span></span><br><span class="line"><span class="comment">// int partition(std::vector&lt;int&gt; &amp;nums, int lo, int hi)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     // 随机置乱数组</span></span><br><span class="line"><span class="comment">//     shuffle(nums.begin(), nums.end(), default_random_engine(time(nullptr)));</span></span><br><span class="line"><span class="comment">//     int pivot = nums[lo];</span></span><br><span class="line"><span class="comment">//     while (lo &lt; hi)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         while (lo &lt; hi &amp;&amp; (pivot &lt;= nums[hi])) hi--;</span></span><br><span class="line"><span class="comment">//         nums[lo] = nums[hi];</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         while (lo &lt; hi &amp;&amp; (nums[lo] &lt;= pivot)) lo++;</span></span><br><span class="line"><span class="comment">//         nums[hi] = nums[lo];</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     nums[lo] = pivot;</span></span><br><span class="line"><span class="comment">//     return lo;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本二, 算法 4 书籍</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 随机置乱数组</span></span><br><span class="line">    shuffle(nums.begin(), nums.end(), default_random_engine(time(<span class="literal">nullptr</span>)));</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[++i] &lt; nums[lo]) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[lo] &lt; nums[--j]) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= i) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::swap(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::swap(nums[lo], nums[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本三, 数据结构视频 9.3.4 节</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 随机置乱数组</span></span><br><span class="line">    shuffle(nums.begin(), nums.end(), default_random_engine(time(<span class="literal">nullptr</span>)));</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = lo;</span><br><span class="line">    <span class="keyword">while</span> (++j &lt;= hi)</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[lo])</span><br><span class="line">            <span class="built_in">std</span>::swap(nums[++i], nums[j]);</span><br><span class="line">    <span class="built_in">std</span>::swap(nums[lo], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(nums, lo, hi);</span><br><span class="line">    quickSort(nums, lo, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, pivot + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序（Top-down-Approach）"><a href="#归并排序（Top-down-Approach）" class="headerlink" title="归并排序（Top-down Approach）"></a>归并排序（<code>Top-down Approach</code>）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意以下的 vector 参数传的都是引用</span></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="comment">// [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 辅助空间, 存储 [mi + 1, hi] 元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(nums.begin() + mi + <span class="number">1</span>, nums.begin() + hi + <span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对两个数组中的元素, 依次从后向前比较</span></span><br><span class="line">    <span class="comment">// 从后向前放置元素, 先放较大者</span></span><br><span class="line">    <span class="keyword">int</span> i = mi;</span><br><span class="line">    <span class="keyword">int</span> j = helper.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = hi;</span><br><span class="line">    <span class="comment">// 注意 i 的终止条件</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= lo &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 注意, 这里如果是 &gt;= 就不稳定了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; helper[j])</span><br><span class="line">            nums[k--] = nums[i--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[k--] = helper[j--];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 单元素自动有序</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, lo, mi);</span><br><span class="line">    mergeSort(nums, mi + <span class="number">1</span>, hi);</span><br><span class="line">    merge(nums, lo, mi, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 排序 [0, nums.size()) 之间的元素</span></span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序（Bottom-up-Approach）"><a href="#归并排序（Bottom-up-Approach）" class="headerlink" title="归并排序（Bottom-up Approach）"></a>归并排序（<code>Bottom-up Approach</code>）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="comment">// [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 辅助空间, 存储 [mi + 1, hi] 元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(nums.begin() + mi + <span class="number">1</span>, nums.begin() + hi + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对两个数组中的元素, 依次从后向前比较</span></span><br><span class="line">    <span class="comment">// 从后向前放置元素, 先放较大者</span></span><br><span class="line">    <span class="keyword">int</span> i = mi;</span><br><span class="line">    <span class="keyword">int</span> j = helper.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = hi;</span><br><span class="line">    <span class="comment">// 注意 i 的终止条件</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= lo &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; helper[j])</span><br><span class="line">            nums[k--] = nums[i--];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">    <span class="comment">// 中间节点相对于起点的位置是 1 个 step</span></span><br><span class="line">    <span class="comment">// 终点相对于起点是 2 个 step</span></span><br><span class="line">    <span class="comment">// step 从 1 开始直到等于数组的长度 sz </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= sz; step *= <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 注意, 这里 lo 从 0 开始直到等于 sz - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; sz; lo += <span class="number">2</span> * step)</span><br><span class="line">            <span class="comment">// 因为 merge 函数实现的原因, 都是闭区间, 而且 [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line">            <span class="comment">// 所以这里求出的 mi 和 hi 都需要减 1</span></span><br><span class="line">            merge(nums, lo, min(lo + step - <span class="number">1</span>, sz - <span class="number">1</span>), min(lo + <span class="number">2</span> * step - <span class="number">1</span>, sz - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ol><li>计数排序要求待排序的<code>n</code>个元素的大小在<code>[0, k]</code>之间，并且<code>k</code>与<code>n</code>在一个数量级上，即<code>k = O(n)</code>，此时使用计数排序可以把时间复杂度降到<code>O(n)</code>上；</li><li>计数排序不是基于比较的排序算法，它基于计数策略；</li><li>写计数排序算法时，应该把它写成稳定排序的；</li><li>计数排序还是原址排序，但需要借助额外的内存空间；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出待排序的数组中最大的元素 maxVal 和最小元素 minVal</span></span><br><span class="line"><span class="comment">// 统计数组中每个值为 val 的元素出现的次数, 存入数组 count 的第 val - minVal 项</span></span><br><span class="line"><span class="comment">// 对所有的计数累加, 从 count 中的第一个元素开始, 每一项和前一项相加</span></span><br><span class="line"><span class="comment">// 反向填充目标数组: 将每个元素 val 放在新数组的第 count(val - minVal) 项</span></span><br><span class="line"><span class="comment">// 每放一个元素就将 count(val - minVal) 减去 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minVal = *min_element(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> maxVal = *max_element(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> valRange = maxVal - minVal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意: 这个数组的大小为 valRange + 1, 用于统计 [0, valRange]范围内的元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(valRange + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计待排序数组中每一个元素的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        count[x - minVal]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处计算待排序数组中小于等于第i个元素的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= valRange; ++i)</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把待排序的数组放到输出数组中, 为了保持排序的稳定性, 从后向前添加元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">backup</span><span class="params">(nums)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = count[backup[i] - minVal] - <span class="number">1</span>;</span><br><span class="line">        nums[index] = backup[i];</span><br><span class="line">        <span class="comment">// 因为可能有重复的元素, 所以要减 1, 为下一个重复的元素计算正确的下标</span></span><br><span class="line">        count[backup[i] - minVal]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>秩为<code>i</code>的元素，其父节点若存在，其秩必为<code>(i - 1) / 2</code>；其左孩子若存在，其秩必为<code>2 * i + 1</code>；其右孩子若存在，其秩必为左孩子秩加<code>1</code>。</p><p><strong>下滤</strong>：将首元素依次和其孩子中较大者交换。<strong>上滤</strong>：将末元素依次和其父亲交换。时间复杂度均为<code>O(logn)</code>。</p><p><strong>批量建堆</strong>：可以是所有的<strong>内部节点</strong>，自右往左依次<strong>下滤</strong>（复杂度正比于所有下滤节点的高度），或者是末元素依次上滤（复杂度是正比于所有上滤节点的深度），相比之下，前者的时间复杂度为<code>O(n)</code>，后者时间复杂度为<code>O(nlogn)</code>。第一个内部节点其实就是末元素的父亲，之后的内部节点依次递减即可。</p><p><strong>堆排序</strong>：先执行<strong>批量建堆</strong>操作，时间复杂度为<code>O(n)</code>，然后进行<code>n</code>次取最大值操作，时间复杂度为<code>O(nlogn)</code>。具体实现可以是建完堆后，反复进行<strong>将首元素和未排序的末元素交换，然后对首元素进行下滤</strong>的操作。总体时间复杂度为<code>O(n) + O(nlogn) = O(nlogn)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(i) ((i - 1) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(i) ((2 * i) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(i) (LC(i) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下滤操作, 复杂度正比于完全二叉树的高度为 log(n)</span></span><br><span class="line"><span class="comment">// 参数 len 代表 [有效堆] 数组的长度, 可用于验证待下滤元素 i 的左右孩子节点的合法性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downFilter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = nums[i]; <span class="comment">// 先保存待下滤的值, i 就可代表洞号</span></span><br><span class="line">    <span class="keyword">int</span> rc = RC(i);    <span class="comment">// 待下滤元素的右孩子</span></span><br><span class="line">    <span class="comment">// 如果右孩子存在</span></span><br><span class="line">    <span class="keyword">while</span> (rc &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果右子节点的值小于左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (nums[rc] &lt;= nums[rc - <span class="number">1</span>])</span><br><span class="line">            rc--;</span><br><span class="line">        <span class="comment">// 此时, rc 指向孩子节点中较大的那一个</span></span><br><span class="line">        <span class="comment">// 如果待下滤的值比孩子中较大的还大, 就不需要下滤了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[rc] &lt;= val)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[i] = nums[rc];</span><br><span class="line">        i = rc;     <span class="comment">// 产生新的洞号</span></span><br><span class="line">        rc = RC(i); <span class="comment">// 获得新洞号的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右孩子不存在, 但如果左孩子存在且其值大于待下滤的值</span></span><br><span class="line">    <span class="keyword">if</span> (rc - <span class="number">1</span> &lt; len &amp;&amp; nums[rc - <span class="number">1</span>] &gt; val)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = nums[rc - <span class="number">1</span>];</span><br><span class="line">        i = rc - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右孩子都不存在了</span></span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">    <span class="keyword">int</span> i = P(sz - <span class="number">1</span>); <span class="comment">// 获取末元素的父亲, 也就是最后一个内部节点</span></span><br><span class="line">    <span class="comment">// 建堆操作, 复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">        downFilter(nums, i--, sz); <span class="comment">// 从最后一个内部节点自后向前 依次下滤</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外层循环 n 加内层的 log(n) 下滤, 因此堆排序复杂度为 nlog(n)</span></span><br><span class="line">    <span class="comment">// 此时最大元素是首元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(nums[<span class="number">0</span>], nums[i]); <span class="comment">// 首尾交换, 末元素就位</span></span><br><span class="line">        downFilter(nums, <span class="number">0</span>, i);      <span class="comment">// 将新首元素下滤</span></span><br><span class="line">        <span class="comment">// 依次缩短未排序数组的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要知识点详细解读之右值与移动语义</title>
      <link href="/63ixVU2ANYIUKUrm/"/>
      <url>/63ixVU2ANYIUKUrm/</url>
      
        <content type="html"><![CDATA[<ol><li>解释<strong>右值引用</strong>和左值引用的区别</li><li>移动构造函数和移动赋值运算符</li><li>理解<code>std::move</code>和<code>std::forward</code></li></ol><a id="more"></a><h4 id="解释右值引用和左值引用的区别"><a href="#解释右值引用和左值引用的区别" class="headerlink" title="解释右值引用和左值引用的区别"></a>解释<strong>右值引用</strong>和左值引用的区别</h4><p>所谓<strong>右值引用</strong>就是必须绑定到右值的引用，通过<code>&amp;&amp;</code>获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。<strong>左值引用</strong>，不能绑定到要转换的表达式、字面常量或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。</p><p><strong>返回左值的表达式</strong>包括返回左值引用的函数及赋值、下标、解引用和前置递增<code>/</code>递减运算符，<strong>返回右值的表达式</strong>包括返回非引用类型的函数及算术、关系、位和后置递增<code>/</code>递减运算符。可以看到，左值的特点是有持久的状态，而右值则是短暂的。</p><p><strong>变量是左值</strong>，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p><p>函数参数和其它任何变量一样，都是左值表达式。</p><h4 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h4><p>参见<code>C++ primer 13.6</code>。</p><p>与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为<code>noexcept</code>。</p><p>在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的<strong>每个非<code>static</code>数据成员</strong>都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。</p><p>移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。</p><p>如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。</p><p>类似拷贝构造函数和拷贝赋值运算符，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。如果有类成员是<code>const</code>的或是引用，则类的移动赋值运算符被定义为删除的。</p><p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。</p><p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数：移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝（即，通过拷贝构造函数来“移动”）。</p><p><strong><em>拷贝并交换赋值运算符和移动操作</em></strong><br><code>HasPtr</code>类定义了一个拷贝并交换赋值运算符，如果为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 添加的移动构造函数</span></span><br><span class="line">    HasPtr(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> : ps(p.ps), i(p.i)</span><br><span class="line">    &#123;</span><br><span class="line">        p.ps = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值运算符既是移动赋值运算符, 也是拷贝赋值运算符</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(HasPtr&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        HasPtr temp(rhs); <span class="comment">// copy and</span></span><br><span class="line">        swap(*<span class="keyword">this</span>, temp); <span class="comment">// swap</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他成员的定义</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个版本中，我们为类添加了一个移动构造函数，它接管了给定实参的值。构造函数体将给定的<code>HasPtr</code>的指针置为<code>0</code>，从而确保销毁移后源对象是安全的。此函数不会抛出异常，因此我们将其标记为<code>noexcept</code>。<br>现在让我们观察赋值运算符。<strong>此运算符有一个非引用参数</strong>，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。<br>假定<code>hp</code>和<code>hp2</code>都是<code>HasPtr</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hp = hp2;<span class="comment">// hp2 是一个左值; hp2 通过拷贝构造函数来拷贝</span></span><br><span class="line">hp = <span class="built_in">std</span>::move(hp2); <span class="comment">// 移动构造函数移动 hp2</span></span><br></pre></td></tr></table></figure><p>在第一个赋值中，右侧运算对象是一个左值，因此移动构造函数是不可行的。<code>rhs</code>将使用拷贝构造函数来初始化。拷贝构造函数将分配一个新<code>string</code>，并拷贝<code>hp2</code>指向的<code>string</code>。<br>在第二个赋值中，我们调用<code>std::move</code>将一个右值引用绑定到<code>hp2</code>上。在此情况下，拷贝构造函数和移动构造函数都是可行的。但是，由于实参是一个右值引用，移动构造函数是精确匹配的。移动构造函数从<code>hp2</code>拷贝指针，而不会分配任何内存。<br>不管使用的是拷贝构造函数还是移动构造函数，赋值运算符的函数体都<code>swap</code>两个运算对象的状态。交换<code>HasPtr</code>会交换两个对象的指针成员。在<code>swap</code>之后，<code>rhs</code>中的指针将指向原来左侧运算对象所拥有的<code>string</code>。当<code>rhs</code>离开其作用域时，这个<code>string</code>将被销毁。</p><h4 id="理解std-move和std-forward"><a href="#理解std-move和std-forward" class="headerlink" title="理解std::move和std::forward"></a>理解<code>std::move</code>和<code>std::forward</code></h4><p>参见<code>C++ primer 16.2.6 &amp; 16.2.7</code>。</p><p><strong>调用<code>std::move</code>就意味着承诺：除了对移后源赋值或销毁外，我们将不再使用它。</strong></p><h5 id="标准库中std-move的实现"><a href="#标准库中std-move的实现" class="headerlink" title="标准库中std::move的实现"></a>标准库中<code>std::move</code>的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从一个左值 static_cast 到一个右值引用是允许的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>remove_reference</code>模板有一个模板类型参数和一个名为<code>type</code>的（<code>public</code>）类型成员。如果我们用一个引用类型实例化<code>remove_reference</code>，则<code>type</code>将表示被引用的类型。例如，如果我们实例化<code>remove_reference&lt;string&amp;&gt;</code>，则<code>type</code>成员将是<code>string</code>。更一般的，给定一个迭代器<code>beg</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br></pre></td></tr></table></figure><p>将获得<code>beg</code>引用的元素的类型：<code>decltype(*beg)</code>返回元素类型的引用类型。<code>remove_reference::type</code>脱去引用，剩下元素类型本身。</p><h5 id="std-move是如何工作的"><a href="#std-move是如何工作的" class="headerlink" title="std::move是如何工作的"></a><code>std::move</code>是如何工作的</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("hi!"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"bye!"</span>));<span class="comment">// 正确: 从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1);<span class="comment">// 正确: 但在赋值之后, s1的值是不确定的</span></span><br></pre></td></tr></table></figure><p>在第一个赋值中，传递给<code>move</code>的实参是<code>string</code>的构造函数的右值结果——<code>string(&quot;bye!&quot;)</code>。因此，在<code>std::move(string(&quot;bye!&quot;))</code>中：</p><ul><li>推断出的<code>T</code>的类型为<code>string</code>；</li><li>因此，<code>remove_reference</code>用<code>string</code>进行实例化；</li><li><code>remove_reference&lt;string&gt;</code>的<code>type</code>成员是<code>string</code>；</li><li><code>move</code>的返回类型是<code>string&amp;&amp;</code>；</li><li><code>move</code>的函数参数<code>t</code>的类型为<code>string&amp;&amp;</code>。</li></ul><p>因此，这个调用实例化<code>move&lt;string&gt;</code>，即函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp;&amp; <span class="title">move</span><span class="params">(<span class="built_in">string</span>&amp;&amp; t)</span></span></span><br></pre></td></tr></table></figure><p>函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。<code>t</code>的类型已经是<code>string&amp;&amp;</code>，于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用。</p><p>现在考虑第二个赋值，它调用了<code>std::move</code>。在此调用中，传递给<code>move</code>的实参是一个左值。这样：</p><ul><li>推断出的<code>T</code>的类型为<code>string&amp;</code>；</li><li>因此，<code>remove_reference</code>用<code>string&amp;</code>进行实例化；</li><li><code>remove_reference&lt;string&amp;&gt;</code>的<code>type</code>成员是<code>string</code>；</li><li><code>move</code>的返回类型仍是<code>string&amp;&amp;</code>；</li><li><code>move</code>的函数参数<code>t</code>实例化为<code>string&amp;&amp; &amp;</code>，会折叠为<code>string&amp;</code>。</li></ul><p>因此，这个调用实例化<code>move&lt;string&amp;&gt;</code>，即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp;&amp; <span class="title">move</span><span class="params">(<span class="built_in">string</span>&amp; t)</span></span></span><br></pre></td></tr></table></figure><p>这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回<code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。在此情况下，<code>t</code>的类型为<code>string&amp;</code>，<code>static_cast</code>将其转换为<code>string&amp;&amp;</code>。</p><h5 id="标准库中std-forward的实现"><a href="#标准库中std-forward的实现" class="headerlink" title="标准库中std::forward的实现"></a>标准库中<code>std::forward</code>的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp;&amp; <span class="title">forward</span>(<span class="title">typename</span> <span class="title">std</span>:</span>:remove_reference&lt;T&gt;::type&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp;&amp; <span class="title">forward</span>(<span class="title">typename</span> <span class="title">std</span>:</span>:remove_reference&lt;T&gt;::type&amp;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。通常情况下，使用<code>forward</code>传递那些<strong>定义为模板类型参数的右值引用的函数参数</strong>。通过其返回类型上的引用折叠，<code>forward</code>可以保持给定实参的左值<code>/</code>右值以及<code>const</code>属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在这里使用 std::forward&lt;T&gt;(t)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实参<code>t</code>是一个右值，则<code>T</code>被推断为一个普通（非引用）类型，<code>std::forward&lt;T&gt;</code>将返回<code>T&amp;&amp;</code>。如果实参是一个左值，则通过引用折叠，<code>T</code>被推断为一个左值引用类型。在此情况下，<code>std::forward&lt;T&gt;</code>返回类型是一个指向左值引用类型的右值引用<code>T&amp;&amp; &amp;</code>，再次引用折叠，将返回一个左值引用类型<code>T&amp;</code>。</p><p>注意：<strong>不能使用一个左值实例化一个右值引用类型的函数参数</strong>。函数参数和其它任何变量一样，在函数体内都是左值表达式。</p>]]></content>
      
      
      <categories>
          
          <category> 重要知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重要知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之二叉树</title>
      <link href="/B90hHtDrYEYJD3xv/"/>
      <url>/B90hHtDrYEYJD3xv/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>4</code>部分——二叉树。这里把有代表性的题目发出来，共计<code>35</code>道。</p><p>接下来这几个月，计划完成的<code>leetcode</code>刷题系列其组织如下：</p><p><code>1</code>. 数组</p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. 字符串</p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. 动态规划</p><p><code>7</code>. 数据结构设计</p><p>预计涉及题目至少<code>200</code>道！</p><a id="more"></a><h4 id="Binary-tree"><a href="#Binary-tree" class="headerlink" title="Binary tree"></a><code>Binary tree</code></h4><h5 id="114-Binary-Tree-Preorder-Traversal"><a href="#114-Binary-Tree-Preorder-Traversal" class="headerlink" title="114. Binary Tree Preorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">114. Binary Tree Preorder Traversal</a></h5><blockquote><p>二叉树的前序遍历。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(node)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) nodes.push(node-&gt;right);</span><br><span class="line"></span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal</a></h5><blockquote><p>二叉树的中序遍历。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nodes.empty()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        root = nodes.top();</span><br><span class="line">        </span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        nodes.pop();</span><br><span class="line">        </span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. Binary Tree Postorder Traversal</a></h5><blockquote><p>二叉树的后序遍历。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此解法借鉴中序遍历的思路</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    TreeNode* preVisited = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nodes.empty()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        root = nodes.top();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;right || root-&gt;right == preVisited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果待访问节点没有右孩子或者右孩子刚才访问过</span></span><br><span class="line">            <span class="comment">// 就访问</span></span><br><span class="line">            preVisited = root;</span><br><span class="line"></span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="comment">// 这是为了跳过下次的 while(root) 循环</span></span><br><span class="line">            root = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// 下一个待访问节点一定是刚刚访问节点的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果待访问节点有右孩子并且右孩子上次没有访问过</span></span><br><span class="line">            <span class="comment">// 就不访问, 去右孩子</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此解法借鉴前序遍历的思路</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    nodes.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* node = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(node)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 和前序遍历相反的顺序访问左右子树</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) nodes.push(node-&gt;left);</span><br><span class="line"></span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后, 逆序输出就和后序遍历一样</span></span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal</a></h5><blockquote><p>二叉树的层序遍历。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用队列迭代实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) nodes.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subVector;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = nodes.size();</span><br><span class="line">        <span class="keyword">while</span>(count--)</span><br><span class="line">        &#123;</span><br><span class="line">            root = nodes.front();</span><br><span class="line">            nodes.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) nodes.push(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) nodes.push(root-&gt;right);</span><br><span class="line"></span><br><span class="line">            subVector.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.push_back(subVector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助前序遍历的思想, 递归实现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每次递归的时候提供被遍历节点的层级信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level &gt;= res.size())</span><br><span class="line">        res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    res[level].push_back(root-&gt;val);</span><br><span class="line">    helper(root-&gt;left, level + <span class="number">1</span>);</span><br><span class="line">    helper(root-&gt;right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree</a></h5><blockquote><p>给定二叉树的根，返回其最大深度。二叉树的最大深度是指沿着从根节点到最远的叶节点的最长路径的节点数。</p><p><strong>Example:</strong></p><img src="tmp-tree.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自底向上递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自上到下递归</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(root, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每次递归时传递被访问节点的深度信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    res = max(res, depth);</span><br><span class="line">    helper(root-&gt;left, <span class="number">1</span> + depth);</span><br><span class="line">    helper(root-&gt;right, <span class="number">1</span> + depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree</a></h5><blockquote><p>  给定二叉树的根，返回其最小深度。二叉树的最小深度是指沿着从根节点到最近的叶节点的最短路径的节点数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMinDepth = minDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> rightMinDepth = minDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(leftMinDepth == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + rightMinDepth;</span><br><span class="line">    <span class="keyword">if</span>(rightMinDepth == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + leftMinDepth;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + min(leftMinDepth, rightMinDepth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 迭代解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(root) q.push(root);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">while</span>(sz--)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a></h5><blockquote><p>给定二叉树的根和一个整数<code>targetSum</code>，如果树具有从根到叶的路径，则沿路径的所有值加起来等于<code>targetSum</code>，则返回<code>true</code>。</p><p><strong>Example:</strong></p><img src="pathsum1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下递归</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(root, targetSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// is leaf and ...</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == root-&gt;val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; helper(root-&gt;left, target - root-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right &amp;&amp; helper(root-&gt;right, target - root-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II</a></h5><blockquote><p>给定二叉树的根和一个整数<code>targetSum</code>，返回所有从根到叶的路径，其中每个路径的和等于<code>targetSum</code>。</p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range<code>[0, 5000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><p><strong>Example:</strong></p><img src="pathsumii1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; target;</span><br><span class="line">    dfs(res, target, root, targetSum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, TreeNode* root, <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果此叶子节点满足</span></span><br><span class="line">        <span class="keyword">if</span>(targetSum == root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            target.push_back(root-&gt;val);</span><br><span class="line">            res.push_back(target);</span><br><span class="line">            target.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    target.push_back(root-&gt;val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    dfs(res, target, root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    <span class="comment">// target.pop_back();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    <span class="comment">// target.push_back(root-&gt;val);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    dfs(res, target, root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    target.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III</a></h5><blockquote><p>你将获得一棵二叉树，其中每个节点都包含一个整数值。查找路径中节点值总和为给定值的路径数。</p><p>该路径无需在根或叶处开始或结束，但必须向下（仅从父节点到子节点移动）。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">       10</span><br><span class="line">      &#x2F;  \</span><br><span class="line">     5   -3</span><br><span class="line">    &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line">&#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等于以从 root 开始的子路径 + ...</span></span><br><span class="line">    <span class="keyword">return</span> rootPathSum(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dfs 求解以从 root 开始的子路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rootPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    dfs(root, targetSum, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum, <span class="keyword">int</span>&amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 和上一题 II 不同了</span></span><br><span class="line">    <span class="comment">// 不必等到是叶子节点</span></span><br><span class="line">    <span class="comment">// 只要中间有满足的, 直接增加计数</span></span><br><span class="line">    <span class="keyword">if</span>(targetSum == root-&gt;val) res++;</span><br><span class="line">    <span class="comment">// 做选择和撤销选择一起了</span></span><br><span class="line">    <span class="comment">// 进入函数自动做选择</span></span><br><span class="line">    <span class="comment">// 出函数自动撤销选择</span></span><br><span class="line">    dfs(root-&gt;left, targetSum - root-&gt;val, res);</span><br><span class="line">    dfs(root-&gt;right, targetSum - root-&gt;val, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="666-Path-Sum-IV"><a href="#666-Path-Sum-IV" class="headerlink" title="666. Path Sum IV"></a><a href="https://leetcode.com/problems/path-sum-iv/" target="_blank" rel="noopener">666. Path Sum IV</a></h5><blockquote><p>对于一棵深度小于<code>5</code>的树，可以用一组三位十进制整数来表示。</p><p>对于每个整数：</p><p>百位上的数字表示这个节点的深度<code>D</code>，<code>1 &lt;= D &lt;= 4</code>。<br>十位上的数字表示这个节点在当前层所在的位置<code>P</code>，<code>1 &lt;= P &lt;= 8</code>。位置编号与一棵满二叉树的位置编号相同。<br>个位上的数字表示这个节点的权值<code>V</code>，<code>0 &lt;= V &lt;= 9</code>。<br>给定一个包含三位整数的升序数组，表示一棵深度小于<code>5</code>的二叉树，请你返回从根到所有叶子结点的路径之和。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [113, 215, 221]</span><br><span class="line">输出: 12</span><br><span class="line">解释: </span><br><span class="line">这棵树形状如下:</span><br><span class="line">  3</span><br><span class="line">&#x2F; \</span><br><span class="line">5   1</span><br><span class="line"></span><br><span class="line">路径和 &#x3D; (3 + 5) + (3 + 1) &#x3D; 12.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [113, 221]</span><br><span class="line">输出: 4</span><br><span class="line">解释: </span><br><span class="line">这棵树形状如下: </span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">路径和 &#x3D; (3 + 1) &#x3D; 4.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似于堆排序中将完全二叉树存储在一个向量的思路</span></span><br><span class="line"><span class="comment">// 借助一个哈希表来记录二叉树的每个节点在向量中的索引和其权重的映射</span></span><br><span class="line"><span class="comment">// 每个节点的索引可通过其深度和位置计算出来</span></span><br><span class="line"><span class="comment">// 公式为 i = 2 ^ (depth - 1) + position - 1</span></span><br><span class="line"><span class="comment">// 比如, 根节点 112, depth = 1, position = 1, i = 2 ^ (1 - 1) + 1 - 1 = 1</span></span><br><span class="line"><span class="comment">// 某节点 346, depth = 3, position = 4, i = 2 ^ (3 - 1) + 4 - 1 = 7</span></span><br><span class="line"><span class="comment">// 这样表示之后, 索引为 i 的节点</span></span><br><span class="line"><span class="comment">// 其左孩子索引为 2 * i, 右孩子索引为 2 * i + 1</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> depth = num / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> position = num % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> weight = num % <span class="number">10</span>;</span><br><span class="line">        mapping[<span class="built_in">pow</span>(<span class="number">2</span>, depth - <span class="number">1</span>) + position - <span class="number">1</span>] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(mapping, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; mapping, <span class="keyword">int</span> i, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mapping.count(i)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(!mapping.count(<span class="number">2</span> * i) &amp;&amp; !mapping.count(<span class="number">2</span> * i + <span class="number">1</span>))</span><br><span class="line">        res = res + sum + mapping[i];</span><br><span class="line">    <span class="comment">// 去左子树</span></span><br><span class="line">    dfs(mapping, <span class="number">2</span> * i, sum + mapping[i]);</span><br><span class="line">    <span class="comment">// 去右子树</span></span><br><span class="line">    dfs(mapping, <span class="number">2</span> * i + <span class="number">1</span>, sum + mapping[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129. Sum Root to Leaf Numbers"></a><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers</a></h5><blockquote><p>你将获得只包含<code>0</code>到<code>9</code>的数字的二叉树的根。树中的每条从根到叶的路径都代表一个数字。</p><p>例如，从根到叶的路径<code>1 -&gt; 2 -&gt; 3</code>表示数字<code>123</code>。返回所有从根到叶的数字的总和。</p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range<code>[1, 1000]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code>.</li><li>The depth of the tree will not exceed <code>10</code>.</li></ul><p><strong>Example:</strong></p><img src="num2tree.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [4,9,0,5,1]</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> sequence;</span><br><span class="line">    dfs(sequence, root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span>&amp; sequence, TreeNode* root, <span class="keyword">int</span>&amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        sequence.push_back(root-&gt;val + <span class="string">'0'</span>);</span><br><span class="line">        res += stoi(sequence);</span><br><span class="line">        sequence.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sequence.push_back(root-&gt;val + <span class="string">'0'</span>);</span><br><span class="line">    dfs(sequence, root-&gt;left, res);</span><br><span class="line">    <span class="comment">// sequence.pop_back();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sequence.push_back(to_string(root-&gt;val));</span></span><br><span class="line">    dfs(sequence, root-&gt;right, res);</span><br><span class="line">    sequence.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. Binary Tree Maximum Path Sum</a></h5><blockquote><p>二叉树中的路径是节点序列，其中序列中的每对相邻节点都有一条连接它们的边。 一个节点最多只能出现在序列中一次。 请注意，该路径不需要通过根。路径的路径总和是路径中节点值的总和。</p><p>给定二叉树的根，返回任何路径的最大路径总和。</p><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range<code>[1, 3 * 104]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code>.</li></ul><p><strong>Example:</strong></p><img src="exx2.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下递归</span></span><br><span class="line"><span class="comment">// int maxPathSum(TreeNode* root)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(!root) return INT_MIN;</span></span><br><span class="line"><span class="comment">//     return max(rootMaxPathSum(root),</span></span><br><span class="line"><span class="comment">//max(maxPathSum(root-&gt;left), maxPathSum(root-&gt;right)));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 该函数的定义是, 返回经过 root 的最大路径和</span></span><br><span class="line"><span class="comment">// int rootMaxPathSum(TreeNode* root)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int resLeft = 0, resRight = 0;</span></span><br><span class="line"><span class="comment">//     if(root-&gt;left) dfs(root-&gt;left, resLeft, 0);</span></span><br><span class="line"><span class="comment">//     if(root-&gt;right) dfs(root-&gt;right, resRight, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return resLeft + resRight + root-&gt;val;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 此递归函数的定义是, 返回 [以 root 为首节点] 的最大路径和</span></span><br><span class="line"><span class="comment">// void dfs(TreeNode* root, int&amp; res, int sum)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if(!root) return;</span></span><br><span class="line"><span class="comment">//     res = max(res, sum + root-&gt;val);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     dfs(root-&gt;left, res, sum + root-&gt;val);</span></span><br><span class="line"><span class="comment">//     dfs(root-&gt;right, res, sum + root-&gt;val);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自底向上的递归</span></span><br><span class="line"><span class="comment">// 和上一种方法对比</span></span><br><span class="line"><span class="comment">// 显然自底向上递归代码简单易懂效率高</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN;</span><br><span class="line">    dfs(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数的定义就是返回 [以 root 为首节点] 的最大路径和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果以 left 或 right 为首节点的路径和为负数</span></span><br><span class="line">    <span class="comment">// 就不加上它</span></span><br><span class="line">    <span class="comment">// 这样就能保证返回的值是以 root 为首节点的最大路径和</span></span><br><span class="line">    <span class="comment">// 就是说将 root 单节点看作一条路径</span></span><br><span class="line">    <span class="keyword">int</span> leftMaxSum = max(<span class="number">0</span>, dfs(root-&gt;left, res));</span><br><span class="line">    <span class="keyword">int</span> rightMaxSum = max(<span class="number">0</span>, dfs(root-&gt;right, res));</span><br><span class="line">    <span class="comment">// 计算 [经过] root 的最大路径和</span></span><br><span class="line">    <span class="comment">// 这样, 通过递归的过程, 保证会, 分别计算经过每一个节点的最大路径和</span></span><br><span class="line">    <span class="comment">// 其中最大的就是答案</span></span><br><span class="line">    res = max(res, leftMaxSum + rightMaxSum + root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val + max(leftMaxSum, rightMaxSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h5><blockquote><p>给定两个整数数组<code>preorder</code>和<code>inorder</code>，其中<code>preorder</code>是二叉树的前序遍历，而<code>inorder</code>是同一树的中序遍历，构造并返回二叉树。</p><img src="640.jpg" alt="640" style="zoom: 50%;" /><img src="sdsef.jpg" alt="sdsef" style="zoom: 50%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要知道前序遍历的首元素就是树的根</span></span><br><span class="line"><span class="comment">// 其在中序遍历的位置的左边所有元素构成左子树</span></span><br><span class="line"><span class="comment">// 右边所有元素构成右子树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, preorder,</span><br><span class="line">                 <span class="number">0</span>, inorder.size() - <span class="number">1</span>, <span class="number">0</span>, preorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定位 rootVal 在中序遍历中的位置</span></span><br><span class="line">    <span class="comment">// 一定存在</span></span><br><span class="line">    <span class="comment">// 这里有一个特殊情况 inStart == inEnd</span></span><br><span class="line">    <span class="comment">// 出现这种情况 index 应该等于 inStart == inEnd</span></span><br><span class="line">    <span class="comment">// 递归基可以处理</span></span><br><span class="line">    <span class="keyword">int</span> index = inStart;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt;= inEnd; index++)</span><br><span class="line">        <span class="keyword">if</span>(inorder[index] == rootVal) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 计算左子树节点数量</span></span><br><span class="line">    <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line"></span><br><span class="line">    root-&gt;left = build(inorder, preorder,</span><br><span class="line">                       inStart, index - <span class="number">1</span>, preStart + <span class="number">1</span>, preStart + leftSize);</span><br><span class="line">    root-&gt;right = build(inorder, preorder,</span><br><span class="line">                        index + <span class="number">1</span>, inEnd, preStart + leftSize + <span class="number">1</span>, preEnd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h5><blockquote><p>给定两个整数数组<code>postorder</code>和<code>inorder</code>，其中<code>postorder</code>是二叉树的后序遍历，而<code>inorder</code>是同一树的中序遍历，构造并返回二叉树。</p><img src="444.jpg" alt="444" style="zoom: 50%;" /><img src="fgfg.jpg" alt="fgfg" style="zoom: 50%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要知道后序遍历的尾元素就是树的根</span></span><br><span class="line"><span class="comment">// 其在中序遍历的位置的左边所有元素构成左子树</span></span><br><span class="line"><span class="comment">// 右边所有元素构成右子树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(inorder, postorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(inStart &gt; inEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 后序遍历尾元素就是根</span></span><br><span class="line">    <span class="keyword">int</span> rootVal = postorder[postEnd];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    <span class="comment">// 定位根在中序遍历中的位置</span></span><br><span class="line">    <span class="comment">// 一定存在</span></span><br><span class="line">    <span class="comment">// 这里有一个特殊情况 inStart == inEnd</span></span><br><span class="line">    <span class="comment">// 出现这种情况 index 应该等于 inStart == inEnd</span></span><br><span class="line">    <span class="comment">// 递归基可以处理</span></span><br><span class="line">    <span class="keyword">int</span> index = inStart;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt;= inEnd; index++)</span><br><span class="line">        <span class="keyword">if</span>(inorder[index] == rootVal) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 计算左子树的节点数</span></span><br><span class="line">    <span class="keyword">int</span> leftSize = index - inStart;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = build(inorder, postorder,</span><br><span class="line">                       inStart, index - <span class="number">1</span>, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = build(inorder, postorder,</span><br><span class="line">                        index + <span class="number">1</span>, inEnd, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener">889. Construct Binary Tree from Preorder and Postorder Traversal</a></h5><blockquote><p>返回与给定的前序和后序遍历匹配的任意二叉树。二叉树中的值是不同的正整数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然有些情况不能确定一棵唯一的二叉树</span></span><br><span class="line"><span class="comment">// 但我们决定左右子树的规则固定即可</span></span><br><span class="line"><span class="comment">// 首先注意到前序遍历的首元素为树的根</span></span><br><span class="line"><span class="comment">// 首元素的下一个元素可能为其左子树的根, 也可能为其右子树的根</span></span><br><span class="line"><span class="comment">// 但我们始终把它认定为左子树的根</span></span><br><span class="line"><span class="comment">// 接下来就是在后序遍历中定位到 前序遍历首元素的下一个元素 的位置</span></span><br><span class="line"><span class="comment">// 这个位置左边的就是左子树所有元素 (包括这个位置上的元素, 实际上它是左子树的根)</span></span><br><span class="line"><span class="comment">// 右边的就是右子树所有元素 (除了末元素, 因为它是当前树的根啊)</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> construct(pre, post, <span class="number">0</span>, pre.size() - <span class="number">1</span>, <span class="number">0</span>, post.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">construct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rootVal = pre[preStart];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    <span class="comment">// 这个条件判断非常重要</span></span><br><span class="line">    <span class="comment">// 如果 preStart == preEnd</span></span><br><span class="line">    <span class="comment">// 下面的 index 就会因为找不到而很大 为 postEnd</span></span><br><span class="line">    <span class="comment">// 导致错误地计算出很大的 leftSize</span></span><br><span class="line">    <span class="comment">// 递归基处理不了</span></span><br><span class="line">    <span class="keyword">if</span>(preStart == preEnd) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 定位到左子树的根在后序遍历中的位置</span></span><br><span class="line">    <span class="comment">// 此时保证至少会有两个元素, 也就是说 pre[preStart + 1] 在后序遍历中一定存在</span></span><br><span class="line">    <span class="keyword">int</span> index = postStart;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt; postEnd; index++)</span><br><span class="line">        <span class="keyword">if</span>(post[index] == pre[preStart + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leftSize = index - postStart + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = construct(pre, post, preStart + <span class="number">1</span>, preStart + leftSize,</span><br><span class="line">                           postStart, index);</span><br><span class="line">    root-&gt;right = construct(pre, post, preStart + leftSize + <span class="number">1</span>, preEnd,</span><br><span class="line">                            index + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">1008. Construct Binary Search Tree from Preorder Traversal</a></h5><blockquote><p>给定一个整数已排序数组，该数组表示二叉搜索树的前序遍历结果，请构造该<code>BST</code>树并返回其根。</p><p>可以确保始终可以找到满足测试用例要求的<code>BST</code>。</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 100</code>.</li><li><code>1 &lt;= preorder[i] &lt;= 108</code>.</li><li>All the values of <code>preorder</code> are <strong>unique</strong>.</li></ul><p><strong>Example:</strong></p><img src="1266.png" alt="img" style="zoom: 50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先可以确定前序遍历的首元素为树的根</span></span><br><span class="line"><span class="comment">// 其左子树的所有元素都小于首元素</span></span><br><span class="line"><span class="comment">// 其右子树的所有元素都大于首元素</span></span><br><span class="line"><span class="comment">// 所以, 我们接下来只要确定数组中第一个大于首元素的值的位置</span></span><br><span class="line"><span class="comment">// 就能够直到左子树和右子树的元素范围</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(preStart &gt; preEnd) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 根为首元素</span></span><br><span class="line">    <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    <span class="comment">// 找到第一个大于首元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> index  = prepreStart + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt;= preEnd; index++)</span><br><span class="line">        <span class="keyword">if</span>(preorder[index] &gt; rootVal) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 到这里, 有两种情况</span></span><br><span class="line">    <span class="comment">// 1. 左子树为空, 此时 index 应该为 prepreStart + 1</span></span><br><span class="line">    <span class="comment">// 2. 右子树为空, 此时 index 应该为 preEnd + 1</span></span><br><span class="line">    <span class="comment">// 无论哪一种情况, 递归进去之后, 递归基都可以处理</span></span><br><span class="line">    root-&gt;left = build(preorder, preStart + <span class="number">1</span>, index - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = build(preorder, index, preEnd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="117-Populating-Next-Right-Pointers-in-Each-Node-II-LeetCode"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-LeetCode" class="headerlink" title="117. Populating Next Right Pointers in Each Node II - LeetCode"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II - LeetCode</a></h5><blockquote><p>填充二叉树的每个节点下一个指针以指向其下一个右节点。 如果没有下一个右节点，则下一个指针应设置为<code>NULL</code>。</p><p>最初，所有下一个指针都设置为<code>NULL</code>。</p><img src="117_sample.png" alt="img" style="zoom: 50%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct Node</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     Node *left;</span></span><br><span class="line"><span class="comment">//     Node *right;</span></span><br><span class="line"><span class="comment">//     Node *next;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用辅助节点的迭代式解法</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    Node* helper = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* p = helper;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = cur-&gt;left;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = cur-&gt;right;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = helper-&gt;next;</span><br><span class="line">        helper-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> helper;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用队列的迭代式解法</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = root;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; nodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) nodes.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> count = nodes.size();</span><br><span class="line">        <span class="keyword">while</span>(count--)</span><br><span class="line">        &#123;</span><br><span class="line">            root = nodes.front();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) root-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> root-&gt;next = nodes.front();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) nodes.push(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) nodes.push(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给定的二叉树是棵<strong>完美二叉树</strong>：<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node</a></p><img src="116_sample.png" alt="img" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对完美二叉树的递归式解法</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    helper(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node* node1, Node* node2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node1 || !node2) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line"></span><br><span class="line">    helper(node1-&gt;left, node1-&gt;right);</span><br><span class="line">    helper(node2-&gt;left, node2-&gt;right);</span><br><span class="line">    helper(node1-&gt;right, node2-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. Validate Binary Search Tree</a></h5><blockquote><p>给定二叉树的根，确定它是否是有效的二叉搜索树。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须将对上层节点的约束传递给下层节点</span></span><br><span class="line"><span class="comment">// 限定以 root 为根的子树节点必须满足 min-&gt;val &lt; root.val &lt; max-&gt;val</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* min, TreeNode* max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(min &amp;&amp; root-&gt;val &lt;= min-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(max &amp;&amp; root-&gt;val &gt;= max-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这时 left 节点的最大就是 root, right 节点的最小值就是 root</span></span><br><span class="line">    <span class="keyword">return</span> helper(root-&gt;left, min, root) &amp;&amp; helper(root-&gt;right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1373-Maximum-Sum-BST-in-Binary-Tree"><a href="#1373-Maximum-Sum-BST-in-Binary-Tree" class="headerlink" title="1373. Maximum Sum BST in Binary Tree"></a><a href="https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/" target="_blank" rel="noopener">1373. Maximum Sum BST in Binary Tree</a></h5><blockquote><p>给定二叉树的根，找出所有是<code>BST</code>的子树，分别计算这些子树的所有节点值的和， 返回其中的最大值。</p><p>二叉搜索树的定义如下：</p><p>任意节点的左子树中的键值都小于此节点的键值。<br>任意节点的右子树中的键值都大于此节点的键值。<br>任意节点的左子树和右子树都是二叉搜索树。</p><p><strong>Example 1:</strong></p><img src="sample_1_1709.png" alt="img" style="zoom: 80%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="sample_2_1709.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [4,3,null,1,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    postOrder(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tuple 中存的是</span></span><br><span class="line"><span class="comment">// 1. 以 root 为根的子树的总和, 如果其不是 BST, 此值为 0</span></span><br><span class="line"><span class="comment">// 2. 以 root 为根的树中的最小值</span></span><br><span class="line"><span class="comment">// 3. 以 root 为根的树中的最大值</span></span><br><span class="line">tuple&lt;int, int, int&gt; postOrder(TreeNode* root, int&amp; ans)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;<span class="number">0</span>, INT_MAX, INT_MIN&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> l = postOrder(root-&gt;left, ans);</span><br><span class="line">    <span class="keyword">auto</span> r = postOrder(root-&gt;right, ans);</span><br><span class="line">    <span class="comment">// 如果当前节点的左子树中节点的最大值比当前节点还大</span></span><br><span class="line">    <span class="comment">// 或者当前节点的右子树中节点的最小值比当前节点还小</span></span><br><span class="line">    <span class="comment">// 以当前节点为根的子树就不是 BST</span></span><br><span class="line">    <span class="comment">// 因此总和为 0</span></span><br><span class="line">    <span class="comment">// 最小值为 INT_MIN 以致于右子树中包含此树的树也被认定为非 BST</span></span><br><span class="line">    <span class="comment">// 最大值为 INT_MAX 以致于左子树中包含此树的树也被认定为非 BST</span></span><br><span class="line">    <span class="keyword">if</span>(get&lt;<span class="number">2</span>&gt;(l) &gt;= root-&gt;val || get&lt;<span class="number">1</span>&gt;(r) &lt;= root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, INT_MIN, INT_MAX&#125;;</span><br><span class="line">    <span class="comment">// 此时, 以当前节点为根的子树是 BST</span></span><br><span class="line">    <span class="comment">// 计算此树的总和并更新最大值</span></span><br><span class="line">    <span class="keyword">int</span> num = get&lt;<span class="number">0</span>&gt;(l) + get&lt;<span class="number">0</span>&gt;(r) + root-&gt;val;</span><br><span class="line">    ans = max(ans, num);</span><br><span class="line">    <span class="comment">// 最后还要返回以当前节点为根的子树的信息</span></span><br><span class="line">    <span class="comment">// 其总和就为 num</span></span><br><span class="line">    <span class="comment">// 1. 当前节点有可能是叶子节点或者只有一颗子树</span></span><br><span class="line">        <span class="comment">// 所以最小值为当前节点的值和左子树中最小的值相比取小者</span></span><br><span class="line">        <span class="comment">// 最小值为当前节点的值和右子树中最大的值相比取大者</span></span><br><span class="line">        <span class="comment">// 因为 if(!root) return &#123;0, INT_MAX, INT_MIN&#125;; 语句</span></span><br><span class="line">        <span class="comment">// 保证了左子树中最小的值为 INT_MAX, 右子树中最大的值为 INT_MIN</span></span><br><span class="line">        <span class="comment">// 所以比较的结果肯定是 root-&gt;val</span></span><br><span class="line">    <span class="comment">// 2. 当前节点有两颗子树, 那么比较的结果肯定不是 root-&gt;val (这是 BST 的规则!)</span></span><br><span class="line">    <span class="keyword">return</span> &#123;num, min(root-&gt;val, get&lt;<span class="number">1</span>&gt;(l)), max(root-&gt;val, get&lt;<span class="number">2</span>&gt;(r))&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. Serialize and Deserialize Binary Tree</a></h5><blockquote><p>序列化是将数据结构或对象转换为位序列的过程，以便可以将其存储在文件或内存缓冲区中，或者通过网络连接链接进行传输，以便稍后在相同或另一台计算机环境中进行重构。</p><p>设计一种用于对二叉树进行序列化和反序列化的算法。 序列化和反序列化算法的工作方式没有任何限制。 你只需要确保可以将二叉树序列化为字符串，并且可以将该字符串反序列化为原始树结构。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前序遍历解法</span></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        serializeHelper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serializeHelper</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            res.append(PLACEHOLDER).append(DELIMITER);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res.append(to_string(root-&gt;val)).append(DELIMITER);</span><br><span class="line">        </span><br><span class="line">        serializeHelper(root-&gt;left, res);</span><br><span class="line">        serializeHelper(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserializeHelper(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserializeHelper</span><span class="params">(<span class="built_in">stringstream</span>&amp; ss)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ss) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        getline(ss, str, <span class="string">','</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">"#"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(str));</span><br><span class="line">        root-&gt;left = deserializeHelper(ss);</span><br><span class="line">        root-&gt;right = deserializeHelper(ss);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> PLACEHOLDER = <span class="string">"#"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> DELIMITER = <span class="string">","</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 后序遍历解法</span></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        serializeHelper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serializeHelper</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            res.append(PLACEHOLDER).append(DELIMITER);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        serializeHelper(root-&gt;left, res);</span><br><span class="line">        serializeHelper(root-&gt;right, res);</span><br><span class="line">        </span><br><span class="line">        res.append(to_string(root-&gt;val)).append(DELIMITER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vecString;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">while</span>(getline(ss, str, <span class="string">','</span>))</span><br><span class="line">            vecString.push_back(str);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> deserializeHelper(vecString);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserializeHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; vecString)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vecString.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">string</span> str = vecString.back();</span><br><span class="line">        vecString.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">"#"</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(str));</span><br><span class="line">        <span class="comment">// 后序遍历解法需要先构造右孩子, 再构造左孩子</span></span><br><span class="line">        root-&gt;right = deserializeHelper(vecString);</span><br><span class="line">        root-&gt;left = deserializeHelper(vecString);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> PLACEHOLDER = <span class="string">"#"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> DELIMITER = <span class="string">","</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="653-Two-Sum-IV-Input-is-a-BST"><a href="#653-Two-Sum-IV-Input-is-a-BST" class="headerlink" title="653. Two Sum IV - Input is a BST"></a><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. Two Sum IV - Input is a BST</a></h5><blockquote><p>给定一个二叉搜索树和一个目标数，如果<code>BST</code>中存在两个元素的总和等于给定的目标数，则返回<code>true</code>。</p><p><strong>Example:</strong></p><img src="sum_tree_1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1 基本思想都是借助 BST 的中序遍历结果是升序排列的, 然后借助双指针搜索即可</span></span><br><span class="line"><span class="comment">// 方法 2 如果使用什么遍历 (写成递归和迭代都行), 都借助哈希表在遍历的过程中记录已经出现的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="keyword">return</span> helper(root, k, setting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(setting.count(k - root-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    setting.insert(root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> helper(root-&gt;left, k, setting) || helper(root-&gt;right, k, setting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List</a></h5><blockquote><p>给定二叉树的根，将树展平为“链表”：“链表”应使用相同的<code>TreeNode</code>类，其中右子指针指向列表中的下一个节点，而左子指针始终为<code>null</code>。</p><p>“链表”的顺序应与二叉树的前序遍历顺序相同。</p><img src="flaten.jpg" alt="img" style="zoom: 67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归思想: 相信递归函数的定义并毫不怀疑的去调用它!</span></span><br><span class="line"><span class="comment">// 此例中, void flatten(TreeNode* root) 函数的定义就是将 root 平展</span></span><br><span class="line"><span class="comment">// 只需要注意递归基的处理就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    <span class="comment">// 此时左右两棵子树都已经 flatten 完毕了</span></span><br><span class="line">    </span><br><span class="line">    TreeNode* p = root-&gt;right; <span class="comment">// 备份右子树</span></span><br><span class="line">    <span class="comment">// 1. 将右孩子指针指向左子树, 随后左孩子指针置空</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = root-&gt;left;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 2. 沿着新右指针一直往前走, 定位到尾节点</span></span><br><span class="line">    <span class="keyword">while</span>(root &amp;&amp; root-&gt;right) root = root-&gt;right;</span><br><span class="line">    <span class="comment">// 3. 将尾节点指向右子树</span></span><br><span class="line">    root-&gt;right = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree"><a href="#1379-Find-a-Corresponding-Node-of-a-Binary-Tree-in-a-Clone-of-That-Tree" class="headerlink" title="1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree"></a><a href="https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/" target="_blank" rel="noopener">1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</a></h5><blockquote><p>给定一个原始树和一个克隆树，克隆树是原始树的副本。并给出对原始树中某目标节点的引用。</p><p>返回对克隆树中相同节点的引用。</p><p>请注意，不允许您更改两个树或目标节点中的任何一个，并且答案必须是对克隆树中节点的引用。</p><p>注意：你的解答要适用于在树上允许有重复的值的情况。</p><p><img src="e4.png" alt="img"></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树上允许有重复的值意味着不能通过比较节点的值来返回目标节点</span></span><br><span class="line"><span class="comment">// 题目已经给出保证 original cloned target 都不为 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对两棵树同步的进行 dfs</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">getTargetCopy</span><span class="params">(TreeNode* original, TreeNode* cloned, TreeNode* target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!original) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(original == target) <span class="keyword">return</span> cloned;</span><br><span class="line">    <span class="comment">// 先在左子树中找</span></span><br><span class="line">    TreeNode* found = getTargetCopy(original-&gt;left, cloned-&gt;left, target);</span><br><span class="line">    <span class="comment">// 没找到再去右子树中找</span></span><br><span class="line">    <span class="keyword">if</span>(!found) found = getTargetCopy(original-&gt;right, cloned-&gt;right, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. Recover Binary Search Tree</a></h5><blockquote><p>给定一个二叉搜索树的根节点，恰好树中的两个节点错误地交换了。 在不更改其结构的前提下，恢复这棵二叉搜索树。</p><table><thead><tr><th align="center">Example 1</th><th align="center">Example 2</th></tr></thead><tbody><tr><td align="center"><img src="recover1.jpg" alt="img"></td><td align="center"><img src="recover2.jpg" alt="img"></td></tr></tbody></table><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,3,null,null,2]</span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line">Explanation: 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,null,2]</span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line">Explanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用<code>O(n)</code>空间复杂度的解决方案非常简单。 你能设计一个<code>O(1)</code>空间解决方案吗？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要知道, BST 的中序遍历是有序的</span></span><br><span class="line"><span class="comment">// 然后注意到, 如果树中有两个节点被交换了</span></span><br><span class="line"><span class="comment">// 在中序遍历序列中必然会出现逆序对 (可能一对, 也可能两对)</span></span><br><span class="line"><span class="comment">// 一对的情况是被交换的两个节点在中序遍历序列中相邻</span></span><br><span class="line"><span class="comment">// 此时我们有两个指针来分别定位这一逆序对的两个节点</span></span><br><span class="line"><span class="comment">// 交换它们的值即可</span></span><br><span class="line"><span class="comment">// 被交换的两个节点不相邻就会出现两对逆序对的情况</span></span><br><span class="line"><span class="comment">// 此时, 有一个指针定位前一个逆序对的第一个节点</span></span><br><span class="line"><span class="comment">// 另一个指针定位后一个逆序对的第二个节点</span></span><br><span class="line"><span class="comment">// 交换它们的值即可</span></span><br><span class="line">TreeNode* startPoint = <span class="literal">nullptr</span>; <span class="comment">// 定位逆序对的第一个节点</span></span><br><span class="line">TreeNode* endPoint = <span class="literal">nullptr</span>; <span class="comment">// 定位逆序对的第二个节点</span></span><br><span class="line">TreeNode* preNode = <span class="literal">nullptr</span>; <span class="comment">// 始终指向当前访问节点的前一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoverBinarySearchTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inorder(root);</span><br><span class="line">    swap(startPoint-&gt;val, endPoint-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;left);</span><br><span class="line">    <span class="comment">// 从这题要学会如何跟踪遍历过程中当前节点的前一个节点的技术</span></span><br><span class="line">    <span class="keyword">if</span>(preNode &amp;&amp; preNode-&gt;val &gt; root-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果为空, 说明遇到的是第一个逆序对</span></span><br><span class="line">        <span class="comment">// 当前节点是逆序对的第二个节点</span></span><br><span class="line">        <span class="comment">// 第一个节点由 preNode 指出, 更新 startPoint</span></span><br><span class="line">        <span class="comment">// 如果不为空, 说明遇到的是第二个逆序对</span></span><br><span class="line">        <span class="comment">// 就不更新 startPoint, 因为我们定位第二个逆序对的第一个节点没有用</span></span><br><span class="line">        <span class="keyword">if</span>(!startPoint) startPoint = preNode;</span><br><span class="line">        <span class="comment">// 无论是第几个逆序对</span></span><br><span class="line">        <span class="comment">// endPoint 都指向逆序对的第二个节点</span></span><br><span class="line">        endPoint = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 持续跟踪前一个节点</span></span><br><span class="line">    preNode = root;</span><br><span class="line">    </span><br><span class="line">    inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="687-Longest-Univalue-Path"><a href="#687-Longest-Univalue-Path" class="headerlink" title="687. Longest Univalue Path"></a><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">687. Longest Univalue Path</a></h5><blockquote><p>给定二叉树的根，返回最长路径的长度，其中路径中的每个节点都具有相同的值。 此路径可能会也可能不会通过根。</p><p>两个节点之间的路径长度由它们之间的边数表示。</p><p><strong>Example 1:</strong></p><img src="ex2.jpg" alt="img" style="zoom: 67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,4,5,4,4,5]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><img src="ex1.jpg" alt="img" style="zoom: 67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,4,5,1,1,5]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    dfs(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该递归函数的定义就是返回以 root 为起点的符合条件的路径的最大长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 利用递归</span></span><br><span class="line">    <span class="comment">// 先获取以其左孩子为起点的符合条件的路径长度</span></span><br><span class="line">    <span class="keyword">int</span> leftPath = dfs(root-&gt;left, res);</span><br><span class="line">    <span class="comment">// 先获取以其右孩子为起点的符合条件的路径长度</span></span><br><span class="line">    <span class="keyword">int</span> rightPath = dfs(root-&gt;right, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rootPathWithLeft = <span class="number">0</span>, rootPathWithRight = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果当前节点的值与其左孩子的值相等</span></span><br><span class="line">    <span class="comment">// 那么它就可以和其左孩子的路径连在一块, 路径长度 +1</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val)</span><br><span class="line">        rootPathWithLeft = leftPath + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前节点的值与其右孩子的值相等</span></span><br><span class="line">    <span class="comment">// 那么它就可以和其右孩子的路径连在一块, 路径长度 +1</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val)</span><br><span class="line">        rootPathWithRight = rightPath + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这两条路径是不一样的</span></span><br><span class="line">    res = max(res, rootPathWithLeft + rootPathWithRight);</span><br><span class="line">    <span class="comment">// 而以 root 为起点的符合条件的路径的最大长度为这两条路径的较大者</span></span><br><span class="line">    <span class="keyword">return</span> max(rootPathWithLeft, rootPathWithRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a><a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. Maximum Binary Tree</a></h5><blockquote><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ol><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ol><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p><strong>Constraints:</strong></p><ul><li>All integers in <code>nums</code> are <strong>unique</strong>.</li></ul><p><strong>Example:</strong></p><img src="tree1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,6,0,5]</span><br><span class="line">Output: [6,3,5,null,2,0,null,null,1]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> construct(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造闭区间 [lo, hi] 内的元素</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">construct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(lo &gt; hi) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 找到最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxIndex = findMax(nums, lo, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 另外, 装逼的话, 获取数组中最大元素的索引可以这样写</span></span><br><span class="line"><span class="comment">    int maxIndex = distance(nums.begin(),</span></span><br><span class="line"><span class="comment">    max_element(nums.begin() + lo, nums.begin() + hi + 1));</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以最大值为根节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(nums[maxIndex]);</span><br><span class="line">    <span class="comment">// 左子树为最大值左边的</span></span><br><span class="line">    root-&gt;left = construct(nums, lo, maxIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 右子树为最大值右边的</span></span><br><span class="line">    root-&gt;right = construct(nums, maxIndex + <span class="number">1</span>, hi);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; maxVal)</span><br><span class="line">        &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            maxVal = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="998-Maximum-Binary-Tree-II"><a href="#998-Maximum-Binary-Tree-II" class="headerlink" title="998. Maximum Binary Tree II"></a><a href="https://leetcode.com/problems/maximum-binary-tree-ii/" target="_blank" rel="noopener">998. Maximum Binary Tree II</a></h5><blockquote><p>最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。</p><p>给出最大树的根节点<code>root</code>。</p><p>就像之前的<code>654. Maximum Binary Tree</code>问题那样，给定的树是从列表<code>A</code>递归地使用下述<code>Construct(A)</code>例程构造的：</p><p>如果<code>A</code>为空，返回<code>null</code><br>否则，令<code>A[i]</code>作为<code>A</code>的最大元素。创建一个值为<code>A[i]</code>的根节点<code>root</code><br><code>root</code>的左子树将被构建为<code>Construct([A[0], A[1], ..., A[i-1]])</code><br><code>root</code>的右子树将被构建为<code>Construct([A[i+1], A[i+2], ..., A[A.length - 1]])</code><br>返回<code>root</code><br>请注意，我们这里没有直接给定<code>A</code>，只有一个根节点<code>root = Construct(A)</code>.</p><p>假设<code>B</code>是<code>A</code>的副本，并在末尾附加值<code>val</code>。题目数据保证B中的值是不同的。返回<code>Construct(B)</code>。</p><p><strong>Example 1:</strong></p><table><thead><tr><th align="center"></th><th></th></tr></thead><tbody><tr><td align="center"><img src="maximum-binary-tree-1-1.png" alt="img"></td><td><img src="maximum-binary-tree-1-2.png" alt="img"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [4,1,3,null,null,2], val &#x3D; 5</span><br><span class="line">Output: [5,4,null,1,3,null,null,2]</span><br><span class="line">Explanation: A &#x3D; [1,4,2,3], B &#x3D; [1,4,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="maximum-binary-tree-2-1.png" alt="img"></td><td><img src="maximum-binary-tree-2-2.png" alt="img"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,2,4,null,1], val &#x3D; 3</span><br><span class="line">Output: [5,2,4,null,1,null,3]</span><br><span class="line">Explanation: A &#x3D; [2,1,5,4], B &#x3D; [2,1,5,4,3]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="maximum-binary-tree-3-1.png" alt="img"></td><td><img src="maximum-binary-tree-3-2.png" alt="img"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,2,3,null,1], val &#x3D; 4</span><br><span class="line">Output: [5,2,4,null,1,3]</span><br><span class="line">Explanation: A &#x3D; [2,1,5,3], B &#x3D; [2,1,5,3,4]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先要明确一点, 最大二叉树指的是在构造的时候最大值左边的为左子树, 右边的为右子树</span></span><br><span class="line"><span class="comment">// 因为是放在数组右边的, 所以新节点必然在右子树中</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果比人家右子树中的所有节点都小</span></span><br><span class="line">    <span class="comment">// 只能作为叶子节点了</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="comment">// 如果目标值当前节点的值大</span></span><br><span class="line">    <span class="comment">// 说明以当前节点为根的子树要成为我的左子树才行</span></span><br><span class="line">    <span class="comment">// 因为我是放在最右边的, 你在我左边我还比你大</span></span><br><span class="line">    <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val, root, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 否则, 就要向右边搜索位置</span></span><br><span class="line">    <span class="comment">// 因为你在原来最大值的右边</span></span><br><span class="line">    root-&gt;right = insertIntoMaxTree(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="508-Most-Frequent-Subtree-Sum"><a href="#508-Most-Frequent-Subtree-Sum" class="headerlink" title="508. Most Frequent Subtree Sum"></a><a href="https://leetcode.com/problems/most-frequent-subtree-sum/" target="_blank" rel="noopener">508. Most Frequent Subtree Sum</a></h5><blockquote><p>给定一棵树的根，要求你找到最频繁的子树总和。 </p><p>节点的子树总和定义为由以该节点为根的子树（包括节点本身）形成的所有节点值的总和。 那么，最频繁的子树总和的值是多少？如果有平局，则以任意顺序返回具有最高频率的所有值。</p><p><strong>Examples 1</strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   -3</span><br></pre></td></tr></table></figure><p>return [2, -3, 4], since all the values happen only once, return all of them in any order.</p><p><strong>Examples 2</strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   -5</span><br></pre></td></tr></table></figure><p>return [2], since 2 happens twice, however -5 only occur once.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想就是先通过递归获得所有子树的和</span></span><br><span class="line"><span class="comment">// 递归的过程中记录下来每一个确定的和出现的次数</span></span><br><span class="line"><span class="comment">// 这需要一个哈希表来记录 sum --&gt; preq 的映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是问题来了, 之后我们要获取出现次数最多的, 也就是值(频率)最大的键</span></span><br><span class="line"><span class="comment">// 并且频率还有可能相同而出现重复</span></span><br><span class="line"><span class="comment">// 第一种方法是 auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);</span></span><br><span class="line"><span class="comment">// 注意, cmp 需要定制 auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)</span></span><br><span class="line"><span class="comment">//                 &#123; return a.second &lt; b.second; &#125;;</span></span><br><span class="line"><span class="comment">// 这种方法效率有点低, 有多少个重复的 freq, 我们就需要遍历哈希表多少次</span></span><br><span class="line"><span class="comment">// 最坏情况下，时间复杂度为 O(n2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法是再使用一个 multimap 来 [逆映射] 原 unordered_map 中的键值对</span></span><br><span class="line"><span class="comment">// for(auto elem : mapping)</span></span><br><span class="line"><span class="comment">//        mappingSwap.insert(&#123;elem.second, elem.first&#125;);</span></span><br><span class="line"><span class="comment">// 需要注意的是, 使用有序可重复哈希表, 将原来的键变成值, 值变成键</span></span><br><span class="line"><span class="comment">// 然后通过逆迭代器直接获得最大键元素 (在红黑树的最右下边嘛)</span></span><br><span class="line"><span class="comment">// 最坏时间复杂度将为 O(n) 啦</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; findFrequentTreeSum(TreeNode* root)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     unordered_map&lt;int, int&gt; mapping;</span></span><br><span class="line"><span class="comment">//     subTreeSum(root, mapping);</span></span><br><span class="line"><span class="comment">//     auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)</span></span><br><span class="line"><span class="comment">//                 &#123; return a.second &lt; b.second; &#125;;</span></span><br><span class="line"><span class="comment">//     vector&lt;int&gt; res;</span></span><br><span class="line"><span class="comment">//     int preFreq = 0;</span></span><br><span class="line"><span class="comment">//     while(1)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if(mapping.empty()) break;</span></span><br><span class="line"><span class="comment">//         auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);</span></span><br><span class="line"><span class="comment">//         if(!res.empty() &amp;&amp; maxFreqSum.second != preFreq)</span></span><br><span class="line"><span class="comment">//             break;</span></span><br><span class="line"><span class="comment">//         preFreq = maxFreqSum.second;</span></span><br><span class="line"><span class="comment">//         res.push_back(maxFreqSum.first);</span></span><br><span class="line"><span class="comment">//         mapping.erase(maxFreqSum.first);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return res;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findFrequentTreeSum</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mappingSwap;</span><br><span class="line">    subTreeSum(root, mapping);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : mapping)</span><br><span class="line">        mappingSwap.insert(&#123;elem.second, elem.first&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(mappingSwap.empty()) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> preFreq = mappingSwap.rbegin()-&gt;first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = mappingSwap.rbegin(); it != mappingSwap.rend(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;first != preFreq) <span class="keyword">break</span>;</span><br><span class="line">        res.push_back(it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subTreeSum</span><span class="params">(TreeNode* root, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; mapping)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = subTreeSum(root-&gt;left, mapping);</span><br><span class="line">    <span class="keyword">int</span> rightSum = subTreeSum(root-&gt;right, mapping);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rootSum = leftSum + rightSum + root-&gt;val;</span><br><span class="line">    mapping[rootSum]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rootSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. Lowest Common Ancestor of a Binary Tree</a></h5><blockquote><p>给定一棵二叉树，找到树中两个给定节点的最低公共祖先（<code>LCA</code>）。一个节点的祖先可以是它自己。</p><p><strong>Constraints:</strong></p><ol><li>所有<code>Node.val</code>互不相同</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code>均存在于给定的二叉树中。</li></ol><img src="236_LCA_Binary_1.png" alt="img" style="zoom: 33%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接下来的几道题全是最低公共祖先的问题</span></span><br><span class="line"><span class="comment">// 这题的限制是给定的两个节点都存在树中</span></span><br><span class="line"><span class="comment">// 基本思想就是借助递归, 时刻牢记递归函数的定义, 并且毫不怀疑的使用它</span></span><br><span class="line"><span class="comment">// 这题中, lowestCommonAncestor 函数的定义就是, 接受一个根节点和两个在树中的其它节点</span></span><br><span class="line"><span class="comment">// 返回它们的 LCA</span></span><br><span class="line"><span class="comment">// 所以, 利用后序遍历, 先分别在当前节点的左右子树中找给定两个节点的 LCA</span></span><br><span class="line"><span class="comment">// 根据返回值判断寻找情况</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前节点为空, 肯定找不到 LCA 了</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// left 为左子树中的寻找情况</span></span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="comment">// right 为右子树中的寻找情况</span></span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 注意, 如果当前节点属于这两个节点之一</span></span><br><span class="line">    <span class="comment">// 意味着 当前节点就是它们的最低公共祖先啦</span></span><br><span class="line">    <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 如果在左子树中和右子树中都找到了一个 LCA</span></span><br><span class="line">    <span class="comment">// 同样的, 说明当前节点就是它们的 LCA</span></span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 否则, 返回在 以当前节点为根的子树 中给定节点的 LCA</span></span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1644-Lowest-Common-Ancestor-of-a-Binary-Tree-II"><a href="#1644-Lowest-Common-Ancestor-of-a-Binary-Tree-II" class="headerlink" title="1644. Lowest Common Ancestor of a Binary Tree II"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/" target="_blank" rel="noopener">1644. Lowest Common Ancestor of a Binary Tree II</a></h5><blockquote><p>给定一棵二叉树的根节点<code>root</code>，返回给定节点p和q的最近公共祖先（<code>LCA</code>）节点。如果<code>p</code>或<code>q</code>之一不存在于该二叉树中，返回<code>null</code>。</p><p><strong>Constraints:</strong></p><ol><li>所有<code>Node.val</code>互不相同</li><li><code>p != q</code></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题和 I 题不同之处在于</span></span><br><span class="line"><span class="comment">// 给定的两个节点可能不在树中</span></span><br><span class="line"><span class="comment">// 所以, 这里我们使用两个 flag</span></span><br><span class="line"><span class="comment">// 在后序遍历的同时, 标志给定的两个节点是否在树中</span></span><br><span class="line"><span class="comment">// 其余的逻辑和 I 题一样</span></span><br><span class="line"><span class="keyword">bool</span> pIsInTree = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> qIsInTree = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 辅助递归函数返回 LCA</span></span><br><span class="line">    res = helper(root, p, q);</span><br><span class="line">    <span class="comment">// 如果有任何一个节点不在树中, 返回 null</span></span><br><span class="line">    <span class="keyword">if</span>(!pIsInTree || !qIsInTree) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode* left = helper(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = helper(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 将上题中的 if(root == p || root == q) return root; 分开写就行了</span></span><br><span class="line">    <span class="keyword">if</span>(root == p)</span><br><span class="line">    &#123;</span><br><span class="line">        pIsInTree = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root == q)</span><br><span class="line">    &#123;</span><br><span class="line">       qIsInTree = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III"><a href="#1650-Lowest-Common-Ancestor-of-a-Binary-Tree-III" class="headerlink" title="1650. Lowest Common Ancestor of a Binary Tree III"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/" target="_blank" rel="noopener">1650. Lowest Common Ancestor of a Binary Tree III</a></h5><blockquote><p>给定一棵二叉树中的两个节点<code>p</code>和<code>q</code>，返回它们的最近公共祖先节点（<code>LCA</code>）。</p><p>每个节点都包含其父节点的引用（指针）。<code>Node</code>的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ol><li>所有<code>Node.val</code>互不相同</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code>均存在于给定的二叉树中。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题中的树的节点都有指向父亲的指针, 而且还说给定的两个节点还肯定存在</span></span><br><span class="line"><span class="comment">// 那就更简单了, 直接分别从给定的两个节点逐层向上找</span></span><br><span class="line"><span class="comment">// 借助一个哈希集合, 第一个节点向上找的过程中, 经过的每一个父节点都放进一个集合内</span></span><br><span class="line"><span class="comment">// 等第二个节点向上找的时候, 如果遇到已经在哈希集合中的父节点 (首个遇到的)</span></span><br><span class="line"><span class="comment">// 那就说明这个节点就是它们的 LCA 啦</span></span><br><span class="line"><span class="comment">// 和查找链表的交叉点的思路一样</span></span><br><span class="line"><span class="function">Node* <span class="title">lowestCommonAncestor</span><span class="params">(Node* p, Node* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;Node*&gt; setting;</span><br><span class="line">    <span class="comment">// p 先向上, 同样的自己也可以是自己的祖先</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 所以自己也得放进集合</span></span><br><span class="line">        setting.insert(p);</span><br><span class="line">        p = p-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已经在集合中了, 就是它!</span></span><br><span class="line">        <span class="keyword">if</span>(setting.count(q)) <span class="keyword">return</span> q;</span><br><span class="line">        setting.insert(q);</span><br><span class="line">        q = q-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1676-Lowest-Common-Ancestor-of-a-Binary-Tree-IV"><a href="#1676-Lowest-Common-Ancestor-of-a-Binary-Tree-IV" class="headerlink" title="1676. Lowest Common Ancestor of a Binary Tree IV"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/" target="_blank" rel="noopener">1676. Lowest Common Ancestor of a Binary Tree IV</a></h5><blockquote><p>给定一棵二叉树的根节点<code>root</code>和<code>TreeNode</code>类对象的数组（列表）<code>nodes</code>，返回<code>nodes</code>中所有节点的最近公共祖先（<code>LCA</code>）。数组（列表）中所有节点都存在于该二叉树中，且二叉树中所有节点的值都是互不相同的。</p><p><strong>Constraints:</strong></p><ol><li>所有的<code>Node.val</code>都是互不相同的。</li><li>所有的<code>nodes[i]</code>都存在于该树中。</li><li>所有的<code>nodes[i]</code>都是互不相同的。</li></ol><p><img src="binarytree.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 4 和 7 的最近公共祖先是 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [7,6,2,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 7、6、2 和 4 的最近公共祖先节点是 5。</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一题, 我笑了</span></span><br><span class="line"><span class="comment">// I 题是找两个节点的 LCA</span></span><br><span class="line"><span class="comment">// 这题找多个节点的, 思路完全一样</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; nodes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先将 nodes 中的节点们都放进一个哈希集合中</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; setting;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : nodes)</span><br><span class="line">        setting.insert(node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(root, setting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">unordered_set</span>&lt;TreeNode*&gt;&amp; setting)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode* left = dfs(root-&gt;left, setting);</span><br><span class="line">    TreeNode* right = dfs(root-&gt;right, setting);</span><br><span class="line">    <span class="comment">// 将 I 题中的 if(root == p || root == q) return root; 换个写法就行了</span></span><br><span class="line">    <span class="keyword">if</span>(setting.count(root)) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. Symmetric Tree</a></h5><blockquote><p>给定二叉树，请检查其是否是其自身的镜像（即围绕其中心对称）。</p><p><strong>Example:</strong></p><img src="symtree1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左右子树同步遍历</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果都为空, 显然对称</span></span><br><span class="line">    <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 此时两者必有不为 null 的</span></span><br><span class="line">    <span class="comment">// 就判断是否有为 null 的</span></span><br><span class="line">    <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 此时两者都不为 null</span></span><br><span class="line">    <span class="comment">// 就判断它们的值是否相等</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1372-Longest-ZigZag-Path-in-a-Binary-Tree"><a href="#1372-Longest-ZigZag-Path-in-a-Binary-Tree" class="headerlink" title="1372. Longest ZigZag Path in a Binary Tree"></a><a href="https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/" target="_blank" rel="noopener">1372. Longest ZigZag Path in a Binary Tree</a></h5><blockquote><p>给你一棵以<code>root</code>为根的二叉树，二叉树中的交错路径定义如下：</p><p>选择二叉树中任意节点和一个方向（左或者右）。<br>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。<br>改变前进方向：左变右或者右变左。<br>重复第二步和第三步，直到你在树中无法继续移动。<br>交错路径的长度定义为：访问过的节点数目 <code>- 1</code>（单个节点的路径长度为<code>0</code>）。</p><p>请你返回给定树中最长交错路径的长度。</p><table><thead><tr><th align="center">Example 1</th><th align="center">Example 2</th></tr></thead><tbody><tr><td align="center"><img src="sample_1_1702.png" alt="img" style="zoom:80%;" /></td><td align="center"><img src="sample_2_1702.png" alt="img"  /></td></tr></tbody></table><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,1,1,null,1,null,null,1,1,null,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right).</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归形式 1</span></span><br><span class="line"><span class="comment">// 0 表示方向向左</span></span><br><span class="line"><span class="comment">// 1 表示方向向右</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(root-&gt;left, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    helper(root-&gt;right, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">bool</span> dir, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    res = max(res, depth);</span><br><span class="line">    <span class="keyword">if</span>(dir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点是从右方向过来的</span></span><br><span class="line">        <span class="comment">// 之后就要转去左方向</span></span><br><span class="line">        helper(node-&gt;left, <span class="number">0</span>, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 同时还可以接着去右方向</span></span><br><span class="line">        <span class="comment">// 只不过深度要重新计算</span></span><br><span class="line">        helper(node-&gt;right, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点是从左方向过来的</span></span><br><span class="line">        <span class="comment">// 之后就要转去右方向</span></span><br><span class="line">        helper(node-&gt;right, <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 同时还可以接着去左方向</span></span><br><span class="line">        <span class="comment">// 只不过深度要重新计算</span></span><br><span class="line">        helper(node-&gt;left, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归形式 2</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">bool</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp_L = <span class="number">1</span> + helper(root-&gt;left, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp_R = <span class="number">1</span> + helper(root-&gt;right, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    res = max(res, tmp_L);</span><br><span class="line">    res = max(res, tmp_R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dir ? tmp_L : tmp_R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(root, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// helper(root, 1);</span></span><br><span class="line">    <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="173-Binary-Search-Tree-Iterator"><a href="#173-Binary-Search-Tree-Iterator" class="headerlink" title="173. Binary Search Tree Iterator"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">173. Binary Search Tree Iterator</a></h5><blockquote><p>  实现一个二叉搜索树迭代器类<code>BSTIterator</code>，表示一个按中序遍历二叉搜索树（<code>BST</code>）的迭代器：</p><p>  <code>BSTIterator(TreeNode* root)</code>初始化<code>BSTIterator</code>类的一个对象。<code>BST</code>的根节点<code>root</code>会作为构造函数的一部分给出。指针应初始化为一个不存在于<code>BST</code>中的数字，且该数字小于<code>BST</code>中的任何元素。</p><p>  <code>bool hasNext()</code>如果向指针右侧遍历存在数字，则返回<code>true</code>；否则返回<code>false</code>。<br>  <code>int next()</code>将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于<code>BST</code>中的数字，所以对<code>next()</code>的首次调用将返回<code>BST</code>中的最小元素。</p><p>  你可以假设<code>next()</code>调用总是有效的，也就是说，当调用<code>next()</code>时，<code>BST</code>的中序遍历中至少存在一个下一个数字。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题考察二叉树的中序遍历的迭代实现</span></span><br><span class="line"><span class="comment">// 只不过把循环分摊在每次调用 next 函数里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode* root) : _pointer(root) &#123;&#125;</span><br><span class="line">    <span class="comment">// 这段和是中序遍历的迭代式写法 while(1) 循环体里的代码完全一样</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(_pointer)</span><br><span class="line">        &#123;</span><br><span class="line">            _stack.push(_pointer);</span><br><span class="line">            _pointer = _pointer-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        _pointer = _stack.top();</span><br><span class="line">        <span class="keyword">int</span> val = _pointer-&gt;val;</span><br><span class="line">        _stack.pop();</span><br><span class="line"></span><br><span class="line">        _pointer = _pointer-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当 _pointer 为空并且 _stack 也为空的情况下</span></span><br><span class="line">        <span class="comment">// 才没有下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> _pointer || !_stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* _pointer;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; _stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题系列之链表</title>
      <link href="/S07PSuYxoZ6CPova/"/>
      <url>/S07PSuYxoZ6CPova/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是<code>leetcode</code>刷题系列的第<code>2</code>部分——链表，链表的大部分题目难度都不大。<code>leetcode</code>上链表部分的题目也就<code>40</code>道左右，基本上都做了，这里就把有代表性的题目发出来，共计<code>22</code>道。每道题都给出了注释，有的题目还给出了另一种思路和解法。</p><p>接下来这几个月，计划完成的<code>leetcode</code>刷题系列其组织如下：</p><p><code>1</code>. 数组</p><p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p><p><code>3</code>. 字符串</p><p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p><p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p><p><code>6</code>. 动态规划</p><p><code>7</code>. 数据结构设计</p><p>预计涉及题目至少<code>200</code>道！</p><a id="more"></a><h4 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a><code>Linked List</code></h4><h5 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse Linked List</a></h5><blockquote><p>给定一个单链表的头节点，反转链表，然后返回反转后的链表头节点。</p><img src="rev1ex1.jpg" alt="img" style="zoom:67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* q = p;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        q = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        p = head;</span><br><span class="line">        </span><br><span class="line">        head = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* q = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse Linked List II</a></h5><blockquote><p>给定一个单链表的头以及<code>left</code>和<code>right</code>两个整数，其中<code>left &lt;= right</code>，将链表中从<code>left</code>位置到<code>right</code>位置的节点反转，返回反转后的链表。</p><img src="rev2ex2.jpg" alt="img" style="zoom:67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 纯递归解法 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转整个链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* q = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转前 n 个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(--n &gt; <span class="number">0</span>) p = p-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ListNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* r = reverseList(head);</span><br><span class="line">    head-&gt;next = q;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>) <span class="keyword">return</span> reverseN(head, right);</span><br><span class="line">    </span><br><span class="line">    head-&gt;next = reverseBetween(head-&gt;next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 纯迭代解法 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转整个链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* q = p;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        q = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        p = head;</span><br><span class="line">        head = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转前 n 个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(--n &gt; <span class="number">0</span>) p = p-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ListNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode* r = reverseList(head);</span><br><span class="line">    head-&gt;next = q;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>) <span class="keyword">return</span> reverseN(head, right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算反转的实际节点数</span></span><br><span class="line">    <span class="keyword">int</span> n = right - left + <span class="number">1</span>;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    </span><br><span class="line">    left--;</span><br><span class="line">    <span class="keyword">while</span>(--left &gt; <span class="number">0</span>) p = p-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// p 现在指向第 left 个节点的前一个节点</span></span><br><span class="line">    p-&gt;next = reverseN(p-&gt;next, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. Reverse Nodes in k-Group</a></h5><blockquote><p>给你一个链表，每<code>k</code>个节点一组进行翻转，请你返回翻转后的链表。<code>k</code>是一个正整数，它的值小于或等于链表的长度。如果节点总数不是<code>k</code>的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：你可以设计一个只使用常数额外空间的算法来解决此问题吗？不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><table><thead><tr><th align="center">Example 1</th><th align="center">Example 2</th></tr></thead><tbody><tr><td align="center"><img src="reverse_ex1.jpg" alt="img"  /></td><td align="center"><img src="reverse_ex2.jpg" alt="img"></td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转整个链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* q = p;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        q = head-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">        p = head;</span><br><span class="line">        head = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转前 n 个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(--n &gt; <span class="number">0</span>) p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">    ListNode* q = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* r = reverseList(head);</span><br><span class="line">    head-&gt;next = q;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* q = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = k;</span><br><span class="line">    <span class="keyword">while</span>(--n &amp;&amp; q) q = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(!q) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="comment">// 这里先反转第一次是为了方便记录头节点</span></span><br><span class="line">    head = reverseN(head, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* r = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        q = r;</span><br><span class="line">        n = k;</span><br><span class="line">        <span class="keyword">while</span>(--n &amp;&amp; q) q = q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!q) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        p-&gt;next = reverseN(p-&gt;next, k);</span><br><span class="line"></span><br><span class="line">        p = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="382-Linked-List-Random-Node"><a href="#382-Linked-List-Random-Node" class="headerlink" title="382. Linked List Random Node"></a><a href="https://leetcode.com/problems/linked-list-random-node/" target="_blank" rel="noopener">382. Linked List Random Node</a></h5><blockquote><p>给定一个单链表，从链表随机返回一个节点的值。 每个节点必须具有相同的被选择概率。</p><p>如果链表很大并且你不知道其长度怎么办？你能在不使用额外空间的情况下有效解决此问题吗？</p><p>如果随机返回<code>k</code>个节点的值呢？</p><p><strong>水塘抽样算法</strong>：遇到第<code>i</code>个元素时，应该有<code>1/i</code>的概率选择该元素，<code>1 - 1/i</code>的概率保持原有的选择。</p><p><strong>证明</strong>：假设总共有<code>n</code>个元素，我们要的随机性无非就是每个元素被选择的概率都是<code>1/n</code> ，那么对于第<code>i</code>个元素，它被选择的概率就是：</p><img src="formula1.png" alt="img" style="zoom: 50%;" /><p>同理，如果要随机选择<code>k</code>个数，只要在第<code>i</code>个元素处以<code>k/i</code>的概率选择该元素，以<code>1 - k/i</code>的概率保持原有选择即可。</p><p><strong>证明</strong>：略。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns a random node's value. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = rand() % ++i;</span><br><span class="line">        <span class="comment">// j 等于 0 的概率就为 1/i</span></span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span>) res = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns k random node's value. */</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRandom</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 前 k 个值默认先选上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; head; i++, head = head-&gt;next)</span><br><span class="line">        res[i] = p-&gt;val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = rand() % ++i;</span><br><span class="line">        <span class="comment">// j 小于 k 的概率就为 k/i</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; k) res[j] = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. Add Two Numbers</a></h5><blockquote><p>给定两个表示两个非负整数的非空链表。 这些数字以相反的顺序存储，即低位数在前，并且它们的每个节点都包含一个数字。 将两个数字相加并返回总和作为链接列表。</p><img src="addtwonumber1.jpg" alt="img" style="zoom: 67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* p, ListNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode head;</span><br><span class="line">    ListNode* last = &amp;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = p-&gt;val + q-&gt;val + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        last-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = p-&gt;val + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        last-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = q-&gt;val + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        last-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后别忘了可能还有近位</span></span><br><span class="line">    <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) last-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="445-Add-Two-Numbers-II"><a href="#445-Add-Two-Numbers-II" class="headerlink" title="445. Add Two Numbers II"></a><a href="https://leetcode.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. Add Two Numbers II</a></h5><blockquote><p>给定两个表示两个非负整数的非空链表。 高位数字在前，并且它们的每个节点都包含一个数字。 将两个数字相加，然后将其作为链表返回。</p><p>如果无法修改输入列表怎么办？ 换句话说，不允许反转列表。</p><p><code>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code><br><code>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助栈后进先出的特性即可</span></span><br><span class="line"><span class="comment">// 只不过插入新节点的时候注意插在头部</span></span><br><span class="line"><span class="comment">// 另外将外面的两个 while 循环拿进去, 减少重复代码, 更优美</span></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* p, ListNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;ListNode*&gt; pStack, qStack;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        pStack.push(p);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        qStack.push(q);</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pStack.empty() || !qStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!pStack.empty() &amp;&amp; !qStack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sum = pStack.top()-&gt;val + qStack.top()-&gt;val + carry;</span><br><span class="line">            pStack.pop();</span><br><span class="line">            qStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!pStack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            sum = pStack.top()-&gt;val + carry;</span><br><span class="line">            pStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum = qStack.top()-&gt;val + carry;</span><br><span class="line">            qStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 插入时, 插在头部</span></span><br><span class="line">        head = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后别忘了可能还有近位</span></span><br><span class="line">    <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) head = <span class="keyword">new</span> ListNode(carry, head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1721-Swapping-Nodes-in-a-Linked-List"><a href="#1721-Swapping-Nodes-in-a-Linked-List" class="headerlink" title="1721. Swapping Nodes in a Linked List"></a><a href="https://leetcode.com/problems/swapping-nodes-in-a-linked-list/" target="_blank" rel="noopener">1721. Swapping Nodes in a Linked List</a></h5><blockquote><p>给定一个链表的头以及一个整数<code>k</code>。将从头开始第<code>k</code>个节点的值与从结尾开始第<code>k</code>个节点的值交换，返回链表的头。</p><p><code>Input: head = [1, 2, 3, 4, 5], k = 2</code><br><code>Output: [1, 4, 3, 2, 5]</code></p><img src="linked1.jpg" alt="img" style="zoom:67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左右双指针的解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">swapNodes</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* left = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(--k) p = p-&gt;next;</span><br><span class="line">    <span class="comment">// 此时 left 指向从左边数第 k 个节点</span></span><br><span class="line">    left = p;</span><br><span class="line">    </span><br><span class="line">    ListNode* right = head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        right = right-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 right 指向从右边数边第 k 个节点</span></span><br><span class="line">    </span><br><span class="line">    swap(left-&gt;val, right-&gt;val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="109. Convert Sorted List to Binary Search Tree"></a><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. Convert Sorted List to Binary Search Tree</a></h5><blockquote><p>给定一个单链表的头，其中元素按升序排序，请将其转换为高度平衡的<code>BST</code>。结果不唯一。</p><p>在此处，高度平衡的二叉树定义为这样一棵二叉树，其中每个节点的两个子树的深度相差不超过<code>1</code>。</p><img src="linked.jpg" alt="img" style="zoom: 50%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本思想是将链表的左半部分节点作为 BST 的左子树, 右半部分节点作为 BST 的右子树,</span></span><br><span class="line"><span class="comment">// 然后进行递归调用就可以了, 每次只需要处理中间节点即可</span></span><br><span class="line"><span class="comment">// 这样可保证 BST 是高度平衡的</span></span><br><span class="line"><span class="comment">// 同样的, 如果给的是有序数组, 也可以利用将中间元素构造成根节点的递归思路</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(!head-&gt;next) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head-&gt;val);</span><br><span class="line">    <span class="comment">// 先定位到链表的中间节点</span></span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* preSlow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        preSlow = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 slow 指向中间节点, preSlow 指向其前一节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将左半部分子链表分离</span></span><br><span class="line">    preSlow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 将中间节点构建成 BST 的根节点</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">    root-&gt;left = sortedListToBST(head);</span><br><span class="line">    root-&gt;right = sortedListToBST(slow-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. Linked List Cycle</a></h5><blockquote><p>给定链表的头节点，确定链表中是否有环。如果链表中有一个循环，则返回<code>true</code>。 否则，返回<code>false</code>。</p><img src="circularlinkedlist.png" alt="img" style="zoom:67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 慢指针每次走一步</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="comment">// 快指针每次走两步</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 如果相遇就有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. Linked List Cycle II</a></h5><blockquote><p>给定一个链表头节点，返回环开始的节点。 如果没有环，则返回<code>null</code>。</p><p>第一次相遇时，假设慢指针<code>slow</code>走了<code>k</code>步，那么快指针<code>fast</code>一定走了<code>2k</code>步：</p><img src="3.jpeg" alt="img" style="zoom: 33%;" /><p><code>fast</code>一定比<code>slow</code>多走了<code>k</code>步，这多走的<code>k</code>步其实就是<code>fast</code>指针在环里转圈圈，所以<code>k</code>的值就是环长度的「整数倍」。设相遇点距环的起点的距离为<code>m</code>，那么环的起点距头结点<code>head</code>的距离为<code>k - m</code>，也就是说如果从<code>head</code>前进<code>k - m</code>步就能到达环起点。</p><p>巧的是，如果从相遇点继续前进<code>k - m</code>步，也恰好到达环起点。你甭管<code>fast</code>在环里到底转了几圈，反正走<code>k</code>步可以到相遇点，那走<code>k - m</code>步一定就是走到环起点了：</p><img src="2.jpeg" alt="img" style="zoom: 33%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是因为相遇才出循环的</span></span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="876-Middle-of-the-Linked-List"><a href="#876-Middle-of-the-Linked-List" class="headerlink" title="876. Middle of the Linked List"></a><a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. Middle of the Linked List</a></h5><blockquote><p>给定一个链表头节点，返回链表的中间节点。</p><p>可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。当链表的长度是奇数时，<code>slow</code>恰巧停在中点位置；如果长度是偶数，<code>slow</code>最终的位置是中间偏右。</p><img src="center.png" alt="img" style="zoom: 50%;" /><p><strong>链表的归并排序</strong>：对于链表，合并两个有序链表是很简单的，难点就在于二分。但是现在知道了找到链表的中点的方法，就能实现链表的二分了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="comment">// 节点个数为偶数时, 返回指向中间两个节点的第二个节点</span></span><br><span class="line"><span class="comment">// 为奇数时返回指向中间的节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本二, 在写链表的归并排序时, 要用这个版本!</span></span><br><span class="line"><span class="comment">// 节点个数为偶数时, 返回指向中间两个节点的第一个节点</span></span><br><span class="line"><span class="comment">// 为奇数时返回指向中间的节点的前一个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* slow = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow ? slow-&gt;next : head;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a></h5><blockquote><p>给定一个链表，删除链表的倒数第<code>n</code>个节点，并且返回链表的头结点。</p><p><strong>Example:</strong></p><img src="remove_ex1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">&gt;Output: [1,2,3,5]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fast) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. Intersection of Two Linked Lists</a></h5><blockquote><p>给定两个单链列表<code>headA</code>和<code>headB</code>的头，返回两个列表相交的节点。 如果两个链接列表完全没有交集，则返回<code>null</code>。</p><p>例如，以下两个链接列表开始在节点<code>c1</code>处相交：</p><img src="160_statement.png" alt="img" style="zoom:80%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先制造出一个环来, 再借助前面讲过的返回环起点的思路</span></span><br><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* p = headA;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next) p = p-&gt;next;</span><br><span class="line">    <span class="comment">// 将 A 链表的首尾相连成环</span></span><br><span class="line">    p-&gt;next = headA;</span><br><span class="line"></span><br><span class="line">    ListNode* slow = headB;</span><br><span class="line">    ListNode* fast = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有相遇, 说明原先不存在交点</span></span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    slow = headB;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后别忘了恢复链表 A</span></span><br><span class="line">    p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a><a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">328. Odd Even Linked List</a></h5><blockquote><p>给定一个单链列表的头，将所有具有奇数索引的节点组合在一起，然后再加上具有偶数索引的节点，然后返回重新排序的列表。</p><p>第一个节点被认为是奇数，第二个节点被认为是偶数，依此类推。请注意，偶数和奇数组中的相对顺序应保持输入中的原样。</p><img src="oddeven2-linked-list.jpg" alt="img" style="zoom:80%;" /><p>Could you solve it in <code>O(1)</code> space complexity and <code>O(nodes)</code> time complexity?</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0, 1, 2 个节点直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next || !head-&gt;next-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    ListNode* q = head-&gt;next;</span><br><span class="line"></span><br><span class="line">    ListNode* r = q;</span><br><span class="line">    <span class="keyword">while</span>(q &amp;&amp; q-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        q-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p-&gt;next = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List</a></h5><blockquote><p>给定一个单链表的头节点，如果它是回文链表，则返回<code>true</code>。例如，下面这个就为回文链表：</p><p><img src="pal1linked-list.jpg" alt="img"></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表的后序遍历结合左右指针</span></span><br><span class="line"><span class="comment">// 利用系统栈来后进先出节点</span></span><br><span class="line">ListNode* left = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">return</span> traverse(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">traverse</span><span class="params">(ListNode* right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> res = traverse(right-&gt;next);</span><br><span class="line">    res = res &amp;&amp; (left-&gt;val == right-&gt;val);</span><br><span class="line">    <span class="comment">// 左指针前进</span></span><br><span class="line">    left = left-&gt;next;</span><br><span class="line">    <span class="comment">// 结束一个递归实例后, 右指针会自动后退</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到链表的中间节点</span></span><br><span class="line"><span class="comment">// 再将后半部分链表反转, 判断</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* q = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="comment">// 用于恢复被破坏结构的后半部分链表头节点的前一个节点</span></span><br><span class="line">    ListNode* preSlow = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        preSlow = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast)</span><br><span class="line">    &#123;</span><br><span class="line">        preSlow = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此后 slow 可以用于恢复被破坏结构的原链表</span></span><br><span class="line">    ListNode* slow = reverseList(slow);</span><br><span class="line">    ListNode* last = slow;</span><br><span class="line">    <span class="keyword">while</span>(last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(last-&gt;val != head-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            preSlow-&gt;next = reverseList(slow);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    preSlow-&gt;next = reverseList(slow);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists</a></h5><blockquote><p>合并两个有序的链表，并将合并结果作为有序链表返回。</p><img src="merge_ex1.jpg" alt="img" style="zoom: 67%;" /></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* p, ListNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 辅助节点</span></span><br><span class="line">    ListNode head;</span><br><span class="line">    ListNode* last = &amp;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt;= q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            last-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            last-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p) last-&gt;next = p;</span><br><span class="line">    <span class="keyword">if</span>(q) last-&gt;next = q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* p, ListNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">if</span>(!q) <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val &lt;= q-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        head = p;</span><br><span class="line">        head-&gt;next = mergeTwoLists(p-&gt;next, q);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    head = q;</span><br><span class="line">    head-&gt;next = mergeTwoLists(p, q-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. Merge k Sorted Lists</a></h5><blockquote><p>给定一个由<code>k</code>个链表头节点所组成的数组，每个链表以升序排列。将所有链表合并为一个排序的链表，然后将其返回。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[</span><br><span class="line">1-&gt;4-&gt;5,</span><br><span class="line">1-&gt;3-&gt;4,</span><br><span class="line">2-&gt;6</span><br><span class="line">]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将这 k 个头节点交给优先级队列管理</span></span><br><span class="line"><span class="comment">// 优先级队列采用最小堆, 以节点内的值为排序对象</span></span><br><span class="line"><span class="comment">// 这样每次 pop 的时候保证总是全局所有节点中最小的节点出队</span></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// C++ 中提供的 priority_queue 默认采用最大堆, 这里需要定制成最小堆</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](ListNode* a, ListNode* b) &#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq(cmp);</span><br><span class="line">    <span class="comment">// 所有头节点移交给 priority_queue 管理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.size(); i++)</span><br><span class="line">        <span class="keyword">if</span>(lists[i]) pq.push(lists[i]);</span><br><span class="line">    <span class="comment">// 辅助节点</span></span><br><span class="line">    ListNode heade;</span><br><span class="line">    ListNode* p = &amp;head;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次将全局最小节点入链出队</span></span><br><span class="line">        p-&gt;next = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="comment">// 放进去的将是最近入链出队的节点的下一个节点</span></span><br><span class="line">        <span class="comment">// 这样才能保证在队列中的是全局最小的 k 个节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next) pq.push(p-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="430-Flatten-a-Multilevel-Doubly-Linked-List"><a href="#430-Flatten-a-Multilevel-Doubly-Linked-List" class="headerlink" title="430. Flatten a Multilevel Doubly Linked List"></a><a href="https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/" target="_blank" rel="noopener">430. Flatten a Multilevel Doubly Linked List</a></h5><blockquote><p>给定一个双向链表，该链表除了拥有指向下一个节点和上一个节点的指针外，还具有一个孩子指针，该孩子指针可能指向也可能不指向单独的双向链接列表。 这些子链表可能有一个或多个自己的子链表，依此类推，以产生一个多级数据结构，如下面的示例所示：</p><p><img src="multilevellinkedlist.png" alt="img"></p><p>展平链表，以便所有节点都出现在单级双链表中。 返回链表的头。</p><p><img src="multilevellinkedlistflattened.png" alt="img"></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">// class Node</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     Node* prev;</span></span><br><span class="line"><span class="comment">//     Node* next;</span></span><br><span class="line"><span class="comment">//     Node* child;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将题目中的孩子节点看做左孩子, 下一节点看作右孩子</span></span><br><span class="line"><span class="function">Node* <span class="title">flatten</span><span class="params">(Node* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="comment">// 初始化辅助节点</span></span><br><span class="line">    Node head;</span><br><span class="line">    head.prev = <span class="literal">nullptr</span>;</span><br><span class="line">    head.next = <span class="literal">nullptr</span>;</span><br><span class="line">    head.child = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Node* q = head;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; nodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接纳新节点</span></span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        p-&gt;prev = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;child)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 有左孩子就将其下一节点压入栈</span></span><br><span class="line">            <span class="comment">// 并前进到左孩子</span></span><br><span class="line">            Node* temp = p;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next) nodes.push(p-&gt;next);</span><br><span class="line">            p = p-&gt;child;</span><br><span class="line">            <span class="comment">// 将此节点的左孩子指针置空</span></span><br><span class="line">            temp-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next; <span class="comment">// 没有左孩子就直接前进到下一节点 (右孩子)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果既没有左孩子也没有右孩子</span></span><br><span class="line">        <span class="comment">// 就从栈中取下一节点</span></span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.empty()) <span class="keyword">break</span>;</span><br><span class="line">            p = nodes.top();</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a><a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="noopener">61. Rotate List</a></h5><blockquote><p>给定一个单链表的头节点，将链表向右旋转<code>k</code>个位置。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">Output: [4,5,1,2,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [0,1,2], k &#x3D; 4</span><br><span class="line">Output: [2,0,1]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Example 1</th><th align="center">Example 2</th></tr></thead><tbody><tr><td align="center"><img src="rotate1.jpg" alt="img" style="zoom: 67%;" /></td><td align="center"><img src="roate2.jpg" alt="img" style="zoom: 67%;" /></td></tr></tbody></table></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要注意到:</span></span><br><span class="line"><span class="comment">// 1. 旋转了几次, 就会有末尾的几个节点整体次序不变的被平移到前面</span></span><br><span class="line"><span class="comment">// 2. 如果旋转了链表长度的倍数次, 链表将恢复原样</span></span><br><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先获取链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算实际旋转的次数</span></span><br><span class="line">    k = k % count;</span><br><span class="line">    <span class="comment">// 如果待旋转次数为链表长度的倍数, 不需要旋转</span></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算新的头节点为第几个节点</span></span><br><span class="line">    k = count - k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 q 定位到新的头节点的前一个节点</span></span><br><span class="line">    ListNode* q = head;</span><br><span class="line">    <span class="keyword">while</span>(--k) q = q-&gt;next;</span><br><span class="line">    <span class="comment">// start 为新的头节点</span></span><br><span class="line">    ListNode* start = q-&gt;next;</span><br><span class="line">    <span class="comment">// 前后接在一块即可</span></span><br><span class="line">    q-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. Copy List with Random Pointer</a></h5><blockquote><p>  给你一个长度为<code>n</code>的链表，每个节点包含一个额外增加的随机指针<code>random</code>，该指针可以指向链表中的任何节点或空节点。</p><p>  构造这个链表的深拷贝。 深拷贝应该正好由<code>n</code>个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code>指针和<code>random</code>指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>  例如，如果原链表中有<code>X</code>和<code>Y</code>两个节点，其中<code>X.random --&gt; Y</code>。那么在复制链表中对应的两个节点<code>x</code>和<code>y</code>，同样有<code>x.random --&gt; y</code>。</p><p>  返回复制链表的头节点。</p><p>  用一个由<code>n</code>个节点组成的链表来表示输入/输出中的链表。每个节点用一个<code>[val, random_index]</code>表示：</p><p>  <code>val</code>：一个表示<code>Node.val</code>的整数。<br>  <code>random_index</code>：随机指针指向的节点索引（范围从<code>0</code>到<code>n - 1</code>）；如果不指向任何节点，则为<code>null</code>。<br>  你的代码只接受原链表的头节点<code>head</code>作为传入参数。</p><p>  <strong>Example 1:</strong></p><p>  <strong><img src="e3.png" alt="img" style="zoom:50%;" /></strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">Output: [[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <img src="e1.png" alt="img" style="zoom: 50%;" />  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">// class Node</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     Node *next;</span></span><br><span class="line"><span class="comment">//     Node *random;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     Node(int _val)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         val = _val;</span></span><br><span class="line"><span class="comment">//         next = NULL;</span></span><br><span class="line"><span class="comment">//         random = NULL;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接从头节点通过 next 指针, 向后一个一个遍历就可以了</span></span><br><span class="line"><span class="comment">// 先拷贝当前节点, 在判断当前节点的 random 指针是否为空</span></span><br><span class="line"><span class="comment">// 如果为空, 直接跳到下一个节点就可以了</span></span><br><span class="line"><span class="comment">// 如果不为空, 那就将 random 节点 new 一份</span></span><br><span class="line"><span class="comment">// 注意当前节点的 random 节点可能已经遍历过或者啊还没有遍历</span></span><br><span class="line"><span class="comment">// 1. 如果已经遍历过, 此时只需要将当前节点的拷贝节点的 random 指向它就可以了</span></span><br><span class="line"><span class="comment">// 那么我们怎么获取已经遍历过的节点的拷贝节点的指针呢？</span></span><br><span class="line"><span class="comment">// 2. 如果没有被遍历过, 直接 new 出来, 再将当前节点的拷贝节点的 random 指向它就行</span></span><br><span class="line"><span class="comment">// 但是, 下次通过 next 指针遍历到它的时候, 不能再 new 了, 因为它已经存在了</span></span><br><span class="line"><span class="comment">// 解决这个问题的方法就是借助哈希表在遍历的过程中记录当前节点和其拷贝节点之间的映射</span></span><br><span class="line"><span class="comment">// 这样在每次遍历新节点的时候先判断是否已经被 new 出来过了</span></span><br><span class="line"><span class="comment">// 下面直接看代码吧, 有详细注释</span></span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录节点与其拷贝节点之间的映射</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; mapping;</span><br><span class="line">    <span class="comment">// 辅助节点, 方便插入新节点和最后返回</span></span><br><span class="line">    <span class="function">Node <span class="title">helper</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// last 之后一直指向新链表的尾节点</span></span><br><span class="line">    Node* last = &amp;helper;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点的辅助节点已经被 new 过了</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(head))</span><br><span class="line">            <span class="comment">// 直接将映射值接在后面就行了</span></span><br><span class="line">            last-&gt;next = mapping[head];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果没有, 需要重新 new 一个</span></span><br><span class="line">            last-&gt;next = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">            <span class="comment">// 之后添加当前节点和被拷贝节点的映射</span></span><br><span class="line">        mapping[head] = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点指向了一个随机节点</span></span><br><span class="line">        <span class="comment">// 就要为它的拷贝节点也要指向一个随机节点</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;random)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果这个随机节点已经 new  过了</span></span><br><span class="line">            <span class="keyword">if</span>(mapping.count(head-&gt;random))</span><br><span class="line">                last-&gt;next-&gt;random = mapping[head-&gt;random];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 否则新 new 一个并添加映射</span></span><br><span class="line">            last-&gt;next-&gt;random = <span class="keyword">new</span> Node(head-&gt;random-&gt;val);</span><br><span class="line">            mapping[head-&gt;random] = last-&gt;next-&gt;random;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新旧链表当前节点指针同步前进一步</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1019-Next-Greater-Node-In-Linked-List"><a href="#1019-Next-Greater-Node-In-Linked-List" class="headerlink" title="1019. Next Greater Node In Linked List"></a><a href="https://leetcode.com/problems/next-greater-node-in-linked-list/" target="_blank" rel="noopener">1019. Next Greater Node In Linked List</a></h5><blockquote><p>  给出一个以头节点<code>head</code>作为第一个节点的链表。链表中的节点分别编号为：<code>node_1, node_2, node_3, ...</code> 。</p><p>  每个节点都可能有下一个更大值（<code>next larger value</code>）：对于<code>node_i</code>，如果其<code>next_larger(node_i)</code>是<code>node_j.val</code>，那么就有<code>j &gt; i</code>且<code>node_j.val &gt; node_i.val</code>，而<code>j</code>是可能的选项中最小的那个。如果不存在这样的<code>j</code>，那么下一个更大值为<code>0</code>。</p><p>  <strong>Example 1:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5]</span><br><span class="line">Output: [5,5,0]</span><br></pre></td></tr></table></figure><p>  <strong>Example 2:</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,4,3,5]</span><br><span class="line">Output: [7,0,5,5,0]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 像这种下一个最大元素之类的问题, 一定用的是单调栈的技巧</span></span><br><span class="line"><span class="comment">// 有几道数组的题目是找下一个最大元素</span></span><br><span class="line"><span class="comment">// 这里给换成了链表了, 换汤不换药</span></span><br><span class="line"><span class="comment">// 这里主要学习的技术是链表的后序遍历</span></span><br><span class="line"><span class="comment">// 对的, 链表就是一种特殊的二叉树嘛</span></span><br><span class="line"><span class="comment">// 链表的后序遍历就是从后向前访问节点</span></span><br><span class="line"><span class="comment">// 你当然可以用栈来完成</span></span><br><span class="line"><span class="comment">// 这里用递归完成</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 存放答案的向量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    helper(head, s, res);</span><br><span class="line">    <span class="comment">// 最后需要反转一下 vector</span></span><br><span class="line">    <span class="comment">// 因为递归函数是从后向前添加的</span></span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(ListNode* head, <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&amp; s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 先不访问节点, 递归去下一个节点</span></span><br><span class="line">    helper(head-&gt;next, s, res);</span><br><span class="line">    <span class="comment">// 后序遍历代码</span></span><br><span class="line">    <span class="comment">// 下面代码都是固定的单调栈算法的模板</span></span><br><span class="line">    <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt;= head-&gt;val)</span><br><span class="line">        s.pop();</span><br><span class="line">    res.push_back(s.empty() ? <span class="number">0</span> : s.top());</span><br><span class="line">    s.push(head-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a><a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">148. Sort List</a></h5><blockquote><p>  链表的排序。这里分别给出归并排序的递归版、迭代版以及快速排序版本。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序, 递归解法</span></span><br><span class="line"><span class="comment">// T: O(nlogn), S: O(logn)</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* mid = getMid(head);</span><br><span class="line">    ListNode* head1 = mid-&gt;next;</span><br><span class="line">    mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(sortList(head), sortList(head1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 这里的 bug 是如果链表的长度为 2</span></span><br><span class="line"><span class="comment">// // 永远返回的是指向第 2 个元素的指针</span></span><br><span class="line"><span class="comment">// // 对这个链表的归并排序将永远循环下去!</span></span><br><span class="line"><span class="comment">// // tmd 卡了我半天, 艹!</span></span><br><span class="line"><span class="comment">// ListNode* getMid(ListNode* head)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     ListNode* slow = head;</span></span><br><span class="line"><span class="comment">//     ListNode* fast = head;</span></span><br><span class="line"><span class="comment">//     while(fast &amp;&amp; fast-&gt;next)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         slow = slow-&gt;next;</span></span><br><span class="line"><span class="comment">//         fast = fast-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return slow;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是修正后的版本</span></span><br><span class="line"><span class="function">ListNode* <span class="title">getMid</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* slow = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow ? slow-&gt;next : head;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* p, ListNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode helper;</span><br><span class="line">    ListNode* last = &amp;helper;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            last-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            last-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last-&gt;next = p ? p : q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序, 迭代解法</span></span><br><span class="line"><span class="comment">// T: O(n + nlogn), S: O(1)</span></span><br><span class="line"><span class="comment">// nextSublist 始终指向后续待归并的链表的头节点</span></span><br><span class="line">ListNode* nextSublist = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// tail 始终指向已经归并好的局部子链表的尾节点</span></span><br><span class="line">ListNode* tail = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = sizeOfList(head);</span><br><span class="line">    <span class="comment">// 辅助头节点</span></span><br><span class="line">    ListNode helper;</span><br><span class="line">    helper.next = head;</span><br><span class="line">    <span class="comment">// 从长度为 1 开始, 每次成倍增长地归并子链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i *= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* start = &amp;helper;</span><br><span class="line">        nextSublist = helper.next;</span><br><span class="line">        <span class="keyword">while</span>(nextSublist)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 划出 i 个有序节点组成一个链表</span></span><br><span class="line">            ListNode* list1 = split(nextSublist, i);</span><br><span class="line">            <span class="comment">// 再划出 i 个有序节点组成一个链表</span></span><br><span class="line">            ListNode* list2 = split(nextSublist, i);</span><br><span class="line">            <span class="comment">// 将这划分出来的两个相邻有序链表合并</span></span><br><span class="line">            start-&gt;next = merge(list1, list2);</span><br><span class="line">            start = tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 head 链表前面划出 size 长度的子链表出来</span></span><br><span class="line"><span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode* head, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(--size &gt; <span class="number">0</span> &amp;&amp; p)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里说明 size 小于 head 链表的长度</span></span><br><span class="line">        <span class="comment">// 现在 p 指向被划出来链表的尾节点</span></span><br><span class="line">        nextSublist = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果 size 大于 head 链表的长度</span></span><br><span class="line">    <span class="comment">// 说明已经有序了</span></span><br><span class="line">        nextSublist = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个有序链表, 和递归版本的没区别</span></span><br><span class="line"><span class="comment">// 主要是要更新 tail 指针</span></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* p, ListNode* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode helper;</span><br><span class="line">    ListNode* last = &amp;helper;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            last-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            last-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    last-&gt;next = p ? p : q;</span><br><span class="line">    <span class="comment">// 更新 tail 指针, 使其指向这被合并完成的有序链表的尾节点</span></span><br><span class="line">    tail = last;</span><br><span class="line">    <span class="keyword">while</span>(last-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        tail = last-&gt;next;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sizeOfList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; head; head = head-&gt;next, ++size);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序版本, 最差时间复杂度为 O(n2), 会 Time limit exceeded!</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> quickSort(head, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个左闭右开区间 [head, end)</span></span><br><span class="line"><span class="function">ListNode* <span class="title">quickSort</span><span class="params">(ListNode* head, ListNode* end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(head == end || head-&gt;next == end) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取首节点元素为基准值</span></span><br><span class="line">    <span class="comment">// 凡小于此值的节点以头插法插入到左边</span></span><br><span class="line">    <span class="comment">// 凡大于此值的节点以尾插法插入到右边</span></span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    ListNode* q = head-&gt;next;</span><br><span class="line">    ListNode* tail = p;</span><br><span class="line">    <span class="keyword">while</span>(q != end)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* next = q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;val &lt; p-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 头插法</span></span><br><span class="line">            q-&gt;next = head;</span><br><span class="line">            head = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 尾插法</span></span><br><span class="line">            tail-&gt;next = q;</span><br><span class="line">            tail = q;</span><br><span class="line">        &#125;</span><br><span class="line">        q = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这行很重要, tail 一直指向右边链表的尾节点</span></span><br><span class="line">    <span class="comment">// 要把开区间的之后的节点们接到它后面</span></span><br><span class="line">    tail-&gt;next = end;</span><br><span class="line">    <span class="comment">// 此时, head 指向新链表的头节点</span></span><br><span class="line">    <span class="comment">// p 指向新链表的基准节点, 以基准节点作为右边链表的开区间尾元素进行下一次递归调用</span></span><br><span class="line">    ListNode* newHead = quickSort(head, p);</span><br><span class="line">    <span class="comment">// 跳过已经归位的基准节点</span></span><br><span class="line">    p-&gt;next = quickSort(p-&gt;next, end);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识C++内存管理的工具 （三）</title>
      <link href="/gMOP9F0b8zMZULMj/"/>
      <url>/gMOP9F0b8zMZULMj/</url>
      
        <content type="html"><![CDATA[<h4 id="13-重载类本身的operator-new-delete"><a href="#13-重载类本身的operator-new-delete" class="headerlink" title="13. 重载类本身的operator new/delete"></a><code>13</code>. 重载类本身的<code>operator new/delete</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A() : this:"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A(): this: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数写不写 static 都会被编译器做成 static</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用 A::operator new 版本</span></span><br><span class="line">    A* a = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用全局的 operator new, 如果想调用 A 的版本, 则需显式调用 A::operator new()</span></span><br><span class="line">    <span class="keyword">void</span>* b = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(A));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    A* c = ::<span class="keyword">new</span> A();       <span class="comment">// 调用全局的 operator new</span></span><br><span class="line">    <span class="keyword">void</span>* d = ::<span class="keyword">new</span> A();    <span class="comment">// 调用全局的 operator new</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> a;   <span class="comment">// 先调用 A 的析构函数, 再调用 A 的 operator delete</span></span><br><span class="line">    <span class="keyword">delete</span> b;   <span class="comment">// 直接调用了全局的 operator delete</span></span><br><span class="line">    ::<span class="keyword">delete</span> c;</span><br><span class="line">    ::<span class="keyword">delete</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="image-20210316211007882.png" alt="image-20210316211007882"></p><h4 id="14-本质就是重载new"><a href="#14-本质就是重载new" class="headerlink" title="14. 本质就是重载new"></a><code>14</code>. 本质就是重载<code>new</code></h4><p><code>new</code>是关键字，编译器看到<code>new</code>，会转换成<code>operator new</code>的调用。</p><p><img src="image-20210316211821850.png" alt="image-20210316211821850"></p><p><img src="image-20210316211849406.png" alt="image-20210316211849406"></p><p><img src="image-20210316211942624.png" alt="image-20210316211942624"></p><h4 id="15-重载new-delete"><a href="#15-重载new-delete" class="headerlink" title="15. 重载new()/delete()"></a><code>15</code>. 重载<code>new()/delete()</code></h4><p><img src="image-20210316212107044.png" alt="image-20210316212107044"></p><p><img src="image-20210316212317475.png" alt="image-20210316212317475"></p><h4 id="16-关于多参new对应的delete"><a href="#16-关于多参new对应的delete" class="headerlink" title="16. 关于多参new对应的delete"></a><code>16</code>. 关于多参<code>new</code>对应的<code>delete</code></h4><p><img src="image-20210316212449598.png" alt="image-20210316212449598"></p><ul><li><p>上面重载了参数不一的<code>operator new()</code>，那是不是要重载对应的<code>operator delete()</code>呢？</p><p>  理论上<code>delete</code>的工作只是为了释放内存，所以只需要一个指针就可以了，但<code>C++</code>在语法上支持多参的<code>delete</code>重载，但<code>delete</code>的调用格式只有<code>delete ptr</code>，所以关于重载的<code>delete</code>版本什么时候被调用，并不是用户手动调用，而是对应版本的<code>Ctor</code>发生异常后，会由<code>crt</code>来调用对应的<code>delete</code>。</p></li></ul><h4 id="17-basic-string使用new-extra-扩充申请量"><a href="#17-basic-string使用new-extra-扩充申请量" class="headerlink" title="17. basic_string使用new(extra)扩充申请量"></a><code>17</code>. <code>basic_string</code>使用<code>new(extra)</code>扩充申请量</h4><p><img src="image-20210316214052184.png" alt="image-20210316214052184"></p><h4 id="18-new-handler"><a href="#18-new-handler" class="headerlink" title="18. new_handler"></a><code>18</code>. <code>new_handler</code></h4><p><img src="image-20210317210723036.png" alt="image-20210317210723036"></p><p><img src="image-20210317211006818.png" alt="image-20210317211006818"></p><p><img src="image-20210317211425498.png" alt="image-20210317211425498"></p><p><img src="image-20210317211445418.png" alt="image-20210317211445418"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识C++内存管理的工具 （二）</title>
      <link href="/vgFO35JETZ2jRu74/"/>
      <url>/vgFO35JETZ2jRu74/</url>
      
        <content type="html"><![CDATA[<h4 id="7-构造和析构的直接调用方式"><a href="#7-构造和析构的直接调用方式" class="headerlink" title="7. 构造和析构的直接调用方式"></a><code>7</code>. 构造和析构的直接调用方式</h4><p>通过指针不可以直接调用构造函数，但可以直接调用析构函数。可以通过<code>placement new</code>来直接调用构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) : a(_a), b(_b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* tmp_a = <span class="keyword">new</span> A(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// tmp-&gt;A::A(2, 8); // error! cannot call constructor 'A::A' directly</span></span><br><span class="line">    tmp_a-&gt;~A(); <span class="comment">// 可以的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然调用了析构函数, 但事实上 tmp_a 的空间并没有释放</span></span><br><span class="line">    <span class="comment">// 因为没有 free 掉, 那块内存还在, 值没有被重写</span></span><br><span class="line">    <span class="comment">// 所以可以访问 通过 tmp_a 访问原对象的值</span></span><br><span class="line">    <span class="comment">// 如果是 delete tmp_a; 就不能访问</span></span><br><span class="line">    <span class="comment">// 因为 delete 调用完析构函数之后, 还调用了 free 函数释放那块内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tmp_a-&gt;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 所有这里访问的值看似没有变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="8-array-new-delete"><a href="#8-array-new-delete" class="headerlink" title="8. array new/delete"></a><code>8</code>. <code>array new/delete</code></h4><p><code>new []/delete[]</code>本质调用<code>malloc/free</code>。<code>malloc/free</code>细节：</p><ul><li><p>除了分配给定的内存之外，还会有<code>cookie</code>——用来记录分配数组的长度，查看<code>cookie</code>中的长度，然后调用适当次数的析构函数</p></li><li><p>所谓内存泄漏</p><p>  对于一个<code>new []</code>，需要有相应的<code>delete []</code>，本质上<code>cookie</code>记录了<code>free</code>本身需要释放的内存大小，泄露则发生在调用的析构函数次数上：如果对象含有指针的<code>data member</code>，指向堆上的内存，则意味着析构函数是<code>nontrival</code>，需要再析构函数中释放指针指向的内存，反之则是<code>trival</code>的，而析构函数的调用次数，则会影响指针指向的内存部分的泄露。</p></li></ul><p><img src="image-20210316200134379.png" alt="image-20210316200134379"></p><p><img src="image-20210316201727370.png" alt="image-20210316201727370"></p><p><img src="image-20210316201922911.png" alt="image-20210316201922911"></p><h4 id="9-placement-new"><a href="#9-placement-new" class="headerlink" title="9. placement new"></a><code>9</code>. <code>placement new</code></h4><p>标准不允许直接用指针调用构造函数，但给出了另一种调用语法，可以在现有的对象的内存中调用构造函数，它不会分配新的内存。这也是没有对应的<code>placement delete</code>的原因。</p><p><img src="image-20210316202736446.png" alt="image-20210316202736446"></p><h4 id="10-C-程序分配内存的途径"><a href="#10-C-程序分配内存的途径" class="headerlink" title="10. C++程序分配内存的途径"></a><code>10</code>. <code>C++</code>程序分配内存的途径</h4><p><img src="image-20210316203737564.png" alt="image-20210316203737564"></p><p><img src="image-20210316205136096.png" alt="image-20210316205136096"></p><p>从图中可以看出，当出现<code>new Foo(x)</code>后，编译器会检查<code>Foo</code>这个类有没有实现<code>operator new(size_t)</code>的<code>static</code>函数，如果有就会调用<code>Foo</code>这个版本的<code>operator new</code>，如果没有就调用全局的<code>::operator new</code>，<code>delete</code>也是如此。</p><p>所以可以为一个类单独实现<code>operator new</code>和<code>operator delete</code>。也可以重载全局的<code>operator new/delete</code>，但很少这么做，因为全局的版本是照顾所有的类。</p><h4 id="11-探究operator-new"><a href="#11-探究operator-new" class="headerlink" title="11. 探究operator new"></a><code>11</code>. 探究<code>operator new</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">new</span> (a) A(<span class="number">27</span>, <span class="number">224</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* b = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(A));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a-&gt;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汇编代码如下:</span></span><br></pre></td></tr></table></figure><img src="30.png" style="zoom:67%;" /><img src="31.png" style="zoom:67%;" /><img src="33.png" style="zoom:67%;" /><img src="34.png" style="zoom:67%;" /><h4 id="12-重载-operator-new-delete"><a href="#12-重载-operator-new-delete" class="headerlink" title="12. 重载::operator new/delete"></a><code>12</code>. 重载<code>::operator new/delete</code></h4><p>上面说了，重载全局的<code>operator new/delete</code>影响深远，谨慎使用。但可以重载，方法是在<strong>非</strong><code>namespace</code>中声明和全局版本相同的函数签名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A() : this:"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) : a(_a), b(_b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A(int,int): this: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A(): this: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下 4 个函数就在当前的文件中声明定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(len); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> A(); <span class="comment">// 调用到上面自定义的 operator new</span></span><br><span class="line">    <span class="keyword">void</span>* b = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(A)); <span class="comment">// 虽然指定的是 ::operator new, 但还是调用到上面自定义的版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 a 是正确的释放, 先调用 A 的析构函数, 再调用上面的 operator delete</span></span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 b, 释放的操作应该显示调用 operator delete</span></span><br><span class="line">    <span class="comment">// 这里用 delete 后, 并没有调用 A 的析构函数, 而是直接调用了 operator delete</span></span><br><span class="line">    <span class="comment">// 可见编译器对于 delete void* 的时候, 是直接转换为 opreator delete</span></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识C++内存管理的工具 （一）</title>
      <link href="/kZo0999uFp6r1QI2/"/>
      <url>/kZo0999uFp6r1QI2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-内存管理函数的层次"><a href="#1-内存管理函数的层次" class="headerlink" title="1. 内存管理函数的层次"></a><code>1</code>. 内存管理函数的层次</h4><p>从下图中可以看到，<code>C++</code>程序员处于的位置是最上层的<code>Applications</code>，用的最多的是<code>new</code>，<code>new[]</code>，如果用容器，则内存基本不用管理。其次也可以调用<code>malloc</code>。至于最底层的操作系统级别的<code>API</code>，没有可移植性。它们之间的调用关系如上图的箭头所示。</p><a id="more"></a><img src="20.png"  /><h4 id="2-Memory-primitives分类"><a href="#2-Memory-primitives分类" class="headerlink" title="2. Memory primitives分类"></a><code>2</code>. <code>Memory primitives</code>分类</h4><table><thead><tr><th>分配</th><th>释放</th><th>所属</th><th>可否重载</th></tr></thead><tbody><tr><td><code>malloc</code></td><td><code>free</code></td><td><code>C</code>函数</td><td>否</td></tr><tr><td><code>new</code></td><td><code>delete</code></td><td><code>C++</code>表达式</td><td>否</td></tr><tr><td><code>::operator new()</code></td><td><code>::operator delete()</code></td><td><code>C++</code>函数</td><td>可</td></tr><tr><td><code>allocator&lt;T&gt;::allocate()</code></td><td><code>allocator&lt;T&gt;::deallocate()</code></td><td><code>STL</code>分配器</td><td>可以自己设计搭配容器</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primitives_sample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// CRT 运行时函数</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>( <span class="number">512</span> );</span><br><span class="line">    <span class="built_in">free</span>( p1 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new</span></span><br><span class="line">    <span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt; *p2 = <span class="keyword">new</span> <span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ::operator new() 全局函数, 可被重载</span></span><br><span class="line">    <span class="keyword">void</span> *p3 = ::<span class="keyword">operator</span> <span class="keyword">new</span>( <span class="keyword">sizeof</span>( <span class="keyword">int</span> ) ); <span class="comment">// 内部调用 malloc</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">( p3 )</span></span>;    <span class="comment">//内部调用delete</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocator 分配器, STL 容器分配内存的方式</span></span><br><span class="line">    <span class="keyword">void</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate( <span class="number">7</span> );</span><br><span class="line">    allocator&lt;<span class="keyword">int</span>&gt;().deallocate( (<span class="keyword">int</span> *)p4, <span class="number">7</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-new的初步探究"><a href="#3-new的初步探究" class="headerlink" title="3. new的初步探究"></a><code>3</code>. <code>new</code>的初步探究</h4><p><code>c++</code>的程序员基本都会用<code>new</code>来为对象分配一个堆内存，并且<code>new</code>会调用对应的构造函数，构造函数是用来初始化对象的，所以总结出<code>new</code>的功能是：</p><ol><li>在堆中分配一块指定对象大小的内存</li><li>将返回的指针转换为指向对象类型的指针</li><li>通过指针调用对象相应的构造函数</li></ol><p><img src="image-20210315204443125.png" alt="image-20210315204443125"></p><h4 id="4-测试new的调用流程"><a href="#4-测试new的调用流程" class="headerlink" title="4. 测试new的调用流程"></a><code>4</code>. 测试<code>new</code>的调用流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b): a(_a), b(_b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* tmp_a = <span class="keyword">new</span> A(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">delete</span> tmp_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="21.png" style="zoom: 67%;" /><img src="22.png" style="zoom:67%;" /><img src="23.png" style="zoom:67%;" /><img src="24.png" style="zoom:67%;" /><p>上面的<code>4</code>张图是在<code>MSVC</code>中反汇编的运行时代码。从第<code>1</code>张图可以看出，<code>new</code>调用了<code>operator new</code>，从第<code>3</code>张图可以看出，<code>operator new</code>内部调用了<code>malloc</code>。实际上编译器是在<code>new</code>的地方调用了对应的构造函数，并不是在<code>new</code>的内部，<code>new</code>只是编译器识别的一个标识符，并不是函数，编译器看到<code>new</code>后会<code>malloc</code>，然后调用构造函数。</p><p><code>VS2019</code>可以看到<code>operator new</code>的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">_CRT_SECURITYCRITICAL_ATTRIBUTE</span><br><span class="line"><span class="function"><span class="keyword">void</span>* __CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="keyword">const</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">void</span>* <span class="keyword">const</span> block = <span class="built_in">malloc</span>(size))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == SIZE_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_array_new_length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_alloc();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The new handler was successful; try to allocate again...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>operator new</code>的作用是调用<code>malloc</code>分配内存。当<code>malloc</code>成功后直接返回。当<code>malloc</code>失败后，并不会再次<code>malloc</code>，而是调用<code>_callnewh() new_handler()</code>，这个函数的作用是向自己定义的函数索取内存，所以<code>new_handler</code>可以理解为释放一些缓存，调用完<code>new_handler</code>后，可能释放了内存，这个时候再尝试调用<code>malloc</code>获取内存。</p><h4 id="5-delete的初步探究"><a href="#5-delete的初步探究" class="headerlink" title="5. delete的初步探究"></a><code>5</code>. <code>delete</code>的初步探究</h4><p><img src="image-20210315210220075.png" alt="image-20210315210220075"></p><h4 id="6-测试delete的调用流程"><a href="#6-测试delete的调用流程" class="headerlink" title="6. 测试delete的调用流程"></a><code>6</code>. 测试<code>delete</code>的调用流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) : a(_a), b(_b) &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* tmp_a = <span class="keyword">new</span> A(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">delete</span> tmp_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="25.png" style="zoom:67%;" /><img src="26.png" style="zoom:67%;" /><img src="27.png" style="zoom:67%;" /><img src="28.png" style="zoom:67%;" /><img src="29.png" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之构造、析构、拷贝语意学</title>
      <link href="/plA8MQtWi85PlNcz/"/>
      <url>/plA8MQtWi85PlNcz/</url>
      
        <content type="html"><![CDATA[<h4 id="第5章：构造、析构、拷贝语意学"><a href="#第5章：构造、析构、拷贝语意学" class="headerlink" title="第5章：构造、析构、拷贝语意学"></a>第<code>5</code>章：构造、析构、拷贝语意学</h4><ul><li><p>可以定义和调用一个纯虚函数，不过只能被静态的调用（通过类作用域运算符），不能通过虚拟机制调用。 </p></li><li><p>你声明了一个纯虚析构函数，就必须定义它。因为在你提供了声明前提下，每一个derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。因此，只要缺乏任何一个base class destructor的定义，就会<strong>导致链接失败</strong>。</p><p>  读到这儿，你可能会有疑问，对于普通的类（没有虚机制参与进来，派生类的析构函数中也会逐一调用基类的析构函数）我们也没有提供它析构函数的，那为什么不会导致链接失败呢？这是因为你没有写析构函数，编译器会默默给你提供一个，以便于在后面的派生类的析构函数中调用它。这里的重点是你没有提供，也就是说你没有声明，如果你声明了，但没有提供定义，同样会导致链接失败。</p></li><li><p>对于基类该不该将虚函数定义为<code>const</code>的，作者不建议。因为derived class中可能会修改自己的数据成员。</p></li></ul><a id="more"></a><h5 id="5-1-无继承情况下的对象构造"><a href="#5-1-无继承情况下的对象构造" class="headerlink" title="5.1 无继承情况下的对象构造"></a><code>5.1</code> 无继承情况下的对象构造</h5><p>当编译器遇到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point global;</span><br></pre></td></tr></table></figure><p>在<code>C</code>之中，<code>global</code>被视为一个“临时性的定义”，因为它没有明确的初始化操作。一个“临时性的定义”可以在程序中发生多次。那些实例会被链接器折叠起来，只留下单独一个实体，被放在程序<code>data segment</code>中一个“特别保留给未初始化之<code>global objects</code>使用”的空间。由于历史的缘故，这块空间被称为<code>BSS</code>，是<code>Block Started by Symbol</code>的缩写。</p><p>而<code>global</code>在<code>C++</code>中被视为完全定义（它会阻止第二个或更多个定义）。<code>C</code>和<code>C++</code>的一个差异就在于，<code>BSS data segment</code>在<code>C++</code>中相对地不重要。<code>C++</code>的所有全局对象都被当作“初始化过的数据”来对待。</p><p><strong>为继承做准备</strong></p><p>虚函数的引入不仅仅是每个类对象增加了一个<code>vptr</code>，而且会引发编译器对类产生膨胀作用。我们所定义的构造函数，编译器会附加一些代码，以便<code>vptr</code>初始化。合成一个<code>copy constructor</code>和一个<code>copy assignment operator</code>，它们都不是<code>trival</code>。因为，如果<code>point</code>类对象被初始化或以一个派生类对象赋值，<code>bitwise</code>操作就存在问题了，<code>vptr</code>设置会出错。</p><p><code>C++</code>编译器要求编译器尽量延迟<code>nontrivial members</code>的实际合成操作，直到遇到使用场合为止。如果在你的设计中存在很多以传值的方式返回局部类对象，提供一个拷贝构造函数就比较合理，因为这会触发编译器的<code>NRV</code>优化。</p><h5 id="5-2-继承体系下的对象构造"><a href="#5-2-继承体系下的对象构造" class="headerlink" title="5.2 继承体系下的对象构造"></a><code>5.2</code> 继承体系下的对象构造</h5><p><code>constructor</code>可能内带大量的隐藏码，因为编译器会扩充每一个<code>constructor</code>，扩充程度视<code>class T</code>的继承体系而定。一般而言编译器所做的扩充操作大约如下：</p><ol><li>记录在<code>member initialization list</code>中的<code>data members</code>初始化操作会被放进<code>constrector</code>的函数本身，并以<code>members</code>的声明顺序为顺序。<ul><li>如果有数据成员为类对象，并被列于<code>member initialization list</code>中，那么任何明确指定的参数都应该传递过去。</li></ul></li><li>如果有一个<code>member</code>并没有出现在<code>member initialization list</code>之中，但它有一个<code>default constructor</code>，那么该<code>default constructor</code>必须被调用。</li><li>在那之前，如果<code>class object</code>有<code>vptr</code>，它（们）必须被设定初值，指向适当的<code>virtual table(s)</code>。</li><li>在那之前，所有上一层的<code>base class constructors</code>必须被调用，以<code>base class</code>的声明顺序为序：<ul><li>如果<code>basc class</code>被列于<code>member initialization list</code>中，那么任何明确指定的参数都应该传递过去。</li><li>如果<code>base class</code>没有被列于<code>member initialization list</code>中，而它有<code>default constructor</code>(或<code>default memberwise copy constructor</code>)，那么就调用之。</li><li>如果<code>base class</code>是多重继承下的第二或后继的<code>base class</code>，那么<code>this</code>指针必须有所调整。</li></ul></li><li>在那之前，所有<code>virtual base class constructors</code>必须被调用，从左到右，从最深到最浅：<ul><li>如果<code>class</code>被列于<code>member initialization list</code>中，那么如果有任何明确指定的参数，都应该传递过去。若没有列于<code>list</code>之中，而<code>class</code>有一个<code>default constructor</code>，也应该调用之。</li><li>此外，<code>class</code>中的每一个<code>virtual base class subobject</code>的偏移量必须在执行期可被存取。</li><li>如果<code>class object</code>是最底层（<code>most-derived</code>）的<code>class</code>，其<code>constructors</code>可能被调用；某些用以支持这个行为的机制必须被放进来。</li></ul></li></ol><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><strong>书中接下来的章节对上面这些做了详细的叙述。全是重点，就不做总结了，自行看书</strong>。</p><h4 id="第6章：执行期语意学"><a href="#第6章：执行期语意学" class="headerlink" title="第6章：执行期语意学"></a>第<code>6</code>章：执行期语意学</h4><p><strong>很重要，不做总结了，自行看书</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个在windows平台的定时更换壁纸的工具</title>
      <link href="/JFfWe2Uugfh1u70r/"/>
      <url>/JFfWe2Uugfh1u70r/</url>
      
        <content type="html"><![CDATA[<p>有没有感觉到自己的电脑桌面一成不变让人厌倦？虽然有一些诸如360桌面之类的软件可以使用，但弹窗、广告又太多！本文就教你用 <em>python</em> 实现一个简洁清爽的桌面壁纸定时更换工具。</p><a id="more"></a><p>本文使用的方法是用 <em>python</em> 实现一个定时更换壁纸的脚本，壁纸来源与自定义的文件夹内，因此你可以搜集一些你喜欢的壁纸图片放于该文件夹下，这样脚本程序便可以使你的电脑桌面轮流展示这些图片了。</p><p>比如我就把我喜欢的壁纸都收集在了 <em>E:/wallpapers/</em> 文件夹下。</p><p><img src="2020-06-14.png" alt=""></p><p>这里推荐几个好的壁纸来源网站 <a href="https://wallhaven.cc/" target="_blank" rel="noopener">https://wallhaven.cc/</a> ，<a href="https://www.artstation.com/wlop" target="_blank" rel="noopener">https://www.artstation.com/wlop</a> 。</p><p>下面直接看代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImages</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 这里的路径就是你放图片的文件夹路径</span></span><br><span class="line">    images_path = <span class="string">'E:\\wallpapers\\'</span></span><br><span class="line">    files = os.listdir(images_path)</span><br><span class="line">    <span class="keyword">return</span> images_path, files</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_wallpaper</span><span class="params">(it)</span>:</span></span><br><span class="line">    path, images = getImages()</span><br><span class="line">    image = path + images[it]</span><br><span class="line">    it = (it + <span class="number">1</span>) % len(images)</span><br><span class="line">    win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, image, <span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">global</span> timer</span><br><span class="line">    <span class="comment"># 我设置的是每60s更换一次，你可以根据需要自定义设置</span></span><br><span class="line">    timer = threading.Timer(<span class="number">60.0</span>, set_wallpaper, (it,))</span><br><span class="line">    timer.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    set_wallpaper(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>为了方便运行，我们可以使用 <em>pyinstaller</em> 工具将该脚本程序转成 <em>.exe</em> 可执行文件。具体的方法可以看这篇文章 <a href="https://blog.csdn.net/zengxiantao1994/article/details/76578421" target="_blank" rel="noopener">Python程序打包成exe可执行文件</a> 。</p><p>生成可执行文件之后，运行就可以了。不过，为了每次开机程序都可以自动运行，我们需要进行一些设置。首先按 <em>win+R</em> 键打开运行窗口，输入 <em>shell:startup</em> 回车，这样会打开一个启动文件夹，这个文件夹下的软件在开机时都会自动启动，将你的可执行文件或其快捷方式放在这里就可以了。</p><p>这里可以直接下载我已经生成的可执行程序：</p><p><a href="https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q</a><br>提取码：v9ng </p><p>使用方法就是在E盘下新建一个名为wallpapers的文件夹，然后把自己喜欢的照片放进去就好，即<em>E:/wallpapers/</em> 。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桌面壁纸工具 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个简易的Linux平台下的划词翻译工具</title>
      <link href="/KT2Sz9hHwziaJtFt/"/>
      <url>/KT2Sz9hHwziaJtFt/</url>
      
        <content type="html"><![CDATA[<p>这里将要介绍的是一种在 <em>Linux</em> 平台实现的划词翻译工具，当然在考虑自己实现一个如此功能的工具前，本人也是在网上搜索了一些在 <em>Linux</em> 平台实现的类似的开源工具，例如 <a href="https://github.com/axipo/pdfTranslator" target="_blank" rel="noopener">pdfTranslator</a>，<a href="https://github.com/bianjp/popup-dict" target="_blank" rel="noopener">popup-dict</a>，但它们的安装和配置都显得比较麻烦，而且使用起来也并不方便。</p><p>本人实现这个工具的初衷本是方便自己看一些英文文献和书籍的，极为方便，考虑到分享出去可以让更多人受惠，因此这里详细介绍一下它的实现步骤。</p><a id="more"></a><p>本文所实现的划词翻译工具主要有以下特性：</p><ul><li>支持英文单词和短语到中文的翻译</li><li>划词翻译，终端显示</li><li>自动过滤选中文本中的换行等特殊字符</li><li>只依赖少数几个 <em>Linux</em> 命令工具</li></ul><p>下面有动图进行演示。</p><p><img src="iKnVA63lpy.gif" alt=""></p><p>本人所使用的环境是运行在 <em>VMware</em> 虚拟机下的 <em>Linux</em> 发行版 <em>Ubuntu 18.04.3 LTS</em> ，因此这里介绍的步骤可能与其他 <em>Linux</em> 发行版中的实现略有不同。下面就来一步一步的实现它吧。</p><h4 id="一-安装必要的命令"><a href="#一-安装必要的命令" class="headerlink" title="一. 安装必要的命令"></a>一. 安装必要的命令</h4><ol><li><em>xclip</em></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install xclip</span></span><br></pre></td></tr></table></figure><p><em>xclip</em> 命令建立了终端和剪切板之间通道，可以用命令的方式将终端输出或文件的内容保存到剪切板中，也可以将剪切板的内容输出到终端或文件。详细的用法可以使用 <em>man xclip</em>，见其手册。这里介绍几个常用的用法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xclip file_name <span class="comment"># 文件内容保存到X window剪切板</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection c file_name <span class="comment">#文件内容保存到外部剪切板</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -o <span class="comment"># X window剪切板内容输出到终端显示</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection c -o <span class="comment"># 外部剪切板内容输出到终端显示</span></span></span><br></pre></td></tr></table></figure><p>值得强调的是，这里所说的 <em>X window</em> 剪切板，简单的说就是你用鼠标选择的文本会实时的存放在这个剪切板，使用鼠标中键可以粘贴。而外部剪切板是保存你用 <em>ctrl+c</em> 复制的文本，<em>ctrl+v</em> 可以粘贴。这两个地方是不一样的。</p><ol start="2"><li><em>translate-shell</em></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install translate-shell</span></span><br></pre></td></tr></table></figure><p>这是命令行版的谷歌翻译工具，之前叫做 <em>Google Translate CLI</em> 是一款借助谷歌翻译（默认）、必应翻译等来翻译的命令行翻译器。它让你可以在终端访问这些翻译引擎。 <em>translate-shell</em> 在大多数 <em>Linux</em> 发行版中都能使用。常用的方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trans en:zh [word] <span class="comment"># 英文到中文的单词翻译</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> trans en:zh -b [text] <span class="comment"># 简要的输出，进行文本翻译</span></span></span><br></pre></td></tr></table></figure><p>需要注意的是，使用这个翻译工具需要你能够<strong>访问外网</strong>，或者通过修改 <em>translate-shell</em> 的默认翻译引擎，具体的方法这里就不阐述了。</p><h4 id="二-编程实现"><a href="#二-编程实现" class="headerlink" title="二. 编程实现"></a>二. 编程实现</h4><p>这个工具整体的思路就是 <em>C</em> 程序实时检测鼠标按键的动态，当检测到用户使用鼠标选择一段文本之后，调用 <em>shell</em> 脚本获取 <em>X window</em> 剪切板的内容进行翻译后输出到终端显示。</p><p><strong>1. 定位鼠标设备文件</strong></p><p>鼠标作为输入设备。其信息可以在文件 <em>/proc/bus/input/devices</em> 中，使用下列命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /proc/bus/input/devices</span></span><br><span class="line">I: Bus=0011 Vendor=0002 Product=0013 Version=0006</span><br><span class="line">N: Name="VirtualPS/2 VMware VMMouse"</span><br><span class="line">P: Phys=isa0060/serio1/input1</span><br><span class="line">S: Sysfs=/devices/platform/i8042/serio1/input/input4</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mouse0 event2 </span><br><span class="line">B: PROP=0</span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=70000 0 0 0 0</span><br><span class="line">B: ABS=3</span><br></pre></td></tr></table></figure><p>其中的 <em>Handlers</em> 的值 <em>event2</em> 表示可以在 <em>/dev/input/event2</em> 文件下读取鼠标的状态。需要注意的是，对于不同的设备，读取鼠标的状态的文件可能不一样，比如也可能是 <em>/dev/input/event3</em>。我们可以使用下面的命令找到你的鼠标对应的是哪一个 <em>event</em>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /dev/input/event2 | hexdump <span class="comment"># 测试时改变数字即可</span></span></span><br></pre></td></tr></table></figure><p>比如，当我运行上面这条命令之后，我移动鼠标、按鼠标左键/中键/右键，终端都会输出一些值，这就说明 <em>event2</em> 文件就是对应着我的鼠标。如果操作鼠标没有反应，说明这个就不是。你可以通过这种方法找到你的鼠标对应的 <em>event</em> 文件。</p><p><strong>2. Linux 下获取按键响应</strong></p><p>在 <em>Linux</em> 内核中，<em>input</em> 设备用 <em>input_dev</em> 结构体描述，使用 <em>input</em> 子系统实现输入设备驱动的时候，驱动的核心工作就是向系统报告按键、触摸屏、键盘、鼠标等输入事件（<em>event*，通过 *input_event</em> 结构体描述），不再需要关心文件操作接口，因为 <em>input</em> 子系统已经完成了文件操作接口 <em>Linux/input.h</em> 这个文件定义了 <em>event</em> 事件的结构体，<em>API</em> 和标准按键的编码等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义见 input.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">// 按键时间</span></span><br><span class="line">    __u16 type;          <span class="comment">// 事件类型</span></span><br><span class="line">    __u16 code;          <span class="comment">// 要模拟成什么按键</span></span><br><span class="line">    __s32 value;         <span class="comment">// 是按下还是释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面宏定义见 input-event-coses.h</span></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_KEY 0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_REL 0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ABS 0x03</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_LEFT 0x110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_RIGHT 0x111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_MIDDLE 0x112</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSC_SERIAL 0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSC_PULSELED 0x01</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里稍微介绍一下 <em>type</em>，指事件类型，常见的事件类型有：<br><em>EV_KEY</em>，按键事件，如键盘的按键（按下哪个键），鼠标的左键右键（是否击下）等；<br><em>EV_REL</em>，相对坐标，主要是指鼠标的移动事件（相对位移）；<br><em>EV_ABS</em>， 绝对坐标，主要指触摸屏的移动事件 。</p><p><strong>3. 编写 <em>C</em> 程序</strong></p><p>下面就可以编写程序来检测鼠标的动态了。首先在你的用户~目录下建立文件夹 <em>Translator*。在 *Translator</em> 里建立一个 <em>ct.c</em> 源文件，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里打开的文件根据你自己的设备情况作相应的改变</span></span><br><span class="line">    keys_fd = <span class="built_in">open</span>(<span class="string">"/dev/input/event2"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (keys_fd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open /dev/input/event2 error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(keys_fd, &amp;t, <span class="keyword">sizeof</span>(t));</span><br><span class="line">        <span class="keyword">if</span> (t.type == EV_KEY)              <span class="comment">// 有键按下</span></span><br><span class="line">            <span class="keyword">if</span> (t.code == BTN_LEFT)        <span class="comment">// 鼠标左键</span></span><br><span class="line">                <span class="keyword">if</span> (t.value == MSC_SERIAL) <span class="comment">// 松开</span></span><br><span class="line">                    <span class="comment">// 调用外部shell脚本</span></span><br><span class="line">                    system(<span class="string">"~/Translator/goTranslate.sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(keys_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是调用 <em>gcc</em> 编译器生成可执行文件 <em>ct</em>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ct.c -o ct</span></span><br></pre></td></tr></table></figure><p><strong>4. 编写 <em>shell</em> 脚本翻译剪切板内容</strong></p><p>在 <em>Translator</em> 里建立 <em>goTranslate.sh</em> 文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str_old=$(cat ~/Translator/lastContent)</span><br><span class="line">str_new=$(xclip -o 2&gt;/dev/null | xargs)</span><br><span class="line">if [[ "$str_new" != "$str_old" &amp;&amp; $str_new ]]; then</span><br><span class="line">    echo -e "\n"</span><br><span class="line">    count=$(echo "$str_new" | wc -w)</span><br><span class="line">    if [ "$count" == "1" ]; then</span><br><span class="line">        echo -n -e "$str_new " &gt;&gt;~/Translator/words</span><br><span class="line">        echo "$str_new" | trans :zh-CN | tail -1 | cut -c 5- | sed "s,\x1b\[[0-9;]*[a-zA-Z],,g" | tee -a ~/Translator/words</span><br><span class="line">    else</span><br><span class="line">        echo "$str_new" | trans :zh-CN -b</span><br><span class="line">    fi</span><br><span class="line">    echo "$str_new" &gt;~/Translator/lastContent</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>原理非常简单，读者自行了解。这里我们还要在 <em>Translator</em> 里建立一个 <em>lastContent.txt</em> 文件作为缓存，目的是本次调用脚本时能够获取上一次调用时翻译的文本内容，如果和本次调用的翻译文本一样，则本次就不进行翻译。</p><p><em>*5. 设置 *ct</em> 别名 **</p><p>这里已经可以通过下面的命令运行程序了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ~/Translator/ct</span></span><br></pre></td></tr></table></figure><p>但是由于每次运行都要输出这么长的命令，因此我们在 <em>~/.bashrc</em> 文件中加入下面一条命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ct='sudo ~/Translator/ct'</span><br></pre></td></tr></table></figure><p>这样，以后每次看英文文献时就可以在命令行下输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ct</span></span><br></pre></td></tr></table></figure><h4 id="三-结束语"><a href="#三-结束语" class="headerlink" title="三. 结束语"></a>三. 结束语</h4><p>这里有一些小技巧。可以更方便的使用这个工具。比如，把终端设为置顶并缩小到合适的尺寸，这样在阅读文献划词翻译时终端屏幕不会遮挡我们的视线。</p><p>值得说明的是，由于本人完全是为了方便自己的使用，而且在搞出这么个工具时仅仅接触 <em>Linux</em> 系统才不到两周，所以里面的实现对于有经验的朋友来说略显的有些笨拙了，请理解哈。</p><p>个人觉得这个工具使用起来还是很方便的，你觉得呢？</p><p>参考文章：</p><ol><li><a href="https://blog.csdn.net/liang12360640/article/details/50350648" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/50350648</a></li><li><a href="https://www.cnblogs.com/yangwindsor/articles/3454955.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangwindsor/articles/3454955.html</a></li><li><a href="https://blog.csdn.net/liang12360640/article/details/50s350648" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/50s350648</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 划词翻译 </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之function语意学</title>
      <link href="/rRW3gD4CDal4WhRJ/"/>
      <url>/rRW3gD4CDal4WhRJ/</url>
      
        <content type="html"><![CDATA[<h4 id="第4章：Function语意学"><a href="#第4章：Function语意学" class="headerlink" title="第4章：Function语意学"></a>第<code>4</code>章：<code>Function</code>语意学</h4><h5 id="4-1-静态成员函数"><a href="#4-1-静态成员函数" class="headerlink" title="4.1 静态成员函数"></a><code>4.1</code> 静态成员函数</h5><p><code>function</code>的调用方式</p><p><code>nonmember function</code>、<code>static member function</code>、<code>nonstatic member function</code>的调用效率完全一样，因为，在内部都被编译器处理成相同的形式。而<code>virtual member function</code>的调用需要通过<code>vptr</code>所指向的<code>virtual table</code>，因此，效率有所降低。</p><p><code>static member function</code>的主要特性就是它没有<code>this</code>指针。以下的次要特性统统根源于其主要特性：</p><a id="more"></a><ul><li>它不能够直接存取其<code>class</code>中的<code>nonstatic members</code>；</li><li>它不能够被声明为<code>const</code>、<code>volatile</code>或<code>virtual</code>；</li><li>它不需要经由<code>class object</code>才被调用——虽然大部分时候它是这样被调用的。</li></ul><p>若取一个<code>static member function</code>的地址不会得到指向其<code>class member function</code>类型的指针（不是<code>return_type (class_type::*)(parameter_types)</code>）。而是一个<code>non-member</code>函数指针（类型为<code>return_type (*)(parameter_types)</code>）。</p><h5 id="4-2-虚拟成员函数"><a href="#4-2-虚拟成员函数" class="headerlink" title="4.2 虚拟成员函数"></a><code>4.2</code> 虚拟成员函数</h5><p>在<code>C++</code>中，<strong>多态</strong>表示以一个指向<code>public base class</code>类型的<code>pointer</code>或<code>reference</code>，寻址出一个<code>derived class object</code>的意思。多态机能体现在通过<code>pointer</code>或<code>reference</code>对虚函数的调用身上。因此，识别一个<code>class</code>是否支持多态，唯一适当的方法就是看看它是否有任何<code>virtual function</code>。</p><p>为了支持多态，需要在执行期决议出正确的<code>virtual function</code>实例，这需要如下执行期信息的支持：</p><ol><li>它所引用的对象的地址，也就是当前它自身的值；</li><li>所引用对象的真实类型。这可使我们选择正确的虚函数所在的实体；</li><li><code>virtual function</code>实体位置，也就是函数地址，以便我能够调用它。</li></ol><p>在实现上，在每一个多态的<code>class object</code>身上增加两个<code>member</code>：</p><ol><li>一个字符串或数字，表示<code>class</code>的类型；</li><li>一个指针，指向某表格，表格中带有程序的<code>virtual function</code>的执行期地址。</li></ol><p><code>virtual function</code>的地址是固定不变的，执行期不可能新增或替换，而表格的大小和内容在执行期不会改变，因此其建构和存取皆在编译期就可以完成。</p><p>为了找到<code>virtual function</code>的地址，需要：</p><ol><li>为了找到表格，每一个<code>class object</code>被安插上一个由编译器内部产生的指针，指向该表格；</li><li>为了找到函数地址，每一个<code>virtual function</code>被指派一个表格索引值。</li></ol><p>这些工作都由编译器完成。执行期要做的，只是在特定的<code>virtual table slot</code>（记录着<code>virtual function</code>的地址）中调用<code>virtual function</code>。这些<code>virtual function</code>可以是：</p><ol><li>这个<code>class</code>所定义的函数实体。它<code>override</code>了一个<code>base class virtual function</code>函数实体；</li><li>继承自<code>base class</code>的函数实体。这是在<code>derived class</code>中决定不<code>override</code>的<code>virtual function</code>时的情况；</li><li>一个<code>pure_virtual_called()</code>函数实体。它既可以扮演<code>pure virtual function</code>的空间保卫者角色，也可以当做执行期异常处理函数（有时候会用到）。</li></ol><p><strong><em>单一继承</em></strong></p><p>例如，对于如下的<strong>单一继承体系</strong>：</p><p><img src="image-20210312160159297.png" alt="image-20210312160159297"></p><p><code>virtual destriucior</code>被赋值<code>slot 1</code>，而<code>mult()</code>被赋值<code>slot 2</code>。此例并没有<code>mult()</code>的函数定义，因为它是一个<code>pure virtual function</code>，所以<code>pure _virtual_called()</code>的函数地址会被放在<code>slot 2</code>中。如果该函数意外地被调用，通常的操作是结束掉这个程序。<code>y()</code>被赋值<code>slot 3</code>而<code>z()</code>被赋值<code>slot 4</code>。<code>x()</code>没有<code>slot</code>，因为<code>x()</code>并非<code>virtual function</code>。</p><p><img src="image-20210312160324194.png" alt="image-20210312160324194"></p><p><img src="image-20210312160340269.png" alt="image-20210312160340269"></p><p>此时，一共有三种可能性：</p><ol><li>它可以继承<code>base class</code>所声明的<code>virtual function</code>的函数实体。正确地说，是该函数实体的地址会被拷贝到<code>derived class</code>的<code>virtual table</code>相对应的<code>slot</code>之中；</li><li>它可以使用自己的函数实体。这表示它自己的函数实体地址必须放在对应的<code>slot</code>之中；</li><li>它可以加人一个新的<code>virtual function</code>。这时候<code>virtual table</code>的尺寸会增大一个<code>slot</code>，而新的函数实体地址会被放进该<code>slot</code>之中。</li></ol><p><code>Point2d</code>的<code>virtual table</code>在<code>slot 1</code>中指出<code>destructor</code>，而在<code>slot 2</code>中指出<code>mult()</code>取代<code>pure virtual function</code>。它自己的<code>y()</code>函数实体地址放在<code>slot 3</code>，继承自<code>Point</code>的<code>z()</code>函数实体地址则放在<code>slot 4</code>。</p><p>类似的情况：</p><p><img src="image-20210312160431103.png" alt="image-20210312160431103"></p><p><code>Point3d</code>的<code>virtual table</code>中的<code>slot 1</code>放置<code>Point3d</code>的<code>destructor</code>，<code>slot 2</code>放置<code>Point3d::mult()</code>函数地址。<code>slot 3</code>放置继承自<code>Point2d</code>的<code>y()</code>函数地址，<code>slot 4</code>放置自己的<code>z()</code>函数地址。</p><p>这个继承体系中的三个类的<code>virtual table</code>布局如下所示：</p><p><img src="image-20210312161401843.png" alt="image-20210312161401843"></p><p>现在，如果我们有这样的式子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;z();</span><br></pre></td></tr></table></figure><p>那么，我如何有足够的知识在编译时期设定<code>virtual function</code>的调用呢？</p><ol><li>一般而言，我并不知道<code>ptr</code>所指对象的真正类型。然而我知道，经由<code>ptr</code>可以存取到该对象的<code>virtual table</code>；</li><li>虽然我不知道哪一个<code>z()</code>函数实体会被调用，但我知道每一个<code>z()</code>函数地址都被放在<code>slot 4</code>。</li></ol><p>这些信息使得编译器可以将该调用转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">4</span>])(ptr);</span><br></pre></td></tr></table></figure><p>在一个单一继承体系中，<code>virtual function</code>机制的行为十分良好，不但有效率而且很容易塑造出模型。但是在多重继承和虚拟继承之中，就呵呵了。</p><p><strong><em>多重继承</em></strong>和<strong><em>虚拟继承</em></strong></p><p>懒得总结了，看是看懂了，乱七八糟的！</p><h5 id="4-3-指向Member-Function的指针"><a href="#4-3-指向Member-Function的指针" class="headerlink" title="4.3 指向Member Function的指针"></a><code>4.3</code> 指向<code>Member Function</code>的指针</h5><p>取一个<code>nonstatic member function</code>的地址，如果该函数是<code>nonvirtual</code>，则得到的结果是它在内存中真正的地址。然而这个值也是不完全的，它也需要被绑定于某个<code>class object</code>的地址上，才能够通过它调用该函数（以参数<code>this</code>指出）。</p><p>回顾一下，一个指向<code>member function</code>的指针，其声明语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (Point::*pmf)();</span><br></pre></td></tr></table></figure><p>然后我们可以这样定义并初始化该指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (Point::*coord)() = &amp;Point::x;</span><br></pre></td></tr></table></figure><p>也可以这样指定其值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord = &amp;Point::y;</span><br></pre></td></tr></table></figure><p>想调用它，可以这么做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(origin.*coord)();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(ptr-&gt;*coord)();</span><br></pre></td></tr></table></figure><p>这些操作会被编译器转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(coord)(&amp;origin);</span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line">(coord)(ptr);</span><br></pre></td></tr></table></figure><p>获得该函数在内存中的地址。然而面对一个<code>virtual function</code>，其地址在编译时期是未知的，所能知道的仅是<code>virtual function</code>在其相关之<code>virtual table</code>中的索引值，也就是说，对一个<code>virtual member function</code>取其地址，所能获得的只是一个索引值。</p><p>那么问题来了，假设我们有以下的<code>Point</code>声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取<code>z()</code>函数的地址得到的索引值是<code>2</code>，而不是函数地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> (Point::*pmf)() = &amp;Point::z;</span><br><span class="line">Point *ptr = <span class="keyword">new</span> Point3d;</span><br></pre></td></tr></table></figure><p>那么如果通过<code>pmf</code>来间接调用<code>z()</code>函数的话：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(ptr-&gt;*pmf)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为</span></span><br><span class="line"></span><br><span class="line">(*ptr-&gt;vptr[(<span class="keyword">int</span>)pmf]<span class="number">5</span>(ptr);</span><br></pre></td></tr></table></figure><p>那么如何知道<code>pmf</code>指向的是<code>virtual function</code>还是<code>nonvirtual function</code>，毕竟<code>pmf</code>如果对<code>nonvirtual function</code>取地址的话得到的是在内存中的地址。也就是说，<code>pmf</code>的内部定义需要允许该函数能够寻址出<code>nonvirtual</code>和<code>virtual</code>两个<code>member function</code>。</p><p>同时为了让执行<code>member function</code>的指针也能支持多重继承和虚拟继承，实现方法为使用一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用以支持在多重继承之下指向 member function 的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">mptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// virtual 函数 在 virtual table 的索引, 当 index 不指向 virtual table 时值为 -1</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptrtofunc faddr; <span class="comment">// nonvirtual 函数的地址</span></span><br><span class="line">        <span class="keyword">int</span> voffset;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这样的模型下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(ptr-&gt;*pmf)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为</span></span><br><span class="line"></span><br><span class="line">(pmf.inidex &lt; <span class="number">0</span>) ? (*pmf.faddr)(ptr) : (*ptr-&gt;vptr[pmf.index](ptr));</span><br></pre></td></tr></table></figure><h5 id="4-4-inline函数"><a href="#4-4-inline函数" class="headerlink" title="4.4 inline函数"></a><code>4.4</code> <code>inline</code>函数</h5>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之data语意学</title>
      <link href="/ShyaVw4WHERlLCqZ/"/>
      <url>/ShyaVw4WHERlLCqZ/</url>
      
        <content type="html"><![CDATA[<h4 id="第3章：Data语意学"><a href="#第3章：Data语意学" class="headerlink" title="第3章：Data语意学"></a>第<code>3</code>章：<code>Data</code>语意学</h4><p><code>The size of class</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// char c; // 此时, sizeof(X) == 1, sizeof(Y) == 8, sizeof(Z) == 8, sizeof(A) == 16</span></span><br><span class="line">    <span class="keyword">char</span> c; <span class="comment">// 此时, sizeof(X) == 1, sizeof(Y) == 16, sizeof(Z) == 16, sizeof(A) == 24</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123; &#125;;</span><br></pre></td></tr></table></figure><p>一个类的大小主要受三个因素的影响：</p><ol><li><p>语言支持的特性所造成的负担</p><p> 比如，含虚函数的类会额外多一个<code>vptr</code>指针，含<code>virtual base class</code>会再多一个额外的指针（它或者指向<code>virtual base class subobject</code>，或者指向一个相关表格；表格中存放的若不是<code>virtual base class subobject</code>地址，就是其偏移量）。</p></li><li><p>编译器对于特殊情况所提供的优化处理</p><p> 现代编译器的对于空基类的优化处理：一个<code>empty virtual base class</code>被视为<code>derived class object</code>最开头的一部分，也就是说它并没有花费任何的额外空间。因为既然有了<code>members</code>，就不需要原本为了<code>empty class</code>而安插的一个<code>char</code>。</p></li><li><p><code>alignment</code>（内存对齐）</p><p> 就是将数值调整到某数的整数倍。在<code>64</code>位计算机上，通常<code>alignment</code>为<code>8 bytes</code>，以使<code>bus</code>的“运输量”达到最高效率。</p></li></ol><a id="more"></a><p><code>nonstatic data members</code>放置的是“个别的<code>class object</code>”感兴趣的数据，<code>static data members</code>则放置的是“整个<code>class</code>”感兴趣的数据。</p><p><code>static data members</code>被放置在程序的一个<code>global data segment</code>中，不会影响个别的<code>class object</code>的大小。在程序之中，不管该<code>class</code>被产生出多少个<code>objects</code>（经由直接产生或间接派生），<code>static data member</code>永远只存在一份实体（即使该<code>class</code>没有任何<code>object</code>实体，其<code>static data members</code>也已存在）。</p><h5 id="3-1-data-member的绑定"><a href="#3-1-data-member的绑定" class="headerlink" title="3.1 data member的绑定"></a><code>3.1</code> <code>data member</code>的绑定</h5><p>类成员函数的<code>argument list</code>中的名称会在它们第一次遭遇时被适当地决议（<code>resolved</code>）完成。因此在<code>extern</code>和<code>nested type name</code>之间的非直觉绑定操作还是会发生。例如在下面的程序片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数列表中的 length 被决议成 std::string!!!</span></span><br><span class="line">    <span class="comment">// 里面的 val_ 被正确决议成 int</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(length val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val_ = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line">    length val_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以这需要使用防御性的程序风格：将<code>nested type name</code>写在class的起始处！</p><h5 id="3-2-数据成员的布局"><a href="#3-2-数据成员的布局" class="headerlink" title="3.2 数据成员的布局"></a><code>3.2</code> 数据成员的布局</h5><p>下面这个<code>template function</code>，接受两个<code>data member</code>，然后判断谁先出现在<code>class object</code>之中。如果两个<code>member</code>都是不同的<code>access sections</code>中的第一个被声明者，此函数就可以用来判断哪一个<code>section</code>先出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">class_type</span>, <span class="title">class</span> <span class="title">data_typel</span>, <span class="title">class</span> <span class="title">data_type2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="function"><span class="built_in">string</span> <span class="title">access_order</span><span class="params">(data_type1 class_type::* mem1, data_type2 class_type::* mem2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(mem1 != mem2);</span><br><span class="line">    <span class="keyword">return</span> mem1 &lt; mem2 ? <span class="string">"member 1 occurs first"</span> : <span class="string">"member 2 occurs first"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数可以这样被调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_order(&amp;Point3d::y, &amp;Point3d::z);</span><br></pre></td></tr></table></figure><h5 id="3-3-data-member的存取"><a href="#3-3-data-member的存取" class="headerlink" title="3.3 data member的存取"></a><code>3.3</code> <code>data member</code>的存取</h5><p><code>static data member</code></p><p>对于类中的静态数据成员，通过一个指针和通过一个对象来存取，效率完全相同，不论这个静态数据成员经过了多么复杂的继承体系。</p><p>若取一个<code>static data member</code>的地址不会得到指向其<code>class member</code>的指针（不是<code>value_type class_type::*</code>类型）。而是指向其数据类型的指针（类型为<code>value_type*</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Point::x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = &amp;Point::func1; <span class="comment">// p 的类型是 void (Point::*p)()</span></span><br><span class="line">    <span class="keyword">auto</span> q = &amp;Point::func2; <span class="comment">// q 的类型是 void (*q)(int a)</span></span><br><span class="line">    <span class="keyword">auto</span> p = &amp;Point::x;<span class="comment">// r 的类型是 int* r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数不能是静态成员函数：如果构造函数是静态成员函数，那么将不能访问非静态变量，也没办法完成初始化的工作。</p><p><code>non static data member</code></p><p>对于类中的非静态数据成员，通过一个指针和通过一个对象来存取，当此数据成员属于继承而来的<code>virtual base class</code>时，使用指针效率较低。如果使用对象直接存取，就不会有这些问题，其类型无疑是确定的，而即使它继承自<code>virtual base class</code>，<code>members</code>的<code>offset</code>位置也在编译时期就固定了。</p><p>欲对一个<code>nonstatic data member</code>进行存取操作，编译器需要把<code>class object</code>的起始地址加上<code>data member</code>的偏移量。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;origin._y == &amp;origin + (&amp;Point3d::_y - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>请注意其中的<code>-1</code>操作。指向<code>data member</code>的指针，其<code>offset</code>值总是被加上<code>1</code>，这样可以使编译系统区分出是用以指出<code>class</code>的第一个<code>member</code>还是没有指出任何<code>member</code>的两种情况。</p><h5 id="3-4-C-对象布局"><a href="#3-4-C-对象布局" class="headerlink" title="3.4 C++对象布局"></a><code>3.4</code> <code>C++</code>对象布局</h5><ol><li><p>个别<code>struct</code>的数据布局</p><p> <img src="image-20210310151329468.png" alt="image-20210310151329468"></p></li><li><p>单一继承而且没有<code>virtual function</code>时的数据布局</p><p> <img src="image-20210310151502431.png" alt="image-20210310151502431"></p></li><li><p><code>C++</code>语言保证——出现在<code>derived class</code>中的<code>base class subobject</code>有其完整原样性</p><p> <img src="image-20210310151740707.png" alt="image-20210310151740707"></p><p> <img src="image-20210310151814511.png" alt="image-20210310151814511"></p></li><li><p>单一继承并含虚拟函数情况下的数据布局</p><p> <img src="image-20210310151910413.png" alt="image-20210310151910413"></p></li><li><p>多重继承</p><p> <img src="image-20210310152020878.png" alt="image-20210310152020878"></p><p> <img src="image-20210310152043648.png" alt="image-20210310152043648"></p></li><li><p>虚拟继承，使用<code>pointer strategy</code>和<code>virtual table offset strategy</code></p><p> <img src="image-20210310152208905.png" alt="image-20210310152208905"></p><p> <img src="image-20210310152330536.png" alt="image-20210310152330536"></p><p> <img src="image-20210310152521106.png" alt="image-20210310152521106"></p></li></ol><h5 id="3-5-指向data-member成员的指针"><a href="#3-5-指向data-member成员的指针" class="headerlink" title="3.5 指向data member成员的指针"></a><code>3.5</code> 指向<code>data member</code>成员的指针</h5><p>取一个<code>nonstatic data member</code>的地址，将会得到它在<code>class</code>中的<code>offset</code>（指针类型为<code>data_type class_type::*</code>），取一个“绑定于真正<code>class object</code>身上的<code>data member</code>”的地址，将会得到该<code>member</code>在内存中的真正地址（指针类型为<code>data_type*</code>）。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之构造函数语意学</title>
      <link href="/FXn6nXyz1FEw9e8Y/"/>
      <url>/FXn6nXyz1FEw9e8Y/</url>
      
        <content type="html"><![CDATA[<h4 id="第2章：构造函数语意学"><a href="#第2章：构造函数语意学" class="headerlink" title="第2章：构造函数语意学"></a>第<code>2</code>章：构造函数语意学</h4><p>在这一章中，主要介绍编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”的冲击。</p><h5 id="2-1-Default-Constructor的构造操作"><a href="#2-1-Default-Constructor的构造操作" class="headerlink" title="2.1 Default Constructor的构造操作"></a><code>2.1</code> <code>Default Constructor</code>的构造操作</h5><p>对于未声明构造函数的类，只有在以下四种情况下编译器才会为它们合成默认构造函数：</p><ul><li>类有一个类对象（<code>Member Class Object</code>）成员，且该成员含有默认构造函数（<code>Default Constructor</code>）</li><li>继承自带有默认构造函数（<code>Default Constructor</code>）的基类（<code>Base class</code>）</li><li>带有虚函数（<code>Virtual function</code>）的类</li><li>继承自虚基类（<code>Virtual base class</code>）的类</li></ul><a id="more"></a><p>对于以上四种情况，<code>C++</code>标准把合成的默认构造函数叫隐式的有意义默认构造函数(<code>implicit nontrivial default constructors</code>)。被合成的构造函数只能满足编译器（而非程序）的需要，它之所以能够完成任务，是借着调用成员对象或基类的默认构造函数（情况<code>1/2</code>），或是为每一个对象初始化其虚函数机制或虚基类机制（情况<code>3/4</code>）。</p><p>至于没有存在上述四种情况，而又没有声明任何构造函数的类，那么它们拥有的是隐式无意义默认构造函数(<code>implicit trivial default constructors</code>)，实际上它们并不会被合成出来。</p><p><code>Default Constructor</code>会在<strong>编译器需要</strong>的时候被产生出来，被合成出来的<code>Constructor</code>只执行编译器所需要的行为。如果程序有需要，定制<code>Default Constructor</code>的行为是程序员的责任。</p><ol><li><p>“带有<code>Default Constructor</code>”的<code>Member Class Object</code></p><p> 如果有多个<code>class member objects</code>都要求<code>constructor</code>初始化操作，将如何呢？<code>C++</code>语言要求以“<code>member objects</code>在<code>class</code>中的声明次序”来调用各个<code>constructors</code>。这一点由编译器完成，它为每一个<code>constructor</code>安插程序代码，以“<code>member</code>声明次序”调用每一个<code>member</code>所关联的<code>default constructors</code>。这些码将被安插在<code>explicit user code</code>之前。举个例子：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dopey</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dopey();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneezy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sneezy(<span class="keyword">int</span>);</span><br><span class="line">    Sneezy();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bashful</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bashful();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snow_White</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Dopey dopey;</span><br><span class="line">    Sneezy sneezy;</span><br><span class="line">    Bashful bashful;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 如果<code>Snow_White</code>没有定义<code>default constructor</code>，就会有一个<code>nontrivial constructor</code>被合成出来，依序调用<code>Dopey</code>、<code>Sneezy</code>、<code>Bashful</code>的<code>default constructors</code>。然而如果<code>Snow_White</code>定义了下面这样的<code>default constructor</code>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序员所写的 default constructor</span></span><br><span class="line">Snow_White::Snow_White() : sneezy(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 它会被扩张为：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器扩张后的 C++ 伪码</span></span><br><span class="line">Snow_White::Snow_White()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用其 constructor</span></span><br><span class="line">    dopey.Dopey::Dopey();</span><br><span class="line">    Sneezy.Sneezy::Sneezy(<span class="number">1024</span>);</span><br><span class="line">    bashful.Bashful::Bashful();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// explicit user code</span></span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>“带有<code>Default Constructor</code>”的<code>Base Class</code></p><p> 类似的道理，如果一个没有任何<code>constructors</code>的<code>class</code>派生自一个“带有<code>default constructor</code>”的<code>base class</code>，那么这个<code>derived class</code>的<code>default constructor</code>会被视为<code>nontrivial</code>，并因此需要被合成出来。它将调用上一层<code>base classes</code>的<code>default constructor</code>（根据它们的声明次序）。对一个后继派生的<code>class</code>而言，这个合成的<code>constructor</code>和一个“被明确提供的<code>default constructor</code>”没有什么差异。</p><p> 如果设计者提供多个<code>constructors</code>，但其中都没有<code>default constructor</code>呢？编译器会扩张现有的每一个<code>constructors</code>，将“用以调用所有必要之<code>default constructors</code>”的程序代码加进去。它不会合成一个新的<code>default constructor</code>，这是因为其它“由<code>user</code>所提供的<code>constructors</code>”存在的缘故。如果同时亦存在着“带有<code>default constructors</code>”的<code>member class objects</code>，那些<code>default constructor</code>也会被调用。</p></li><li><p>“带有（声明或继承）一个<code>Virtual Function</code>”的<code>Class</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">const</span> Widget&amp; widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    widget.flip();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 Bell 和 Whistle 都派生自 Widget</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line">    </span><br><span class="line">    flip(b);</span><br><span class="line">    flip(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 下面两个扩张操作会在编译期间发生：</p><ol><li><p>一个<code>virtual function table</code>会被编译器产生出来，内放<code>class</code>的<code>virtual functions</code>地址。</p></li><li><p>在每一个<code>class object</code>中，一个额外的<code>pointer member</code>会被编译器合成出来，内含相关的<code>class vtbl</code>的地址。</p><p>此外，<code>widget.flip()</code>的虚拟引发操作会被重新改写，以使用<code>widget</code>的<code>vptr</code>和<code>vtbl</code>中的<code>flip()</code>条目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 表示 flip() 在 virtual table 的固定索引</span></span><br><span class="line"><span class="comment">// &amp;widget 代表要交给"被调用的某个 flip() 实体"的 this 指针</span></span><br><span class="line">(*widget.vptr[<span class="number">1</span>])(&amp;widget));</span><br></pre></td></tr></table></figure><p>为了让这个机制发挥功效，编译器必须为每一个<code>Widget</code>（或其派生类之）<code>object</code>的<code>vptr</code>设定初值，放置适当的<code>virtual table</code>地址。对于<code>class</code>所定义的每一个<code>constructor</code>，编译器会安插一些码来做这样的事情。对于那些未声明任何<code>constructors</code>的<code>classes</code>，编译器会为它们合成一个<code>default constructor</code>，以便正确地初始化每一个<code>class object</code>的<code>vptr</code>。</p></li></ol></li><li><p>“带有一个<code>Virtual Base Class</code>”的<code>Class</code></p><p> 编译器必须使<code>virtual base class</code>在其每一个<code>derived class object</code>中的位置，能够在执行期准备妥当。一种可能的做法是在<code>derived class</code>中安插一个指向每一个<code>virtual base class</code>的指针，所有“经由<code>reference</code>和<code>pointer</code>来存取其中<code>virtual base class</code>中数据的操作”都通过此指针完成。</p><p> 同样地，这个<code>virtual base class</code>指针是在<code>class object</code>构建期间完成的，编译器的默认行为和<code>3</code>中的<code>vptr</code>的处理方式一样。</p></li></ol><h5 id="2-2-Copy-Constructor的构造操作"><a href="#2-2-Copy-Constructor的构造操作" class="headerlink" title="2.2 Copy Constructor的构造操作"></a><code>2.2</code> <code>Copy Constructor</code>的构造操作</h5><p>有三种情况会调用<code>copy constructor</code>：</p><ul><li><p>对一个<code>class object</code>做明确的初始化操作</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>...&#125;;</span><br><span class="line">X x;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">xx</span><span class="params">(x)</span></span>;</span><br><span class="line">X xx = x;</span><br></pre></td></tr></table></figure></li><li><p>当<code>class object</code>被当作参数交给某个函数时</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    foo(xx);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当函数返回一个<code>class object</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p><code>Default Memberwise Initialization</code></p><p> 如果<code>class</code>没有提供一个<code>explicit copy constructor</code>又当如何？当<code>class object</code>以“相同<code>class</code>的另一个<code>object</code>”作为初值时，其内部是以所谓的<code>default memberwise initialization</code>完成的，也就是把每一个内建的或派生的<code>data member</code>的值，从某个<code>object</code>拷贝一份到另一个<code>object</code>身上。不过它并不会拷贝其中的<code>member class object</code>，而是以递归的方式施行<code>memberwise initialization</code>。</p><p> 一个良好的编译器可以为大部分<code>class objects</code>产生<code>bitwise copies</code>，因为它们有<code>bitwise copy semantics</code>。<code>copy constructors</code>在<strong>必要的时候</strong>才由编译器产生出来。这个句子中的“必要”意指当<code>class</code>不展现<code>bitwise copy semantics</code>时。</p></li><li><p><code>Bitwise Copy Semantics</code></p><p> <code>C++ Standard</code>把<code>copy constructor</code>区分为<code>trivial</code>和<code>nontrivial</code>两种。只有<code>nontrivial</code>的实体才会被合成于程序之中。决定一个<code>copy constructor</code>是否为<code>trivial</code>的标准在于<code>class</code>是否展现出所谓的“<code>bitwise copy semantics</code>”。</p><p> 什么时候一个class不展现出<code>Bitwise Copy Semantics</code>呢？</p><ul><li><p>当<code>class</code>内含一个<code>member object</code>而后者的<code>class</code>声明有一个<code>copy constructor</code>时（不论是被<code>class</code>设计者明确地声明；或是被编译器合成）。</p></li><li><p>当<code>class</code>继承自一个<code>base class</code>而后者存在有一个<code>copy constructor</code>（再次强调，不论是被明确声明或是被合成而得）。</p></li><li><p>当<code>class</code>声明了一个或多个<code>virtual functions</code>时。</p></li><li><p>当<code>class</code>派生自一个继承串链，其中有一个或多个<code>virtual base classes</code>时。</p><p>有一点很值得注意：在被合成出来的<code>copy constructor</code>中，如整数、指针、数组等等的<code>nonclass members</code>也都会被复制。</p></li></ul></li><li><p>重新设定<code>virtual table</code>的指针<code>vptr</code></p><p> 当编译器导入一个<code>vptr</code>到<code>class</code>之中时，该<code>class</code>就不再展现<code>bitwise semantics</code>了。编译器需要合成出一个<code>copy constructor</code>，以求将<code>vptr</code>适当地初始化。</p><p> <code>base class object</code>以另一个<code>base class object</code>作为初值，或<code>derived class object</code>以另一个<code>derived  class object</code>作为初值，都可以直接靠“<code>bitwise copy semantics</code>”完成。当一个<code>base class object</code>以其<code>derived class</code>的<code>object</code>内容做初始化操作时，其<code>vptr</code>复制操作必须保证安全。此时，合成出来的<code>base copy constructor</code>会明确设定<code>object</code>的<code>vptr</code>指向<code>base class</code>的<code>virtual table</code>，而不是直接从右手边的<code>class object</code>中将其<code>vptr</code>现值拷贝过来。</p></li><li><p>处理<code>virtual base class subject</code></p><p> 和<code>3</code>同理，需要合成<code>copy constructor</code>来明确的设定<code>virtual base class pointer</code>的初值。</p></li></ol><h5 id="2-3-程序转化语意学"><a href="#2-3-程序转化语意学" class="headerlink" title="2.3 程序转化语意学"></a><code>2.3</code> 程序转化语意学</h5><p>已知有这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X x0;</span><br></pre></td></tr></table></figure><p>下面有三个定义，每一个都明显地以<code>x0</code>来初始化其<code>class object</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">xl</span><span class="params">(x0)</span></span>;</span><br><span class="line">    X x2 = x0;</span><br><span class="line">    X x3 = X(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必要的程序转化有两个阶段：</p><ol><li>重写每一个定义，其中的初始化操作会被剥除。</li><li><code>class</code>的<code>copy constructor</code>调用操作会被安插进去。</li></ol><p>举个例子，在明确的双阶段转化之后，<code>foo_bar()</code>可能看起来像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能的程序转换</span></span><br><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意没有初始化操作</span></span><br><span class="line">    X x1;</span><br><span class="line">    X x2;</span><br><span class="line">    X x3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译器安插X copy construction的调用操作</span></span><br><span class="line">    x1.X::X(x0);</span><br><span class="line">    x2.X::X(x0);</span><br><span class="line">    x3.X::X(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>参数的初始化</p><p>  把一个<code>class object</code>当做参数传给一个函数，相当于以下形式的初始化操作：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx 代表形式参数, arg 代表真正的参数值</span></span><br><span class="line">X xx = arg;</span><br></pre></td></tr></table></figure></li><li><p>返回值的初始化</p><p>  已知下面这个函数定义：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 处理 xx ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里有一个双阶段转化：</p><ol><li><p>首先加上一个额外参数，类型是<code>class object</code>的一个<code>reference</code>。这个参数将用来放置被“拷贝建构（<code>copy constructed</code>）”而得的返回值。</p></li><li><p>在<code>return</code>指令之前安插一个<code>copy constructor</code>调用操作，以便将欲传回之<code>object</code>的内容当做上述新增参数的初值。</p><p>根据这样的算法，<code>bar()</code>转换如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 编译器所产生的 default constructor 调用操作</span></span><br><span class="line">    xx.X::X();</span><br><span class="line">    <span class="comment">// ... 处理 xx</span></span><br><span class="line">    <span class="comment">// 编译器所产生的 copy constructor</span></span><br><span class="line">    result.X::X(xx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在编译器必须转换每一个<code>bar()</code>调用操作，以反映其新定义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X xx = bar();</span><br></pre></td></tr></table></figure><p>将被转换为下列两个指令句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意, 不必施行 default constructor</span></span><br><span class="line">X xx;</span><br><span class="line">bar(xx);</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>NRV</code>优化</p><p>  已知下面这个函数定义：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 处理 xx ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  编译器会把它优化为：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  default constructor 调用操作</span></span><br><span class="line">    _result.X::X();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 直接处理 _result</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>只有当程序提供了<code>explicit copy constructor</code>，编译器才会实施<code>NRV</code>优化。没有提供的话（编译器自己合成的），是不会实施<code>NRV</code>优化的。</strong></p></li><li><p><code>copy constructor</code>要还是不要？</p><p>  对于下面的<code>3D</code>坐标点类，这个<code>class</code>的设计者应该提供一个<code>explicit copy constructor</code>吗？</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  除非你预见该<code>class</code>需要大量的<code>memberwise</code>初始化操作，例如函数以传值（<code>by value</code>）的方式传回<code>objects</code>，那么提供一个<code>copy constructor</code>的<code>explicit inline</code>函数实体就非常合理——可以激活编译器提供的<code>NRV</code>优化。否则，不提供<code>explicit copy constructor</code>既快速又安全。</p></li></ul><h5 id="2-4-Member-initialization-list"><a href="#2-4-Member-initialization-list" class="headerlink" title="2.4 Member initialization list"></a><code>2.4</code> <code>Member initialization list</code></h5><p>为了让你的程序能够被顺利编译，必须使用<code>member initialization list</code>的情况：</p><ol><li>当初始化一个<code>refercnce member</code>时；</li><li>当初始化一个<code>const member</code>时；</li><li>当调用一个<code>base class</code>的<code>constructor</code>，而它拥有一组参数时；</li><li>当调用一个<code>member class</code>的<code>constructor</code>，而它拥有一组参数时。</li></ol><p>在这四种情况之外，不使用<code>member initialization list</code>，程序可以被正确编译并执行，但是效率不彰。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Word()</span><br><span class="line">    &#123;</span><br><span class="line">        _name = <span class="number">0</span>;</span><br><span class="line">        _cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String _name;</span><br><span class="line">    <span class="keyword">int</span> _cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是编译器对<code>constructor</code>可能的内部扩张结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line">Word::Word(<span class="comment">/* this pointer goes here */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 String default constructor</span></span><br><span class="line">    _name.String::String();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产生临时性对象</span></span><br><span class="line">    String temp = String(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// memberwise 地拷贝 _name</span></span><br><span class="line">    _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 摧毁暂时性对象</span></span><br><span class="line">    temp.String::~String();</span><br><span class="line">    </span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更有效率的实现方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 较佳的方式</span></span><br><span class="line">Word::Word : _name(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会被扩张成这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line">Word::Word(<span class="comment">/* this pointer goes here */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 String(int) constructor</span></span><br><span class="line">    _name.String::String(<span class="number">0</span>);</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会一一操作<code>initialization list</code>，以<code>member</code><strong>声明次序</strong>（不是由<code>initialization list</code>中的排列次序决定的）在<code>constructor</code>之内的<strong><code>explicit user code</code>之前</strong>安插初始化操作。</p><p>调用一个<code>member function</code>以设定一个<code>member</code>的初值是可以的，因为此时<code>this</code>指针已经被构造妥当。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// X::xfoo() 被调用</span></span><br><span class="line">X::X(<span class="keyword">int</span> val) : i(xfoo(val)), j(val)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会被扩张为</span></span><br><span class="line">X::X(<span class="comment">/* this pointer */</span>, <span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="keyword">this</span>-&gt;xfoo(val);</span><br><span class="line">    i = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果一个<code>derived class member function</code>被调用，其返回值被当做<code>base class constructor</code>的一个参数，这不是一个好主意！！！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型之前言</title>
      <link href="/jOQUhpad0yAY7aMb/"/>
      <url>/jOQUhpad0yAY7aMb/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>Simplifier</code>是编译器的一部分，处于<code>type checking</code>和<code>code generation</code>之间。它用来转换内部的程序表现。有<code>3</code>种转换是任何对象模型都需要的：</p><ol><li><p>与编译器息息相关的转换（<code>Implementation-dependent transformations</code>）</p><p> 例如，当<code>parser</code>看到这个表达式：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fct();</span><br></pre></td></tr></table></figure><p> 它并不知道是否（<code>a</code>）这是一个函数调用操作，或者（<code>b</code>）这是<code>overloaded calloperator</code>在<code>class object fct</code>上的一种应用。默认情况下，这个式子所代表的是一个函数调用，但是当（<code>b</code>）的情况出现，<code>Simplifier</code>就要重写并调换<code>call subtree</code>。</p></li><li><p>语言语意转换（<code>Language semantics transformations</code>）</p><p> 这包括<code>constructor</code>/<code>destructor</code>的合成和扩展、<code>memberwise</code>初始化、对于<code>memberwise copy</code>的支持、在程序代码中安插<code>conversion operators</code>、临时性对象，以及对<code>constructor</code>/<code>destructor</code>的调用。</p></li><li><p>程序代码和对象模型的转换（<code>Code and object model transformations</code>）</p><p> 这包括对<code>virtual functions</code>、<code>virtual base class</code>和<code>inheritance</code>的一般支持、<code>new</code>和<code>delete</code>运算符、<code>class objects</code>所组成的数组、<code>local static class instances</code>、带有非常量表达式（<code>nonconstant cxpression</code>）之<code>global object</code>的静态初始化操作。</p></li></ol><p>什么是<code>C++</code>对象模型？</p><ul><li>语言中直接支持面向对象程序设计的部分</li><li>对于各种支持的底层实现机制</li></ul><a id="more"></a><h4 id="第1章：关于对象"><a href="#第1章：关于对象" class="headerlink" title="第1章：关于对象"></a>第<code>1</code>章：关于对象</h4><p>在<code>C</code>语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。</p><p><code>C++</code>在布局以及存取时间上主要的额外负担是由<code>virtual</code>引起，包括：</p><ol><li><code>virtual function</code>机制——用以支持一个有效率的“执行期绑定”</li><li><code>virtual base class</code>——用以实现“多次出现在继承体系中的<code>base class</code>，有一个单一而被共享的实体”</li><li>此外，还有一些多重继承下的额外负担，发生在“一个<code>derived class</code>和其第二或后继之<code>base class</code>的转换”之间。</li></ol><h5 id="1-1-C-对象模型"><a href="#1-1-C-对象模型" class="headerlink" title="1.1 C++对象模型"></a><code>1.1</code> <code>C++</code>对象模型</h5><p>在<code>C++</code>中，有两种<code>class data members</code>：<code>static</code>和<code>nonstatic</code>，以及三种<code>class member functions</code>：<code>static</code>、<code>nonstatic</code>和<code>virtual</code>。</p><p>在<code>C++</code>对象模型中，<code>nonstatic data members</code>被配置于每一个<code>class object</code>之内，<code>static data members</code>则被存放在所有的<code>class object</code>之外。<code>static</code>和<code>nonstatic function members</code>也被放在所有的<code>class object</code>之外。<code>virtual functions</code>则以两个步骤支持之：</p><ol><li>每一个<code>class</code>产生出一堆指向<code>virtual functions</code>的指针，放在表格之中。这个表格被称为 <code>vtbl</code>。</li><li>每一个<code>class object</code>被添加了一个指针，指向相关的<code>virtual table</code>。通常这个指针被称为<code>vptr</code>。<code>vptr</code>的设定（<code>setting</code>）和重置（<code>resetting</code>）由每一个<code>class</code>的<code>constructor</code>、<code>destructor</code>和<code>copy assignment</code>运算符自动完成。</li></ol><p>在虚拟继承的情况下，<code>base class</code>不管在继承串链中被派生（<code>derived</code>）多少次，永远只会存在一个实体（称为<code>subobject</code>）。</p><p><code>C++</code>最初采用的继承模型并不运用任何间接性: <code>base class subobject</code>的<code>data members</code>被直接放置于<code>derived class object</code>中。这提供了对<code>base class members</code>最紧凑而且最有效率的存取。缺点就是: <code>base class members</code>的任何改变，包括增加﹑移除或改变类型等等，都使得所有用到“此<code>base class</code>或其<code>derived class</code>之<code>objects</code>”者重新编译。</p><p><code>virtual base class</code>的原始模型是在<code>class object</code>中为每一个有关联的<code>virtual base class</code>加上一个指针。</p><p>对象模型如何影响程序？</p><p>不同的对象模型，会导致“现有的程序代码必须修改”以及“必须加人新的程序代码”两个结果。例如下面这个函数，其中<code>class X</code>定义了一个<code>copy constructor</code>，一个<code>virtual destructor</code>，和一个<code>virtual function foo</code>：</p><img src="image-20210219212057818.png" alt="image-20210219212057818" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foobar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    X* px = <span class="keyword">new</span> X;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// foo 是一个虚函数</span></span><br><span class="line">    xx.foo();</span><br><span class="line">    px-&gt;foo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> px;</span><br><span class="line">    <span class="keyword">return</span> xx; <span class="comment">// 这里会用到 copy constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有可能在内部被转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(X&amp; _result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造 _result</span></span><br><span class="line">    <span class="comment">// _result 用来取代 local xx...</span></span><br><span class="line">    _result.X::X();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 ×* px= new x;</span></span><br><span class="line">    px = _new(<span class="keyword">sizeof</span>(X));</span><br><span class="line">    <span class="keyword">if</span>(px != <span class="number">0</span>)</span><br><span class="line">        px-&gt;X::X();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 xx.foo() 但不使用 virtual 机制</span></span><br><span class="line">    <span class="comment">// 以 _result 取代 xx</span></span><br><span class="line">    foo(&amp;_result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 virtual 机制扩展 px-&gt;foo()</span></span><br><span class="line">    (*px-&gt;vtbl[<span class="number">2</span>])(px);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 delete px;</span></span><br><span class="line">    <span class="keyword">if</span>(px != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (*px-&gt;vtbl[<span class="number">1</span>])(px); <span class="comment">// destructor</span></span><br><span class="line">        _delete(px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需使用 named return statement</span></span><br><span class="line">    <span class="comment">//不需要摧毁 local object xx</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-关键词所带来的差异"><a href="#1-2-关键词所带来的差异" class="headerlink" title="1.2 关键词所带来的差异"></a><code>1.2</code> 关键词所带来的差异</h5><ul><li>掌握<code>struct</code>和<code>class</code>关键字的差异</li></ul><p><code>struct</code>关键词的使用实现了<code>C</code>的数据萃取概念，而<code>class</code>关键词实现的是<code>C++</code>的<code>ADT</code>（<code>Abstract Data Type</code>）概念。</p><p><code>C</code>程序员的巧计（<code>C++</code>中不可用）。例如把单一元素的数组放在一个<code>struct</code>的尾端，于是每个<code>struct objects</code>可以拥有可变大小的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// stuff</span></span><br><span class="line">    <span class="keyword">char</span> pc[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从档案或标准输入装置中取得一个字符串 str</span></span><br><span class="line"><span class="comment">// 然后为 struct 本身和该字符串配置足够的内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span> *<span class="title">pmumble</span> = (<span class="title">struct</span> <span class="title">mumble</span>*)</span></span><br><span class="line"><span class="class">                         <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">mumble</span>) + <span class="title">strlen</span>(<span class="title">str</span>) + 1);</span></span><br><span class="line"><span class="built_in">strcpy</span>(&amp;(pmumble-&gt;pc), str);</span><br></pre></td></tr></table></figure><p><code>C++</code>中凡处于同一个<code>access section</code>的数据，必定保证以其声明次序出现在内存布局当中。然而被放置在多个<code>access sections</code>中的各笔数据，排列次序就不一定了。组合（<code>composition</code>)，而非继承，才是把<code>C</code>和<code>C++</code>结合在一起的唯一可行方法（<code>conversion</code>运算符提供了一个十分便利的萃取方法）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C_point</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">C_point</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c_point_; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    C_point c_point_;</span><br></pre></td></tr></table></figure><p><code>C struct</code>在<code>C++</code>中的一个合理用途，是当你要传递“一个复杂的<code>class object</code>的全部或部分”到某个<code>C</code>函数中去时，<code>struct</code>声明可以将数据封装起来，并保证拥有与<code>C</code>兼容的空间布局。然而这项保证只在组合的情况下才存在。</p><h5 id="1-3-对象的差异"><a href="#1-3-对象的差异" class="headerlink" title="1.3 对象的差异"></a><code>1.3</code> 对象的差异</h5><p><code>C++</code>支持<code>3</code>种程序设计模型：</p><ol><li>程序模型（面向过程）</li><li>抽象数据类型模型（基于对象模型）（封装）</li><li>面向对象模型（继承、多态）</li></ol><p>在<code>C++</code>，多态只存在于一个个的<code>public class</code>体系中。<code>nonpublic</code>的派生行为以及类型为<code>void*</code>的指针可以说是多态，但它们并没有被语言明白地支持，也就是说它们必须由程序员通过明白的<strong>转型操作</strong>来管理。<code>C++</code>以下列方法支持多态：</p><ol><li><p>经由一组隐含的转化操作。例如把一个<code>derived class</code>指针转化为一个指向其<code>public base type</code>的指针</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure></li><li><p>经由<code>virtual function</code>机制</p></li><li><p>经由<code>dynamic_cast</code>和<code>typeid</code>运算符</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Circle* pc = <span class="keyword">dynamic_cast</span>&lt;Circle*&gt;(ps))</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol><p><code>virtual function</code>机制不只使得“当类型有所增加、修改、或删减时，我们的程序代码不需改变”。而且也使一个新的<code>subtype</code>的供应者不需要重新写出“对继承体系中的所有类型都共通”的行为和操作。</p><p>需要多少内存才能够表现一个<code>class object</code>？</p><ul><li><code>nonstatic data members</code>的总和大小</li><li>加上任何<code>alignment</code>（内存对齐）</li><li>加上为了支持<code>virtual</code>（<code>function</code>，<code>base class</code>）而由内部产生的额外负担</li></ul><p>转型（<code>cast</code>）其实是一种编译器指令。<strong>大部分情况下</strong>它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。</p><p>一个<code>Base</code>指针<code>pb</code>和一个<code>Derived</code>指针<code>pd</code>有什么不同？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;</span><br><span class="line">Derived* pd = &amp;d;</span><br></pre></td></tr></table></figure><p>它们每个都指向<code>Base object</code>的第一个<code>byte</code>。其间的差别是，<code>pd</code>所涵盖的地址包含整个<code>Derived object</code>，而<code>pb</code>所涵盖的地址只包含<code>Derived object</code>中的<code>Base subobject</code>。</p><p>除了<code>Base subobject</code>中出现的<code>members</code>，你不能使用<code>pb</code>来直接处理<code>Derived</code>的任何<code>members</code>。例外是通过<code>virtual</code>机制或转型操作。</p><p>当一个<code>base class object</code>被直接初始化为（或是被指定为）一个<code>derived class object</code>时，<code>derived object</code>就会被切割，以塞人较小的<code>base type</code>内存中，<code>derived type</code>将没有留下任何蛛丝马迹。</p><p>下面这一组定义，其可能的内存布局为：</p><img src="image-20210220202640585.png" alt="image-20210220202640585" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal za;</span><br><span class="line">ZooAnimal *pza;</span><br><span class="line">Bear b;</span><br><span class="line">Panda* pp = <span class="keyword">new</span> Panda;</span><br><span class="line">pza = &amp;b;</span><br></pre></td></tr></table></figure><img src="image-20210220153355200.png" alt="image-20210220153355200" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之模板与泛型编程</title>
      <link href="/MBICE5WlMJtd4Rku/"/>
      <url>/MBICE5WlMJtd4Rku/</url>
      
        <content type="html"><![CDATA[<h4 id="第7章：模板与泛型编程"><a href="#第7章：模板与泛型编程" class="headerlink" title="第7章：模板与泛型编程"></a>第<code>7</code>章：模板与泛型编程</h4><h5 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款<code>41</code>：了解隐式接口和编译期多态</h5><ul><li><p>哪一个重载函数被调用——发生在编译期</p></li><li><p>哪一个<code>virtual</code>函数被绑定——发生在运行期</p></li><li><p><code>class</code>和<code>template</code>都支持接口和多态</p><p>  对<code>class</code>而言，接口是显式的，以成员函数的签名为中心，多态则通过<code>virtual</code>函数发生在运行期。对<code>template</code>而言，接口是隐式的，以有效表达式为中心，多态则通过<code>template</code>具现化和函数重载解析发生于编译期。</p></li></ul><a id="more"></a><h5 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款<code>42</code>：了解<code>typename</code>的双重意义</h5><ul><li><p>当我们声明模板类型参数，<code>class</code>和<code>typename</code>的意义完全相同</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>typename</code>用来标识嵌套从属类型名称</p><p>  <code>template</code>内出现的名称如果相依于某个<code>template</code>参数，称这个名称为从属名称，如果丛属名称在<code>class</code>内呈嵌套状，称为嵌套从属名称。如果嵌套从属名称还指涉某种类型名称为嵌套从属类型名称</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::iterator_traits&lt;IterT&gt;::value_type 就是嵌套从属类型名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须使用 typename 关键字标识</span></span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 typedef 少打几个字</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须使用 typename 关键字标识</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不允许在<code>base class list</code>或<code>member initialization list</code>内使用<code>typename</code>作为<code>base class</code>的标识符</p></li></ul><h5 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款<code>43</code>：学习处理模板化基类内的名称</h5><p>假设我们需要撰写一个<code>MsgSender</code>类，它能够传送信息到若干不同的<code>Company</code>去。信息要不进行加密后的密文，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于<code>template</code>的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 针对其他公司设计的 class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgInfo</span> &#123;</span>...&#125;; <span class="comment">// 这个 class 以备将来产生信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">//构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">        ... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.sendCleartext(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">        ... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.sendEncrypted(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在假设我们想要在每次送出信息时<code>log</code>某些信息。<code>derived class</code>可轻易提供解决方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">        sendClear(info); <span class="comment">// 调用 base class 函数, 这段码无法通过编译!</span></span><br><span class="line">        ... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译器会抱怨<code>sendClear</code>函数不存在，明明在那里，为什么？</p><p>问题在于，当编译器看见<code>class template LoggingMsgSender</code>定义式时，并不知道它继承什么样的<code>class</code>。当然它继承的是<code>MsgSender&lt;Company&gt;</code>，但其中的<code>Company</code>是个<code>template</code>参数，不当<code>LoggingMsgSender</code>被具现化之前无法确切知道它是什么。而如果不知道<code>Company</code>是什么，就无法知道<code>class MsgSender&lt;Company&gt;</code>看起来像什么——更明确地说是没办法知道它是否有个<code>sendClear</code>函数。</p><p>具体点说，假设现在有个<code>CompanyZ</code>坚持只使用加密通讯：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不提供 sendCleartext 函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyZ</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般性的<code>MsgSender template</code>对<code>CompanyZ</code>并不合适，因为那个<code>template</code>提供了一个<code>sendClearMsg</code>函数，而这对<code>CompanyZ</code>对象并不合理。欲矫正这个问题，我们可以针对<code>CompanyZ</code>产生一个<code>MsgSender</code>特化版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全特化版本只提供 sendSecret 函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&lt;CompanyZ&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">//构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">        ... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">        c.sendEncrypted(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就解释了前面编译器拒绝那个调用的原因：它知道<code>base class template</code>有可能被特化，而那个特化版本可能不提供和一般性<code>template</code>相同的接口。因此它往往拒绝在<code>templatized base class</code>（本例的<code>MsgSender&lt;Company&gt;</code>）内寻找继承而来的名称（本例的<code>SendClear</code>)。</p><ul><li>当我们从<code>Object Oriented C++</code>跨进<code>Template C++</code>（见条款<code>1</code>) ，继承就不像以前那样畅行无阻了</li></ul><p>有三个解决令<code>C++</code>编译器“不进入<code>templatized base class</code>观察”的行为失效的办法：</p><ol><li><p>使用<code>this</code>指针</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">        ... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>using</code>声明</p><p> 虽然<code>using</code>声明式在在条款<code>33</code>或在这里都可有效运作，但两处解决的问题其实不相同。前者是<code>base class</code>名称被<code>derived class</code>名称遮掩，而后者是编译器不进入<code>base class</code>作用域内查找，于是我们通过<code>using</code>告诉它，请它那么做。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">    ... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">        sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">        ... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用作用域运算符<code>::</code>明确指定</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">        MsgSender&lt;Company&gt;::sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">        ... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>即使如此，如果稍后这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoggingMsgSender&lt;Companyz&gt;zMsgSender;</span><br><span class="line">MsgInfo msgData;</span><br><span class="line">...</span><br><span class="line">zMsgSender.sendClearMsg(msgData); <span class="comment">// 仍然无法通过编译</span></span><br></pre></td></tr></table></figure><p>其中对<code>sendClearMsg</code>的调用动作将无法通过编译，因为在那个点上，编译器知道<code>base class</code>是个<code>template</code>特化版本<code>MsgSender&lt;CompanyZ&gt;</code>，而且它知道那个<code>class</code>不提供<code>sendClear</code>函数，而<code>sendClear</code>却是<code>sendClearMsg</code>尝试调用的函数。 </p><h5 id="条款44：将与基类无关的代码抽离template"><a href="#条款44：将与基类无关的代码抽离template" class="headerlink" title="条款44：将与基类无关的代码抽离template"></a>条款<code>44</code>：将与基类无关的代码抽离<code>template</code></h5><p>当你编写某个函数，其中某些部分的实现码和另一个函数的实现码实质相同，你会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。如果你正在编写某个<code>class</code>，而你明白其中某些部分和另一个<code>class</code>的某些部分相同，你也不会重复这共同的部分。你会把共同部分搬移到新<code>class</code>去，然后使用继承或复合（见条款<code>32</code>，<code>38</code>，<code>39</code>) ，令原先的<code>class</code>取用这共同特性。而原<code>class</code>的互异部分仍然留在原位置不动。</p><p>编写<code>template</code>时，也是做相同的分析，以相同的方式避免重复。然而在<code>template</code>代码中，重复是隐晦的：毕竟只存在一份<code>template</code>源码，所以你必须训练自己去感受当<code>template</code>被具现化多次时可能发生的重复。</p><p>举个例子，假设你想为固定尺寸的正方矩阵编写一个<code>template</code>。该矩阵的性质之一是支持逆矩阵运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template 支持 n x n 矩阵, 元素类型为 T</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">squareMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">( )</span></span>; <span class="comment">// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; sml;</span><br><span class="line">...</span><br><span class="line">sm1.invert(); <span class="comment">// 调用 SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">sSquareMatrix&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.invert(); <span class="comment">// 调用 SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure><p>这会具现化两份<code>invert</code>。这些函数并非完完全全相同，因为其中一个操作的是<code>5x5</code>矩阵而另一个操作的是<code>10x10</code>矩阵，但除了常量<code>5</code>和<code>10</code>，两个函数的其他部分完全相同。这是<code>template</code>引出代码膨胀的一个典型例子。</p><p>第一次修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与尺寸无关的 base class</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">size_t</span> matrixSize)</span> <span class="comment">// 以给定的尺寸求逆矩阵</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明为 private 是为了不让客户看见</span></span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert; <span class="comment">// 避免遮掩 base 版的 invert, 见条款 33</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invert(n);<span class="comment">// inline 调用 base class 版的 invert</span></span><br><span class="line">        <span class="comment">// 为什么这儿出现 this-&gt; 见条款 43</span></span><br><span class="line">        <span class="comment">// LYL 认为前面已经使用了 using, this-&gt; 应该也不需要了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>base class</code>只是为了帮助<code>derived class</code>实现，不是为了表现<code>SquareMatrix</code>和<code>SquareMatrixBase</code>之间的<code>is-a</code>关系（关于<code>private</code>继承，见条款<code>39</code>)。</p><p>目前为止一切都好，但还有一些棘手的题目没有解决。<code>SquareMatrixBase::invert</code>如何知道该操作什么数据？虽然它从参数中知道矩阵尺寸，但它如何知道哪个特定矩阵的数据在哪儿？想必只有<code>derived class</code>知道。<code>derived class</code>如何联络其<code>base class</code>做逆运算动作？一个可能的做法是为<code>SquareMatrixBase::invert</code>添加另一个参数，可以是个指针，指向一块用来放置矩阵数据的内存地址。</p><p>第二次修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 存储矩阵大小和一个指针, 指向矩阵数值</span></span><br><span class="line">    squareMatrixBase(<span class="keyword">size_t</span> n, T* pMem) : size(n), pData(pMem) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span> <span class="comment">// 不用指定尺寸了</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> size; <span class="comment">// 矩阵的大小</span></span><br><span class="line">    T* pData; <span class="comment">// 指针, 指向矩阵内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SquareMatrix() : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n * n];<span class="comment">// 这里直接将数据矩阵存储在 SquareMatrix 对象内部</span></span><br><span class="line">                    <span class="comment">// 也可以使用动态内存分配的方案</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个条款只讨论由<code>non-type template parameter</code>（非类型模板参数）带来的膨胀，其实<code>type parameter</code>（类型参数）也会导致膨胀。例如在许多平台上<code>int</code>和 <code>long</code>有相同的二进制表述，所以像<code>vector&lt;int&gt;</code>和<code>vector&lt;long&gt;</code>的成员函数有可能完全相同。某些链接器（<code>linker</code>）会合并完全相同的函数实现码，但有些不会，后者意味某些<code>template</code>被具现化为<code>int</code>和<code>long</code>两个版本，并因此造成代码膨胀。类似情况，所有指针类型都有相同的二进制表述，因此凡<code>template</code>持有指针者（例如<code>list&lt;int*&gt;</code>，<code>list&lt;const int*&gt;</code>，<code>list&lt;SquareMatrix&lt;long, 3&gt;*&gt;</code>等等）往往应该对每一个成员函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它们操作强型指针（<code>strongly typed pointer</code>，即<code>T*</code>），你应该令它们调用另一个操作无类型指针（<code>untyped pointer</code>，即<code>void*</code>）的函数，由后者完成实际工作。某些<code>C++</code>标准程序库实现版本的确为<code>vector</code>，<code>deque</code>和<code>list</code>等<code>template</code>做了这件事。</p><h5 id="条款45：成员函数模板接受所有兼容类型"><a href="#条款45：成员函数模板接受所有兼容类型" class="headerlink" title="条款45：成员函数模板接受所有兼容类型"></a>条款<code>45</code>：成员函数模板接受所有兼容类型</h5><p>内置指针是支持隐式转换的，比如<code>derived class</code>的指针可以隐式转换为<code>base class</code>指针，指向<code>non-const</code>对象的指针可以转换为指向<code>const</code>对象等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> :</span> <span class="keyword">public</span> Top &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> :</span> <span class="keyword">public</span> Middle &#123;...&#125;;</span><br><span class="line">Top* pt1 = <span class="keyword">new</span> Middle; <span class="comment">// 将 Middle* 转换为 Top*</span></span><br><span class="line">Top* pt2 = <span class="keyword">new</span> Bottom; <span class="comment">// 将 Bottom* 转换为 Top*</span></span><br><span class="line"><span class="keyword">const</span> Top* = pt1; <span class="comment">// Top* 转换为 const Top*</span></span><br></pre></td></tr></table></figure><p>但是我们自己实现的智能指针模板类，想做到这样就稍稍有点麻烦了。我们希望下面的代码能够通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">temmplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* realPtr)</span></span>; <span class="comment">// 智能指针通常以内置指针完成初始化</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Middle&gt;转 换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(<span class="keyword">new</span> Middle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Bottom&gt; 转换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Top&gt; 转换为 SmartPtr&lt;const Top&gt;</span></span><br><span class="line">SmartPtr&lt;<span class="keyword">const</span> Top&gt; pct2 = ptl;</span><br></pre></td></tr></table></figure><p><strong>注意，这些赋值表达式需要调用的都是<code>copy</code>构造函数。</strong>这里的代码不能通过编译，因为如果以带有<code>base-derived</code>关系的<code>B</code>，<code>D</code>两类型分别具现化某个<code>template</code>，产生出来的两个具现体并不带有<code>base-derived</code>关系，所以编译器视<code>SmartPtr&lt;Middle&gt;</code>和<code>SmartPtr&lt;Top&gt;</code>为完全不同的<code>class</code>，为了获得我们希望获得的<code>SmartPtr class</code>之间的转换能力，我们必须将它们明确地编写出来。</p><p>我们应该为它写一个<strong>构造模板</strong>。这样的模板是所谓<code>member function template</code>，其作用是为<code>class</code>生成函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// member template, 为了生成 copy 构造函数</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们称之为泛化（<code>generalized</code>）<code>copy</code>构造函数。它并未被声明为<code>explicit</code>，那是因为内置指针类型之间的转换（例如从<code>derived class</code>指针转为<code>base class指针</code>）是隐式转换，所以让智能指针按照这种形式也属合理。</p><p>但是，这个为<code>SmartPtr</code>而写的“泛化<code>copy</code>构造函数”提供的东西比我们需要的更多。我们只希望根据一个<code>SmartPtr&lt;Bottom&gt;</code>创建一个<code>SmartPtr&lt;Top&gt;</code>，却不希望根据一个<code>SmartPtr&lt;Top&gt;</code>创建一个<code>SmartPtr&lt;Bottomr&gt;</code>，因为那对<code>public</code>继承而言（见条款32）是矛盾的。我们也不希望根据一个<code>SmartPtr&lt;double&gt;</code>创建一个<code>SmartPtr&lt;int&gt;</code>，我们必须从某方面对这一<code>member template</code>所创建的成员函数群进行挑拣。</p><p>假设<code>SmartPtr</code>遵循<code>std::shared_ptr</code>也提供一个<code>get</code>成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以 other 的 heldPtr 初始化 this 的 heldPtr</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) : heldPtr(other.get()) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr; <span class="comment">// 这个 SmartPtr 持有的内置指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个行为只有当“存在某个隐式转换可将一个<code>U*</code>指针转为一个<code>T*</code>指针”时才能通过编译，而这正是我们想要的。</p><p><code>member function template</code>（成员函数模板）的效用不限于构造函数，<strong>它常扮演的另一个角色是支持赋值操作。</strong>例如<code>std::shared_ptr</code>同时支持所有“来自兼容之内置指针、<code>std::shared_ptr</code>、<code>std::weak_ptr</code>”的构造行为以及赋值操作（<code>std::weak_ptr</code>除外）。赋值操作符和<code>copy</code>构造函数实现类似，故省略。</p><ul><li>如果你声明<code>member template</code>用于“泛化<code>copy</code>构造”或“泛化<code>assignment</code>操作”你还是需要声明正常的<code>copy</code>构造函数和<code>copy assignment</code>操作符</li></ul><p>条款<code>5</code>说过，编译器可能为我们产生四个成员函数，其中两个是<code>copy</code>构造函数和<code>copy assignment</code>操作符。现在，<code>SmartPtr</code>声明了一个泛化<code>copy</code>构造函数，而显然一旦类型<code>T</code>和<code>U</code>相同，泛化<code>copy</code>构造函数会被具现化为“正常的”<code>copy</code>构造函数。那么究竟编译器会暗自为<code>SmartPtr</code>生成一个<code>copy</code>构造函数呢？或当某个<code>SmartPtr</code>对象根据另一个同型的<code>SmartPtr</code>对象展开构造行为时，编译器会将“泛化copy构造函数模板”具现化呢？</p><p><code>member template</code>并不改变语言规则：“如果程序需要一个<code>copy</code>构造函数，你却没有声明它，编译器会为你暗自生成一个”。在<code>class</code>内声明泛化<code>copy</code>构造函数（是个<code>member template</code>）并不会阻止编译器生成它们自己的<code>copy</code>构造函数（一个<code>non-template</code>），所以如果你想要控制<code>copy</code>构造的方方面面，你必须同时声明泛化<code>copy</code>构造函数和“正常的”<code>copy</code>构造函数。相同规则也适用于赋值操作。</p><h5 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款<code>46</code>：需要类型转换时请为模板定义非成员函数</h5><p>条款<code>24</code>讨论过为什么惟有<code>non-member</code>函数才有能力“在所有实参身上实施隐式类型转换”，该条款并以<code>Rational class</code>的<code>operator*</code>函数为例。本条款将<code>Rational</code>和<code>operator*</code>模板化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 条款 20 告诉你为什么参数以 passed by reference 方式传递</span></span><br><span class="line">    Rational(<span class="keyword">const</span> T&amp; numerator = <span class="number">0</span>, <span class="keyword">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条款 28 告诉你为啥返回值以 passed by value 方式传递</span></span><br><span class="line">    <span class="comment">// 条款 3 告诉你为啥它们是 const</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像条款<code>24</code>一样，我们也希望支持混合式算术运算，然而以下代码却不能通过编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;int&gt; oneHalf(1, 2);</span><br><span class="line">Rational&lt;int&gt; result &#x3D; oneHalf * 2; &#x2F;&#x2F; 错误!无法通过编译</span><br></pre></td></tr></table></figure><p>在这里，编译器不知道我们想要调用哪个函数！它们试图找到什么函数被名为<code>operator*</code>的<code>template</code>具现化出来。它们知道它们应该可以具现化某个“名为<code>operator*</code>并接受两个<code>Rational&lt;T&gt;</code>参数”的函数，但为完成这一具现化行动，必须先算出<code>T</code>是什么。</p><p>为了推导<code>T</code>，它们看了看<code>operator*</code>调用动作中的实参类型。分别是<code>Rational&lt;int&gt;</code>（<code>oneHalf</code>的类型）和<code>int</code>（<code>2</code>的类型）。</p><p>以<code>oneHalf</code>进行推导，过程并不困难。第二参数的推导则没有这么顺利。<code>operator*</code>的第二参数被声明为<code>Rational&lt;T&gt;</code>，但传递给<code>operator*</code>的类型是<code>int</code>（<code>2</code>）。编译器如何根据这个<code>2</code>推算出<code>T</code>？你或许会期盼编译器使用<code>Rational&lt;int&gt;</code>的<code>non-explicit</code>构造函数将转换为<code>Rational&lt;int&gt;</code>，进而将<code>T</code>推导为<code>int</code>，然而<strong><code>template</code>实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。</strong></p><p><code>template class</code>内的<code>friend</code>声明式可以指涉某个特定函数。这意味<code>class Rational&lt;T&gt;</code>可以声明<code>operator*</code>是它的一个<code>friend</code>函数。<code>class template</code>并不倚赖<code>template</code>实参推导，所以编译器总是能够在<code>class Rational&lt;T&gt;</code>具现化时得知<code>T</code>。因此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                                <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>，<code>class Rational&lt;int&gt;</code>于是被具现化出来，而作为过程的一部分，<code>friend</code>函数<code>operator*</code>（接受<code>Rational&lt;int&gt;</code>参数）也就被自动声明出来。后者身为一个函数而非<code>function template</code>，因此编译器可在调用它时使用隐式转换函数（例如调用<code>Rational</code>的<code>non-explicit</code>构造函数）。                                                        </p><p>但是，虽然这段代码通过编译，却无法连接。</p><p>因为这个友元函数只被声明于<code>Rational</code>内，并没有被定义出来。我们意图令此<code>class</code>外部的<code>operator* template</code>提供定义式，是行不通的。既然我们没有提供定义式，连接器当然找不到它！</p><p>最简单的方法就是，将函数本体放进<code>class</code>内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                        lhs.denominator() * rhs.denominator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了让类型转换可能发生于所有实参身上，我们需要一个<code>non-member</code>函数（条款<code>24</code>）；为了令这个函数被自动具现化，我们需要将它声明在<code>class</code>内部；而在class内部声明<code>non-member</code>函数的唯一办法就是：令它成为一个<code>friend</code>。因此我们就这样做了。</p><ul><li><p>当此<code>friend</code>函数过于复杂时，令其调用类外的辅助函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rational</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp;rhs)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational&lt;T&gt;(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                       lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">    <span class="keyword">const</span> Rational&lt;T&gt;<span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                                <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> doMultiply(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  作为一个<code>template</code>，<code>doMultiply</code>当然不支持混合式乘法，但它其实也不需要。它只被<code>operator*</code>调用，而<code>operator*</code>支持混合式操作。</p></li></ul><h5 id="条款47：traits-classes表现类型信息"><a href="#条款47：traits-classes表现类型信息" class="headerlink" title="条款47：traits classes表现类型信息"></a>条款<code>47</code>：<code>traits classes</code>表现类型信息</h5><p><code>STL</code>迭代器分类：</p><ol><li><p><code>input</code>迭代器</p><p> 只能向前移动，一次一步，用户只能读取它所指的东西，而且只能读取一次，读完立即自动向前一步。程序库中的输入流迭代器<code>istream_iterator</code>就属于这一类。</p></li><li><p><code>output</code>迭代器</p><p> 只能向前移动，一次一步，用户只能涂写它所指的东西，而且只能涂写一次，写完立即自动向前一步。程序库中的输出流迭代器<code>ostream_iterator</code>就属于这一类。</p></li><li><p><code>forward</code>迭代器</p><p> 可以做上述两种迭代器做的事情，而且支持多次读写，读写完由用户自行决定是否前进。单向链表<code>slist</code>提供的迭代器就属于这一类。</p></li><li><p><code>bidirectional</code>迭代器</p><p> 除了能做<code>forward</code>迭代器做的事情，还可以向后移动。双向链表<code>list</code>以及<code>set</code>，<code>mutilset</code>，<code>map</code>，<code>mutilmap</code>提供的迭代器属于这一类。</p></li><li><p><code>random access</code>迭代器</p><p> 功能类似于内置指针，可以进行算数操作。<code>vector</code>，<code>deque</code>和<code>string</code>提供的迭代器属于这一类。</p></li><li><p><em>迭代器适配器</em></p><ul><li><em><code>reverse</code>迭代器</em></li><li><em><code>insert</code>迭代器</em><ul><li><em><code>back inserter</code></em></li><li><em><code>front inserter</code></em></li><li><em><code>general inserter</code></em></li></ul></li><li><em><code>stream</code>迭代器</em></li><li><em><code>move</code>迭代器</em></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional</span> <span class="title">iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这些<code>struct</code>之间的继承关系是有效的<code>is-a</code>关系：所有<code>forward</code>迭代器都是<code>input</code>迭代器，依此类推。</p><p>关于<code>iterator_trait</code>的实现技术（参考书籍<code>P227-P232</code>）</p><h5 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款<code>48</code>：认识<code>template</code>元编程</h5><ul><li>如题，以后买本书再专门去学吧！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之继承与面向对象设计</title>
      <link href="/5pPP61A5gGyfCrjb/"/>
      <url>/5pPP61A5gGyfCrjb/</url>
      
        <content type="html"><![CDATA[<h4 id="第6章：继承与面向对象设计"><a href="#第6章：继承与面向对象设计" class="headerlink" title="第6章：继承与面向对象设计"></a>第<code>6</code>章：继承与面向对象设计</h4><h5 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款<code>32</code>：确定你的<code>public</code>继承塑模出<code>is-a</code>关系</h5><ul><li>“<code>public</code>继承”意味<code>is-a</code>。适用于<code>base class</code>身上的每一件事情一定也适用于<code>derived class</code>身上，因为每一个<code>derived class</code>对象也都是一个<code>base class</code>对象</li></ul><a id="more"></a><h5 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款<code>33</code>：避免遮掩继承而来的名称</h5><ul><li><p><code>derived class</code>的作用域被嵌套在<code>base class</code>作用域内</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); <span class="comment">// 没问题, 调用 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 错误! 因为 Derived::mf1 遮掩了 Base::mf1</span></span><br><span class="line">d.mf2(); <span class="comment">// 没问题, 调用 Derived::mf2</span></span><br><span class="line">d.mf2(x); <span class="comment">// 错误! 因为 Derived::mf2 遮掩了 Base::mf2</span></span><br></pre></td></tr></table></figure><p>  这段代码中<code>base class</code>内所有名为<code>mf1</code>和<code>mf2</code>的函数都被<code>derived class</code>内的<code>mf1</code>和<code>mf2</code>函数遮掩掉了。从名称查找观点来看，<code>Base::mf1</code>和<code>Base::mf2</code>不再被<code>Derived</code>继承！</p><p>  实际上如果你正在使用<code>public</code>继承而又不继承那些重载函数，就是违反<code>base</code>和<code>derived class</code>之间的<code>is-a</code>关系，而条款<code>32</code>说过<code>is-a</code>是<code>public</code>继承的基石。因此你几乎总会想要推翻<code>C++</code>对“继承而来的名称”的缺省遮掩行为。</p><ul><li><p>使用<code>using</code>声明式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::mf1; <span class="comment">// 让 Base class 内名为 mf1 和 mf2 的所有东西</span></span><br><span class="line">    <span class="keyword">using</span> Base::mf2; <span class="comment">// 在 Derived 作用域内都可见, 并且 public</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); <span class="comment">// 没问题, 调用 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 现在没问题了, 调用 Based::mf1</span></span><br><span class="line">d.mf2(); <span class="comment">// 没问题, 调用 Derived::mf2</span></span><br><span class="line">d.mf2(x); <span class="comment">// 现在没问题了, 调用 Based::mf2</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>inline</code>转交函数（<code>forwarding function</code>）</p><p>  然而在<code>private</code>继承之下（见条款<code>39</code>），有时候你并不想继承<code>base class</code>的所有函数。假设<code>Derived</code>以<code>private</code>形式继承<code>Base</code>，而<code>Derived</code>唯一想继承的<code>mf1</code>是那个无参数版本。<code>using</code>声明式在这里派不上用场，因为<code>using</code>声明式会令继承而来的某给定名称之所有同名函数在<code>derived class</code>中都可见。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    ... <span class="comment">// 与前同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="comment">// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::mf1(); <span class="comment">// 暗自成为 inline (见条款 30)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">d.mf1(); <span class="comment">// 很好, 调用的是 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 错误! Base::mf1 被遮掩</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款<code>34</code>：区分接口继承和实现继承</h5><p>身为<code>class</code>设计者，有时候你会希望<code>derived class</code>只继承成员函数的接口，也就是声明；有时候你又会希望<code>derived class</code>同时继承函数的接口和实现，但又希望能够覆写（<code>override</code>）它们所继承的实现；又有时候你希望<code>derived class</code>同时继承函数的接口和实现，并且不允许覆写任何东西。</p><p><code>base</code>类强烈影响以<code>public</code>形式继承它的<code>derived class</code>，因为：</p><ul><li><p>成员函数的接口总是会被继承</p></li><li><p>声明一个<code>pure virtual</code>函数的目的是为了让<code>derived</code>类只继承函数接口</p><p>  含有<code>pure virtual</code>函数的类属于抽象基类，不能被实例化。继承了它们的类必须重新声明此函数接口并给予实现。抽象基类可以给<code>pure virtual</code>函数提供定义，但调用它的唯一途径是“调用时指定其<code>class</code>的名称”。</p></li><li><p>声明<code>impure</code>函数的目的是让<code>derived class</code>继承该函数的接口和缺省实现</p><p>  但是，允许<code>impure virtual</code>函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑<code>XYZ</code>航空公司设计的飞机继承体系。该公司只有<code>A</code>型和<code>B</code>型两种飞机，两者都以相同方式飞行。因此<code>XYZ</code>设计出这样的继承体系：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span> &#123;</span>...&#125;; <span class="comment">// 用以表现机场</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省代码, 将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>  为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的<code>fly</code>实现”，<code>Airplane::fly</code>被声明为<code>virtual</code>。然而为了避免在<code>ModelA</code>和<code>ModelB</code>中撰写相同代码，缺省飞行行为由<code>Airplane::fly</code>提供，它同时被<code>ModelA</code>和<code>ModelB</code>继承。</p><p>  现在，<code>XYZ</code>航空公司决定购买一种新式<code>C</code>型飞机。<code>C</code>型和<code>A</code>型以及<code>B</code>型的飞行方式不同。<code>XYZ</code>公司的程序员在继承体系中针对<code>C</code>型飞机添加了一个<code>class</code>，但由于他们急着让新飞机上线服务，竟忘了重新定义其<code>fly</code>函数：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 未声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Airport <span class="title">PDX</span><span class="params">(... )</span></span>; <span class="comment">// PDX 是我家附近的机场</span></span><br><span class="line">Airplane* pa= <span class="keyword">new</span> ModelC;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这将酿成大灾难</span></span><br><span class="line">pa-&gt;fly(PDX); <span class="comment">// 调用 Airplane::fly</span></span><br></pre></td></tr></table></figure><p>  一种解救办法为切断“<code>virtual</code>函数接口”和其“缺省实现”之间的连接。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 现在是 pure virtual 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span> <span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省行为, 将飞机飞至指定的目的地。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        defaultFly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        defaultFly (destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 ModelC class 不可能意外继承不正确的 fly 实现代码了</span></span><br><span class="line"><span class="comment">// 因为 Airplane 中的 pure virtual 函数追使 ModelC 必须提供自己的 f1y 版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ... <span class="comment">// 将 C 型飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  另一种解救方法是，利用“<code>pure virtual</code>函数必须在<code>derived class</code>中重新声明，但它们也可以拥有自己的实现”这一事实。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 现在是 pure virtual 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给予 pure virtual 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省行为, 将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Airplane::fly(destination); <span class="comment">// 通过指定其类名调用它</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">virtuai <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Airplane::fly(destination); <span class="comment">// 通过指定其类名调用它</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 将 C 型飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明<code>non-virtual</code>函数的目的是为了<code>derived class</code>继承函数的接口及其强制性实现</p><p>  <code>non-virtual</code>函数为其所属<code>class</code>建立的意义是不变性凌驾其特异性，所以它不该在<code>derived class</code>中被重新定义。</p></li></ul><h5 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款<code>35</code>：考虑<code>virtual</code>函数以外的其他选择</h5><p>假设你正在写一个视频游戏软件，你的游戏属于暴力砍杀类型，剧中人物存在被伤害而降低健康状态的情况。因此你决定提供一个成员函数 <code>healthvalue</code>，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将<code>healthvalue</code>声明为<code>virtual</code>似乎是再明白不过的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 返回人物的健康指数,</span></span><br><span class="line">                                    <span class="comment">// derived classes 可重新定义它</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在考虑一些其它解法：</p><ul><li><p>借助<code>non-virtual interface</code>(<code>NVI</code>)手法实现<code>Template Method</code>模式</p><p>  保留<code>healthvalue</code>为<code>public</code>成员函数，但让它成为<code>non-virtual</code>，并调用一个<code>private virtual</code>函数进行实际工作：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// derived class 不重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 做一些事前工作</span></span><br><span class="line">        <span class="keyword">int</span> retval = doHealthvalue(); <span class="comment">// 做真正的工作</span></span><br><span class="line">        ... <span class="comment">// 做一些事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NVI 手法下没必要让 virtual 函数一定是 private</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// derived class 可重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省算法, 计算健康指数。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这一基本设计，“令客户通过<code>public non-virtual</code>成员函数间接调用<code>private virtual</code>函数”，称为<code>non-virtual interface</code>(<code>NVI</code>)手法。它是所谓<code>Template Method</code>设计模式的一个独特表现形式。我把这个<code>non-virtual</code>函数（<code>healthvalue</code>）称为<code>virtual</code>函数的外覆器（<code>wrapper</code>) 。</p><p>  <code>NVI</code>手法的一个优点隐藏在上述代码注释“做一些事前工作”和“做一些事后工作”之中。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证 <code>class</code>约束条件、验证函数先决条件等。“事后工作”可以包括互斥器解除锁定、验证函数的事后条件、再次验证<code>class</code>约束条件等。如果你让客户直接调用<code>virtual</code>函数，就没有任何好办法可以做这些事。</p></li><li><p>借助<code>Function Pointer</code>实现<code>Strategy</code>模式</p><p>  另一个设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个函数指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"><span class="comment">// 以下函数是计算健康指数的缺省算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span> <span class="params">(HealthCalcFunc hcf = defaultFealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">healthFunc</span><span class="params">(hcf)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这种设计策略和前面介绍的方法相比提供了一些有趣的弹性：</p><ul><li><p>同一人物类型的不同实体可以有不同的健康计算函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span> :</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">GameCharacter</span><span class="params">(hcf)</span> </span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 健康指数计算函数 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 健康指数计算函数 2</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>; <span class="comment">// 相同类型的人物搭配</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>; <span class="comment">// 不同的健康计算方式</span></span><br></pre></td></tr></table></figure></li><li><p>某已知人物之健康指数计算函数可在运行期变更</p><p>  例如<code>GameCharacter</code>可提供一个成员函数<code>setHealthcalculator</code>，用来替换当前的健康指数计算函数。</p><p>然而这种策略意味着，计算函数并不能访问“被计算健康指数的”那个对象的内部（<code>non-public</code>）成分。如果需要访问<code>non-public</code>成分进行精确计算，这就有问题了。</p><p>唯一能够解决的办法就是：弱化<code>class</code>的封装。例如，将健康计算函数声明为<code>friend</code>。或是为其实现的某一部分提供<code>public</code>访问函数。这需要你来权衡利弊进行抉择。</p></li></ul></li><li><p>借助<code>std::function</code>实现<code>Strategy</code>模式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不同之处</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span> <span class="params">(HealthCalcFunc hcf = defaultFealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">healthFunc</span><span class="params">(hcf)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  那个签名代表的函数是“接受一个<code>reference</code>指向<code>const GameCharacter</code>，并返回<code>int</code>”。这个<code>std::function</code>类型（也就是我们所定义的<code>HealthCalcFunc</code>类型）产生的对象可以持有（保存）任何与此签名式<strong>兼容的</strong>可调用物。所谓兼容，意思是这个可调用物的参数可被<strong>隐式转换</strong>为<code>const GameCharacter&amp;</code>，而其返回类型可被<strong>隐式转换</strong>为<code>int</code>。</p><p>  这就提供了很大的灵活性：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">short <span class="title">calcHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// 健康计算函数</span></span><br><span class="line">                                        <span class="comment">// 注意其返回类型为 non-int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HealthCalculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 为计算健康而设计的函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameLevel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">health</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span>;<span class="comment">// 成员函数, 用以计算健康</span></span><br><span class="line">    <span class="comment">// 注意其 non-int 返回类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物类型 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span>:</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 同前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物类型 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EyeCandyCharacter</span>:</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 假设其构造函数与 EvilBadGuy 同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物 1, 使用某个函数计算健康指数</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物 2, 使用某个函数对象计算健康指数</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator())</span></span>;</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 人物 3, 使用某个成员函数计算健康指数</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(<span class="built_in">std</span>::bind(&amp;GameLevel::health, &amp;currentLevel, _1))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>传统的<code>Strategy</code>模式</p><p>  <img src="strategy.png" alt=""></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~HealthCalcFunc() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlowHealthLoser</span> :</span> HealthCalcFunc</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastHealthLoser</span> :</span> HealthCalcFunc</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf)</span> : <span class="title">pHealthCalc</span><span class="params">(phcf)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc-&gt;calc(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款<code>36</code>：绝不重新定义继承而来的<code>non-virtual</code>函数</h5><ul><li>如题</li></ul><h5 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款<code>37</code>：绝不重新定义继承而来的缺省参数值</h5><p>本条款的讨论局限于“继承一个带有缺省参数值的<code>virtual</code>函数”：<code>virtual</code>函数是动态绑定（后期绑定，延迟绑定），而缺省参数值却是静态绑定（前期绑定，早绑定）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个用以描述几何形状的class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> ShapeColor&#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="comment">// 所有形状都必须提供一个函数, 用来绘出自己</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注意, 赋予不同的缺省参数值, 这真糟糕!</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 请注意，以上这么写则当客户以 对象 调用此函数一定要指定参数值</span></span><br><span class="line">    <span class="comment">// 因为静态绑定下这个函数并不从其 base 继承缺省参数值</span></span><br><span class="line">    <span class="comment">// 但若以指针或 reference 调用此函数, 可以不指定参数值</span></span><br><span class="line">    <span class="comment">// 因为动态绑定下这个函数会从其 base 继承缺省参数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>对象的静态类型就是它在程序中所声明的类型，对象的动态类型则是指“目前所指对象的类型”</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shape* ps; <span class="comment">// 静态类型为 shape*, 无动态类型</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle; <span class="comment">// 静态类型为 Shape*, 动态类型是 Circle*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle; <span class="comment">// 静态类型为 shape*, 动态类型是 Rectangle*</span></span><br></pre></td></tr></table></figure><p>  动态类型可在程序执行过程中改变（通常是经由赋值动作）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = pc; <span class="comment">// ps 的动态类型如今是 circle*</span></span><br><span class="line">ps = pr; <span class="comment">// ps 的动态类型如今是 Rectangle*</span></span><br></pre></td></tr></table></figure></li></ul><p><code>virtual</code>函数系动态绑定而来，意思是调用一个<code>virtual</code>函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pr-&gt;draw(); <span class="comment">// 调用的是 Rectangle::draw(shape::Red)!</span></span><br><span class="line">            <span class="comment">// 注意缺省参数是 Red 而不是 Green</span></span><br></pre></td></tr></table></figure><p>此例之中，<code>pr</code>的动态类型是<code>Rectangle*</code>，所以调用的是<code>Rectangle</code>的<code>virtual</code>函数。<code>Rectangle::draw</code>函数的缺省参数值应该是<code>Green</code>，但由于<code>pr</code>的静态类型是<code>shape*</code>，所以此一调用的缺省参数值来自<code>Shape class</code>而非<code>Rectangle class</code>！这不符合预期。</p><p>解救方法是利用条款<code>35</code>中介绍的<code>NVI</code>手法替代<code>virtual</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> shapeColor&#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span><span class="comment">// 如今它是 non-virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        doDraw(color); <span class="comment">// 调用一个 virtual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 真正的工作在此处完成</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span> <span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>; <span class="comment">// 注意, 不须指定缺省参数值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个设计很清楚地使得<code>draw</code>函数的<code>color</code>缺省参数值总是<code>Red</code>。</p><h5 id="条款38：通过复合塑模出has-a或is-implemented-in-terms-of"><a href="#条款38：通过复合塑模出has-a或is-implemented-in-terms-of" class="headerlink" title="条款38：通过复合塑模出has-a或is-implemented-in-terms-of"></a>条款<code>38</code>：通过复合塑模出<code>has-a</code>或<code>is-implemented-in-terms-of</code></h5><p>当某种类型的对象内含其它对象时便形成了复合关系。</p><ul><li><p>应用域</p><p>  程序中的对象其实相当于你所塑造出来的世界中的某些事物。比如人，汽车，高楼大厦等。这样的对象属于应用域部分。</p></li><li><p>实现域</p><p>  其它对象如缓冲区，互斥器，搜索树等纯粹是实现细节上的工具。这些对象相当于软件中的实现域。</p></li></ul><p>当复合发生于应用域对象之间表现出<code>has-a</code>关系，当它发生于实现域内则表现出<code>is-implemented-in-terms-of</code>（根据某物实现出）的关系。</p><ul><li><p>复合的意义和<code>public</code>继承完全不同</p><p>  注意区分<code>is-a</code>和<code>is-implemented-in-terms-of</code>这两种对象关系。</p></li></ul><h5 id="条款39：明智而谨慎地使用private继承"><a href="#条款39：明智而谨慎地使用private继承" class="headerlink" title="条款39：明智而谨慎地使用private继承"></a>条款<code>39</code>：明智而谨慎地使用<code>private</code>继承</h5><p>一个<code>derived</code>类继承<code>base</code>类有<code>public</code>、<code>protected</code>或<code>private</code>三种继承方式。</p><ul><li><p>公有继承（<code>public</code>）（普遍使用）</p><p>  <code>base</code>类的<code>public</code>成员也是<code>derived</code>类的<code>public</code>成员，<code>base</code>类的<code>protected</code>成员也是<code>derived</code>类的<code>protected</code>成员</p></li><li><p>保护继承（<code>protected</code>）（基本不使用）</p><p>  <code>base</code>类的<code>public</code>和<code>protected</code>成员将成为<code>derived</code>类的<code>protected</code>成员。</p></li><li><p>私有继承（<code>private</code>）（少的情况使用）</p><p>  <code>base</code>类的<code>public</code>和<code>protected</code>成员将成为<code>derived</code>类的<code>private</code>成员。</p></li></ul><p>无论哪一种继承方式，<code>base</code>类的<code>private</code>成员都不能直接被<code>derived</code>类访问，但是可以通过调用<code>base</code>类的<code>public</code>和<code>protected</code>成员间接来访问（如果<code>base</code>类提供了访问接口的话）。</p><ul><li><p><code>private</code>继承意味着<code>is-implemented-in-terms-of</code></p><p>  <code>private</code>继承只限于软件实现层面，这就是为什么<code>private</code>继承后，<code>base class</code>的所有成分（除了<code>private</code>）在你的<code>class</code>内都是<code>private</code>，因为它们都只是实现细节而已。</p></li><li><p>尽可能使用复合，<strong>必要时</strong>才使用<code>private</code>继承</p><ol><li><p>当<code>derived</code>类想要访问<code>base class</code>的<code>protected</code>成员时</p></li><li><p>当<code>derived</code>类为了重新定义<code>base class</code>的<code>virtual</code>函数时</p><p> 现在考虑一个<code>Widget</code>类，它需要用到另一个计时器<code>Timer</code>类来实现一些业务。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> tickFrequecy)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 定时器每滴答一次, 此函数就调用一次</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p> 为了让<code>Widget</code>重新定义<code>Timer</code>内的<code>virtual</code>函数，<code>Widget</code>必须继承自<code>Timer</code>。因为<code>Widget</code>不是个<code>Timer</code>，因此<code>public</code>继承不合适。必须以<code>private</code>方式继承：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 通过<code>private</code>继承，<code>Timer</code>的<code>public onTick</code>函数在<code>Widget</code>内变成<code>private</code>，而我们重新声明（定义）时仍然把它留在那儿。如果把<code>onTick</code>放进<code>public</code>内会误导客户以为他们可以调用它，那就违反了条款<code>18</code>。</p><p> 另一种设计方案是采用复合 + <code>public</code>继承：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在 Widget 内声明一个嵌套式 private class</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WidgetTimer</span> :</span> <span class="keyword">public</span> Timer</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 以 public 方式继承并重新定义 virtual 函数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 采用第二种较为复杂的方式的两点理由：</p><ul><li>你或许会想设计<code>Widget</code>使它得以拥有<code>derived class</code>，但同时你可能会想阻止<code>derived class</code>重新定义<code>onTick</code>。如果<code>Widget</code>继承自<code>Timer</code>，上面的想法就不可能实现，即使是<code>private</code>继承也不可能。但如果<code>WidgetTimer</code>是<code>Widget</code>内部的一个<code>private</code>成员并继承自<code>Timer</code>，<code>Widget</code>的<code>derived class</code>将无法取用<code>WidgetTimer</code>，因此无法继承它或重新定义它的<code>virtual</code>函数。</li><li>你或许会想要将<code>Widget</code>的编译依存性降至最低（条款<code>31</code>）。如果<code>Widget</code>继承<code>Timer</code>，当<code>Widget</code>被编译时<code>Timer</code>的定义必须可见，所以定义<code>Widget</code>的那个文件恐怕必须<code>#include Timer.h</code>。但如果<code>WidgetTimer</code>移出<code>Widget</code>所在文件之外而<code>Widget</code>内含指针指向一个<code>WidgetTimer</code>，<code>Widget</code>可以只带着一个简单的<code>WidgetTimer</code>前向声明式，不再需要<code>#include</code>任何与<code>Timer</code>有关的东西。很容易就实现了解耦。</li></ul></li><li><p><code>EBO</code>（<code>empty base optimization</code>）</p><p> <code>empty class</code>指的是没有<code>non-static</code>成员变量，没有<code>virtual</code>函数，也没有<code>virtual base class</code>。于是这种<code>class</code>不占用理论上不占用任何内存空间。然而在实现技术上，<code>C++</code>要求<strong>独立（非附属）对象</strong>都必须有非零大小。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;; <span class="comment">// 没有任何需要存储的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论上 sizeof(HoldAnInt) = 4 字节(就一个 int)</span></span><br><span class="line"><span class="comment">// 实际上 sizeof(HoldAnInt) = 8 字节</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 字节</span></span><br><span class="line">    Empty e; <span class="comment">// 理论上应该不占据内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>C++</code>编译器默认为<code>empty class</code><strong>独立对象</strong>安插一个<code>char</code>（<code>1</code>字节）</p></li><li><p>由于内存对齐<code>HoldAnInt</code>的实际大小为<code>4 + 1(内存对齐至 4) = 8</code></p><p>但这个约束不适用于<code>derived class</code>对象的<code>base class</code>成分（非独立）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论和实际上 sizeof(HoldAnInt) = 4 字节(就一个 int)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span> :</span> <span class="keyword">public</span> Empty</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现实中的<code>empty class</code>并非真是<code>empty</code>。往往内含<code>typedef</code>，<code>enum</code>，<code>static</code>成员变量，或<code>non-virtual</code>函数。<code>STL</code>就有许多技术用途的<code>empty class</code>，其中内含有用的成员（通常是<code>typedef</code>），包括<code>base class unary_function</code>和<code>binary_function</code>，这些是“用户自定义之函数对象”通常会继承的<code>class</code>。由于<code>EBO</code>，这样的继承很少增加<code>derived class</code>的大小。</p></li></ul></li></ol></li></ul><h5 id="条款40：明智而谨慎地使用多重继承"><a href="#条款40：明智而谨慎地使用多重继承" class="headerlink" title="条款40：明智而谨慎地使用多重继承"></a>条款<code>40</code>：明智而谨慎地使用多重继承</h5><ul><li><p>多重继承较单一继承复杂，可能导致歧义性</p><p>  当继承的多个<code>base</code>具有同名成员函数时，<code>derived</code>类调用时会出现歧义。</p></li><li><p>有时多重继承不得不需要<code>virtual</code>继承，而这会带来额外的体积、运行速度、初始化复杂度等成本</p><p>  比如这样的钻石继承体系：</p><p>  <img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.png" alt=""></p><p>  这个继承体系中某个<code>base class</code>和某个<code>derived class</code>之间有一条以上的相通路线，假设<code>File class</code>有个成员变量<code>fileName</code>，那么<code>IOFile</code>从每一个<code>base class</code>各继承一份，所以其对象内会有两份<code>fileName</code>成员变量。然而<code>IOFile</code>对象只该有一个文件名称，所以名称<code>fileName</code>不该重复。</p><p>  解决办法就是采用<code>virtual</code>继承：</p><p>  <img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BFvirtual%E7%BB%A7%E6%89%BF.png" alt=""></p><p>  <code>virtual</code>继承带来的后果是：</p><ul><li><p>使用<code>virtual</code>继承的那些<code>class</code>所产生的对象往往比使用<code>non-virtual</code>继承的<code>class</code>体积大</p></li><li><p>访问<code>virtual base class</code>的成员变量时，也比访问<code>non-virtual base class</code>的成员变量速度慢</p></li><li><p>另外，支配“<code>virtual base class</code>初始化”的规则比起<code>non-virtual base class</code>的情况远为复杂且不直观。<code>virtual base class</code>的初始化责任是由继承体系中的最低层（<code>most derived</code>）<code>class</code>负责的，这意味着：</p><ol><li><code>class</code>若派生自<code>virtual base</code>而需要初始化，必须知道其<code>virtual base class</code>——不论那些<code>base class</code>距离多远。</li><li>当一个新的<code>derived class</code>加入继承体系中，它必须承担其<code>virtual base class</code>的初始化责任。</li></ol><p>关于<code>virtual</code>继承的忠告：</p></li></ul><ol><li>非必要不使用<code>virtual base</code>。平常请使用<code>non-virtual</code>继承。</li><li>如果必须使用<code>virtual base class</code>，尽可能避免在其中放置数据。这么一来你就不需担心这些<code>class</code>身上的初始化（和赋值）所带来的诡异事情了。</li></ol></li></ul><p>最后看一个多重继承的应用例子——<code>public</code>继承某个<code>Interface class</code>和<code>private</code>继承某个协助实现的<code>class</code>。</p><p><img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90.png" alt=""></p><p>（参考书籍<code>P195-P198</code>）</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之概论</title>
      <link href="/eSK55yN7G7dNea2c/"/>
      <url>/eSK55yN7G7dNea2c/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>相互之间存在一种或多种特定关系的数据元素的集合。研究数据结构，关心的是数据对象的描述以及相关操作函数的实现。</p><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如整型、浮点型等数值类型，以及声音、图像等非数值类型。</p><h4 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h4><p>是组成数据的、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。</p><a id="more"></a><h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p>一个数据元素可以由若干个数据项组成。它是数据不可分割的最小单位。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p>是性质相同的数据元素（即有相同的数量和类型的数据项）的集合，是数据的子集。</p><h4 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h4><ul><li><p>线性数据结构：向量<code>vector</code>（顺序存储）、链表<code>list</code>（链式存储）、栈<code>stack</code>和队列<code>queue</code>（优先队列）。</p></li><li><p>半线性数据结构：二叉树、搜索树（二叉搜索树<code>BST</code>、<code>AVL</code>树、<code>B</code>树、红黑树）、竞赛树等。</p></li><li><p>非线性数据结构：图。</p></li><li><p>哈希表<code>hashtable</code>、字典<code>dictionary</code>。</p></li></ul><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><ul><li><p>数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p></li><li><p>抽象数据类型：指一个数学模型及定义在该模型上的一组操作。可以理解为<code>C++</code>中的类<code>class</code>。它体现的是程序设计中问题分解、抽象和信息隐藏的特性。</p></li></ul><h4 id="抽象数据类型的标准格式"><a href="#抽象数据类型的标准格式" class="headerlink" title="抽象数据类型的标准格式"></a>抽象数据类型的标准格式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">    数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">    操作<span class="number">1</span></span><br><span class="line">    操作<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是解决指定问题求解步骤的描述。在计算机中是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。</p><h4 id="计算或信息处理"><a href="#计算或信息处理" class="headerlink" title="计算或信息处理"></a>计算或信息处理</h4><p>指借助某种工具，按照一定的规则，以明确而机械的形式进行。</p><p>算法中的计算模型就是计算机，即信息处理工具。</p><h4 id="算法必须具备的几大要素"><a href="#算法必须具备的几大要素" class="headerlink" title="算法必须具备的几大要素"></a>算法必须具备的几大要素</h4><ol><li>输入：待处理的信息或问题。</li><li>输出：经处理的信息，即答案。</li><li>正确性：的确可以解决指定的问题。</li><li>确定性：任何一个算法都可以描述为一个由基本操作组成的序列。</li><li>可行性：每一基本操作都可实现，且能在常数时间内完成。</li><li>有穷性：对于任何输入，经有限次的基本操作，都可以得到输出。</li></ol><h4 id="一个好的算法"><a href="#一个好的算法" class="headerlink" title="一个好的算法"></a>一个好的算法</h4><ol><li><p>正确，即符合语法，能够编译、链接。</p><blockquote><p>能够正确处理<strong>简单的</strong>、<strong>大规模的</strong>、<strong>一般性的</strong>、<strong>退化的</strong>、<strong>任意合法</strong>的输入。</p></blockquote></li><li><p>健壮，能够辨别不合法的输入并做适当处理，而不致非正常退出。</p></li><li><p>可读，结构化 <code>+</code> 准确命名 <code>+</code> 注释 <code>+</code> …。</p></li><li><p>效率，运行速度尽可能快，用到的存储空间尽可能少。</p></li></ol><h4 id="常见的算法"><a href="#常见的算法" class="headerlink" title="常见的算法"></a>常见的算法</h4><ol><li><p>查找</p><p> 顺序查找、二分查找、插值查找、斐波那契查找、分块查找和哈希查找等。</p></li><li><p>排序</p><p> 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序和希尔排序等。</p></li><li><p>递归、分而治之、动态规划、回溯法和分支定界法等。</p></li></ol><p>要对数据结构和算法设计方法给予评价，就必须能够计算程序性能。</p><h4 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h4><ul><li><p>数据结构(<code>data structures</code>) + 算法(<code>algorithms</code>) = 程序(<code>programs</code>)</p></li><li><p><code>(data structures + algorithms) x efficiency = computation</code></p></li></ul><h3 id="程序性能分析"><a href="#程序性能分析" class="headerlink" title="程序性能分析"></a>程序性能分析</h3><p>是指分析一个程序对于内存空间和运行时间的需求。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>指程序运行时临时占用内存的大小。广义上的概念是包括存储算法本身所占用的空间、算法的输入输出数据所占用的空间以及算法在运行过程中临时占用的存储空间这三个方面。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>指运行程序所需要的时间。这里度量的是程序中基本操作执行的次数，它是问题规模<code>n</code>的函数<code>f(n)</code>。记<code>T(n)=O(f(n))</code>，它表示随问题规模<code>n</code>的增大，算法执行时间的增长率和<code>f(n)</code>相同，称作算法的渐进时间复杂度。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>这里的复杂度分析通常指的是最坏时间复杂度分析。</p><ul><li>常数阶<code>O(1)</code></li></ul><p><img src="image-20200101210400776.png" alt=""></p><p>取前三个元素<code>x = S[0]</code>、<code>y = S[1]</code>和<code>z = S[2]</code>，这一步只需执行三次（从特定单元读取元素的）基本操作，耗费<code>O(3)</code>时间。接下来，为确定这三个元素的大小次序，最多需要做三次比较，也需<code>O(3)</code>时间。最后，输出居中的非极端元素只需<code>O(1)</code>时间。因此，上面取非极端元素算法的时间复杂度为：<br><code>T(n) = O(3) + O(3) + O(1) = O(7) = O(1)</code>。</p><ul><li>对数阶<code>O(logn)</code></li></ul><p><img src="image-20200101210742484.png" alt=""></p><p>根据右移运算的性质，每右移一位，<code>n</code>都至少缩减一半。也就是说，至多经过<code>1 + log2n</code>次循环，<code>n</code>必然缩减至<code>0</code>，从而算法终止。因此时间复杂度为：<code>O(1 + log2n) = O(log2n)</code> 。</p><ul><li>线性阶<code>O(n)</code></li></ul><p><img src="image-20200101211150536.png" alt=""></p><ul><li>平方阶<code>O(n)</code></li></ul><p><img src="image-20200101211909446.png" alt=""></p><p>时间复杂度为：<code>O(2n^2 + n + 1) = O(n^2)</code>。</p><h4 id="常见的算法时间复杂度排序"><a href="#常见的算法时间复杂度排序" class="headerlink" title="常见的算法时间复杂度排序"></a>常见的算法时间复杂度排序</h4><p><code>Ο(1) ＜ Ο(logn) ＜ Ο(n) ＜ Ο(nlogn) ＜ Ο(n^2) ＜ … ＜ Ο(2^n) ＜ Ο(n!)</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之实现</title>
      <link href="/hNsvEFKo8ZJPUeMf/"/>
      <url>/hNsvEFKo8ZJPUeMf/</url>
      
        <content type="html"><![CDATA[<h4 id="第5章：实现"><a href="#第5章：实现" class="headerlink" title="第5章：实现"></a>第<code>5</code>章：实现</h4><h5 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款<code>26</code>：尽可能延后变量定义式的出现时间</h5><ul><li>应该延长变量的定义，直到非得使用它时</li><li>应该延后这份定义，直到能够给它初值实参</li></ul><p>对于循环存在的情况：</p><ul><li><p>做法<code>A</code>：定义于循环外</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    w = 取决于 i 的某个值；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>做法<code>B</code>：定义于循环内</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于 i 的某个值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这两种写法的成本如下：</p><ul><li><p>做法<code>A</code>：<code>1</code>个构造函数 + <code>1</code>个析构函数 + <code>n</code>个赋值操作</p></li><li><p>做法<code>B</code>：<code>n</code>个构造函数 + <code>n</code>个析构函数</p></li><li><p>做法<code>A</code>会造成名称<code>w</code>的作用域比做法<code>B</code>更大</p><p>除非（1）你知道赋值成本比构造 + 析构成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法<code>B</code>。</p></li></ul></li></ul><a id="more"></a><h5 id="条款27：尽量少做转型操作"><a href="#条款27：尽量少做转型操作" class="headerlink" title="条款27：尽量少做转型操作"></a>条款<code>27</code>：尽量少做转型操作</h5><p>旧式<code>C</code>转型：</p><ul><li><code>T(expression)</code></li><li><code>(T)expression</code></li></ul><p>新式<code>C++</code>转型：</p><ul><li><p><code>const_cast&lt;T&gt;(expression)</code></p><p>  用来将对象的常量性（<code>const</code>）转除（只有它能办到）。</p></li><li><p><code>dynamic_cast&lt;T&gt;(expression)</code></p><p>  用来执行安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型。</p></li><li><p><code>reinterpret_cast&lt;T&gt;(expression)</code></p><p>  用来执行低级转型，如将一个<code>pointer to in</code>t 转为一个<code>int</code>。很少使用（在条款<code>50</code>中使用过一次）。</p></li><li><p><code>static_cast&lt;T&gt;(expression)</code></p><p>  用来强迫隐式转换，例如将<code>non-const</code>对象转为<code>const</code>对象，将<code>int</code>转为<code>double</code>，将<code>void*</code>指针转为<code>typed</code>指针，或将<code>pointer to base</code>转为<code>pointer to derived</code>。</p></li></ul><p>任何一种类型转换（无论显式转换还是隐式转换）往往都会令编译器编译出运行期间执行的码。如将<code>int</code>转为<code>double</code>会产生一些代码，因为<code>int</code>的底层表述不同于<code>double</code>的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> z = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">// 隐喻的将 Derived* 转换为 Base*</span></span><br></pre></td></tr></table></figure><p>这种情况下有时候会有一个偏移量在运行期被施行于<code>Derived*</code>身上，用来取得正确的<code>Base*</code>指针值。这个例子表明单一对象可能有一个以上的地址（以<code>Base*</code>指向它时的地址和以<code>Derived*</code>指向它时的地址）。</p><p>假设我们有个<code>base class Window</code>和一个<code>derived class Specialwindow</code>，两者都定义了<code>virtual</code>函数<code>onResize</code>。进一步假设<code>Specialwindow</code>的<code>onResize</code>函数被要求首先调用<code>Window</code>的<code>onResize</code>。下面实际上是错的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span> <span class="params">()</span> </span>&#123;...&#125; <span class="comment">// base onResize实现代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Specialwindow</span>:</span> <span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">// derived onResize 实现代码</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).onResize(); <span class="comment">// 将 *this 转型为 Window,</span></span><br><span class="line">                                                <span class="comment">// 然后调用其 onResize;</span></span><br><span class="line">        <span class="comment">// 这不可行!</span></span><br><span class="line">        ... <span class="comment">// 这里进行 Specialwindow 专属行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“<code>*this</code>对象之<code>base class</code>成分”的<strong>暂时副本</strong>身上的<code>onResize</code>！如果<code>Window::onResize</code>修改了对象内容，当前对象其实没被改动，改动的是副本。然而<code>SpecialWindow::onResize</code>内如果也修改对象，当前对象真的会被改动。这使当前对象进入一种“伤残”状态：其<code>base class</code>成分的更改没有落实，而<code>derived class</code>成分的更改倒是落实了。</p><p>正确的做法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Specialwindow</span>:</span> <span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Window::onResize();<span class="comment">// 调用 Window::onResize 作用于 *this 身上</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code>的实现版本执行速度相当慢，应该在注重效率的代码中保持对<code>dynamic_cast</code>的警觉</li><li>优良的<code>C++</code>代码很少使用转型，我们应该尽可能隔离转型动作，通过将它隐藏在某个函数内，使得客户可以调用该函数而不需要将转型放进他们自己代码内</li><li>宁可使用新式转型，也不要使用旧式转型，前者很容易辨识出来</li></ul><h5 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款<code>28</code>：避免返回<code>handles</code>指向对象内部成分</h5><ul><li><code>handles</code>指指针、引用和迭代器</li><li>成员变量的封装性最多只等于“返回其<code>reference</code>”的函数的访问级别</li><li>如果<code>const</code>成员函数不得不传出去一个<code>reference</code>，则最好将返回类型限定为<code>const</code></li><li>有可能会导致空悬的<code>handles</code>，它的生命期却长于其所指对象</li></ul><h5 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款<code>29</code>：为“异常安全”而努力是值得的</h5><p>当异常被抛出时，带有异常安全性的函数会：</p><ul><li>不泄露任何资源</li><li>不允许数据败坏</li></ul><p>较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也少。异常安全码必须提供以下三个保证之一：</p><ul><li><p>基本承诺</p><p>  如果异常被抛出，程序内的任何事物仍然保证在有效状态（只要那是个合法状态）下，没有任何对象或数据结构会因此而败坏，所有对象处于一种内部前后一致的状态。</p></li><li><p>强烈保证</p><p>  如果异常被抛出，程序状态不改变。</p></li><li><p>不抛掷保证</p><p>  承诺绝不抛出异常，因为它们总能完成原先承诺的功能。</p></li></ul><p>可以实现强烈保证的<code>copy and swap</code>技术：为你打算修改的对象做出<code>copy</code>一份副本，然后在副本身上做一切修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。带所有改变都成功后，再将修改后的副本和原对象<code>swap</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之所以实现为 struct 是因为其 PrettyMenu 的数据封装性</span></span><br><span class="line"><span class="comment">// 已经由 pImpl 是 private 获得了保证</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> &#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PMImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pImpl; <span class="comment">// pimpl idiom 详细描述见条款 31</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    <span class="comment">// 见条款25</span></span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 获得mutex的副本数据</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">    pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc)); <span class="comment">// 修改副本</span></span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    swap(pImpl, pNew); <span class="comment">// 置换(swap)数据, 释放 mutex</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意，并非所有函数都可实现强烈保证或其具备现实意义。</p></blockquote><p>函数提供的”异常安全保证“通常最高只等于其所调用各个函数提供的”异常安全保证“中的最弱者。</p><h5 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款<code>30</code>：透彻了解<code>inlining</code>的里里外外</h5><p><code>inline</code>函数是指将对此函数的每一个调用都以函数本体替换之。这将导致两种情况：</p><ul><li>目标码增加（显然）</li><li>如果<code>inline</code>函数的体积很小，编译器对“函数本体”所产出的码可能比“函数调用”所产出的码小</li></ul><p><code>inline</code>只是对编译器的一个申请，不是强制命令，也就是说编译器可以拒绝将太过复杂（带有递归或循环）的函数进行<code>inline</code>。通过对函数使用<code>inline</code>关键字属于明确提出申请，将函数定义于类内属于隐喻申请。</p><ul><li><p>将大多数<code>inline</code>限制在小型、被频繁调用的函数身上</p></li><li><p><code>inline</code>函数通常一定被置于头文件内</p><p>  因为大多数构建环境在编译过程中进行<code>inlining</code>，而为了将一个函数调用替换为被调用函数的本体，编译器必须知道那个函数长什么样子。</p></li><li><p>所有对<code>virtual</code>函数的<code>inline</code>申请都会被拒绝（因为对<code>virtual</code>函数的调用在运行期才确定）</p></li></ul><h5 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款<code>31</code>：将文件间的编译依存关系降至最低</h5><ul><li><p>将接口从实现中分离</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> theName; <span class="comment">// 实现细目</span></span><br><span class="line">    Date theBirthDate; <span class="comment">// 实现细目</span></span><br><span class="line">    Address theAddress; <span class="comment">// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这里的<code>class</code>无法通过编译，因为编译器没有取得其实现代码所用到的<code>class string</code>，<code>Date</code>，<code>Address</code>的定义式，通常应该在<code>Person</code>定义文件的最上方存在<code>include</code>头文件。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"date.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"address.h"</span></span></span><br></pre></td></tr></table></figure><p>  不幸的是，这么一来便是在<code>Person</code>定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其他头文件有任何改变，那么每一个含入<code>Person class</code>的文件就得重新编译，任何使用<code>person class</code>的文件也必须重新编译。这样的连串编译依存关系（<code>cascading compilation dependencies</code>）会对许多项目造成难以形容的灾难。</p></li><li><p><code>Handle classes</code>：<code>pimpl idiom</code>(<code>pointer to implenmentation</code>) + 前向声明</p><p>  把<code>Person</code>分割成两个<code>class</code>，一个只提供接口，另一个负责实现接口。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //标准程序库组件不该被前向声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向声明而不是包含头文件, 这个很关键</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span> <span class="comment">// Person 实现类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 接口用到的 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl; <span class="comment">// 指针, 指向实现物</span></span><br><span class="line">    <span class="comment">// 如果不这样做的话, 编译器在编译 Person 类的时候，必须知道 Person 类的大小</span></span><br><span class="line">    <span class="comment">// 就不得不包含这三个实现细目</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    string theName; // 实现细目</span></span><br><span class="line"><span class="comment">Date theBirthDate; // 实现细目</span></span><br><span class="line"><span class="comment">Address theAddress; // 实现细目</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 然而一旦这样写, 前面的前向声明就没用了, 必须包含头文件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这样一来，<code>Person</code>类的使用者就完全于<code>Date</code>，<code>Address</code>以及<code>Person</code>的实现细目相分离了。这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：实现上让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。</p><p>  几个简单的设计策略：</p><ul><li><p>如果使用<code>object reference</code>或<code>object pointer</code>可以完成任务，就不要使用<code>object</code></p><p>  你可以只靠一个类型声明式就定义出指向该类型的<code>reference</code>和<code>pointer</code>；但如果定义某类型的<code>object</code>，就需要用到该类型的定义式。</p></li><li><p>如果能够，尽量以<code>class</code>声明式替换<code>class</code>定义式</p><p>  注意，当你声明一个函数而它用到某个<code>class</code>时，你并不需要该<code>class</code>的定义。</p></li><li><p>为声明式和定义式提供不同的头文件</p><p>  对于前面代码中的前向声明，最好是提供一个声明式头文件，包含全部的前向声明。</p><p>下面式<code>Person.cpp</code>文件的部分实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Person.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;PersonImpl.h&gt; </span></span></span><br><span class="line"><span class="comment">// 注意，Person 和PersonImpl的成员函数完全相同, 两者接口完全相同</span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span><br><span class="line">        <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">        <span class="keyword">const</span> Address&amp; addr) : pImpl(<span class="keyword">new</span> PersonImpl(name, birthday,addr)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::narne</span><span class="params">( )</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pImpl-&gt;name();&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Interface classes</code>：<code>abstract base class</code> + <code>factory</code>函数</p><p>  <code>abstract base class</code>通常没有成员变量，也没有构造函数，只有一个<code>virtual</code>析构函数和一组<code>pure virtual</code>函数。但<code>Interface class</code>的客户必须有办法为这种<code>class</code>创建新对象。他们通常调用一个特殊函数，此函数创建实际实现的<code>derived class</code>，这样的函数通常称为<code>factory</code>(工厂）函数（见条款<code>13</code>），它们返回智能指针指向动态分配所得对象，而该对象支持<code>Interface class</code>的接口。这样的函数又往往在<code>Interface class</code>内被声明为<code>static</code>：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 Person.h</span></span><br><span class="line"><span class="comment">// 抽象基类, 只有声明</span></span><br><span class="line"><span class="comment">// 提供给客户使用的头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> strng <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> strng <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// static 的 factory 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Address&amp; addr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于 Person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealPerson(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span><br><span class="line">               <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="keyword">const</span> Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RealPerson() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 虚函数的实现码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>Handle classes</code>和<code>Interface classes</code>解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之设计与声明</title>
      <link href="/S0Qfg61EKNlwLo15/"/>
      <url>/S0Qfg61EKNlwLo15/</url>
      
        <content type="html"><![CDATA[<h4 id="第4章：设计与声明"><a href="#第4章：设计与声明" class="headerlink" title="第4章：设计与声明"></a>第<code>4</code>章：设计与声明</h4><h5 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款<code>18</code>：让接口容易被正确使用，不容易被误用</h5><ul><li>如果客户企图使用某个接口却没有获得所预期的行为，这个代码不应该通过编译；如果代码通过了编译，则它的行为就应该是客户想要的</li><li>欲达“让接口容易被正确使用，不容易被误用”的目的，必须考虑客户调用接口时可能做出什么样的错误</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型兼容</li><li>“阻止误用”的办法包括建立新类型、限制在类型上的操作，束缚对象值以及消除客户的资源管理责任</li></ul><a id="more"></a><h5 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款<code>19</code>：设计class犹如设计<code>type</code></h5><p>你应该带着“语言设计者当初设计语言内置类型时”一样的谨慎来研讨每一个<code>class</code>的设计。因为，重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结…全都在你手上。</p><ul><li><p>新的<code>type</code>的对象应该如何创建和销毁？</p><p>  设计函数为类的构造函数和析构函数以及内存分配函数和释放函数（见条款<code>49-52</code>）。</p></li><li><p>对象的初始化和对象的赋值该有什么样的差别？</p><p>  决定了构造函数和赋值操作符的行为以及差异。</p></li><li><p>新<code>type</code>的对象被<code>passed by value</code>，意味着什么？</p><p>  取决于<code>copy</code>构造函数的实现。</p></li><li><p>什么新<code>type</code>的合法值？</p></li><li><p>你的新<code>type</code>需要配合某个继承图系吗？</p><p>  见条款<code>7</code>、<code>34</code>、<code>36</code>。</p></li><li><p>你的新<code>type</code>需要什么样的转换？</p><p>  <code>explicit</code>和<code>operator</code>关键字的使用。见条款<code>15</code>。</p></li><li><p>什么样的操作符和函数对此新<code>type</code>而言时合理的？</p><p>  见条款<code>23</code>、<code>24</code>、<code>46</code>。</p></li><li><p>什么样的标准函数应该驳回？</p><p>  见条款<code>6</code>。</p></li><li><p>谁该取用新<code>type</code>的成员？</p><p>  决定了数据成员是<code>public</code>、<code>private</code>还是<code>protected</code>，以及<code>friend</code>关键的使用。</p></li><li><p>什么是新<code>type</code>的“未声明接口”？</p><p>  见条款<code>29</code>。</p></li><li><p>你的新<code>type</code>有多么一般化？</p><p>  决定<code>class template</code>的使用。</p></li><li><p>你真的需要一个新<code>type</code>吗？</p></li></ul><h5 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass by reference to const替换pass by value"></a>条款<code>20</code>：宁以<code>pass by reference to const</code>替换<code>pass by value</code></h5><ul><li>当把具有继承关系的类作为参数传递时，如果<code>pass by value</code>可能会出现“截断”问题。</li></ul><h5 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款<code>21</code>：必须返回对象时，别妄想返回其<code>reference</code></h5><ul><li>绝不要返回指向一个<code>local stack</code>对象的<code>pointer</code>或<code>reference</code></li><li>绝不要返回指向一个<code>heap allocated</code>对象的<code>reference</code></li><li>除非有单例模式的设计要求，否则绝对不要返回指向一个<code>local static</code>对象的<code>pointer</code>或<code>reference</code></li></ul><h5 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款<code>22</code>：将成员变量声明为<code>private</code></h5><ul><li><p>客户访问数据的一致性</p><p>  <code>public</code>里都是函数。</p></li><li><p>可以对成员变量有更精确的控制</p><p>  可以实现成员变量的不可访问，只读、只写、读写访问。</p></li><li><p>封装性</p><p>  将成员变量隐藏在函数接口背后，可以为所有可能的实现提供弹性。</p></li><li><p>从封装的角度看，只有两种权限：<code>private</code>（提供封装）和其它</p><p>  <code>protected</code>并不比<code>private</code>更具封装性。</p></li></ul><h5 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款<code>23</code>：宁以<code>non-member</code>、<code>non-friend</code>替换<code>member</code>函数</h5><p>考虑一个用来表示网页浏览器的<code>class</code>，这个<code>class</code>提供的众多成员函数中，有用来清除下载元素高速缓冲区的，有用来清除访问过的历史记录的，有用来移除系统中所有<code>cookies</code>的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleatCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户想一整个执行所有的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以提供一个 member 函数的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverthing</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以提供一个 non-member 函数的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wb.clearCache();</span><br><span class="line">    wb.clearHistory();</span><br><span class="line">    wb.cleatCookies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后者比较好。因为：</p><ul><li><p>增加封装性</p><p>  <code>non-member non-friend</code>将提供较大的封装性，因为它并不增加能够访问<code>class</code>内的<code>private</code>成分的函数数量。<code>friend</code>函数对<code>class private</code>成员的访问权力和<code>member</code>函数相同，两者对封装的冲击力度是一样的。</p></li><li><p>增加扩充机能性</p><p>  在<code>C++</code>中，正确且自然的做法是：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span>...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>; <span class="comment">// 为 WebBrowser “提供便利”的函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>namespace</code>和<code>class</code>的不同是，前者可跨越多个源码文件而后者不能。</p><p>像<code>WebBrowser</code>这样的类可能有大量的“提供便利”函数，某些与书签有关，与打印有关，与<code>cookie</code>有关… 分离它们最直接的做法就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 WebBrowser.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span>...&#125;;</span><br><span class="line">    ... <span class="comment">// 核心机能, 例如所有客户都想要的 non-member 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件 WebBrowserBookmarks.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 与书签相关的 non-member 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件 WebBrowserCookies.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 与 cookie 相关的 non-member 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有“便利函数”放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组“便利函数”。</p></li></ul></li></ul><h5 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款<code>24</code>：若所有参数皆需类型转换，请为此采用<code>non-member</code>函数</h5><ul><li><p>有理数类<code>Rational</code>的实现</p><p>  重点关注用来将两个有理数相乘的<code>operator*</code>操作符重载函数的实现方式。</p></li></ul><h5 id="条款25：考虑写出一个不抛异常的swap函数"><a href="#条款25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛异常的swap函数"></a>条款<code>25</code>：考虑写出一个不抛异常的<code>swap</code>函数</h5><p>标准程序库提供的<code>swap</code>算法的典型实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要<code>T</code>类型支持<code>copying</code>函数（<code>copy</code>构造函数和<code>copy assignment</code>操作符）。对于用户自定义类型，效率低下（需要三次复制）。</p><p>现在考虑所谓的<code>pimpl(pointer to implementation)</code>实现手法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这是个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 细节不重要</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ... <span class="comment">// 有很多数据, 意味着复制时间很长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这是个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&lt;T&gt;&amp; rhs);</span><br><span class="line">    <span class="comment">// 关于 operator= 的一般性实现参考条款 10, 11, 12</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl&lt;T&gt;* pImpl; <span class="comment">// 指向实际实现的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一旦需要置换两个<code>Widget</code>对象值，我们实际唯一需要的是置换两个指针即可。但缺省的<code>swap</code>函数不知道这一点！</p><p>下面是正确的实现步骤：</p><ol><li><p>令<code>Widget</code>实现一个名为<code>swap</code>的<code>public</code>成员函数做真正的置换工作</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 必须的</span></span><br><span class="line">        swap(pImpl, other.pImpl); <span class="comment">// 直接置换指针即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>std::swap</code>特化，令它调用该成员函数<strong>（当<code>Widget</code>是类时。这里的例子中，<code>Widget</code>是个模板类则不要这一步）</strong></p><ul><li><p>因为，<code>C++</code>只允许对<code>class template</code>偏特化，不允许对<code>function template</code>进行偏特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.swap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>声明一个<code>non-member swap</code>，令它调用<code>member swap</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意, 要将它放在和 Widget&lt;T&gt; 同一个空间内(全局或者自定义的 namespace)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编程时，在调用<code>swap</code>置换对象的语句之前加上<code>using std::swap</code>声明</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户代码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1. T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 令 std::swap 在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    swap(obj1, obj2); <span class="comment">// 这样一来, 编译器将为 T 类型对象调用最佳版本 swap</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译器首先在全局作用域或<code>T</code>所在命名空间内寻找<code>T</code>（在这里，<code>T</code>就是例子中的<code>Widget</code>哦）专属的<code>swap</code>（也就是步骤<code>3</code>中实现的）。如果没有实现这些，则调用<code>std</code>内的<code>swap</code>，如果步骤<code>2</code>还实现了特化版本，将会选中特化版本。</p></li></ol><ul><li><p>劝告，<code>member swap</code>绝不可抛出异常</p><p>  具体参考条款29。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之资源管理</title>
      <link href="/ojSMOM86r5rbvAqL/"/>
      <url>/ojSMOM86r5rbvAqL/</url>
      
        <content type="html"><![CDATA[<h4 id="第3章：资源管理"><a href="#第3章：资源管理" class="headerlink" title="第3章：资源管理"></a>第<code>3</code>章：资源管理</h4><h5 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款<code>13</code>：以对象管理资源</h5><ul><li><p><code>RAII</code>(<code>Resource Acquisition Is Initialization</code>)</p><p>  使用<code>new</code>获取资源后于同一条语句内以它初始化某个资源管理对象。利用当管理对象离开作用域被销毁时自动调用其析构函数的机制确保资源被释放。不直接用<code>new</code>和<code>delete</code>，多用智能指针。</p></li><li><p>智能指针在其析构函数中做<code>delete</code>动作而非<code>delete[]</code>动作</p><p>  因此，不要在动态分配来的数组身上使用智能指针（虽然它仍然会通过编译）。</p></li></ul><a id="more"></a><h5 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款<code>14</code>：在资源管理类中小心<code>copying</code>行为</h5><ul><li>当不想<code>RAII</code>类被复制时可以继承<code>Uncopyable</code>类</li></ul><p>将智能指针施于<code>heap-based</code>资源身上是个好主意，但并不是所有资源都是<code>heap-based</code>的，比如互斥器<code>mutex</code>，<code>mutex</code>就不可复制。</p><h5 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款<code>15</code>：在资源管理类中提供对原始资源的访问</h5><ul><li><p>显示转换（安全）</p><p>  例如，<code>shared_ptr</code>类就提供可一个<code>get</code>成员函数来返回智能指针内部的原始指针。</p></li><li><p><code>operator</code>隐式转换（调用方便）</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// operator 可以实现隐式转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B b; <span class="comment">// B 类型对象成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受 B 类型对象的一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(B b)</span></span>;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">func(a); <span class="comment">// a 会被编译器隐式转换为 B 类型对象</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="条款16：使用new和delete时要采用相同的形式"><a href="#条款16：使用new和delete时要采用相同的形式" class="headerlink" title="条款16：使用new和delete时要采用相同的形式"></a>条款<code>16</code>：使用<code>new</code>和<code>delete</code>时要采用相同的形式</h5><ul><li><p>编译器在给数组分配内存时，会包括数组大小的记录</p><p>  这样的好处是，<code>delete[]</code>时知道需要调用多少次析构函数。</p></li><li><p>不要对数组形式进行<code>typedef</code>动作</p></li></ul><h5 id="条款17：以独立语句将new来的对象置入智能指针"><a href="#条款17：以独立语句将new来的对象置入智能指针" class="headerlink" title="条款17：以独立语句将new来的对象置入智能指针"></a>条款<code>17</code>：以独立语句将<code>new</code>来的对象置入智能指针</h5><p>考虑这样两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>; <span class="comment">// 调用这个函数不排除会发生异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><p>如果这样调用编译不通过，因为<code>shared_ptr</code>接收原始指针的构造函数是<code>explicit</code>的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="keyword">new</span> Widget, priority());</span><br></pre></td></tr></table></figure><p>如果这样调用可能会造成内存泄漏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure><p>因为编译器在编译这条语句时，实际上会创建三个动作：</p><ul><li>调用<code>priority()</code></li><li>执行<code>new Widget</code></li><li>调用<code>shared_ptr</code>的构造函数</li></ul><p>而<code>C++</code>编译器安排这三个动作的次序是不确定的。</p><p>如果执行次序是这样：</p><ol><li>执行<code>new Widget</code></li><li>调用<code>priority()</code></li><li>调用<code>shared_ptr</code>的构造函数</li></ol><p>一旦中途<code>priority()</code>导致异常，那么<code>new</code>返回的原始指针并未交给智能指针保管，将造成资源泄露。</p><p>正确的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure><p>因为，编译器对“跨越语句的各项操作”没有重新排列执行次序的自由。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之构造、析构、赋值运算</title>
      <link href="/MeCvwFxjI4asjddf/"/>
      <url>/MeCvwFxjI4asjddf/</url>
      
        <content type="html"><![CDATA[<h4 id="第2章：构造、析构、赋值运算"><a href="#第2章：构造、析构、赋值运算" class="headerlink" title="第2章：构造、析构、赋值运算"></a>第<code>2</code>章：构造、析构、赋值运算</h4><h5 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款<code>05</code>：了解<code>C++</code>默默编写并调用哪些函数</h5><ul><li><p>编译器会暗自为<code>class</code>创建<code>default</code>构造函数、<code>copy</code>构造函数、<code>copy assignment</code>操作符以及析构函数</p></li><li><p>对于<code>class</code>内含<code>reference</code>成员或<code>const</code>成员，编译器拒绝为其生成<code>copy</code>构造函数和<code>copy assignment</code>操作符</p><blockquote><p>因为<code>C++</code>不允许<code>reference</code>改指向不同的对象以及更改<code>const</code>成员。 </p></blockquote></li></ul><a id="more"></a><h5 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款<code>06</code>：若不想使用编译器自动生成的函数，就该明确拒绝</h5><ul><li><p>为驳回编译器自动提供的函数，可将相应的成员函数声明为<code>private</code>并且不予实现。</p></li><li><p>掌握<code>Uncopyable</code>类的实现机制</p><ul><li><p>将构造函数和析构函数设置为<code>protected</code>的</p></li><li><p>将拷贝构造函数和拷贝赋值运算符设置为<code>private</code>的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable() &#123;&#125;</span><br><span class="line">    ~Uncopyable() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">    <span class="keyword">const</span> Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款<code>07</code>：为多态基类声明<code>virtual</code>析构函数</h5><ul><li><p>带多态性质的<code>base class</code>应该声明一个<code>virtual</code>析构函数</p></li><li><p>当<code>class</code>内至少含有一个<code>virtual</code>函数，才为它声明<code>virtual</code>析构函数</p></li><li><p><code>class</code>的设计目的如果不是作为<code>base class</code>使用，或不是为了具备多态性，就不该声明<code>virtual</code>析构函数</p></li><li><p>然而，有时候你希望拥有一个抽象类，但没有任何需要的<code>pure virtual</code>方法，怎么办？</p><p>  由于<code>abstract class</code>（不能实例化）总是被期望当作多态基类，多态基类又需要<code>virtual</code>析构函数，而<code>pure virtual</code>函数会导致<code>abstract class</code>，因此可将析构函数声明为<code>pure virtual</code>并且给出默认实现。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小技巧:pure virtual 析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AWOV::~AWOV() &#123;<span class="comment">/* default */</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款<code>08</code>：别让异常逃离析构函数</h5><ul><li>析构函数绝对不要吐出异常</li></ul><p>假设有一个类负责数据库的连接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; <span class="comment">// 关闭联机, 失败则抛出异常</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了确保客户不忘记在<code>DBConnection</code>对象上调用<code>close</code>函数，一个合理的想法是创建一个用来管理<code>DBConnection</code>资源的类，并在析构函数中调用<code>close</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~DBConn()</span><br><span class="line">    &#123;</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户可以写出这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 区块作用域结束，调用析构函数销毁对象</span></span><br></pre></td></tr></table></figure><p>如果被析构函数调用的函数<code>close</code>可能抛出异常，析构函数应该捕获异常然后吞下它们或者结束程序。</p><p>一个好的策略是，开放一个<code>close</code>接口供用户调用，把调用<code>close</code>的责任从<code>DBConn</code>析构函数手上移到用户手上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.close();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DBConn()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                 db.close(); <span class="comment">// 关闭连接（如果客户没做的话）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(...)</span><br><span class="line">            &#123;</span><br><span class="line">                日志记录下对 close 调用的失败;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，如果客户需要对某个操作函数运行期间的异常作出反应，那么<code>class</code>应该提供一个接口执行该操作。如果<code>close</code>的确发生了异常，而客户没有调用<code>close</code>接口进行处理，<code>DBConn</code>只能吞下或结束程序。</p><h5 id="条款09：绝不在析构和构造函数中调用virtual函数"><a href="#条款09：绝不在析构和构造函数中调用virtual函数" class="headerlink" title="条款09：绝不在析构和构造函数中调用virtual函数"></a>条款<code>09</code>：绝不在析构和构造函数中调用<code>virtual</code>函数</h5><ul><li>派生类对象内的基类成分会在派生类自身成分被构造之前先被构造</li><li>基类构造期间，虚函数绝不会下降到派生类层</li></ul><p>需要注意的是，有时类有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复时会把相同的初始化代码放到一个<code>init</code>函数中实现，如果这时在<code>init</code>函数中同样调用了虚函数，情况是一样的但<strong>比较隐秘</strong>。 </p><h5 id="条款10：令赋值操作符operator-返回一个reference-to-this"><a href="#条款10：令赋值操作符operator-返回一个reference-to-this" class="headerlink" title="条款10：令赋值操作符operator=返回一个reference to *this"></a>条款<code>10</code>：令赋值操作符<code>operator=</code>返回一个<code>reference to *this</code></h5><ul><li>为了实现连续赋值</li></ul><h5 id="条款11：在operator-中处理自我赋值"><a href="#条款11：在operator-中处理自我赋值" class="headerlink" title="条款11：在operator=中处理自我赋值"></a>条款<code>11</code>：在<code>operator=</code>中处理自我赋值</h5><ul><li>有些自我赋值并不明显，如通过指针或引用</li></ul><p>假设你建立一个<code>class</code>来保存一个指针指向一块动态分配的位图（<code>bitmap</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb; <span class="comment">// 指向一个从 heap 分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>错误的<code>operator=</code>实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自我赋值不安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过一个“证同测试”来检验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自我赋值安全, 但不具备异常安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的异常安全指的是，如果<code>new Bitmap</code>发生异常，会导致<code>Widget</code>最终会持有一个指针指向一块被删除的<code>Bitmap</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具备异常安全, 则自动具备自我赋值安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* oldPb = pb; <span class="comment">// 记住之前的 pb</span></span><br><span class="line">    </span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">delete</span> oldPb;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用更好的<code>copy and swap</code>技术：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 交换 *this 和 rhs 的数据, 见条款 25</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提升点效率 ?</span></span><br><span class="line">    <span class="comment">// if(this == &amp;rhs)</span></span><br><span class="line">    <span class="comment">//     return *this;</span></span><br><span class="line">    </span><br><span class="line">    Widget temp(rhs); <span class="comment">// copy</span></span><br><span class="line">    </span><br><span class="line">    swap(temp); <span class="comment">// swap</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="条款12：复制对象时勿忘每一个成分"><a href="#条款12：复制对象时勿忘每一个成分" class="headerlink" title="条款12：复制对象时勿忘每一个成分"></a>条款<code>12</code>：复制对象时勿忘每一个成分</h5><ul><li>每一个成分包括对象内所有成员变量以及所继承的<strong>基类成分</strong><ul><li>在拷贝构造函数中的初始化列表中调用所继承的类的拷贝构造函数</li><li>在拷贝赋值操作符函数中调用所继承的类的拷贝赋值操作符函数</li></ul></li><li>不要尝试让拷贝构造函数和拷贝赋值操作符函数互相调用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++之让自己习惯C++</title>
      <link href="/l4snoL8SUW9lGasI/"/>
      <url>/l4snoL8SUW9lGasI/</url>
      
        <content type="html"><![CDATA[<h4 id="第1章：让自己习惯C"><a href="#第1章：让自己习惯C" class="headerlink" title="第1章：让自己习惯C++"></a>第<code>1</code>章：让自己习惯<code>C++</code></h4><h5 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款<code>01</code>：视<code>C++</code>为一个语言联邦</h5><ul><li>将<code>C++</code>视为由<code>4</code>个次语言组成的联邦：<ul><li><code>C</code>：没有模板、没有异常、没有重载…</li><li><code>Object-Oriented C++</code>：类、封装、继承、多态、虚函数、动态绑定等等；</li><li><code>Template C++</code>：泛型编程部分；</li><li><code>STL</code>：是一个<code>Template</code>程序库，容器、迭代器、算法以及函数对象。</li></ul></li></ul><p>从某个此语言切换到另一个时，高效编程守则可能会发生变化。比如，<code>C-like</code>类型（内置类型）<code>pass by value</code>更好；对于<code>Object-Oriented C++</code>而言，<code>pass by reference to-const</code>更好；再切换到<code>STL</code>，由于迭代器和函数对象都是在<code>C</code>指针之上塑造出来的，<code>pass by value</code>守则再次适用。</p><a id="more"></a><h5 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款<code>02</code>：尽量以<code>const</code>，<code>enum</code>，<code>inline</code>替换<code>#define</code></h5><ul><li><p>对于单纯常量，最好以<code>const</code>对象或<code>enum hack</code>替换<code>#define</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记号名称未进入符号表, 难以调试</span></span><br><span class="line"><span class="comment">// 在多处出现目标码, 尤其浮点常量</span></span><br><span class="line"><span class="comment">// 无作用域概念, 不提供任何封装性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量会被编译器看到, 进入符号表</span></span><br><span class="line"><span class="comment">// 导致较小量的目标码, 因为只有一份</span></span><br><span class="line"><span class="comment">// 可放置在类内或 namespace 中限制其作用域</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以放在类或 namespace 中</span></span><br><span class="line"><span class="comment">// 令 NumTurns 成为 5 的记号名称, 一般用在类中做常量用</span></span><br><span class="line"><span class="comment">// 行为像 #define, 对 const 取地址合法，对 enum 和 #define 取地址就不合法</span></span><br><span class="line"><span class="keyword">enum</span> &#123;NumTurns = <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>对于形似函数的宏，最好用<code>inline</code>（或模板）函数替换</p><p>  宏中的变量有可能会被运算多次。</p></li></ul><h5 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款<code>03</code>：尽可能使用<code>const</code></h5><ul><li><p><code>const</code>作用于迭代器</p><p>  <code>STL</code>迭代器是以指针为根据塑模出来的，其作用就像个<code>T*</code>指针。声明迭代器为<code>const</code>只是声明一个<code>const</code>指针（作用就像<code>T* const</code>），表明的是迭代器本身不可变，但其所指的值是可以改动的。如果希望迭代器所指的值不可改动，需要的是<code>const_iterator</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line">*iter = <span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">++iter; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator citer = vec.begin();</span><br><span class="line">*citer = <span class="number">10</span>; <span class="comment">// 错误</span></span><br><span class="line">++citer; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>将<code>operator*</code>的返回类型声明为<code>const-by-value</code></p></li><li><p><code>const</code>可被施加于任何作用域内的对象、函数参数（常用<code>pass-by-reference-to-const</code>），函数返回类型、类成员函数本体</p></li><li><p><code>const</code>施加于成员函数</p><p>  成员函数上的<code>const</code>限定符意味着不能修改<code>non-mutable</code>，<code>non-static</code>类数据成员。</p></li><li><p>当<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>成员函数调用<code>const</code>版本可避免代码重复</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验</span></span><br><span class="line">        ... <span class="comment">// 日记数据访问</span></span><br><span class="line">        ... <span class="comment">// 检验数据完整性</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    char&amp; operator[](std::size_t position)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ... // 边界检验</span></span><br><span class="line"><span class="comment">        ... // 日记数据访问</span></span><br><span class="line"><span class="comment">        ... // 检验数据完整性</span></span><br><span class="line"><span class="comment">        return text[position];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用 const_cast 移除对象身上的 const</span></span><br><span class="line">        <span class="comment">// 调用 static_cast 为 *this 加上 cosnt</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBook&amp;&gt;(*<span class="keyword">this</span>)[position]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>const</code>版本成员函数调用<code>non-const</code>版本不合法</p></li></ul><h5 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款<code>04</code>：确定对象被使用前已先被初始化</h5><ul><li><p>为内置型对象进行手工初始化，因为<code>C++</code>并不保证初始化它们</p></li><li><p>构造函数使用成员初始化列表，初始化顺序与在类中声明顺序一致</p></li><li><p>为避免“跨编译单元内定义的<code>non-local static</code>对象的初始化问题”，以<code>local</code>对象替换<code>non-local static</code>对象</p><ul><li><code>static</code>对象包括<code>global</code>对象、定义与<code>namespace</code>作用域内的对象、在<code>class</code>内、函数内、以及在<code>file</code>作用域内被声明为static的对象</li><li>函数内的<code>static</code>被称为<code>local static</code>对象，其它<code>static</code>对象被称为<code>non-local static</code>对象</li><li>程序结束时，<code>static</code>对象会被自动销毁，也就是它们的析构函数在<code>main</code>函数结束时被自动调用</li><li>编译单元是指产出单一目标文件的源码文件以及所含入的头文件</li></ul></li></ul><p>现在有两个源码文件，每个至少含入一个<code>non-local static</code>对象，其中一个<code>non-local static</code>对象用到了另一个<code>non-local static</code>对象，而被用到的尚未被初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 FileSystem.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span><span class="keyword">const</span></span>; <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs; <span class="comment">// 预备给客户使用的对象, non-local static 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 Directory.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(); <span class="comment">// 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks(); <span class="comment">// 使用 tfs 对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在客户决定创建一个Directory对象，用来放置临时文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Directory tempDir; <span class="comment">// 为临时文件而做出的目录</span></span><br></pre></td></tr></table></figure><p>这个时候就会出现初始化次序带来的问题。由于<code>tfs</code>和<code>tempDir</code>是不同的人在不同的时间于不同的源码文件中创建出来的，因此初始化次序不一定。</p><p>解决方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 FileSystem.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> <span class="comment">// 用于创建预备给客户使用的对象的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs; <span class="comment">// local static 对象</span></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 Directory.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(); <span class="comment">// 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这样就保证了被使用对象先被初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks(); <span class="comment">// 使用 tfs() 创建对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
