<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>认识C++内存管理的工具 （三）</title>
      <link href="/gMOP9F0b8zMZULMj/"/>
      <url>/gMOP9F0b8zMZULMj/</url>
      
        <content type="html"><![CDATA[<h4 id="13-重载类本身的operator-new-delete"><a href="#13-重载类本身的operator-new-delete" class="headerlink" title="13. 重载类本身的operator new/delete"></a><code>13</code>. 重载类本身的<code>operator new/delete</code></h4><p><img src="image-20210316211007882.png" alt="image-20210316211007882"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A() : this:"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A(): this: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数写不写 static 都会被编译器做成 static</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用 A::operator new版本</span></span><br><span class="line">    A* a = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用全局的 operator new, 如果想调用 A 的版本, 则需显式调用 A::operator new()</span></span><br><span class="line">    <span class="keyword">void</span>* b = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(A));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    A* c = ::<span class="keyword">new</span> A();       <span class="comment">//调 用全局的 operator new</span></span><br><span class="line">    <span class="keyword">void</span>* d = ::<span class="keyword">new</span> A();    <span class="comment">// 调用全局的 operator new</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> a;   <span class="comment">// 先调用 A 的析构函数, 再调用 A 的 operator delete</span></span><br><span class="line">    <span class="keyword">delete</span> b;   <span class="comment">// 直接调用了全局的 operator delete</span></span><br><span class="line">    ::<span class="keyword">delete</span> c;</span><br><span class="line">    ::<span class="keyword">delete</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="14-本质就是重载new"><a href="#14-本质就是重载new" class="headerlink" title="14. 本质就是重载new"></a><code>14</code>. 本质就是重载<code>new</code></h4><p><code>new</code>是关键字，编译器看到<code>new</code>，会转换成<code>operator new</code>的调用。</p><p><img src="image-20210316211821850.png" alt="image-20210316211821850"></p><p><img src="image-20210316211849406.png" alt="image-20210316211849406"></p><p><img src="image-20210316211942624.png" alt="image-20210316211942624"></p><h4 id="15-重载new-delete"><a href="#15-重载new-delete" class="headerlink" title="15. 重载new()/delete()"></a><code>15</code>. 重载<code>new()/delete()</code></h4><p><img src="image-20210316212107044.png" alt="image-20210316212107044"></p><p><img src="image-20210316212317475.png" alt="image-20210316212317475"></p><h4 id="16-关于多参new对应的delete"><a href="#16-关于多参new对应的delete" class="headerlink" title="16. 关于多参new对应的delete"></a><code>16</code>. 关于多参<code>new</code>对应的<code>delete</code></h4><p><img src="image-20210316212449598.png" alt="image-20210316212449598"></p><ul><li><p>上面重载了参数不一的<code>operator new()</code>，那是不是要重载对应的<code>operator delete()</code>呢？</p><p>  理论上<code>delete</code>的工作只是为了释放内存，所以只需要一个指针就可以了，但<code>C++</code>在语法上支持多参的<code>delete</code>重载，但<code>delete</code>的调用格式只有<code>delete ptr</code>，所以关于重载的<code>delete</code>版本什么时候被调用，并不是用户手动调用，而是对应版本的<code>Ctor</code>发生异常后，会由<code>crt</code>来调用对应的<code>delete</code>。</p></li></ul><h4 id="17-basic-string使用new-extra-扩充申请量"><a href="#17-basic-string使用new-extra-扩充申请量" class="headerlink" title="17. basic_string使用new(extra)扩充申请量"></a><code>17</code>. <code>basic_string</code>使用<code>new(extra)</code>扩充申请量</h4><p><img src="image-20210316214052184.png" alt="image-20210316214052184"></p><h4 id="18-new-handler"><a href="#18-new-handler" class="headerlink" title="18. new_handler"></a><code>18</code>. <code>new_handler</code></h4><p><img src="image-20210317210723036.png" alt="image-20210317210723036"></p><p><img src="image-20210317211006818.png" alt="image-20210317211006818"></p><p><img src="image-20210317211425498.png" alt="image-20210317211425498"></p><p><img src="image-20210317211445418.png" alt="image-20210317211445418"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识C++内存管理的工具 （二）</title>
      <link href="/vgFO35JETZ2jRu74/"/>
      <url>/vgFO35JETZ2jRu74/</url>
      
        <content type="html"><![CDATA[<h4 id="7-构造和析构的直接调用方式"><a href="#7-构造和析构的直接调用方式" class="headerlink" title="7. 构造和析构的直接调用方式"></a><code>7</code>. 构造和析构的直接调用方式</h4><p>通过指针不可以直接调用构造函数，但可以直接调用析构函数。可以通过<code>placement new</code>来直接调用构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) : a(_a), b(_b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* tmp_a = <span class="keyword">new</span> A(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// tmp-&gt;A::A(2, 8); // error! cannot call constructor 'A::A' directly</span></span><br><span class="line">    tmp_a-&gt;~A(); <span class="comment">// 可以的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然调用了析构函数, 但事实上 tmp_a 的空间并没有释放</span></span><br><span class="line">    <span class="comment">// 因为没有 free 掉, 那块内存还在, 值没有被重写</span></span><br><span class="line"><span class="comment">// 所以可以访问 通过 tmp_a 访问原对象的值</span></span><br><span class="line"><span class="comment">// 如果是 delete tmp_a; 就不能访问</span></span><br><span class="line">    <span class="comment">// 因为 delete 调用完析构函数之后, 还调用了 free 函数释放那块内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tmp_a-&gt;a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 所有这里访问的值看似没有变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="8-array-new-delete"><a href="#8-array-new-delete" class="headerlink" title="8. array new/delete"></a><code>8</code>. <code>array new/delete</code></h4><p><code>new []/delete[]</code>本质调用<code>malloc/free</code>。<code>malloc/free</code>细节：</p><ul><li><p>除了分配给定的内存之外，还会有<code>cookie</code>——用来记录分配数组的长度，查看<code>cookie</code>中的长度，然后调用适当次数的析构函数</p></li><li><p>所谓内存泄漏</p><p>  对于一个<code>new []</code>，需要有相应的<code>delete []</code>，本质上<code>cookie</code>记录了<code>free</code>本身需要释放的内存大小，泄露则发生在调用的析构函数次数上：如果对象含有指针的<code>data member</code>，指向堆上的内存，则意味着析构函数是<code>nontrival</code>，需要再析构函数中释放指针指向的内存，反之则是<code>trival</code>的，而析构函数的调用次数，则会影响指针指向的内存部分的泄露。</p></li></ul><p><img src="image-20210316200134379.png" alt="image-20210316200134379"></p><p><img src="image-20210316201727370.png" alt="image-20210316201727370"></p><p><img src="image-20210316201922911.png" alt="image-20210316201922911"></p><h4 id="9-placement-new"><a href="#9-placement-new" class="headerlink" title="9. placement new"></a><code>9</code>. <code>placement new</code></h4><p>标准不允许直接用指针调用构造函数，但给出了另一种调用语法，可以在现有的对象的内存中调用构造函数，它不会分配新的内存。这也是没有对应的<code>placement delete</code>的原因。</p><p><img src="image-20210316202736446.png" alt="image-20210316202736446"></p><h4 id="10-C-程序分配内存的途径"><a href="#10-C-程序分配内存的途径" class="headerlink" title="10. C++程序分配内存的途径"></a><code>10</code>. <code>C++</code>程序分配内存的途径</h4><p><img src="image-20210316203737564.png" alt="image-20210316203737564"></p><p><img src="image-20210316205136096.png" alt="image-20210316205136096"></p><p>从图中可以看出，当出现<code>new Foo(x)</code>后，编译器会检查<code>Foo</code>这个类有没有实现<code>operator new(size_t)</code>的<code>static</code>函数，如果有就会调用<code>Foo</code>这个版本的<code>operator new</code>，如果没有就调用全局的<code>::operator new</code>，<code>delete</code>也是如此。</p><p>所以可以为一个类单独实现<code>operator new</code>和<code>operator delete</code>。也可以重载全局的<code>operator new/delete</code>，但很少这么做，因为全局的版本是照顾所有的类。</p><h4 id="11-探究operator-new"><a href="#11-探究operator-new" class="headerlink" title="11. 探究operator new"></a><code>11</code>. 探究<code>operator new</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">new</span> (a) A(<span class="number">27</span>, <span class="number">224</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* b = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(A));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a-&gt;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汇编代码如下:</span></span><br></pre></td></tr></table></figure><img src="30.png" style="zoom: 67%;" /><img src="31.png" style="zoom:67%;" /><img src="33.png" style="zoom:67%;" /><img src="34.png" style="zoom:67%;" /><h4 id="12-重载-operator-new-delete"><a href="#12-重载-operator-new-delete" class="headerlink" title="12. 重载::operator new/delete"></a><code>12</code>. 重载<code>::operator new/delete</code></h4><p>上面说了，重载全局的<code>operator new/delete</code>影响深远，谨慎使用。但可以重载，方法是在<strong>非</strong><code>namespace</code>中声明和全局版本相同的函数签名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A() : this:"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) : a(_a), b(_b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A(int,int): this: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~A(): this: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下 4 个函数就在当前的文件中声明定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(len); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>* ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> A(); <span class="comment">// 调用到上面自定义的 operator new</span></span><br><span class="line">    <span class="keyword">void</span>* b = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(A)); <span class="comment">// 虽然指定的是 ::operator new, 但还是调用到上面自定义的版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 a 是正确的释放, 先调用 A 的析构函数, 再调用上面的 operator delete</span></span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 b, 释放的操作应该显示调用 operator delete</span></span><br><span class="line">    <span class="comment">// 这里用 delete 后, 并没有调用 A 的析构函数, 而是直接调用了 operator delete</span></span><br><span class="line">    <span class="comment">// 可见编译器对于 delete void* 的时候, 是直接转换为 opreator delete</span></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识C++内存管理的工具 （一）</title>
      <link href="/kZo0999uFp6r1QI2/"/>
      <url>/kZo0999uFp6r1QI2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-内存管理函数的层次"><a href="#1-内存管理函数的层次" class="headerlink" title="1. 内存管理函数的层次"></a><code>1</code>. 内存管理函数的层次</h4><img src="20.png"  /><p>从图中可以看到，<code>C++</code>程序员处于的位置是最上层的<code>Applications</code>，用的最多的是<code>new</code>，<code>new[]</code>，如果用容器，则内存基本不用管理。其次也可以调用<code>malloc</code>。至于最底层的操作系统级别的<code>API</code>，没有可移植性。它们之间的调用关系如上图的箭头所示。</p><a id="more"></a><h4 id="2-Memory-primitives分类"><a href="#2-Memory-primitives分类" class="headerlink" title="2. Memory primitives分类"></a><code>2</code>. <code>Memory primitives</code>分类</h4><table><thead><tr><th>分配</th><th>释放</th><th>所属</th><th>可否重载</th></tr></thead><tbody><tr><td><code>malloc</code></td><td><code>free</code></td><td><code>C</code>函数</td><td>否</td></tr><tr><td><code>new</code></td><td><code>delete</code></td><td><code>C++</code>表达式</td><td>否</td></tr><tr><td><code>::operator new()</code></td><td><code>::operator delete()</code></td><td><code>C++</code>函数</td><td>可</td></tr><tr><td><code>allocator&lt;T&gt;::allocate()</code></td><td><code>allocator&lt;T&gt;::deallocate()</code></td><td><code>STL</code>分配器</td><td>可以自己设计搭配容器</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primitives_sample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// CRT 运行时函数</span></span><br><span class="line">    <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>( <span class="number">512</span> );</span><br><span class="line">    <span class="built_in">free</span>( p1 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new</span></span><br><span class="line">    <span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt; *p2 = <span class="keyword">new</span> <span class="built_in">complex</span>&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ::operator new() 全局函数, 可被重载</span></span><br><span class="line">    <span class="keyword">void</span> *p3 = ::<span class="keyword">operator</span> <span class="keyword">new</span>( <span class="keyword">sizeof</span>( <span class="keyword">int</span> ) ); <span class="comment">// 内部调用 malloc</span></span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">( p3 )</span></span>;    <span class="comment">//内部调用delete</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocator 分配器, STL 容器分配内存的方式</span></span><br><span class="line">    <span class="keyword">void</span> *p4 = allocator&lt;<span class="keyword">int</span>&gt;().allocate( <span class="number">7</span> );</span><br><span class="line">    allocator&lt;<span class="keyword">int</span>&gt;().deallocate( (<span class="keyword">int</span> *)p4, <span class="number">7</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-new的初步探究"><a href="#3-new的初步探究" class="headerlink" title="3. new的初步探究"></a><code>3</code>. <code>new</code>的初步探究</h4><p><code>c++</code>的程序员基本都会用<code>new</code>来为对象分配一个堆内存，并且<code>new</code>会调用对应的构造函数，构造函数是用来初始化对象的，所以总结出<code>new</code>的功能是：</p><ol><li>在堆中分配一块指定对象大小的内存</li><li>将返回的指针转换为指向对象类型的指针</li><li>通过指针调用对象相应的构造函数</li></ol><p><img src="image-20210315204443125.png" alt="image-20210315204443125"></p><h4 id="4-测试new的调用流程"><a href="#4-测试new的调用流程" class="headerlink" title="4. 测试new的调用流程"></a><code>4</code>. 测试<code>new</code>的调用流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b): a(_a), b(_b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* tmp_a = <span class="keyword">new</span> A(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">delete</span> tmp_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="21.png" style="zoom: 67%;" /><img src="22.png" style="zoom:67%;" /><img src="23.png" style="zoom:67%;" /><img src="24.png" style="zoom:67%;" /><p>上面的<code>4</code>张图是在<code>MSVC</code>中反汇编的运行时代码。从第<code>1</code>张图可以看出，<code>new</code>调用了<code>operator new</code>，从第<code>3</code>张图可以看出，<code>operator new</code>内部调用了<code>malloc</code>。实际上编译器是在<code>new</code>的地方调用了对应的构造函数，并不是在<code>new</code>的内部，<code>new</code>只是编译器识别的一个标识符，并不是函数，编译器看到<code>new</code>后会<code>malloc</code>，然后调用构造函数。</p><p><code>VS2019</code>可以看到<code>operator new</code>的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">_CRT_SECURITYCRITICAL_ATTRIBUTE</span><br><span class="line"><span class="function"><span class="keyword">void</span>* __CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> <span class="keyword">const</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">void</span>* <span class="keyword">const</span> block = <span class="built_in">malloc</span>(size))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == SIZE_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_array_new_length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                __scrt_throw_std_bad_alloc();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The new handler was successful; try to allocate again...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>operator new</code>的作用是调用<code>malloc</code>分配内存。当<code>malloc</code>成功后直接返回。当<code>malloc</code>失败后，并不会再次<code>malloc</code>，而是调用<code>_callnewh() new_handler()</code>，这个函数的作用是向自己定义的函数索取内存，所以<code>new_handler</code>可以理解为释放一些缓存，调用完<code>new_handler</code>后，可能释放了内存，这个时候再尝试调用<code>malloc</code>获取内存。</p><h4 id="5-delete的初步探究"><a href="#5-delete的初步探究" class="headerlink" title="5. delete的初步探究"></a><code>5</code>. <code>delete</code>的初步探究</h4><p><img src="image-20210315210220075.png" alt="image-20210315210220075"></p><h4 id="6-测试delete的调用流程"><a href="#6-测试delete的调用流程" class="headerlink" title="6. 测试delete的调用流程"></a><code>6</code>. 测试<code>delete</code>的调用流程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b) : a(_a), b(_b) &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* tmp_a = <span class="keyword">new</span> A(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">delete</span> tmp_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="25.png" style="zoom:67%;" /><img src="26.png" style="zoom:67%;" /><img src="27.png" style="zoom:67%;" /><img src="28.png" style="zoom:67%;" /><img src="29.png" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> C++内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型 第五章和第六章</title>
      <link href="/plA8MQtWi85PlNcz/"/>
      <url>/plA8MQtWi85PlNcz/</url>
      
        <content type="html"><![CDATA[<h4 id="第5章：构造、析构、拷贝语意学"><a href="#第5章：构造、析构、拷贝语意学" class="headerlink" title="第5章：构造、析构、拷贝语意学"></a>第<code>5</code>章：构造、析构、拷贝语意学</h4><ul><li><p>可以定义和调用一个纯虚函数，不过只能被静态的调用（通过类作用域运算符），不能通过虚拟机制调用。 </p></li><li><p>你声明了一个纯虚析构函数，就必须定义它。因为在你提供了声明前提下，每一个derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。因此，只要缺乏任何一个base class destructor的定义，就会<strong>导致链接失败</strong>。</p><p>  读到这儿，你可能会有疑问，对于普通的类（没有虚机制参与进来，派生类的析构函数中也会逐一调用基类的析构函数）我们也没有提供它析构函数的，那为什么不会导致链接失败呢？这是因为你没有写析构函数，编译器会默默给你提供一个，以便于在后面的派生类的析构函数中调用它。这里的重点是你没有提供，也就是说你没有声明，如果你声明了，但没有提供定义，同样会导致链接失败。</p></li><li><p>对于基类该不该将虚函数定义为<code>const</code>的，作者不建议。因为derived class中可能会修改自己的数据成员。</p></li></ul><a id="more"></a><h5 id="5-1-无继承情况下的对象构造"><a href="#5-1-无继承情况下的对象构造" class="headerlink" title="5.1 无继承情况下的对象构造"></a><code>5.1</code> 无继承情况下的对象构造</h5><p>当编译器遇到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point global;</span><br></pre></td></tr></table></figure><p>在<code>C</code>之中，<code>global</code>被视为一个“临时性的定义”，因为它没有明确的初始化操作。一个“临时性的定义”可以在程序中发生多次。那些实例会被链接器折叠起来，只留下单独一个实体，被放在程序<code>data segment</code>中一个“特别保留给未初始化之<code>global objects</code>使用”的空间。由于历史的缘故，这块空间被称为<code>BSS</code>，是<code>Block Started by Symbol</code>的缩写。</p><p>而<code>global</code>在<code>C++</code>中被视为完全定义（它会阻止第二个或更多个定义）。<code>C</code>和<code>C++</code>的一个差异就在于，<code>BSS data segment</code>在<code>C++</code>中相对地不重要。<code>C++</code>的所有全局对象都被当作“初始化过的数据”来对待。</p><p><strong>为继承做准备</strong></p><p>虚函数的引入不仅仅是每个类对象增加了一个<code>vptr</code>，而且会引发编译器对类产生膨胀作用。我们所定义的构造函数，编译器会附加一些代码，以便<code>vptr</code>初始化。合成一个<code>copy constructor</code>和一个<code>copy assignment operator</code>，它们都不是<code>trival</code>。因为，如果<code>point</code>类对象被初始化或以一个派生类对象赋值，<code>bitwise</code>操作就存在问题了，<code>vptr</code>设置会出错。</p><p><code>C++</code>编译器要求编译器尽量延迟<code>nontrivial members</code>的实际合成操作，直到遇到使用场合为止。如果在你的设计中存在很多以传值的方式返回局部类对象，提供一个拷贝构造函数就比较合理，因为这会触发编译器的<code>NRV</code>优化。</p><h5 id="5-2-继承体系下的对象构造"><a href="#5-2-继承体系下的对象构造" class="headerlink" title="5.2 继承体系下的对象构造"></a><code>5.2</code> 继承体系下的对象构造</h5><p><code>constructor</code>可能内带大量的隐藏码，因为编译器会扩充每一个<code>constructor</code>，扩充程度视<code>class T</code>的继承体系而定。一般而言编译器所做的扩充操作大约如下：</p><ol><li>记录在<code>member initialization list</code>中的<code>data members</code>初始化操作会被放进<code>constrector</code>的函数本身，并以<code>members</code>的声明顺序为顺序。<ul><li>如果有数据成员为类对象，并被列于<code>member initialization list</code>中，那么任何明确指定的参数都应该传递过去。</li></ul></li><li>如果有一个<code>member</code>并没有出现在<code>member initialization list</code>之中，但它有一个<code>default constructor</code>，那么该<code>default constructor</code>必须被调用。</li><li>在那之前，如果<code>class object</code>有<code>vptr</code>，它（们）必须被设定初值，指向适当的<code>virtual table(s)</code>。</li><li>在那之前，所有上一层的<code>base class constructors</code>必须被调用，以<code>base class</code>的声明顺序为序：<ul><li>如果<code>basc class</code>被列于<code>member initialization list</code>中，那么任何明确指定的参数都应该传递过去。</li><li>如果<code>base class</code>没有被列于<code>member initialization list</code>中，而它有<code>default constructor</code>(或<code>default memberwise copy constructor</code>)，那么就调用之。</li><li>如果<code>base class</code>是多重继承下的第二或后继的<code>base class</code>，那么<code>this</code>指针必须有所调整。</li></ul></li><li>在那之前，所有<code>virtual base class constructors</code>必须被调用，从左到右，从最深到最浅：<ul><li>如果<code>class</code>被列于<code>member initialization list</code>中，那么如果有任何明确指定的参数，都应该传递过去。若没有列于<code>list</code>之中，而<code>class</code>有一个<code>default constructor</code>，也应该调用之。</li><li>此外，<code>class</code>中的每一个<code>virtual base class subobject</code>的偏移量必须在执行期可被存取。</li><li>如果<code>class object</code>是最底层（<code>most-derived</code>）的<code>class</code>，其<code>constructors</code>可能被调用；某些用以支持这个行为的机制必须被放进来。</li></ul></li></ol><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><strong>书中接下来的章节对上面这些做了详细的叙述。全是重点，就不做总结了，自行看书</strong>。</p><h4 id="第6章：执行期语意学"><a href="#第6章：执行期语意学" class="headerlink" title="第6章：执行期语意学"></a>第<code>6</code>章：执行期语意学</h4><p><strong>很重要，不做总结了，自行看书</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你用python实现一个在windows平台的定时更换壁纸的工具</title>
      <link href="/JFfWe2Uugfh1u70r/"/>
      <url>/JFfWe2Uugfh1u70r/</url>
      
        <content type="html"><![CDATA[<p>有没有感觉到自己的电脑桌面一成不变让人厌倦？虽然有一些诸如360桌面之类的软件可以使用，但弹窗、广告又太多！本文就教你用 <em>python</em> 实现一个简洁清爽的桌面壁纸定时更换工具。</p><a id="more"></a><p>本文使用的方法是用 <em>python</em> 实现一个定时更换壁纸的脚本，壁纸来源与自定义的文件夹内，因此你可以搜集一些你喜欢的壁纸图片放于该文件夹下，这样脚本程序便可以使你的电脑桌面轮流展示这些图片了。</p><p>比如我就把我喜欢的壁纸都收集在了 <em>E:/wallpapers/</em> 文件夹下。</p><p><img src="2020-06-14.png" alt=""></p><p>这里推荐几个好的壁纸来源网站 <a href="https://wallhaven.cc/" target="_blank" rel="noopener">https://wallhaven.cc/</a> ，<a href="https://www.artstation.com/wlop" target="_blank" rel="noopener">https://www.artstation.com/wlop</a> 。</p><p>下面直接看代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImages</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 这里的路径就是你放图片的文件夹路径</span></span><br><span class="line">    images_path = <span class="string">'E:\\wallpapers\\'</span></span><br><span class="line">    files = os.listdir(images_path)</span><br><span class="line">    <span class="keyword">return</span> images_path, files</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_wallpaper</span><span class="params">(it)</span>:</span></span><br><span class="line">    path, images = getImages()</span><br><span class="line">    image = path + images[it]</span><br><span class="line">    it = (it + <span class="number">1</span>) % len(images)</span><br><span class="line">    win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, image, <span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">global</span> timer</span><br><span class="line">    <span class="comment"># 我设置的是每60s更换一次，你可以根据需要自定义设置</span></span><br><span class="line">    timer = threading.Timer(<span class="number">60.0</span>, set_wallpaper, (it,))</span><br><span class="line">    timer.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    set_wallpaper(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>为了方便运行，我们可以使用 <em>pyinstaller</em> 工具将该脚本程序转成 <em>.exe</em> 可执行文件。具体的方法可以看这篇文章 <a href="https://blog.csdn.net/zengxiantao1994/article/details/76578421" target="_blank" rel="noopener">Python程序打包成exe可执行文件</a> 。</p><p>生成可执行文件之后，运行就可以了。不过，为了每次开机程序都可以自动运行，我们需要进行一些设置。首先按 <em>win+R</em> 键打开运行窗口，输入 <em>shell:startup</em> 回车，这样会打开一个启动文件夹，这个文件夹下的软件在开机时都会自动启动，将你的可执行文件或其快捷方式放在这里就可以了。</p><p>这里可以直接下载我已经生成的可执行程序：</p><p><a href="https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q</a><br>提取码：v9ng </p><p>使用方法就是在E盘下新建一个名为wallpapers的文件夹，然后把自己喜欢的照片放进去就好，即<em>E:/wallpapers/</em> 。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桌面壁纸工具 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你实现一个简易的Linux平台下的划词翻译工具</title>
      <link href="/KT2Sz9hHwziaJtFt/"/>
      <url>/KT2Sz9hHwziaJtFt/</url>
      
        <content type="html"><![CDATA[<p>这里将要介绍的是一种在 <em>Linux</em> 平台实现的划词翻译工具，当然在考虑自己实现一个如此功能的工具前，本人也是在网上搜索了一些在 <em>Linux</em> 平台实现的类似的开源工具，例如 <a href="https://github.com/axipo/pdfTranslator" target="_blank" rel="noopener">pdfTranslator</a>，<a href="https://github.com/bianjp/popup-dict" target="_blank" rel="noopener">popup-dict</a>，但它们的安装和配置都显得比较麻烦，而且使用起来也并不方便。</p><p>本人实现这个工具的初衷本是方便自己看一些英文文献和书籍的，极为方便，考虑到分享出去可以让更多人受惠，因此这里详细介绍一下它的实现步骤。</p><a id="more"></a><p>本文所实现的划词翻译工具主要有以下特性：</p><ul><li>支持英文单词和短语到中文的翻译</li><li>划词翻译，终端显示</li><li>自动过滤选中文本中的换行等特殊字符</li><li>只依赖少数几个 <em>Linux</em> 命令工具</li></ul><p>下面有动图进行演示。</p><p><img src="iKnVA63lpy.gif" alt=""></p><p>本人所使用的环境是运行在 <em>VMware</em> 虚拟机下的 <em>Linux</em> 发行版 <em>Ubuntu 18.04.3 LTS</em> ，因此这里介绍的步骤可能与其他 <em>Linux</em> 发行版中的实现略有不同。下面就来一步一步的实现它吧。</p><h4 id="一-安装必要的命令"><a href="#一-安装必要的命令" class="headerlink" title="一. 安装必要的命令"></a>一. 安装必要的命令</h4><ol><li><em>xclip</em></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install xclip</span></span><br></pre></td></tr></table></figure><p><em>xclip</em> 命令建立了终端和剪切板之间通道，可以用命令的方式将终端输出或文件的内容保存到剪切板中，也可以将剪切板的内容输出到终端或文件。详细的用法可以使用 <em>man xclip</em>，见其手册。这里介绍几个常用的用法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xclip file_name <span class="comment"># 文件内容保存到X window剪切板</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection c file_name <span class="comment">#文件内容保存到外部剪切板</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -o <span class="comment"># X window剪切板内容输出到终端显示</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection c -o <span class="comment"># 外部剪切板内容输出到终端显示</span></span></span><br></pre></td></tr></table></figure><p>值得强调的是，这里所说的 <em>X window</em> 剪切板，简单的说就是你用鼠标选择的文本会实时的存放在这个剪切板，使用鼠标中键可以粘贴。而外部剪切板是保存你用 <em>ctrl+c</em> 复制的文本，<em>ctrl+v</em> 可以粘贴。这两个地方是不一样的。</p><ol start="2"><li><em>translate-shell</em></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install translate-shell</span></span><br></pre></td></tr></table></figure><p>这是命令行版的谷歌翻译工具，之前叫做 <em>Google Translate CLI</em> 是一款借助谷歌翻译（默认）、必应翻译等来翻译的命令行翻译器。它让你可以在终端访问这些翻译引擎。 <em>translate-shell</em> 在大多数 <em>Linux</em> 发行版中都能使用。常用的方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trans en:zh [word] <span class="comment"># 英文到中文的单词翻译</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> trans en:zh -b [text] <span class="comment"># 简要的输出，进行文本翻译</span></span></span><br></pre></td></tr></table></figure><p>需要注意的是，使用这个翻译工具需要你能够<strong>访问外网</strong>，或者通过修改 <em>translate-shell</em> 的默认翻译引擎，具体的方法这里就不阐述了。</p><h4 id="二-编程实现"><a href="#二-编程实现" class="headerlink" title="二. 编程实现"></a>二. 编程实现</h4><p>这个工具整体的思路就是 <em>C</em> 程序实时检测鼠标按键的动态，当检测到用户使用鼠标选择一段文本之后，调用 <em>shell</em> 脚本获取 <em>X window</em> 剪切板的内容进行翻译后输出到终端显示。</p><p><strong>1. 定位鼠标设备文件</strong></p><p>鼠标作为输入设备。其信息可以在文件 <em>/proc/bus/input/devices</em> 中，使用下列命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /proc/bus/input/devices</span></span><br><span class="line">I: Bus=0011 Vendor=0002 Product=0013 Version=0006</span><br><span class="line">N: Name="VirtualPS/2 VMware VMMouse"</span><br><span class="line">P: Phys=isa0060/serio1/input1</span><br><span class="line">S: Sysfs=/devices/platform/i8042/serio1/input/input4</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mouse0 event2 </span><br><span class="line">B: PROP=0</span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=70000 0 0 0 0</span><br><span class="line">B: ABS=3</span><br></pre></td></tr></table></figure><p>其中的 <em>Handlers</em> 的值 <em>event2</em> 表示可以在 <em>/dev/input/event2</em> 文件下读取鼠标的状态。需要注意的是，对于不同的设备，读取鼠标的状态的文件可能不一样，比如也可能是 <em>/dev/input/event3</em>。我们可以使用下面的命令找到你的鼠标对应的是哪一个 <em>event</em>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /dev/input/event2 | hexdump <span class="comment"># 测试时改变数字即可</span></span></span><br></pre></td></tr></table></figure><p>比如，当我运行上面这条命令之后，我移动鼠标、按鼠标左键/中键/右键，终端都会输出一些值，这就说明 <em>event2</em> 文件就是对应着我的鼠标。如果操作鼠标没有反应，说明这个就不是。你可以通过这种方法找到你的鼠标对应的 <em>event</em> 文件。</p><p><strong>2. Linux 下获取按键响应</strong></p><p>在 <em>Linux</em> 内核中，<em>input</em> 设备用 <em>input_dev</em> 结构体描述，使用 <em>input</em> 子系统实现输入设备驱动的时候，驱动的核心工作就是向系统报告按键、触摸屏、键盘、鼠标等输入事件（<em>event*，通过 *input_event</em> 结构体描述），不再需要关心文件操作接口，因为 <em>input</em> 子系统已经完成了文件操作接口 <em>Linux/input.h</em> 这个文件定义了 <em>event</em> 事件的结构体，<em>API</em> 和标准按键的编码等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义见 input.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">// 按键时间</span></span><br><span class="line">    __u16 type;          <span class="comment">// 事件类型</span></span><br><span class="line">    __u16 code;          <span class="comment">// 要模拟成什么按键</span></span><br><span class="line">    __s32 value;         <span class="comment">// 是按下还是释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面宏定义见 input-event-coses.h</span></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_KEY 0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_REL 0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ABS 0x03</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_LEFT 0x110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_RIGHT 0x111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_MIDDLE 0x112</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSC_SERIAL 0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSC_PULSELED 0x01</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里稍微介绍一下 <em>type</em>，指事件类型，常见的事件类型有：<br><em>EV_KEY</em>，按键事件，如键盘的按键（按下哪个键），鼠标的左键右键（是否击下）等；<br><em>EV_REL</em>，相对坐标，主要是指鼠标的移动事件（相对位移）；<br><em>EV_ABS</em>， 绝对坐标，主要指触摸屏的移动事件 。</p><p><strong>3. 编写 <em>C</em> 程序</strong></p><p>下面就可以编写程序来检测鼠标的动态了。首先在你的用户~目录下建立文件夹 <em>Translator*。在 *Translator</em> 里建立一个 <em>ct.c</em> 源文件，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里打开的文件根据你自己的设备情况作相应的改变</span></span><br><span class="line">    keys_fd = <span class="built_in">open</span>(<span class="string">"/dev/input/event2"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (keys_fd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open /dev/input/event2 error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(keys_fd, &amp;t, <span class="keyword">sizeof</span>(t));</span><br><span class="line">        <span class="keyword">if</span> (t.type == EV_KEY)              <span class="comment">// 有键按下</span></span><br><span class="line">            <span class="keyword">if</span> (t.code == BTN_LEFT)        <span class="comment">// 鼠标左键</span></span><br><span class="line">                <span class="keyword">if</span> (t.value == MSC_SERIAL) <span class="comment">// 松开</span></span><br><span class="line">                    <span class="comment">// 调用外部shell脚本</span></span><br><span class="line">                    system(<span class="string">"~/Translator/goTranslate.sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(keys_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是调用 <em>gcc</em> 编译器生成可执行文件 <em>ct</em>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ct.c -o ct</span></span><br></pre></td></tr></table></figure><p><strong>4. 编写 <em>shell</em> 脚本翻译剪切板内容</strong></p><p>在 <em>Translator</em> 里建立 <em>goTranslate.sh</em> 文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str_old=$(cat ~/Translator/lastContent)</span><br><span class="line">str_new=$(xclip -o 2&gt;/dev/null | xargs)</span><br><span class="line">if [[ "$str_new" != "$str_old" &amp;&amp; $str_new ]]; then</span><br><span class="line">    echo -e "\n"</span><br><span class="line">    count=$(echo "$str_new" | wc -w)</span><br><span class="line">    if [ "$count" == "1" ]; then</span><br><span class="line">        echo -n -e "$str_new " &gt;&gt;~/Translator/words</span><br><span class="line">        echo "$str_new" | trans :zh-CN | tail -1 | cut -c 5- | sed "s,\x1b\[[0-9;]*[a-zA-Z],,g" | tee -a ~/Translator/words</span><br><span class="line">    else</span><br><span class="line">        echo "$str_new" | trans :zh-CN -b</span><br><span class="line">    fi</span><br><span class="line">    echo "$str_new" &gt;~/Translator/lastContent</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>原理非常简单，读者自行了解。这里我们还要在 <em>Translator</em> 里建立一个 <em>lastContent.txt</em> 文件作为缓存，目的是本次调用脚本时能够获取上一次调用时翻译的文本内容，如果和本次调用的翻译文本一样，则本次就不进行翻译。</p><p><em>*5. 设置 *ct</em> 别名 **</p><p>这里已经可以通过下面的命令运行程序了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ~/Translator/ct</span></span><br></pre></td></tr></table></figure><p>但是由于每次运行都要输出这么长的命令，因此我们在 <em>~/.bashrc</em> 文件中加入下面一条命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ct='sudo ~/Translator/ct'</span><br></pre></td></tr></table></figure><p>这样，以后每次看英文文献时就可以在命令行下输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ct</span></span><br></pre></td></tr></table></figure><h4 id="三-结束语"><a href="#三-结束语" class="headerlink" title="三. 结束语"></a>三. 结束语</h4><p>这里有一些小技巧。可以更方便的使用这个工具。比如，把终端设为置顶并缩小到合适的尺寸，这样在阅读文献划词翻译时终端屏幕不会遮挡我们的视线。</p><p>值得说明的是，由于本人完全是为了方便自己的使用，而且在搞出这么个工具时仅仅接触 <em>Linux</em> 系统才不到两周，所以里面的实现对于有经验的朋友来说略显的有些笨拙了，请理解哈。</p><p>个人觉得这个工具使用起来还是很方便的，你觉得呢？</p><p>参考文章：</p><ol><li><a href="https://blog.csdn.net/liang12360640/article/details/50350648" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/50350648</a></li><li><a href="https://www.cnblogs.com/yangwindsor/articles/3454955.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangwindsor/articles/3454955.html</a></li><li><a href="https://blog.csdn.net/liang12360640/article/details/50s350648" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/50s350648</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 划词翻译 </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型 第四章</title>
      <link href="/rRW3gD4CDal4WhRJ/"/>
      <url>/rRW3gD4CDal4WhRJ/</url>
      
        <content type="html"><![CDATA[<h4 id="第4章：Function语意学"><a href="#第4章：Function语意学" class="headerlink" title="第4章：Function语意学"></a>第<code>4</code>章：<code>Function</code>语意学</h4><h5 id="4-1-静态成员函数"><a href="#4-1-静态成员函数" class="headerlink" title="4.1 静态成员函数"></a><code>4.1</code> 静态成员函数</h5><p><code>function</code>的调用方式</p><p><code>nonmember function</code>、<code>static member function</code>、<code>nonstatic member function</code>的调用效率完全一样，因为，在内部都被编译器处理成相同的形式。而<code>virtual member function</code>的调用需要通过<code>vptr</code>所指向的<code>virtual table</code>，因此，效率有所降低。</p><p><code>static member function</code>的主要特性就是它没有<code>this</code>指针。以下的次要特性统统根源于其主要特性：</p><a id="more"></a><ul><li>它不能够直接存取其<code>class</code>中的<code>nonstatic members</code>；</li><li>它不能够被声明为<code>const</code>、<code>volatile</code>或<code>virtual</code>；</li><li>它不需要经由<code>class object</code>才被调用——虽然大部分时候它是这样被调用的。</li></ul><p>若取一个<code>static member function</code>的地址不会得到指向其<code>class member function</code>类型的指针（不是<code>return_type (class_type::*)(parameter_types)</code>）。而是一个<code>non-member</code>函数指针（类型为<code>return_type (*)(parameter_types)</code>）。</p><h5 id="4-2-虚拟成员函数"><a href="#4-2-虚拟成员函数" class="headerlink" title="4.2 虚拟成员函数"></a><code>4.2</code> 虚拟成员函数</h5><p>在<code>C++</code>中，<strong>多态</strong>表示以一个指向<code>public base class</code>类型的<code>pointer</code>或<code>reference</code>，寻址出一个<code>derived class object</code>的意思。多态机能体现在通过<code>pointer</code>或<code>reference</code>对虚函数的调用身上。因此，识别一个<code>class</code>是否支持多态，唯一适当的方法就是看看它是否有任何<code>virtual function</code>。</p><p>为了支持多态，需要在执行期决议出正确的<code>virtual function</code>实例，这需要如下执行期信息的支持：</p><ol><li>它所引用的对象的地址，也就是当前它自身的值；</li><li>所引用对象的真实类型。这可使我们选择正确的虚函数所在的实体；</li><li><code>virtual function</code>实体位置，也就是函数地址，以便我能够调用它。</li></ol><p>在实现上，在每一个多态的<code>class object</code>身上增加两个<code>member</code>：</p><ol><li>一个字符串或数字，表示<code>class</code>的类型；</li><li>一个指针，指向某表格，表格中带有程序的<code>virtual function</code>的执行期地址。</li></ol><p><code>virtual function</code>的地址是固定不变的，执行期不可能新增或替换，而表格的大小和内容在执行期不会改变，因此其建构和存取皆在编译期就可以完成。</p><p>为了找到<code>virtual function</code>的地址，需要：</p><ol><li>为了找到表格，每一个<code>class object</code>被安插上一个由编译器内部产生的指针，指向该表格；</li><li>为了找到函数地址，每一个<code>virtual function</code>被指派一个表格索引值。</li></ol><p>这些工作都由编译器完成。执行期要做的，只是在特定的<code>virtual table slot</code>（记录着<code>virtual function</code>的地址）中调用<code>virtual function</code>。这些<code>virtual function</code>可以是：</p><ol><li>这个<code>class</code>所定义的函数实体。它<code>override</code>了一个<code>base class virtual function</code>函数实体；</li><li>继承自<code>base class</code>的函数实体。这是在<code>derived class</code>中决定不<code>override</code>的<code>virtual function</code>时的情况；</li><li>一个<code>pure_virtual_called()</code>函数实体。它既可以扮演<code>pure virtual function</code>的空间保卫者角色，也可以当做执行期异常处理函数（有时候会用到）。</li></ol><p><strong><em>单一继承</em></strong></p><p>例如，对于如下的<strong>单一继承体系</strong>：</p><p><img src="image-20210312160159297.png" alt="image-20210312160159297"></p><p><code>virtual destriucior</code>被赋值<code>slot 1</code>，而<code>mult()</code>被赋值<code>slot 2</code>。此例并没有<code>mult()</code>的函数定义，因为它是一个<code>pure virtual function</code>，所以<code>pure _virtual_called()</code>的函数地址会被放在<code>slot 2</code>中。如果该函数意外地被调用，通常的操作是结束掉这个程序。<code>y()</code>被赋值<code>slot 3</code>而<code>z()</code>被赋值<code>slot 4</code>。<code>x()</code>没有<code>slot</code>，因为<code>x()</code>并非<code>virtual function</code>。</p><p><img src="image-20210312160324194.png" alt="image-20210312160324194"></p><p><img src="image-20210312160340269.png" alt="image-20210312160340269"></p><p>此时，一共有三种可能性：</p><ol><li>它可以继承<code>base class</code>所声明的<code>virtual function</code>的函数实体。正确地说，是该函数实体的地址会被拷贝到<code>derived class</code>的<code>virtual table</code>相对应的<code>slot</code>之中；</li><li>它可以使用自己的函数实体。这表示它自己的函数实体地址必须放在对应的<code>slot</code>之中；</li><li>它可以加人一个新的<code>virtual function</code>。这时候<code>virtual table</code>的尺寸会增大一个<code>slot</code>，而新的函数实体地址会被放进该<code>slot</code>之中。</li></ol><p><code>Point2d</code>的<code>virtual table</code>在<code>slot 1</code>中指出<code>destructor</code>，而在<code>slot 2</code>中指出<code>mult()</code>取代<code>pure virtual function</code>。它自己的<code>y()</code>函数实体地址放在<code>slot 3</code>，继承自<code>Point</code>的<code>z()</code>函数实体地址则放在<code>slot 4</code>。</p><p>类似的情况：</p><p><img src="image-20210312160431103.png" alt="image-20210312160431103"></p><p><code>Point3d</code>的<code>virtual table</code>中的<code>slot 1</code>放置<code>Point3d</code>的<code>destructor</code>，<code>slot 2</code>放置<code>Point3d::mult()</code>函数地址。<code>slot 3</code>放置继承自<code>Point2d</code>的<code>y()</code>函数地址，<code>slot 4</code>放置自己的<code>z()</code>函数地址。</p><p>这个继承体系中的三个类的<code>virtual table</code>布局如下所示：</p><p><img src="image-20210312161401843.png" alt="image-20210312161401843"></p><p>现在，如果我们有这样的式子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;z();</span><br></pre></td></tr></table></figure><p>那么，我如何有足够的知识在编译时期设定<code>virtual function</code>的调用呢？</p><ol><li>一般而言，我并不知道<code>ptr</code>所指对象的真正类型。然而我知道，经由<code>ptr</code>可以存取到该对象的<code>virtual table</code>；</li><li>虽然我不知道哪一个<code>z()</code>函数实体会被调用，但我知道每一个<code>z()</code>函数地址都被放在<code>slot 4</code>。</li></ol><p>这些信息使得编译器可以将该调用转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">4</span>])(ptr);</span><br></pre></td></tr></table></figure><p>在一个单一继承体系中，<code>virtual function</code>机制的行为十分良好，不但有效率而且很容易塑造出模型。但是在多重继承和虚拟继承之中，就呵呵了。</p><p><strong><em>多重继承</em></strong>和<strong><em>虚拟继承</em></strong></p><p>懒得总结了，看是看懂了，乱七八糟的！</p><h5 id="4-3-指向Member-Function的指针"><a href="#4-3-指向Member-Function的指针" class="headerlink" title="4.3 指向Member Function的指针"></a><code>4.3</code> 指向<code>Member Function</code>的指针</h5><p>取一个<code>nonstatic member function</code>的地址，如果该函数是<code>nonvirtual</code>，则得到的结果是它在内存中真正的地址。然而这个值也是不完全的，它也需要被绑定于某个<code>class object</code>的地址上，才能够通过它调用该函数（以参数<code>this</code>指出）。</p><p>回顾一下，一个指向<code>member function</code>的指针，其声明语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (Point::*pmf)();</span><br></pre></td></tr></table></figure><p>然后我们可以这样定义并初始化该指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (Point::*coord)() = &amp;Point::x;</span><br></pre></td></tr></table></figure><p>也可以这样指定其值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coord = &amp;Point::y;</span><br></pre></td></tr></table></figure><p>想调用它，可以这么做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(origin.*coord)();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(ptr-&gt;*coord)();</span><br></pre></td></tr></table></figure><p>这些操作会被编译器转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(coord)(&amp;origin);</span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line">(coord)(ptr);</span><br></pre></td></tr></table></figure><p>获得该函数在内存中的地址。然而面对一个<code>virtual function</code>，其地址在编译时期是未知的，所能知道的仅是<code>virtual function</code>在其相关之<code>virtual table</code>中的索引值，也就是说，对一个<code>virtual member function</code>取其地址，所能获得的只是一个索引值。</p><p>那么问题来了，假设我们有以下的<code>Point</code>声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Point();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取<code>z()</code>函数的地址得到的索引值是<code>2</code>，而不是函数地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> (Point::*pmf)() = &amp;Point::z;</span><br><span class="line">Point *ptr = <span class="keyword">new</span> Point3d;</span><br></pre></td></tr></table></figure><p>那么如果通过<code>pmf</code>来间接调用<code>z()</code>函数的话：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(ptr-&gt;*pmf)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为</span></span><br><span class="line"></span><br><span class="line">(*ptr-&gt;vptr[(<span class="keyword">int</span>)pmf]<span class="number">5</span>(ptr);</span><br></pre></td></tr></table></figure><p>那么如何知道<code>pmf</code>指向的是<code>virtual function</code>还是<code>nonvirtual function</code>，毕竟<code>pmf</code>如果对<code>nonvirtual function</code>取地址的话得到的是在内存中的地址。也就是说，<code>pmf</code>的内部定义需要允许该函数能够寻址出<code>nonvirtual</code>和<code>virtual</code>两个<code>member function</code>。</p><p>同时为了让执行<code>member function</code>的指针也能支持多重继承和虚拟继承，实现方法为使用一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用以支持在多重继承之下指向 member function 的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">mptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// virtual 函数 在 virtual table 的索引, 当 index 不指向 virtual table 时值为 -1</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">ptrtofunc faddr; <span class="comment">// nonvirtual 函数的地址</span></span><br><span class="line">        <span class="keyword">int</span> voffset;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这样的模型下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(ptr-&gt;*pmf)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为</span></span><br><span class="line"></span><br><span class="line">(pmf.inidex &lt; <span class="number">0</span>) ? (*pmf.faddr)(ptr) : (*ptr-&gt;vptr[pmf.index](ptr));</span><br></pre></td></tr></table></figure><h5 id="4-4-inline函数"><a href="#4-4-inline函数" class="headerlink" title="4.4 inline函数"></a><code>4.4</code> <code>inline</code>函数</h5>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型 第三章</title>
      <link href="/ShyaVw4WHERlLCqZ/"/>
      <url>/ShyaVw4WHERlLCqZ/</url>
      
        <content type="html"><![CDATA[<h4 id="第3章：Data语意学"><a href="#第3章：Data语意学" class="headerlink" title="第3章：Data语意学"></a>第<code>3</code>章：<code>Data</code>语意学</h4><p><code>The size of class</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// char c; // 此时, sizeof(X) == 1, sizeof(Y) == 8, sizeof(Z) == 8, sizeof(A) == 16</span></span><br><span class="line">    <span class="keyword">char</span> c; <span class="comment">// 此时, sizeof(X) == 1, sizeof(Y) == 16, sizeof(Z) == 16, sizeof(A) == 24</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123; &#125;;</span><br></pre></td></tr></table></figure><p>一个类的大小主要受三个因素的影响：</p><ol><li><p>语言支持的特性所造成的负担</p><p> 比如，含虚函数的类会额外多一个<code>vptr</code>指针，含<code>virtual base class</code>会再多一个额外的指针（它或者指向<code>virtual base class subobject</code>，或者指向一个相关表格；表格中存放的若不是<code>virtual base class subobject</code>地址，就是其偏移量）。</p></li><li><p>编译器对于特殊情况所提供的优化处理</p><p> 现代编译器的对于空基类的优化处理：一个<code>empty virtual base class</code>被视为<code>derived class object</code>最开头的一部分，也就是说它并没有花费任何的额外空间。因为既然有了<code>members</code>，就不需要原本为了<code>empty class</code>而安插的一个<code>char</code>。</p></li><li><p><code>alignment</code>（内存对齐）</p><p> 就是将数值调整到某数的整数倍。在<code>64</code>位计算机上，通常<code>alignment</code>为<code>8 bytes</code>，以使<code>bus</code>的“运输量”达到最高效率。</p></li></ol><a id="more"></a><p><code>nonstatic data members</code>放置的是“个别的<code>class object</code>”感兴趣的数据，<code>static data members</code>则放置的是“整个<code>class</code>”感兴趣的数据。</p><p><code>static data members</code>被放置在程序的一个<code>global data segment</code>中，不会影响个别的<code>class object</code>的大小。在程序之中，不管该<code>class</code>被产生出多少个<code>objects</code>（经由直接产生或间接派生），<code>static data member</code>永远只存在一份实体（即使该<code>class</code>没有任何<code>object</code>实体，其<code>static data members</code>也已存在）。</p><h5 id="3-1-data-member的绑定"><a href="#3-1-data-member的绑定" class="headerlink" title="3.1 data member的绑定"></a><code>3.1</code> <code>data member</code>的绑定</h5><p>类成员函数的<code>argument list</code>中的名称会在它们第一次遭遇时被适当地决议（<code>resolved</code>）完成。因此在<code>extern</code>和<code>nested type name</code>之间的非直觉绑定操作还是会发生。例如在下面的程序片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 参数列表中的 length 被决议成 std::string!!!</span></span><br><span class="line">    <span class="comment">// 里面的 val_ 被正确决议成 int</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(length val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val_ = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line">    length val_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以这需要使用防御性的程序风格：将<code>nested type name</code>写在class的起始处！</p><h5 id="3-2-数据成员的布局"><a href="#3-2-数据成员的布局" class="headerlink" title="3.2 数据成员的布局"></a><code>3.2</code> 数据成员的布局</h5><p>下面这个<code>template function</code>，接受两个<code>data member</code>，然后判断谁先出现在<code>class object</code>之中。如果两个<code>member</code>都是不同的<code>access sections</code>中的第一个被声明者，此函数就可以用来判断哪一个<code>section</code>先出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">class_type</span>, <span class="title">class</span> <span class="title">data_typel</span>, <span class="title">class</span> <span class="title">data_type2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:<span class="function"><span class="built_in">string</span> <span class="title">access_order</span><span class="params">(data_type1 class_type::* mem1, data_type2 class_type::* mem2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(mem1 != mem2);</span><br><span class="line"><span class="keyword">return</span> mem1 &lt; mem2 ? <span class="string">"member 1 occurs first"</span> : <span class="string">"member 2 occurs first"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数可以这样被调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_order(&amp;Point3d::y, &amp;Point3d::z);</span><br></pre></td></tr></table></figure><h5 id="3-3-data-member的存取"><a href="#3-3-data-member的存取" class="headerlink" title="3.3 data member的存取"></a><code>3.3</code> <code>data member</code>的存取</h5><p><code>static data member</code></p><p>对于类中的静态数据成员，通过一个指针和通过一个对象来存取，效率完全相同，不论这个静态数据成员经过了多么复杂的继承体系。</p><p>若取一个<code>static data member</code>的地址不会得到指向其<code>class member</code>的指针（不是<code>value_type class_type::*</code>类型）。而是指向其数据类型的指针（类型为<code>value_type*</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Point::x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = &amp;Point::func1; <span class="comment">// p 的类型是 void (Point::*p)()</span></span><br><span class="line">    <span class="keyword">auto</span> q = &amp;Point::func2; <span class="comment">// q 的类型是 void (*q)(int a)</span></span><br><span class="line">    <span class="keyword">auto</span> p = &amp;Point::x;<span class="comment">// r 的类型是 int* r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数不能是静态成员函数：如果构造函数是静态成员函数，那么将不能访问非静态变量，也没办法完成初始化的工作。</p><p><code>non static data member</code></p><p>对于类中的非静态数据成员，通过一个指针和通过一个对象来存取，当此数据成员属于继承而来的<code>virtual base class</code>时，使用指针效率较低。如果使用对象直接存取，就不会有这些问题，其类型无疑是确定的，而即使它继承自<code>virtual base class</code>，<code>members</code>的<code>offset</code>位置也在编译时期就固定了。</p><p>欲对一个<code>nonstatic data member</code>进行存取操作，编译器需要把<code>class object</code>的起始地址加上<code>data member</code>的偏移量。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;origin._y == &amp;origin + (&amp;Point3d::_y - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>请注意其中的<code>-1</code>操作。指向<code>data member</code>的指针，其<code>offset</code>值总是被加上<code>1</code>，这样可以使编译系统区分出是用以指出<code>class</code>的第一个<code>member</code>还是没有指出任何<code>member</code>的两种情况。</p><h5 id="3-4-C-对象布局"><a href="#3-4-C-对象布局" class="headerlink" title="3.4 C++对象布局"></a><code>3.4</code> <code>C++</code>对象布局</h5><ol><li><p>个别<code>struct</code>的数据布局</p><p> <img src="image-20210310151329468.png" alt="image-20210310151329468"></p></li><li><p>单一继承而且没有<code>virtual function</code>时的数据布局</p><p> <img src="image-20210310151502431.png" alt="image-20210310151502431"></p></li><li><p><code>C++</code>语言保证——出现在<code>derived class</code>中的<code>base class subobject</code>有其完整原样性</p><p> <img src="image-20210310151740707.png" alt="image-20210310151740707"></p><p> <img src="image-20210310151814511.png" alt="image-20210310151814511"></p></li><li><p>单一继承并含虚拟函数情况下的数据布局</p><p> <img src="image-20210310151910413.png" alt="image-20210310151910413"></p></li><li><p>多重继承</p><p> <img src="image-20210310152020878.png" alt="image-20210310152020878"></p><p> <img src="image-20210310152043648.png" alt="image-20210310152043648"></p></li><li><p>虚拟继承，使用<code>pointer strategy</code>和<code>virtual table offset strategy</code></p><p> <img src="image-20210310152208905.png" alt="image-20210310152208905"></p><p> <img src="image-20210310152330536.png" alt="image-20210310152330536"></p><p> <img src="image-20210310152521106.png" alt="image-20210310152521106"></p></li></ol><h5 id="3-5-指向data-member成员的指针"><a href="#3-5-指向data-member成员的指针" class="headerlink" title="3.5 指向data member成员的指针"></a><code>3.5</code> 指向<code>data member</code>成员的指针</h5><p>取一个<code>nonstatic data member</code>的地址，将会得到它在<code>class</code>中的<code>offset</code>（指针类型为<code>data_type class_type::*</code>），取一个“绑定于真正<code>class object</code>身上的<code>data member</code>”的地址，将会得到该<code>member</code>在内存中的真正地址（指针类型为<code>data_type*</code>）。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型 第二章</title>
      <link href="/FXn6nXyz1FEw9e8Y/"/>
      <url>/FXn6nXyz1FEw9e8Y/</url>
      
        <content type="html"><![CDATA[<h4 id="第2章：构造函数语意学"><a href="#第2章：构造函数语意学" class="headerlink" title="第2章：构造函数语意学"></a>第<code>2</code>章：构造函数语意学</h4><p>在这一章中，主要介绍编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”的冲击。</p><h5 id="2-1-Default-Constructor的构造操作"><a href="#2-1-Default-Constructor的构造操作" class="headerlink" title="2.1 Default Constructor的构造操作"></a><code>2.1</code> <code>Default Constructor</code>的构造操作</h5><p>对于未声明构造函数的类，只有在以下四种情况下编译器才会为它们合成默认构造函数：</p><ul><li>类有一个类对象（<code>Member Class Object</code>）成员，且该成员含有默认构造函数（<code>Default Constructor</code>）</li><li>继承自带有默认构造函数（<code>Default Constructor</code>）的基类（<code>Base class</code>）</li><li>带有虚函数（<code>Virtual function</code>）的类</li><li>继承自虚基类（<code>Virtual base class</code>）的类</li></ul><a id="more"></a><p>对于以上四种情况，<code>C++</code>标准把合成的默认构造函数叫隐式的有意义默认构造函数(<code>implicit nontrivial default constructors</code>)。被合成的构造函数只能满足编译器（而非程序）的需要，它之所以能够完成任务，是借着调用成员对象或基类的默认构造函数（情况<code>1/2</code>），或是为每一个对象初始化其虚函数机制或虚基类机制（情况<code>3/4</code>）。</p><p>至于没有存在上述四种情况，而又没有声明任何构造函数的类，那么它们拥有的是隐式无意义默认构造函数(<code>implicit trivial default constructors</code>)，实际上它们并不会被合成出来。</p><p><code>Default Constructor</code>会在<strong>编译器需要</strong>的时候被产生出来，被合成出来的<code>Constructor</code>只执行编译器所需要的行为。如果程序有需要，定制<code>Default Constructor</code>的行为是程序员的责任。</p><ol><li><p>“带有<code>Default Constructor</code>”的<code>Member Class Object</code></p><p> 如果有多个<code>class member objects</code>都要求<code>constructor</code>初始化操作，将如何呢？<code>C++</code>语言要求以“<code>member objects</code>在<code>class</code>中的声明次序”来调用各个<code>constructors</code>。这一点由编译器完成，它为每一个<code>constructor</code>安插程序代码，以“<code>member</code>声明次序”调用每一个<code>member</code>所关联的<code>default constructors</code>。这些码将被安插在<code>explicit user code</code>之前。举个例子：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dopey</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dopey();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneezy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sneezy(<span class="keyword">int</span>);</span><br><span class="line">    Sneezy();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bashful</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bashful();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snow_White</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Dopey dopey;</span><br><span class="line">Sneezy sneezy;</span><br><span class="line">Bashful bashful;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 如果<code>Snow_White</code>没有定义<code>default constructor</code>，就会有一个<code>nontrivial constructor</code>被合成出来，依序调用<code>Dopey</code>、<code>Sneezy</code>、<code>Bashful</code>的<code>default constructors</code>。然而如果<code>Snow_White</code>定义了下面这样的<code>default constructor</code>：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序员所写的 default constructor</span></span><br><span class="line">Snow_White::Snow_White() : sneezy(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 它会被扩张为：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器扩张后的 C++ 伪码</span></span><br><span class="line">Snow_White::Snow_White()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用其 constructor</span></span><br><span class="line">    dopey.Dopey::Dopey();</span><br><span class="line">    Sneezy.Sneezy::Sneezy(<span class="number">1024</span>);</span><br><span class="line">    bashful.Bashful::Bashful();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// explicit user code</span></span><br><span class="line">    mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>“带有<code>Default Constructor</code>”的<code>Base Class</code></p><p> 类似的道理，如果一个没有任何<code>constructors</code>的<code>class</code>派生自一个“带有<code>default constructor</code>”的<code>base class</code>，那么这个<code>derived class</code>的<code>default constructor</code>会被视为<code>nontrivial</code>，并因此需要被合成出来。它将调用上一层<code>base classes</code>的<code>default constructor</code>（根据它们的声明次序）。对一个后继派生的<code>class</code>而言，这个合成的<code>constructor</code>和一个“被明确提供的<code>default constructor</code>”没有什么差异。</p><p> 如果设计者提供多个<code>constructors</code>，但其中都没有<code>default constructor</code>呢？编译器会扩张现有的每一个<code>constructors</code>，将“用以调用所有必要之<code>default constructors</code>”的程序代码加进去。它不会合成一个新的<code>default constructor</code>，这是因为其它“由<code>user</code>所提供的<code>constructors</code>”存在的缘故。如果同时亦存在着“带有<code>default constructors</code>”的<code>member class objects</code>，那些<code>default constructor</code>也会被调用。</p></li><li><p>“带有（声明或继承）一个<code>Virtual Function</code>”的<code>Class</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">const</span> Widget&amp; widget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    widget.flip();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 Bell 和 Whistle 都派生自 Widget</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    Whistle w;</span><br><span class="line">    </span><br><span class="line">    flip(b);</span><br><span class="line">    flip(w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 下面两个扩张操作会在编译期间发生：</p><ol><li><p>一个<code>virtual function table</code>会被编译器产生出来，内放<code>class</code>的<code>virtual functions</code>地址。</p></li><li><p>在每一个<code>class object</code>中，一个额外的<code>pointer member</code>会被编译器合成出来，内含相关的<code>class vtbl</code>的地址。</p><p>此外，<code>widget.flip()</code>的虚拟引发操作会被重新改写，以使用<code>widget</code>的<code>vptr</code>和<code>vtbl</code>中的<code>flip()</code>条目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 表示 flip() 在 virtual table 的固定索引</span></span><br><span class="line"><span class="comment">// &amp;widget 代表要交给"被调用的某个 flip() 实体"的 this 指针</span></span><br><span class="line">(*widget.vptr[<span class="number">1</span>])(&amp;widget));</span><br></pre></td></tr></table></figure><p>为了让这个机制发挥功效，编译器必须为每一个<code>Widget</code>（或其派生类之）<code>object</code>的<code>vptr</code>设定初值，放置适当的<code>virtual table</code>地址。对于<code>class</code>所定义的每一个<code>constructor</code>，编译器会安插一些码来做这样的事情。对于那些未声明任何<code>constructors</code>的<code>classes</code>，编译器会为它们合成一个<code>default constructor</code>，以便正确地初始化每一个<code>class object</code>的<code>vptr</code>。</p></li></ol></li><li><p>“带有一个<code>Virtual Base Class</code>”的<code>Class</code></p><p> 编译器必须使<code>virtual base class</code>在其每一个<code>derived class object</code>中的位置，能够在执行期准备妥当。一种可能的做法是在<code>derived class</code>中安插一个指向每一个<code>virtual base class</code>的指针，所有“经由<code>reference</code>和<code>pointer</code>来存取其中<code>virtual base class</code>中数据的操作”都通过此指针完成。</p><p> 同样地，这个<code>virtual base class</code>指针是在<code>class object</code>构建期间完成的，编译器的默认行为和<code>3</code>中的<code>vptr</code>的处理方式一样。</p></li></ol><h5 id="2-2-Copy-Constructor的构造操作"><a href="#2-2-Copy-Constructor的构造操作" class="headerlink" title="2.2 Copy Constructor的构造操作"></a><code>2.2</code> <code>Copy Constructor</code>的构造操作</h5><p>有三种情况会调用<code>copy constructor</code>：</p><ul><li><p>对一个<code>class object</code>做明确的初始化操作</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>...&#125;;</span><br><span class="line">X x;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">xx</span><span class="params">(x)</span></span>;</span><br><span class="line">X xx = x;</span><br></pre></td></tr></table></figure></li><li><p>当<code>class object</code>被当作参数交给某个函数时</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(X x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    foo(xx);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当函数返回一个<code>class object</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p><code>Default Memberwise Initialization</code></p><p> 如果<code>class</code>没有提供一个<code>explicit copy constructor</code>又当如何？当<code>class object</code>以“相同<code>class</code>的另一个<code>object</code>”作为初值时，其内部是以所谓的<code>default memberwise initialization</code>完成的，也就是把每一个内建的或派生的<code>data member</code>的值，从某个<code>object</code>拷贝一份到另一个<code>object</code>身上。不过它并不会拷贝其中的<code>member class object</code>，而是以递归的方式施行<code>memberwise initialization</code>。</p><p> 一个良好的编译器可以为大部分<code>class objects</code>产生<code>bitwise copies</code>，因为它们有<code>bitwise copy semantics</code>。<code>copy constructors</code>在<strong>必要的时候</strong>才由编译器产生出来。这个句子中的“必要”意指当<code>class</code>不展现<code>bitwise copy semantics</code>时。</p></li><li><p><code>Bitwise Copy Semantics</code></p><p> <code>C++ Standard</code>把<code>copy constructor</code>区分为<code>trivial</code>和<code>nontrivial</code>两种。只有<code>nontrivial</code>的实体才会被合成于程序之中。决定一个<code>copy constructor</code>是否为<code>trivial</code>的标准在于<code>class</code>是否展现出所谓的“<code>bitwise copy semantics</code>”。</p><p> 什么时候一个class不展现出<code>Bitwise Copy Semantics</code>呢？</p><ul><li><p>当<code>class</code>内含一个<code>member object</code>而后者的<code>class</code>声明有一个<code>copy constructor</code>时（不论是被<code>class</code>设计者明确地声明；或是被编译器合成）。</p></li><li><p>当<code>class</code>继承自一个<code>base class</code>而后者存在有一个<code>copy constructor</code>（再次强调，不论是被明确声明或是被合成而得）。</p></li><li><p>当<code>class</code>声明了一个或多个<code>virtual functions</code>时。</p></li><li><p>当<code>class</code>派生自一个继承串链，其中有一个或多个<code>virtual base classes</code>时。</p><p>有一点很值得注意：在被合成出来的<code>copy constructor</code>中，如整数、指针、数组等等的<code>nonclass members</code>也都会被复制。</p></li></ul></li><li><p>重新设定<code>virtual table</code>的指针<code>vptr</code></p><p> 当编译器导入一个<code>vptr</code>到<code>class</code>之中时，该<code>class</code>就不再展现<code>bitwise semantics</code>了。编译器需要合成出一个<code>copy constructor</code>，以求将<code>vptr</code>适当地初始化。</p><p> <code>base class object</code>以另一个<code>base class object</code>作为初值，或<code>derived class object</code>以另一个<code>derived  class object</code>作为初值，都可以直接靠“<code>bitwise copy semantics</code>”完成。当一个<code>base class object</code>以其<code>derived class</code>的<code>object</code>内容做初始化操作时，其<code>vptr</code>复制操作必须保证安全。此时，合成出来的<code>base copy constructor</code>会明确设定<code>object</code>的<code>vptr</code>指向<code>base class</code>的<code>virtual table</code>，而不是直接从右手边的<code>class object</code>中将其<code>vptr</code>现值拷贝过来。</p></li><li><p>处理<code>virtual base class subject</code></p><p> 和<code>3</code>同理，需要合成<code>copy constructor</code>来明确的设定<code>virtual base class pointer</code>的初值。</p></li></ol><h5 id="2-3-程序转化语意学"><a href="#2-3-程序转化语意学" class="headerlink" title="2.3 程序转化语意学"></a><code>2.3</code> 程序转化语意学</h5><p>已知有这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X x0;</span><br></pre></td></tr></table></figure><p>下面有三个定义，每一个都明显地以<code>x0</code>来初始化其<code>class object</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">X <span class="title">xl</span><span class="params">(x0)</span></span>;</span><br><span class="line">X x2 = x0;</span><br><span class="line">X x3 = X(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必要的程序转化有两个阶段：</p><ol><li>重写每一个定义，其中的初始化操作会被剥除。</li><li><code>class</code>的<code>copy constructor</code>调用操作会被安插进去。</li></ol><p>举个例子，在明确的双阶段转化之后，<code>foo_bar()</code>可能看起来像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能的程序转换</span></span><br><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意没有初始化操作</span></span><br><span class="line">X x1;</span><br><span class="line">    X x2;</span><br><span class="line">    X x3;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 编译器安插X copy construction的调用操作</span></span><br><span class="line">    x1.X::X(x0);</span><br><span class="line">x2.X::X(x0);</span><br><span class="line">    x3.X::X(x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>参数的初始化</p><p>  把一个<code>class object</code>当做参数传给一个函数，相当于以下形式的初始化操作：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx 代表形式参数, arg 代表真正的参数值</span></span><br><span class="line">X xx = arg;</span><br></pre></td></tr></table></figure></li><li><p>返回值的初始化</p><p>  已知下面这个函数定义：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line"><span class="comment">// 处理 xx ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里有一个双阶段转化：</p><ol><li><p>首先加上一个额外参数，类型是<code>class object</code>的一个<code>reference</code>。这个参数将用来放置被“拷贝建构（<code>copy constructed</code>）”而得的返回值。</p></li><li><p>在<code>return</code>指令之前安插一个<code>copy constructor</code>调用操作，以便将欲传回之<code>object</code>的内容当做上述新增参数的初值。</p><p>根据这样的算法，<code>bar()</code>转换如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// 编译器所产生的 default constructor 调用操作</span></span><br><span class="line">    xx.X::X();</span><br><span class="line"><span class="comment">// ... 处理 xx</span></span><br><span class="line"><span class="comment">// 编译器所产生的 copy constructor</span></span><br><span class="line">    result.X::X(xx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在编译器必须转换每一个<code>bar()</code>调用操作，以反映其新定义。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X xx = bar();</span><br></pre></td></tr></table></figure><p>将被转换为下列两个指令句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意, 不必施行 default constructor</span></span><br><span class="line">X xx;</span><br><span class="line">bar(xx);</span><br></pre></td></tr></table></figure></li></ol></li><li><p><code>NRV</code>优化</p><p>  已知下面这个函数定义：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line"><span class="comment">// 处理 xx ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  编译器会把它优化为：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(X &amp;_result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  default constructor 调用操作</span></span><br><span class="line">    _result.X::X();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 直接处理 _result</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>只有当程序提供了<code>explicit copy constructor</code>，编译器才会实施<code>NRV</code>优化。没有提供的话（编译器自己合成的），是不会实施<code>NRV</code>优化的。</strong></p></li><li><p><code>copy constructor</code>要还是不要？</p><p>  对于下面的<code>3D</code>坐标点类，这个<code>class</code>的设计者应该提供一个<code>explicit copy constructor</code>吗？</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point3d(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  除非你预见该<code>class</code>需要大量的<code>memberwise</code>初始化操作，例如函数以传值（<code>by value</code>）的方式传回<code>objects</code>，那么提供一个<code>copy constructor</code>的<code>explicit inline</code>函数实体就非常合理——可以激活编译器提供的<code>NRV</code>优化。否则，不提供<code>explicit copy constructor</code>既快速又安全。</p></li></ul><h5 id="2-4-Member-initialization-list"><a href="#2-4-Member-initialization-list" class="headerlink" title="2.4 Member initialization list"></a><code>2.4</code> <code>Member initialization list</code></h5><p>为了让你的程序能够被顺利编译，必须使用<code>member initialization list</code>的情况：</p><ol><li>当初始化一个<code>refercnce member</code>时；</li><li>当初始化一个<code>const member</code>时；</li><li>当调用一个<code>base class</code>的<code>constructor</code>，而它拥有一组参数时；</li><li>当调用一个<code>member class</code>的<code>constructor</code>，而它拥有一组参数时。</li></ol><p>在这四种情况之外，不使用<code>member initialization list</code>，程序可以被正确编译并执行，但是效率不彰。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Word()</span><br><span class="line">    &#123;</span><br><span class="line">        _name = <span class="number">0</span>;</span><br><span class="line">        _cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String _name;</span><br><span class="line">    <span class="keyword">int</span> _cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是编译器对<code>constructor</code>可能的内部扩张结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line">Word::Word(<span class="comment">/* this pointer goes here */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 String default constructor</span></span><br><span class="line">    _name.String::String();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产生临时性对象</span></span><br><span class="line">    String temp = String(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// memberwise 地拷贝 _name</span></span><br><span class="line">    _name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 摧毁暂时性对象</span></span><br><span class="line">    temp.String::~String();</span><br><span class="line">    </span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更有效率的实现方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 较佳的方式</span></span><br><span class="line">Word::Word : _name(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会被扩张成这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line">Word::Word(<span class="comment">/* this pointer goes here */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 String(int) constructor</span></span><br><span class="line">_name.String::String(<span class="number">0</span>);</span><br><span class="line">_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会一一操作<code>initialization list</code>，以<code>member</code><strong>声明次序</strong>（不是由<code>initialization list</code>中的排列次序决定的）在<code>constructor</code>之内的<strong><code>explicit user code</code>之前</strong>安插初始化操作。</p><p>调用一个<code>member function</code>以设定一个<code>member</code>的初值是可以的，因为此时<code>this</code>指针已经被构造妥当。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// X::xfoo() 被调用</span></span><br><span class="line">X::X(<span class="keyword">int</span> val) : i(xfoo(val)), j(val)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会被扩张为</span></span><br><span class="line">X::X(<span class="comment">/* this pointer */</span>, <span class="keyword">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="keyword">this</span>-&gt;xfoo(val);</span><br><span class="line">    i = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果一个<code>derived class member function</code>被调用，其返回值被当做<code>base class constructor</code>的一个参数，这不是一个好主意！！！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型 第一章</title>
      <link href="/jOQUhpad0yAY7aMb/"/>
      <url>/jOQUhpad0yAY7aMb/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>Simplifier</code>是编译器的一部分，处于<code>type checking</code>和<code>code generation</code>之间。它用来转换内部的程序表现。有<code>3</code>种转换是任何对象模型都需要的：</p><ol><li><p>与编译器息息相关的转换（<code>Implementation-dependent transformations</code>）</p><p> 例如，当<code>parser</code>看到这个表达式：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fct();</span><br></pre></td></tr></table></figure><p> 它并不知道是否（<code>a</code>）这是一个函数调用操作，或者（<code>b</code>）这是<code>overloaded calloperator</code>在<code>class object fct</code>上的一种应用。默认情况下，这个式子所代表的是一个函数调用，但是当（<code>b</code>）的情况出现，<code>Simplifier</code>就要重写并调换<code>call subtree</code>。</p></li><li><p>语言语意转换（<code>Language semantics transformations</code>）</p><p> 这包括<code>constructor</code>/<code>destructor</code>的合成和扩展、<code>memberwise</code>初始化、对于<code>memberwise copy</code>的支持、在程序代码中安插<code>conversion operators</code>、临时性对象，以及对<code>constructor</code>/<code>destructor</code>的调用。</p></li><li><p>程序代码和对象模型的转换（<code>Code and object model transformations</code>）</p><p> 这包括对<code>virtual functions</code>、<code>virtual base class</code>和<code>inheritance</code>的一般支持、<code>new</code>和<code>delete</code>运算符、<code>class objects</code>所组成的数组、<code>local static class instances</code>、带有非常量表达式（<code>nonconstant cxpression</code>）之<code>global object</code>的静态初始化操作。</p></li></ol><p>什么是<code>C++</code>对象模型？</p><ul><li>语言中直接支持面向对象程序设计的部分</li><li>对于各种支持的底层实现机制</li></ul><a id="more"></a><h4 id="第1章：关于对象"><a href="#第1章：关于对象" class="headerlink" title="第1章：关于对象"></a>第<code>1</code>章：关于对象</h4><p>在<code>C</code>语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。</p><p><code>C++</code>在布局以及存取时间上主要的额外负担是由<code>virtual</code>引起，包括：</p><ol><li><code>virtual function</code>机制——用以支持一个有效率的“执行期绑定”</li><li><code>virtual base class</code>——用以实现“多次出现在继承体系中的<code>base class</code>，有一个单一而被共享的实体”</li><li>此外，还有一些多重继承下的额外负担，发生在“一个<code>derived class</code>和其第二或后继之<code>base class</code>的转换”之间。</li></ol><h5 id="1-1-C-对象模型"><a href="#1-1-C-对象模型" class="headerlink" title="1.1 C++对象模型"></a><code>1.1</code> <code>C++</code>对象模型</h5><p>在<code>C++</code>中，有两种<code>class data members</code>：<code>static</code>和<code>nonstatic</code>，以及三种<code>class member functions</code>：<code>static</code>、<code>nonstatic</code>和<code>virtual</code>。</p><p>在<code>C++</code>对象模型中，<code>nonstatic data members</code>被配置于每一个<code>class object</code>之内，<code>static data members</code>则被存放在所有的<code>class object</code>之外。<code>static</code>和<code>nonstatic function members</code>也被放在所有的<code>class object</code>之外。<code>virtual functions</code>则以两个步骤支持之：</p><ol><li>每一个<code>class</code>产生出一堆指向<code>virtual functions</code>的指针，放在表格之中。这个表格被称为 <code>vtbl</code>。</li><li>每一个<code>class object</code>被添加了一个指针，指向相关的<code>virtual table</code>。通常这个指针被称为<code>vptr</code>。<code>vptr</code>的设定（<code>setting</code>）和重置（<code>resetting</code>）由每一个<code>class</code>的<code>constructor</code>、<code>destructor</code>和<code>copy assignment</code>运算符自动完成。</li></ol><p>在虚拟继承的情况下，<code>base class</code>不管在继承串链中被派生（<code>derived</code>）多少次，永远只会存在一个实体（称为<code>subobject</code>）。</p><p><code>C++</code>最初采用的继承模型并不运用任何间接性: <code>base class subobject</code>的<code>data members</code>被直接放置于<code>derived class object</code>中。这提供了对<code>base class members</code>最紧凑而且最有效率的存取。缺点就是: <code>base class members</code>的任何改变，包括增加﹑移除或改变类型等等，都使得所有用到“此<code>base class</code>或其<code>derived class</code>之<code>objects</code>”者重新编译。</p><p><code>virtual base class</code>的原始模型是在<code>class object</code>中为每一个有关联的<code>virtual base class</code>加上一个指针。</p><p>对象模型如何影响程序？</p><p>不同的对象模型，会导致“现有的程序代码必须修改”以及“必须加人新的程序代码”两个结果。例如下面这个函数，其中<code>class X</code>定义了一个<code>copy constructor</code>，一个<code>virtual destructor</code>，和一个<code>virtual function foo</code>：</p><img src="image-20210219212057818.png" alt="image-20210219212057818" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foobar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X xx;</span><br><span class="line">X* px = <span class="keyword">new</span> X;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// foo 是一个虚函数</span></span><br><span class="line">    xx.foo();</span><br><span class="line">px-&gt;foo();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> px;</span><br><span class="line">    <span class="keyword">return</span> xx; <span class="comment">// 这里会用到 copy constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有可能在内部被转化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(X&amp; _result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 构造 _result</span></span><br><span class="line"><span class="comment">// _result 用来取代 local xx...</span></span><br><span class="line">_result.X::X();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展 ×* px= new x;</span></span><br><span class="line">px = _new(<span class="keyword">sizeof</span>(X));</span><br><span class="line"><span class="keyword">if</span>(px != <span class="number">0</span>)</span><br><span class="line">px-&gt;X::X();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展 xx.foo() 但不使用 virtual 机制</span></span><br><span class="line"><span class="comment">// 以 _result 取代 xx</span></span><br><span class="line">foo(&amp;_result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 virtual 机制扩展 px-&gt;foo()</span></span><br><span class="line">(*px-&gt;vtbl[<span class="number">2</span>])(px);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展 delete px;</span></span><br><span class="line"><span class="keyword">if</span>(px != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">(*px-&gt;vtbl[<span class="number">1</span>])(px); <span class="comment">// destructor</span></span><br><span class="line">        _delete(px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需使用 named return statement</span></span><br><span class="line"><span class="comment">//不需要摧毁 local object xx</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-关键词所带来的差异"><a href="#1-2-关键词所带来的差异" class="headerlink" title="1.2 关键词所带来的差异"></a><code>1.2</code> 关键词所带来的差异</h5><ul><li>掌握<code>struct</code>和<code>class</code>关键字的差异</li></ul><p><code>struct</code>关键词的使用实现了<code>C</code>的数据萃取概念，而<code>class</code>关键词实现的是<code>C++</code>的<code>ADT</code>（<code>Abstract Data Type</code>）概念。</p><p><code>C</code>程序员的巧计（<code>C++</code>中不可用）。例如把单一元素的数组放在一个<code>struct</code>的尾端，于是每个<code>struct objects</code>可以拥有可变大小的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// stuff</span></span><br><span class="line"><span class="keyword">char</span> pc[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从档案或标准输入装置中取得一个字符串 str</span></span><br><span class="line"><span class="comment">// 然后为 struct 本身和该字符串配置足够的内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mumble</span> *<span class="title">pmumble</span> = (<span class="title">struct</span> <span class="title">mumble</span>*)</span></span><br><span class="line"><span class="class"><span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">mumble</span>) + <span class="title">strlen</span>(<span class="title">str</span>) + 1);</span></span><br><span class="line"><span class="built_in">strcpy</span>(&amp;(pmumble-&gt;pc), str);</span><br></pre></td></tr></table></figure><p><code>C++</code>中凡处于同一个<code>access section</code>的数据，必定保证以其声明次序出现在内存布局当中。然而被放置在多个<code>access sections</code>中的各笔数据，排列次序就不一定了。组合（<code>composition</code>)，而非继承，才是把<code>C</code>和<code>C++</code>结合在一起的唯一可行方法（<code>conversion</code>运算符提供了一个十分便利的萃取方法）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C_point</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">C_point</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c_point_; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    C_point c_point_;</span><br></pre></td></tr></table></figure><p><code>C struct</code>在<code>C++</code>中的一个合理用途，是当你要传递“一个复杂的<code>class object</code>的全部或部分”到某个<code>C</code>函数中去时，<code>struct</code>声明可以将数据封装起来，并保证拥有与<code>C</code>兼容的空间布局。然而这项保证只在组合的情况下才存在。</p><h5 id="1-3-对象的差异"><a href="#1-3-对象的差异" class="headerlink" title="1.3 对象的差异"></a><code>1.3</code> 对象的差异</h5><p><code>C++</code>支持<code>3</code>种程序设计模型：</p><ol><li>程序模型（面向过程）</li><li>抽象数据类型模型（基于对象模型）（封装）</li><li>面向对象模型（继承、多态）</li></ol><p>在<code>C++</code>，多态只存在于一个个的<code>public class</code>体系中。<code>nonpublic</code>的派生行为以及类型为<code>void*</code>的指针可以说是多态，但它们并没有被语言明白地支持，也就是说它们必须由程序员通过明白的<strong>转型操作</strong>来管理。<code>C++</code>以下列方法支持多态：</p><ol><li><p>经由一组隐含的转化操作。例如把一个<code>derived class</code>指针转化为一个指向其<code>public base type</code>的指针</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape *ps = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure></li><li><p>经由<code>virtual function</code>机制</p></li><li><p>经由<code>dynamic_cast</code>和<code>typeid</code>运算符</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Circle* pc = <span class="keyword">dynamic_cast</span>&lt;Circle*&gt;(ps))</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ol><p><code>virtual function</code>机制不只使得“当类型有所增加、修改、或删减时，我们的程序代码不需改变”。而且也使一个新的<code>subtype</code>的供应者不需要重新写出“对继承体系中的所有类型都共通”的行为和操作。</p><p>需要多少内存才能够表现一个<code>class object</code>？</p><ul><li><code>nonstatic data members</code>的总和大小</li><li>加上任何<code>alignment</code>（内存对齐）</li><li>加上为了支持<code>virtual</code>（<code>function</code>，<code>base class</code>）而由内部产生的额外负担</li></ul><p>转型（<code>cast</code>）其实是一种编译器指令。<strong>大部分情况下</strong>它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。</p><p>一个<code>Base</code>指针<code>pb</code>和一个<code>Derived</code>指针<code>pd</code>有什么不同？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;</span><br><span class="line">Derived* pd = &amp;d;</span><br></pre></td></tr></table></figure><p>它们每个都指向<code>Base object</code>的第一个<code>byte</code>。其间的差别是，<code>pd</code>所涵盖的地址包含整个<code>Derived object</code>，而<code>pb</code>所涵盖的地址只包含<code>Derived object</code>中的<code>Base subobject</code>。</p><p>除了<code>Base subobject</code>中出现的<code>members</code>，你不能使用<code>pb</code>来直接处理<code>Derived</code>的任何<code>members</code>。例外是通过<code>virtual</code>机制或转型操作。</p><p>当一个<code>base class object</code>被直接初始化为（或是被指定为）一个<code>derived class object</code>时，<code>derived object</code>就会被切割，以塞人较小的<code>base type</code>内存中，<code>derived type</code>将没有留下任何蛛丝马迹。</p><p>下面这一组定义，其可能的内存布局为：</p><img src="image-20210220202640585.png" alt="image-20210220202640585" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal za;</span><br><span class="line">ZooAnimal *pza;</span><br><span class="line">Bear b;</span><br><span class="line">Panda* pp = <span class="keyword">new</span> Panda;</span><br><span class="line">pza = &amp;b;</span><br></pre></td></tr></table></figure><img src="image-20210220153355200.png" alt="image-20210220153355200" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 深度探索C++对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第七章</title>
      <link href="/MBICE5WlMJtd4Rku/"/>
      <url>/MBICE5WlMJtd4Rku/</url>
      
        <content type="html"><![CDATA[<h4 id="第7章：模板与泛型编程"><a href="#第7章：模板与泛型编程" class="headerlink" title="第7章：模板与泛型编程"></a>第<code>7</code>章：模板与泛型编程</h4><h5 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款<code>41</code>：了解隐式接口和编译期多态</h5><ul><li><p>哪一个重载函数被调用——发生在编译期</p></li><li><p>哪一个<code>virtual</code>函数被绑定——发生在运行期</p></li><li><p><code>class</code>和<code>template</code>都支持接口和多态</p><p>  对<code>class</code>而言，接口是显式的，以成员函数的签名为中心，多态则通过<code>virtual</code>函数发生在运行期。对<code>template</code>而言，接口是隐式的，以有效表达式为中心，多态则通过<code>template</code>具现化和函数重载解析发生于编译期。</p></li></ul><a id="more"></a><h5 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款<code>42</code>：了解<code>typename</code>的双重意义</h5><ul><li><p>当我们声明模板类型参数，<code>class</code>和<code>typename</code>的意义完全相同</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>typename</code>用来标识嵌套从属类型名称</p><p>  <code>template</code>内出现的名称如果相依于某个<code>template</code>参数，称这个名称为从属名称，如果丛属名称在<code>class</code>内呈嵌套状，称为嵌套从属名称。如果嵌套从属名称还指涉某种类型名称为嵌套从属类型名称</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::iterator_traits&lt;IterT&gt;::value_type 就是嵌套从属类型名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须使用 typename 关键字标识</span></span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 typedef 少打几个字</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须使用 typename 关键字标识</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不允许在<code>base class list</code>或<code>member initialization list</code>内使用<code>typename</code>作为<code>base class</code>的标识符</p></li></ul><h5 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款<code>43</code>：学习处理模板化基类内的名称</h5><p>假设我们需要撰写一个<code>MsgSender</code>类，它能够传送信息到若干不同的<code>Company</code>去。信息要不进行加密后的密文，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于<code>template</code>的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 针对其他公司设计的 class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgInfo</span> &#123;</span>...&#125;; <span class="comment">// 这个 class 以备将来产生信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">//构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">string</span> msg;</span><br><span class="line">... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">c.sendCleartext(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">c.sendEncrypted(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在假设我们想要在每次送出信息时<code>log</code>某些信息。<code>derived class</code>可轻易提供解决方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">sendClear(info); <span class="comment">// 调用 base class 函数, 这段码无法通过编译!</span></span><br><span class="line">... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译器会抱怨<code>sendClear</code>函数不存在，明明在那里，为什么？</p><p>问题在于，当编译器看见<code>class template LoggingMsgSender</code>定义式时，并不知道它继承什么样的<code>class</code>。当然它继承的是<code>MsgSender&lt;Company&gt;</code>，但其中的<code>Company</code>是个<code>template</code>参数，不当<code>LoggingMsgSender</code>被具现化之前无法确切知道它是什么。而如果不知道<code>Company</code>是什么，就无法知道<code>class MsgSender&lt;Company&gt;</code>看起来像什么——更明确地说是没办法知道它是否有个<code>sendClear</code>函数。</p><p>具体点说，假设现在有个<code>CompanyZ</code>坚持只使用加密通讯：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不提供 sendCleartext 函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyZ</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般性的<code>MsgSender template</code>对<code>CompanyZ</code>并不合适，因为那个<code>template</code>提供了一个<code>sendClearMsg</code>函数，而这对<code>CompanyZ</code>对象并不合理。欲矫正这个问题，我们可以针对<code>CompanyZ</code>产生一个<code>MsgSender</code>特化版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全特化版本只提供 sendSecret 函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&lt;CompanyZ&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">//构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">c.sendEncrypted(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就解释了前面编译器拒绝那个调用的原因：它知道<code>base class template</code>有可能被特化，而那个特化版本可能不提供和一般性<code>template</code>相同的接口。因此它往往拒绝在<code>templatized base class</code>（本例的<code>MsgSender&lt;Company&gt;</code>）内寻找继承而来的名称（本例的<code>SendClear</code>)。</p><ul><li>当我们从<code>Object Oriented C++</code>跨进<code>Template C++</code>（见条款<code>1</code>) ，继承就不像以前那样畅行无阻了</li></ul><p>有三个解决令<code>C++</code>编译器“不进入<code>templatized base class</code>观察”的行为失效的办法：</p><ol><li><p>使用<code>this</code>指针</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line"><span class="keyword">this</span>-&gt;sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>using</code>声明</p><p> 虽然<code>using</code>声明式在在条款<code>33</code>或在这里都可有效运作，但两处解决的问题其实不相同。前者是<code>base class</code>名称被<code>derived class</code>名称遮掩，而后者是编译器不进入<code>base class</code>作用域内查找，于是我们通过<code>using</code>告诉它，请它那么做。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用作用域运算符<code>::</code>明确指定</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">MsgSender&lt;Company&gt;::sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>即使如此，如果稍后这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoggingMsgSender&lt;Companyz&gt;zMsgSender;</span><br><span class="line">MsgInfo msgData;</span><br><span class="line">...</span><br><span class="line">zMsgSender.sendClearMsg(msgData); <span class="comment">// 仍然无法通过编译</span></span><br></pre></td></tr></table></figure><p>其中对<code>sendClearMsg</code>的调用动作将无法通过编译，因为在那个点上，编译器知道<code>base class</code>是个<code>template</code>特化版本<code>MsgSender&lt;CompanyZ&gt;</code>，而且它知道那个<code>class</code>不提供<code>sendClear</code>函数，而<code>sendClear</code>却是<code>sendClearMsg</code>尝试调用的函数。 </p><h5 id="条款44：将与基类无关的代码抽离template"><a href="#条款44：将与基类无关的代码抽离template" class="headerlink" title="条款44：将与基类无关的代码抽离template"></a>条款<code>44</code>：将与基类无关的代码抽离<code>template</code></h5><p>当你编写某个函数，其中某些部分的实现码和另一个函数的实现码实质相同，你会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。如果你正在编写某个<code>class</code>，而你明白其中某些部分和另一个<code>class</code>的某些部分相同，你也不会重复这共同的部分。你会把共同部分搬移到新<code>class</code>去，然后使用继承或复合（见条款<code>32</code>，<code>38</code>，<code>39</code>) ，令原先的<code>class</code>取用这共同特性。而原<code>class</code>的互异部分仍然留在原位置不动。</p><p>编写<code>template</code>时，也是做相同的分析，以相同的方式避免重复。然而在<code>template</code>代码中，重复是隐晦的：毕竟只存在一份<code>template</code>源码，所以你必须训练自己去感受当<code>template</code>被具现化多次时可能发生的重复。</p><p>举个例子，假设你想为固定尺寸的正方矩阵编写一个<code>template</code>。该矩阵的性质之一是支持逆矩阵运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template 支持 n x n 矩阵, 元素类型为 T</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">squareMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">( )</span></span>; <span class="comment">// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; sml;</span><br><span class="line">...</span><br><span class="line">sm1.invert(); <span class="comment">// 调用 SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">sSquareMatrix&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.invert(); <span class="comment">// 调用 SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure><p>这会具现化两份<code>invert</code>。这些函数并非完完全全相同，因为其中一个操作的是<code>5x5</code>矩阵而另一个操作的是<code>10x10</code>矩阵，但除了常量<code>5</code>和<code>10</code>，两个函数的其他部分完全相同。这是<code>template</code>引出代码膨胀的一个典型例子。</p><p>第一次修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与尺寸无关的 base class</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">size_t</span> matrixSize)</span> <span class="comment">// 以给定的尺寸求逆矩阵</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明为 private 是为了不让客户看见</span></span><br><span class="line"><span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert; <span class="comment">// 避免遮掩 base 版的 invert, 见条款 33</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invert(n);<span class="comment">// inline 调用 base class 版的 invert</span></span><br><span class="line">        <span class="comment">// 为什么这儿出现 this-&gt; 见条款 43</span></span><br><span class="line">        <span class="comment">// LYL 认为前面已经使用了 using, this-&gt; 应该也不需要了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>base class</code>只是为了帮助<code>derived class</code>实现，不是为了表现<code>SquareMatrix</code>和<code>SquareMatrixBase</code>之间的<code>is-a</code>关系（关于<code>private</code>继承，见条款<code>39</code>)。</p><p>目前为止一切都好，但还有一些棘手的题目没有解决。<code>SquareMatrixBase::invert</code>如何知道该操作什么数据？虽然它从参数中知道矩阵尺寸，但它如何知道哪个特定矩阵的数据在哪儿？想必只有<code>derived class</code>知道。<code>derived class</code>如何联络其<code>base class</code>做逆运算动作？一个可能的做法是为<code>SquareMatrixBase::invert</code>添加另一个参数，可以是个指针，指向一块用来放置矩阵数据的内存地址。</p><p>第二次修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 存储矩阵大小和一个指针, 指向矩阵数值</span></span><br><span class="line">squareMatrixBase(<span class="keyword">size_t</span> n, T* pMem) : size(n), pData(pMem) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span> <span class="comment">// 不用指定尺寸了</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">size_t</span> size; <span class="comment">// 矩阵的大小</span></span><br><span class="line">T* pData; <span class="comment">// 指针, 指向矩阵内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SquareMatrix() : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T data[n * n];<span class="comment">// 这里直接将数据矩阵存储在 SquareMatrix 对象内部</span></span><br><span class="line"><span class="comment">// 也可以使用动态内存分配的方案</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个条款只讨论由<code>non-type template parameter</code>（非类型模板参数）带来的膨胀，其实<code>type parameter</code>（类型参数）也会导致膨胀。例如在许多平台上<code>int</code>和 <code>long</code>有相同的二进制表述，所以像<code>vector&lt;int&gt;</code>和<code>vector&lt;long&gt;</code>的成员函数有可能完全相同。某些链接器（<code>linker</code>）会合并完全相同的函数实现码，但有些不会，后者意味某些<code>template</code>被具现化为<code>int</code>和<code>long</code>两个版本，并因此造成代码膨胀。类似情况，所有指针类型都有相同的二进制表述，因此凡<code>template</code>持有指针者（例如<code>list&lt;int*&gt;</code>，<code>list&lt;const int*&gt;</code>，<code>list&lt;SquareMatrix&lt;long, 3&gt;*&gt;</code>等等）往往应该对每一个成员函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它们操作强型指针（<code>strongly typed pointer</code>，即<code>T*</code>），你应该令它们调用另一个操作无类型指针（<code>untyped pointer</code>，即<code>void*</code>）的函数，由后者完成实际工作。某些<code>C++</code>标准程序库实现版本的确为<code>vector</code>，<code>deque</code>和<code>list</code>等<code>template</code>做了这件事。</p><h5 id="条款45：成员函数模板接受所有兼容类型"><a href="#条款45：成员函数模板接受所有兼容类型" class="headerlink" title="条款45：成员函数模板接受所有兼容类型"></a>条款<code>45</code>：成员函数模板接受所有兼容类型</h5><p>内置指针是支持隐式转换的，比如<code>derived class</code>的指针可以隐式转换为<code>base class</code>指针，指向<code>non-const</code>对象的指针可以转换为指向<code>const</code>对象等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> :</span> <span class="keyword">public</span> Top &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> :</span> <span class="keyword">public</span> Middle &#123;...&#125;;</span><br><span class="line">Top* pt1 = <span class="keyword">new</span> Middle; <span class="comment">// 将 Middle* 转换为 Top*</span></span><br><span class="line">Top* pt2 = <span class="keyword">new</span> Bottom; <span class="comment">// 将 Bottom* 转换为 Top*</span></span><br><span class="line"><span class="keyword">const</span> Top* = pt1; <span class="comment">// Top* 转换为 const Top*</span></span><br></pre></td></tr></table></figure><p>但是我们自己实现的智能指针模板类，想做到这样就稍稍有点麻烦了。我们希望下面的代码能够通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">temmplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* realPtr)</span></span>; <span class="comment">// 智能指针通常以内置指针完成初始化</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Middle&gt;转 换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(<span class="keyword">new</span> Middle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Bottom&gt; 转换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Top&gt; 转换为 SmartPtr&lt;const Top&gt;</span></span><br><span class="line">SmartPtr&lt;<span class="keyword">const</span> Top&gt; pct2 = ptl;</span><br></pre></td></tr></table></figure><p><strong>注意，这些赋值表达式需要调用的都是<code>copy</code>构造函数。</strong>这里的代码不能通过编译，因为如果以带有<code>base-derived</code>关系的<code>B</code>，<code>D</code>两类型分别具现化某个<code>template</code>，产生出来的两个具现体并不带有<code>base-derived</code>关系，所以编译器视<code>SmartPtr&lt;Middle&gt;</code>和<code>SmartPtr&lt;Top&gt;</code>为完全不同的<code>class</code>，为了获得我们希望获得的<code>SmartPtr class</code>之间的转换能力，我们必须将它们明确地编写出来。</p><p>我们应该为它写一个<strong>构造模板</strong>。这样的模板是所谓<code>member function template</code>，其作用是为<code>class</code>生成函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// member template, 为了生成 copy 构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们称之为泛化（<code>generalized</code>）<code>copy</code>构造函数。它并未被声明为<code>explicit</code>，那是因为内置指针类型之间的转换（例如从<code>derived class</code>指针转为<code>base class指针</code>）是隐式转换，所以让智能指针按照这种形式也属合理。</p><p>但是，这个为<code>SmartPtr</code>而写的“泛化<code>copy</code>构造函数”提供的东西比我们需要的更多。我们只希望根据一个<code>SmartPtr&lt;Bottom&gt;</code>创建一个<code>SmartPtr&lt;Top&gt;</code>，却不希望根据一个<code>SmartPtr&lt;Top&gt;</code>创建一个<code>SmartPtr&lt;Bottomr&gt;</code>，因为那对<code>public</code>继承而言（见条款32）是矛盾的。我们也不希望根据一个<code>SmartPtr&lt;double&gt;</code>创建一个<code>SmartPtr&lt;int&gt;</code>，我们必须从某方面对这一<code>member template</code>所创建的成员函数群进行挑拣。</p><p>假设<code>SmartPtr</code>遵循<code>std::shared_ptr</code>也提供一个<code>get</code>成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以 other 的 heldPtr 初始化 this 的 heldPtr</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) : heldPtr(other.get()) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* heldPtr; <span class="comment">// 这个 SmartPtr 持有的内置指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个行为只有当“存在某个隐式转换可将一个<code>U*</code>指针转为一个<code>T*</code>指针”时才能通过编译，而这正是我们想要的。</p><p><code>member function template</code>（成员函数模板）的效用不限于构造函数，<strong>它常扮演的另一个角色是支持赋值操作。</strong>例如<code>std::shared_ptr</code>同时支持所有“来自兼容之内置指针、<code>std::shared_ptr</code>、<code>std::weak_ptr</code>”的构造行为以及赋值操作（<code>std::weak_ptr</code>除外）。赋值操作符和<code>copy</code>构造函数实现类似，故省略。</p><ul><li>如果你声明<code>member template</code>用于“泛化<code>copy</code>构造”或“泛化<code>assignment</code>操作”你还是需要声明正常的<code>copy</code>构造函数和<code>copy assignment</code>操作符</li></ul><p>条款<code>5</code>说过，编译器可能为我们产生四个成员函数，其中两个是<code>copy</code>构造函数和<code>copy assignment</code>操作符。现在，<code>SmartPtr</code>声明了一个泛化<code>copy</code>构造函数，而显然一旦类型<code>T</code>和<code>U</code>相同，泛化<code>copy</code>构造函数会被具现化为“正常的”<code>copy</code>构造函数。那么究竟编译器会暗自为<code>SmartPtr</code>生成一个<code>copy</code>构造函数呢？或当某个<code>SmartPtr</code>对象根据另一个同型的<code>SmartPtr</code>对象展开构造行为时，编译器会将“泛化copy构造函数模板”具现化呢？</p><p><code>member template</code>并不改变语言规则：“如果程序需要一个<code>copy</code>构造函数，你却没有声明它，编译器会为你暗自生成一个”。在<code>class</code>内声明泛化<code>copy</code>构造函数（是个<code>member template</code>）并不会阻止编译器生成它们自己的<code>copy</code>构造函数（一个<code>non-template</code>），所以如果你想要控制<code>copy</code>构造的方方面面，你必须同时声明泛化<code>copy</code>构造函数和“正常的”<code>copy</code>构造函数。相同规则也适用于赋值操作。</p><h5 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款<code>46</code>：需要类型转换时请为模板定义非成员函数</h5><p>条款<code>24</code>讨论过为什么惟有<code>non-member</code>函数才有能力“在所有实参身上实施隐式类型转换”，该条款并以<code>Rational class</code>的<code>operator*</code>函数为例。本条款将<code>Rational</code>和<code>operator*</code>模板化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 条款 20 告诉你为什么参数以 passed by reference 方式传递</span></span><br><span class="line">Rational(<span class="keyword">const</span> T&amp; numerator = <span class="number">0</span>, <span class="keyword">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 条款 28 告诉你为啥返回值以 passed by value 方式传递</span></span><br><span class="line"><span class="comment">// 条款 3 告诉你为啥它们是 const</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像条款<code>24</code>一样，我们也希望支持混合式算术运算，然而以下代码却不能通过编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;int&gt; oneHalf(1, 2);</span><br><span class="line">Rational&lt;int&gt; result &#x3D; oneHalf * 2; &#x2F;&#x2F; 错误!无法通过编译</span><br></pre></td></tr></table></figure><p>在这里，编译器不知道我们想要调用哪个函数！它们试图找到什么函数被名为<code>operator*</code>的<code>template</code>具现化出来。它们知道它们应该可以具现化某个“名为<code>operator*</code>并接受两个<code>Rational&lt;T&gt;</code>参数”的函数，但为完成这一具现化行动，必须先算出<code>T</code>是什么。</p><p>为了推导<code>T</code>，它们看了看<code>operator*</code>调用动作中的实参类型。分别是<code>Rational&lt;int&gt;</code>（<code>oneHalf</code>的类型）和<code>int</code>（<code>2</code>的类型）。</p><p>以<code>oneHalf</code>进行推导，过程并不困难。第二参数的推导则没有这么顺利。<code>operator*</code>的第二参数被声明为<code>Rational&lt;T&gt;</code>，但传递给<code>operator*</code>的类型是<code>int</code>（<code>2</code>）。编译器如何根据这个<code>2</code>推算出<code>T</code>？你或许会期盼编译器使用<code>Rational&lt;int&gt;</code>的<code>non-explicit</code>构造函数将转换为<code>Rational&lt;int&gt;</code>，进而将<code>T</code>推导为<code>int</code>，然而<strong><code>template</code>实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。</strong></p><p><code>template class</code>内的<code>friend</code>声明式可以指涉某个特定函数。这意味<code>class Rational&lt;T&gt;</code>可以声明<code>operator*</code>是它的一个<code>friend</code>函数。<code>class template</code>并不倚赖<code>template</code>实参推导，所以编译器总是能够在<code>class Rational&lt;T&gt;</code>具现化时得知<code>T</code>。因此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>，<code>class Rational&lt;int&gt;</code>于是被具现化出来，而作为过程的一部分，<code>friend</code>函数<code>operator*</code>（接受<code>Rational&lt;int&gt;</code>参数）也就被自动声明出来。后者身为一个函数而非<code>function template</code>，因此编译器可在调用它时使用隐式转换函数（例如调用<code>Rational</code>的<code>non-explicit</code>构造函数）。                                                        </p><p>但是，虽然这段代码通过编译，却无法连接。</p><p>因为这个友元函数只被声明于<code>Rational</code>内，并没有被定义出来。我们意图令此<code>class</code>外部的<code>operator* template</code>提供定义式，是行不通的。既然我们没有提供定义式，连接器当然找不到它！</p><p>最简单的方法就是，将函数本体放进<code>class</code>内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                        lhs.denominator() * rhs.denominator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了让类型转换可能发生于所有实参身上，我们需要一个<code>non-member</code>函数（条款<code>24</code>）；为了令这个函数被自动具现化，我们需要将它声明在<code>class</code>内部；而在class内部声明<code>non-member</code>函数的唯一办法就是：令它成为一个<code>friend</code>。因此我们就这样做了。</p><ul><li><p>当此<code>friend</code>函数过于复杂时，令其调用类外的辅助函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rational</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp;rhs)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Rational&lt;T&gt;(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                       lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt;<span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                                <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> doMultiply(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  作为一个<code>template</code>，<code>doMultiply</code>当然不支持混合式乘法，但它其实也不需要。它只被<code>operator*</code>调用，而<code>operator*</code>支持混合式操作。</p></li></ul><h5 id="条款47：traits-classes表现类型信息"><a href="#条款47：traits-classes表现类型信息" class="headerlink" title="条款47：traits classes表现类型信息"></a>条款<code>47</code>：<code>traits classes</code>表现类型信息</h5><p><code>STL</code>迭代器分类：</p><ol><li><p><code>input</code>迭代器</p><p> 只能向前移动，一次一步，用户只能读取它所指的东西，而且只能读取一次，读完立即自动向前一步。程序库中的输入流迭代器<code>istream_iterator</code>就属于这一类。</p></li><li><p><code>output</code>迭代器</p><p> 只能向前移动，一次一步，用户只能涂写它所指的东西，而且只能涂写一次，写完立即自动向前一步。程序库中的输出流迭代器<code>ostream_iterator</code>就属于这一类。</p></li><li><p><code>forward</code>迭代器</p><p> 可以做上述两种迭代器做的事情，而且支持多次读写，读写完由用户自行决定是否前进。单向链表<code>slist</code>提供的迭代器就属于这一类。</p></li><li><p><code>bidirectional</code>迭代器</p><p> 除了能做<code>forward</code>迭代器做的事情，还可以向后移动。双向链表<code>list</code>以及<code>set</code>，<code>mutilset</code>，<code>map</code>，<code>mutilmap</code>提供的迭代器属于这一类。</p></li><li><p><code>random access</code>迭代器</p><p> 功能类似于内置指针，可以进行算数操作。<code>vector</code>，<code>deque</code>和<code>string</code>提供的迭代器属于这一类。</p></li><li><p><em>迭代器适配器</em></p><ul><li><em><code>reverse</code>迭代器</em></li><li><em><code>insert</code>迭代器</em><ul><li><em><code>back inserter</code></em></li><li><em><code>front inserter</code></em></li><li><em><code>general inserter</code></em></li></ul></li><li><em><code>stream</code>迭代器</em></li><li><em><code>move</code>迭代器</em></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional</span> <span class="title">iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这些<code>struct</code>之间的继承关系是有效的<code>is-a</code>关系：所有<code>forward</code>迭代器都是<code>input</code>迭代器，依此类推。</p><p>关于<code>iterator_trait</code>的实现技术（参考书籍<code>P227-P232</code>）</p><h5 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款<code>48</code>：认识<code>template</code>元编程</h5><ul><li>如题，以后买本书再专门去学吧！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第六章</title>
      <link href="/5pPP61A5gGyfCrjb/"/>
      <url>/5pPP61A5gGyfCrjb/</url>
      
        <content type="html"><![CDATA[<h4 id="第6章：继承与面向对象设计"><a href="#第6章：继承与面向对象设计" class="headerlink" title="第6章：继承与面向对象设计"></a>第<code>6</code>章：继承与面向对象设计</h4><h5 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款<code>32</code>：确定你的<code>public</code>继承塑模出<code>is-a</code>关系</h5><ul><li>“<code>public</code>继承”意味<code>is-a</code>。适用于<code>base class</code>身上的每一件事情一定也适用于<code>derived class</code>身上，因为每一个<code>derived class</code>对象也都是一个<code>base class</code>对象</li></ul><a id="more"></a><h5 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款<code>33</code>：避免遮掩继承而来的名称</h5><ul><li><p><code>derived class</code>的作用域被嵌套在<code>base class</code>作用域内</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); <span class="comment">// 没问题, 调用 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 错误! 因为 Derived::mf1 遮掩了 Base::mf1</span></span><br><span class="line">d.mf2(); <span class="comment">// 没问题, 调用 Derived::mf2</span></span><br><span class="line">d.mf2(x); <span class="comment">// 错误! 因为 Derived::mf2 遮掩了 Base::mf2</span></span><br></pre></td></tr></table></figure><p>  这段代码中<code>base class</code>内所有名为<code>mf1</code>和<code>mf2</code>的函数都被<code>derived class</code>内的<code>mf1</code>和<code>mf2</code>函数遮掩掉了。从名称查找观点来看，<code>Base::mf1</code>和<code>Base::mf2</code>不再被<code>Derived</code>继承！</p><p>  实际上如果你正在使用<code>public</code>继承而又不继承那些重载函数，就是违反<code>base</code>和<code>derived class</code>之间的<code>is-a</code>关系，而条款<code>32</code>说过<code>is-a</code>是<code>public</code>继承的基石。因此你几乎总会想要推翻<code>C++</code>对“继承而来的名称”的缺省遮掩行为。</p><ul><li><p>使用<code>using</code>声明式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::mf1; <span class="comment">// 让 Base class 内名为 mf1 和 mf2 的所有东西</span></span><br><span class="line"><span class="keyword">using</span> Base::mf2; <span class="comment">// 在 Derived 作用域内都可见, 并且 public</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); <span class="comment">// 没问题, 调用 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 现在没问题了, 调用 Based::mf1</span></span><br><span class="line">d.mf2(); <span class="comment">// 没问题, 调用 Derived::mf2</span></span><br><span class="line">d.mf2(x); <span class="comment">// 现在没问题了, 调用 Based::mf2</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>inline</code>转交函数（<code>forwarding function</code>）</p><p>  然而在<code>private</code>继承之下（见条款<code>39</code>），有时候你并不想继承<code>base class</code>的所有函数。假设<code>Derived</code>以<code>private</code>形式继承<code>Base</code>，而<code>Derived</code>唯一想继承的<code>mf1</code>是那个无参数版本。<code>using</code>声明式在这里派不上用场，因为<code>using</code>声明式会令继承而来的某给定名称之所有同名函数在<code>derived class</code>中都可见。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">... <span class="comment">// 与前同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="comment">// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::mf1(); <span class="comment">// 暗自成为 inline (见条款 30)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">d.mf1(); <span class="comment">// 很好, 调用的是 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 错误! Base::mf1 被遮掩</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款<code>34</code>：区分接口继承和实现继承</h5><p>身为<code>class</code>设计者，有时候你会希望<code>derived class</code>只继承成员函数的接口，也就是声明；有时候你又会希望<code>derived class</code>同时继承函数的接口和实现，但又希望能够覆写（<code>override</code>）它们所继承的实现；又有时候你希望<code>derived class</code>同时继承函数的接口和实现，并且不允许覆写任何东西。</p><p><code>base</code>类强烈影响以<code>public</code>形式继承它的<code>derived class</code>，因为：</p><ul><li><p>成员函数的接口总是会被继承</p></li><li><p>声明一个<code>pure virtual</code>函数的目的是为了让<code>derived</code>类只继承函数接口</p><p>  含有<code>pure virtual</code>函数的类属于抽象基类，不能被实例化。继承了它们的类必须重新声明此函数接口并给予实现。抽象基类可以给<code>pure virtual</code>函数提供定义，但调用它的唯一途径是“调用时指定其<code>class</code>的名称”。</p></li><li><p>声明<code>impure</code>函数的目的是让<code>derived class</code>继承该函数的接口和缺省实现</p><p>  但是，允许<code>impure virtual</code>函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑<code>XYZ</code>航空公司设计的飞机继承体系。该公司只有<code>A</code>型和<code>B</code>型两种飞机，两者都以相同方式飞行。因此<code>XYZ</code>设计出这样的继承体系：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span> &#123;</span>...&#125;; <span class="comment">// 用以表现机场</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省代码, 将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>  为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的<code>fly</code>实现”，<code>Airplane::fly</code>被声明为<code>virtual</code>。然而为了避免在<code>ModelA</code>和<code>ModelB</code>中撰写相同代码，缺省飞行行为由<code>Airplane::fly</code>提供，它同时被<code>ModelA</code>和<code>ModelB</code>继承。</p><p>  现在，<code>XYZ</code>航空公司决定购买一种新式<code>C</code>型飞机。<code>C</code>型和<code>A</code>型以及<code>B</code>型的飞行方式不同。<code>XYZ</code>公司的程序员在继承体系中针对<code>C</code>型飞机添加了一个<code>class</code>，但由于他们急着让新飞机上线服务，竟忘了重新定义其<code>fly</code>函数：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 未声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Airport <span class="title">PDX</span><span class="params">(... )</span></span>; <span class="comment">// PDX 是我家附近的机场</span></span><br><span class="line">Airplane* pa= <span class="keyword">new</span> ModelC;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这将酿成大灾难</span></span><br><span class="line">pa-&gt;fly(PDX); <span class="comment">// 调用 Airplane::fly</span></span><br></pre></td></tr></table></figure><p>  一种解救办法为切断“<code>virtual</code>函数接口”和其“缺省实现”之间的连接。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 现在是 pure virtual 函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span> <span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">... <span class="comment">// 缺省行为, 将飞机飞至指定的目的地。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        defaultFly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        defaultFly (destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 ModelC class 不可能意外继承不正确的 fly 实现代码了</span></span><br><span class="line"><span class="comment">// 因为 Airplane 中的 pure virtual 函数追使 ModelC 必须提供自己的 f1y 版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">... <span class="comment">// 将 C 型飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  另一种解救方法是，利用“<code>pure virtual</code>函数必须在<code>derived class</code>中重新声明，但它们也可以拥有自己的实现”这一事实。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 现在是 pure virtual 函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给予 pure virtual 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省行为, 将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Airplane::fly(destination); <span class="comment">// 通过指定其类名调用它</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">virtuai <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Airplane::fly(destination); <span class="comment">// 通过指定其类名调用它</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">... <span class="comment">// 将 C 型飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明<code>non-virtual</code>函数的目的是为了<code>derived class</code>继承函数的接口及其强制性实现</p><p>  <code>non-virtual</code>函数为其所属<code>class</code>建立的意义是不变性凌驾其特异性，所以它不该在<code>derived class</code>中被重新定义。</p></li></ul><h5 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款<code>35</code>：考虑<code>virtual</code>函数以外的其他选择</h5><p>假设你正在写一个视频游戏软件，你的游戏属于暴力砍杀类型，剧中人物存在被伤害而降低健康状态的情况。因此你决定提供一个成员函数 <code>healthvalue</code>，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将<code>healthvalue</code>声明为<code>virtual</code>似乎是再明白不过的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 返回人物的健康指数,</span></span><br><span class="line"><span class="comment">// derived classes 可重新定义它</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在考虑一些其它解法：</p><ul><li><p>借助<code>non-virtual interface</code>(<code>NVI</code>)手法实现<code>Template Method</code>模式</p><p>  保留<code>healthvalue</code>为<code>public</code>成员函数，但让它成为<code>non-virtual</code>，并调用一个<code>private virtual</code>函数进行实际工作：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// derived class 不重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 做一些事前工作</span></span><br><span class="line"><span class="keyword">int</span> retval = doHealthvalue(); <span class="comment">// 做真正的工作</span></span><br><span class="line">... <span class="comment">// 做一些事后工作</span></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NVI 手法下没必要让 virtual 函数一定是 private</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// derived class 可重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省算法, 计算健康指数。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这一基本设计，“令客户通过<code>public non-virtual</code>成员函数间接调用<code>private virtual</code>函数”，称为<code>non-virtual interface</code>(<code>NVI</code>)手法。它是所谓<code>Template Method</code>设计模式的一个独特表现形式。我把这个<code>non-virtual</code>函数（<code>healthvalue</code>）称为<code>virtual</code>函数的外覆器（<code>wrapper</code>) 。</p><p>  <code>NVI</code>手法的一个优点隐藏在上述代码注释“做一些事前工作”和“做一些事后工作”之中。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证 <code>class</code>约束条件、验证函数先决条件等。“事后工作”可以包括互斥器解除锁定、验证函数的事后条件、再次验证<code>class</code>约束条件等。如果你让客户直接调用<code>virtual</code>函数，就没有任何好办法可以做这些事。</p></li><li><p>借助<code>Function Pointer</code>实现<code>Strategy</code>模式</p><p>  另一个设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个函数指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"><span class="comment">// 以下函数是计算健康指数的缺省算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span> <span class="params">(HealthCalcFunc hcf = defaultFealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">healthFunc</span><span class="params">(hcf)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这种设计策略和前面介绍的方法相比提供了一些有趣的弹性：</p><ul><li><p>同一人物类型的不同实体可以有不同的健康计算函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span> :</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">GameCharacter</span><span class="params">(hcf)</span> </span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 健康指数计算函数 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 健康指数计算函数 2</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>; <span class="comment">// 相同类型的人物搭配</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>; <span class="comment">// 不同的健康计算方式</span></span><br></pre></td></tr></table></figure></li><li><p>某已知人物之健康指数计算函数可在运行期变更</p><p>  例如<code>GameCharacter</code>可提供一个成员函数<code>setHealthcalculator</code>，用来替换当前的健康指数计算函数。</p><p>然而这种策略意味着，计算函数并不能访问“被计算健康指数的”那个对象的内部（<code>non-public</code>）成分。如果需要访问<code>non-public</code>成分进行精确计算，这就有问题了。</p><p>唯一能够解决的办法就是：弱化<code>class</code>的封装。例如，将健康计算函数声明为<code>friend</code>。或是为其实现的某一部分提供<code>public</code>访问函数。这需要你来权衡利弊进行抉择。</p></li></ul></li><li><p>借助<code>std::function</code>实现<code>Strategy</code>模式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不同之处</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span> <span class="params">(HealthCalcFunc hcf = defaultFealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">healthFunc</span><span class="params">(hcf)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  那个签名代表的函数是“接受一个<code>reference</code>指向<code>const GameCharacter</code>，并返回<code>int</code>”。这个<code>std::function</code>类型（也就是我们所定义的<code>HealthCalcFunc</code>类型）产生的对象可以持有（保存）任何与此签名式<strong>兼容的</strong>可调用物。所谓兼容，意思是这个可调用物的参数可被<strong>隐式转换</strong>为<code>const GameCharacter&amp;</code>，而其返回类型可被<strong>隐式转换</strong>为<code>int</code>。</p><p>  这就提供了很大的灵活性：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">short <span class="title">calcHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// 健康计算函数</span></span><br><span class="line">                                        <span class="comment">// 注意其返回类型为 non-int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HealthCalculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 为计算健康而设计的函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameLevel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">health</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span>;<span class="comment">// 成员函数, 用以计算健康</span></span><br><span class="line">    <span class="comment">// 注意其 non-int 返回类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物类型 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span>:</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">... <span class="comment">// 同前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物类型 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EyeCandyCharacter</span>:</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 假设其构造函数与 EvilBadGuy 同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物 1, 使用某个函数计算健康指数</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物 2, 使用某个函数对象计算健康指数</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator())</span></span>;</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 人物 3, 使用某个成员函数计算健康指数</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(<span class="built_in">std</span>::bind(&amp;GameLevel::health, &amp;currentLevel, _1))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>传统的<code>Strategy</code>模式</p><p>  <img src="strategy.png" alt=""></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~HealthCalcFunc() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlowHealthLoser</span> :</span> HealthCalcFunc</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastHealthLoser</span> :</span> HealthCalcFunc</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf)</span> : <span class="title">pHealthCalc</span><span class="params">(phcf)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc-&gt;calc(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款<code>36</code>：绝不重新定义继承而来的<code>non-virtual</code>函数</h5><ul><li>如题</li></ul><h5 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款<code>37</code>：绝不重新定义继承而来的缺省参数值</h5><p>本条款的讨论局限于“继承一个带有缺省参数值的<code>virtual</code>函数”：<code>virtual</code>函数是动态绑定（后期绑定，延迟绑定），而缺省参数值却是静态绑定（前期绑定，早绑定）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个用以描述几何形状的class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> ShapeColor&#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="comment">// 所有形状都必须提供一个函数, 用来绘出自己</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 注意, 赋予不同的缺省参数值, 这真糟糕!</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// 请注意，以上这么写则当客户以 对象 调用此函数一定要指定参数值</span></span><br><span class="line">    <span class="comment">// 因为静态绑定下这个函数并不从其 base 继承缺省参数值</span></span><br><span class="line">    <span class="comment">// 但若以指针或 reference 调用此函数, 可以不指定参数值</span></span><br><span class="line">    <span class="comment">// 因为动态绑定下这个函数会从其 base 继承缺省参数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>对象的静态类型就是它在程序中所声明的类型，对象的动态类型则是指“目前所指对象的类型”</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shape* ps; <span class="comment">// 静态类型为 shape*, 无动态类型</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle; <span class="comment">// 静态类型为 Shape*, 动态类型是 Circle*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle; <span class="comment">// 静态类型为 shape*, 动态类型是 Rectangle*</span></span><br></pre></td></tr></table></figure><p>  动态类型可在程序执行过程中改变（通常是经由赋值动作）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = pc; <span class="comment">// ps 的动态类型如今是 circle*</span></span><br><span class="line">ps = pr; <span class="comment">// ps 的动态类型如今是 Rectangle*</span></span><br></pre></td></tr></table></figure></li></ul><p><code>virtual</code>函数系动态绑定而来，意思是调用一个<code>virtual</code>函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pr-&gt;draw(); <span class="comment">// 调用的是 Rectangle::draw(shape::Red)!</span></span><br><span class="line"><span class="comment">// 注意缺省参数是 Red 而不是 Green</span></span><br></pre></td></tr></table></figure><p>此例之中，<code>pr</code>的动态类型是<code>Rectangle*</code>，所以调用的是<code>Rectangle</code>的<code>virtual</code>函数。<code>Rectangle::draw</code>函数的缺省参数值应该是<code>Green</code>，但由于<code>pr</code>的静态类型是<code>shape*</code>，所以此一调用的缺省参数值来自<code>Shape class</code>而非<code>Rectangle class</code>！这不符合预期。</p><p>解救方法是利用条款<code>35</code>中介绍的<code>NVI</code>手法替代<code>virtual</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> shapeColor&#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span><span class="comment">// 如今它是 non-virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">doDraw(color); <span class="comment">// 调用一个 virtual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 真正的工作在此处完成</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span> <span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>; <span class="comment">// 注意, 不须指定缺省参数值</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个设计很清楚地使得<code>draw</code>函数的<code>color</code>缺省参数值总是<code>Red</code>。</p><h5 id="条款38：通过复合塑模出has-a或is-implemented-in-terms-of"><a href="#条款38：通过复合塑模出has-a或is-implemented-in-terms-of" class="headerlink" title="条款38：通过复合塑模出has-a或is-implemented-in-terms-of"></a>条款<code>38</code>：通过复合塑模出<code>has-a</code>或<code>is-implemented-in-terms-of</code></h5><p>当某种类型的对象内含其它对象时便形成了复合关系。</p><ul><li><p>应用域</p><p>  程序中的对象其实相当于你所塑造出来的世界中的某些事物。比如人，汽车，高楼大厦等。这样的对象属于应用域部分。</p></li><li><p>实现域</p><p>  其它对象如缓冲区，互斥器，搜索树等纯粹是实现细节上的工具。这些对象相当于软件中的实现域。</p></li></ul><p>当复合发生于应用域对象之间表现出<code>has-a</code>关系，当它发生于实现域内则表现出<code>is-implemented-in-terms-of</code>（根据某物实现出）的关系。</p><ul><li><p>复合的意义和<code>public</code>继承完全不同</p><p>  注意区分<code>is-a</code>和<code>is-implemented-in-terms-of</code>这两种对象关系。</p></li></ul><h5 id="条款39：明智而谨慎地使用private继承"><a href="#条款39：明智而谨慎地使用private继承" class="headerlink" title="条款39：明智而谨慎地使用private继承"></a>条款<code>39</code>：明智而谨慎地使用<code>private</code>继承</h5><p>一个<code>derived</code>类继承<code>base</code>类有<code>public</code>、<code>protected</code>或<code>private</code>三种继承方式。</p><ul><li><p>公有继承（<code>public</code>）（普遍使用）</p><p>  <code>base</code>类的<code>public</code>成员也是<code>derived</code>类的<code>public</code>成员，<code>base</code>类的<code>protected</code>成员也是<code>derived</code>类的<code>protected</code>成员</p></li><li><p>保护继承（<code>protected</code>）（基本不使用）</p><p>  <code>base</code>类的<code>public</code>和<code>protected</code>成员将成为<code>derived</code>类的<code>protected</code>成员。</p></li><li><p>私有继承（<code>private</code>）（少的情况使用）</p><p>  <code>base</code>类的<code>public</code>和<code>protected</code>成员将成为<code>derived</code>类的<code>private</code>成员。</p></li></ul><p>无论哪一种继承方式，<code>base</code>类的<code>private</code>成员都不能直接被<code>derived</code>类访问，但是可以通过调用<code>base</code>类的<code>public</code>和<code>protected</code>成员间接来访问（如果<code>base</code>类提供了访问接口的话）。</p><ul><li><p><code>private</code>继承意味着<code>is-implemented-in-terms-of</code></p><p>  <code>private</code>继承只限于软件实现层面，这就是为什么<code>private</code>继承后，<code>base class</code>的所有成分（除了<code>private</code>）在你的<code>class</code>内都是<code>private</code>，因为它们都只是实现细节而已。</p></li><li><p>尽可能使用复合，<strong>必要时</strong>才使用<code>private</code>继承</p><ol><li><p>当<code>derived</code>类想要访问<code>base class</code>的<code>protected</code>成员时</p></li><li><p>当<code>derived</code>类为了重新定义<code>base class</code>的<code>virtual</code>函数时</p><p> 现在考虑一个<code>Widget</code>类，它需要用到另一个计时器<code>Timer</code>类来实现一些业务。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> tickFrequecy)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 定时器每滴答一次, 此函数就调用一次</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p> 为了让<code>Widget</code>重新定义<code>Timer</code>内的<code>virtual</code>函数，<code>Widget</code>必须继承自<code>Timer</code>。因为<code>Widget</code>不是个<code>Timer</code>，因此<code>public</code>继承不合适。必须以<code>private</code>方式继承：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 通过<code>private</code>继承，<code>Timer</code>的<code>public onTick</code>函数在<code>Widget</code>内变成<code>private</code>，而我们重新声明（定义）时仍然把它留在那儿。如果把<code>onTick</code>放进<code>public</code>内会误导客户以为他们可以调用它，那就违反了条款<code>18</code>。</p><p> 另一种设计方案是采用复合 + <code>public</code>继承：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在 Widget 内声明一个嵌套式 private class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetTimer</span> :</span> <span class="keyword">public</span> Timer</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 以 public 方式继承并重新定义 virtual 函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">WidgetTimer timer;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 采用第二种较为复杂的方式的两点理由：</p><ul><li>你或许会想设计<code>Widget</code>使它得以拥有<code>derived class</code>，但同时你可能会想阻止<code>derived class</code>重新定义<code>onTick</code>。如果<code>Widget</code>继承自<code>Timer</code>，上面的想法就不可能实现，即使是<code>private</code>继承也不可能。但如果<code>WidgetTimer</code>是<code>Widget</code>内部的一个<code>private</code>成员并继承自<code>Timer</code>，<code>Widget</code>的<code>derived class</code>将无法取用<code>WidgetTimer</code>，因此无法继承它或重新定义它的<code>virtual</code>函数。</li><li>你或许会想要将<code>Widget</code>的编译依存性降至最低（条款<code>31</code>）。如果<code>Widget</code>继承<code>Timer</code>，当<code>Widget</code>被编译时<code>Timer</code>的定义必须可见，所以定义<code>Widget</code>的那个文件恐怕必须<code>#include Timer.h</code>。但如果<code>WidgetTimer</code>移出<code>Widget</code>所在文件之外而<code>Widget</code>内含指针指向一个<code>WidgetTimer</code>，<code>Widget</code>可以只带着一个简单的<code>WidgetTimer</code>前向声明式，不再需要<code>#include</code>任何与<code>Timer</code>有关的东西。很容易就实现了解耦。</li></ul></li><li><p><code>EBO</code>（<code>empty base optimization</code>）</p><p> <code>empty class</code>指的是没有<code>non-static</code>成员变量，没有<code>virtual</code>函数，也没有<code>virtual base class</code>。于是这种<code>class</code>不占用理论上不占用任何内存空间。然而在实现技术上，<code>C++</code>要求<strong>独立（非附属）对象</strong>都必须有非零大小。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;; <span class="comment">// 没有任何需要存储的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论上 sizeof(HoldAnInt) = 4 字节(就一个 int)</span></span><br><span class="line"><span class="comment">// 实际上 sizeof(HoldAnInt) = 8 字节</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 字节</span></span><br><span class="line">    Empty e; <span class="comment">// 理论上应该不占据内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>C++</code>编译器默认为<code>empty class</code><strong>独立对象</strong>安插一个<code>char</code>（<code>1</code>字节）</p></li><li><p>由于内存对齐<code>HoldAnInt</code>的实际大小为<code>4 + 1(内存对齐至 4) = 8</code></p><p>但这个约束不适用于<code>derived class</code>对象的<code>base class</code>成分（非独立）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论和实际上 sizeof(HoldAnInt) = 4 字节(就一个 int)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span> :</span> <span class="keyword">public</span> Empty</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现实中的<code>empty class</code>并非真是<code>empty</code>。往往内含<code>typedef</code>，<code>enum</code>，<code>static</code>成员变量，或<code>non-virtual</code>函数。<code>STL</code>就有许多技术用途的<code>empty class</code>，其中内含有用的成员（通常是<code>typedef</code>），包括<code>base class unary_function</code>和<code>binary_function</code>，这些是“用户自定义之函数对象”通常会继承的<code>class</code>。由于<code>EBO</code>，这样的继承很少增加<code>derived class</code>的大小。</p></li></ul></li></ol></li></ul><h5 id="条款40：明智而谨慎地使用多重继承"><a href="#条款40：明智而谨慎地使用多重继承" class="headerlink" title="条款40：明智而谨慎地使用多重继承"></a>条款<code>40</code>：明智而谨慎地使用多重继承</h5><ul><li><p>多重继承较单一继承复杂，可能导致歧义性</p><p>  当继承的多个<code>base</code>具有同名成员函数时，<code>derived</code>类调用时会出现歧义。</p></li><li><p>有时多重继承不得不需要<code>virtual</code>继承，而这会带来额外的体积、运行速度、初始化复杂度等成本</p><p>  比如这样的钻石继承体系：</p><p>  <img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.png" alt=""></p><p>  这个继承体系中某个<code>base class</code>和某个<code>derived class</code>之间有一条以上的相通路线，假设<code>File class</code>有个成员变量<code>fileName</code>，那么<code>IOFile</code>从每一个<code>base class</code>各继承一份，所以其对象内会有两份<code>fileName</code>成员变量。然而<code>IOFile</code>对象只该有一个文件名称，所以名称<code>fileName</code>不该重复。</p><p>  解决办法就是采用<code>virtual</code>继承：</p><p>  <img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BFvirtual%E7%BB%A7%E6%89%BF.png" alt=""></p><p>  <code>virtual</code>继承带来的后果是：</p><ul><li><p>使用<code>virtual</code>继承的那些<code>class</code>所产生的对象往往比使用<code>non-virtual</code>继承的<code>class</code>体积大</p></li><li><p>访问<code>virtual base class</code>的成员变量时，也比访问<code>non-virtual base class</code>的成员变量速度慢</p></li><li><p>另外，支配“<code>virtual base class</code>初始化”的规则比起<code>non-virtual base class</code>的情况远为复杂且不直观。<code>virtual base class</code>的初始化责任是由继承体系中的最低层（<code>most derived</code>）<code>class</code>负责的，这意味着：</p><ol><li><code>class</code>若派生自<code>virtual base</code>而需要初始化，必须知道其<code>virtual base class</code>——不论那些<code>base class</code>距离多远。</li><li>当一个新的<code>derived class</code>加入继承体系中，它必须承担其<code>virtual base class</code>的初始化责任。</li></ol><p>关于<code>virtual</code>继承的忠告：</p></li></ul><ol><li>非必要不使用<code>virtual base</code>。平常请使用<code>non-virtual</code>继承。</li><li>如果必须使用<code>virtual base class</code>，尽可能避免在其中放置数据。这么一来你就不需担心这些<code>class</code>身上的初始化（和赋值）所带来的诡异事情了。</li></ol></li></ul><p>最后看一个多重继承的应用例子——<code>public</code>继承某个<code>Interface class</code>和<code>private</code>继承某个协助实现的<code>class</code>。</p><p><img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90.png" alt=""></p><p>（参考书籍<code>P195-P198</code>）</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之概论</title>
      <link href="/eSK55yN7G7dNea2c/"/>
      <url>/eSK55yN7G7dNea2c/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>相互之间存在一种或多种特定关系的数据元素的集合。研究数据结构，关心的是数据对象的描述以及相关操作函数的实现。</p><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如整型、浮点型等数值类型，以及声音、图像等非数值类型。</p><h4 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h4><p>是组成数据的、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。</p><a id="more"></a><h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p>一个数据元素可以由若干个数据项组成。它是数据不可分割的最小单位。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p>是性质相同的数据元素（即有相同的数量和类型的数据项）的集合，是数据的子集。</p><h4 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h4><ul><li><p>线性数据结构：向量<code>vector</code>（顺序存储）、链表<code>list</code>（链式存储）、栈<code>stack</code>和队列<code>queue</code>（优先队列）。</p></li><li><p>半线性数据结构：二叉树、搜索树（二叉搜索树<code>BST</code>、<code>AVL</code>树、<code>B</code>树、红黑树）、竞赛树等。</p></li><li><p>非线性数据结构：图。</p></li><li><p>哈希表<code>hashtable</code>、字典<code>dictionary</code>。</p></li></ul><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><ul><li><p>数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p></li><li><p>抽象数据类型：指一个数学模型及定义在该模型上的一组操作。可以理解为<code>C++</code>中的类<code>class</code>。它体现的是程序设计中问题分解、抽象和信息隐藏的特性。</p></li></ul><h4 id="抽象数据类型的标准格式"><a href="#抽象数据类型的标准格式" class="headerlink" title="抽象数据类型的标准格式"></a>抽象数据类型的标准格式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">操作<span class="number">1</span></span><br><span class="line">操作<span class="number">2</span></span><br><span class="line">...</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是解决指定问题求解步骤的描述。在计算机中是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。</p><h4 id="计算或信息处理"><a href="#计算或信息处理" class="headerlink" title="计算或信息处理"></a>计算或信息处理</h4><p>指借助某种工具，按照一定的规则，以明确而机械的形式进行。</p><p>算法中的计算模型就是计算机，即信息处理工具。</p><h4 id="算法必须具备的几大要素"><a href="#算法必须具备的几大要素" class="headerlink" title="算法必须具备的几大要素"></a>算法必须具备的几大要素</h4><ol><li>输入：待处理的信息或问题。</li><li>输出：经处理的信息，即答案。</li><li>正确性：的确可以解决指定的问题。</li><li>确定性：任何一个算法都可以描述为一个由基本操作组成的序列。</li><li>可行性：每一基本操作都可实现，且能在常数时间内完成。</li><li>有穷性：对于任何输入，经有限次的基本操作，都可以得到输出。</li></ol><h4 id="一个好的算法"><a href="#一个好的算法" class="headerlink" title="一个好的算法"></a>一个好的算法</h4><ol><li><p>正确，即符合语法，能够编译、链接。</p><blockquote><p>能够正确处理<strong>简单的</strong>、<strong>大规模的</strong>、<strong>一般性的</strong>、<strong>退化的</strong>、<strong>任意合法</strong>的输入。</p></blockquote></li><li><p>健壮，能够辨别不合法的输入并做适当处理，而不致非正常退出。</p></li><li><p>可读，结构化 <code>+</code> 准确命名 <code>+</code> 注释 <code>+</code> …。</p></li><li><p>效率，运行速度尽可能快，用到的存储空间尽可能少。</p></li></ol><h4 id="常见的算法"><a href="#常见的算法" class="headerlink" title="常见的算法"></a>常见的算法</h4><ol><li><p>查找</p><p> 顺序查找、二分查找、插值查找、斐波那契查找、分块查找和哈希查找等。</p></li><li><p>排序</p><p> 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序和希尔排序等。</p></li><li><p>递归、分而治之、动态规划、回溯法和分支定界法等。</p></li></ol><p>要对数据结构和算法设计方法给予评价，就必须能够计算程序性能。</p><h4 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h4><ul><li><p>数据结构(<code>data structures</code>) + 算法(<code>algorithms</code>) = 程序(<code>programs</code>)</p></li><li><p><code>(data structures + algorithms) x efficiency = computation</code></p></li></ul><h3 id="程序性能分析"><a href="#程序性能分析" class="headerlink" title="程序性能分析"></a>程序性能分析</h3><p>是指分析一个程序对于内存空间和运行时间的需求。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>指程序运行时临时占用内存的大小。广义上的概念是包括存储算法本身所占用的空间、算法的输入输出数据所占用的空间以及算法在运行过程中临时占用的存储空间这三个方面。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>指运行程序所需要的时间。这里度量的是程序中基本操作执行的次数，它是问题规模<code>n</code>的函数<code>f(n)</code>。记<code>T(n)=O(f(n))</code>，它表示随问题规模<code>n</code>的增大，算法执行时间的增长率和<code>f(n)</code>相同，称作算法的渐进时间复杂度。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>这里的复杂度分析通常指的是最坏时间复杂度分析。</p><ul><li>常数阶<code>O(1)</code></li></ul><p><img src="image-20200101210400776.png" alt=""></p><p>取前三个元素<code>x = S[0]</code>、<code>y = S[1]</code>和<code>z = S[2]</code>，这一步只需执行三次（从特定单元读取元素的）基本操作，耗费<code>O(3)</code>时间。接下来，为确定这三个元素的大小次序，最多需要做三次比较，也需<code>O(3)</code>时间。最后，输出居中的非极端元素只需<code>O(1)</code>时间。因此，上面取非极端元素算法的时间复杂度为：<br><code>T(n) = O(3) + O(3) + O(1) = O(7) = O(1)</code>。</p><ul><li>对数阶<code>O(logn)</code></li></ul><p><img src="image-20200101210742484.png" alt=""></p><p>根据右移运算的性质，每右移一位，<code>n</code>都至少缩减一半。也就是说，至多经过<code>1 + log2n</code>次循环，<code>n</code>必然缩减至<code>0</code>，从而算法终止。因此时间复杂度为：<code>O(1 + log2n) = O(log2n)</code> 。</p><ul><li>线性阶<code>O(n)</code></li></ul><p><img src="image-20200101211150536.png" alt=""></p><ul><li>平方阶<code>O(n)</code></li></ul><p><img src="image-20200101211909446.png" alt=""></p><p>时间复杂度为：<code>O(2n^2 + n + 1) = O(n^2)</code>。</p><h4 id="常见的算法时间复杂度排序"><a href="#常见的算法时间复杂度排序" class="headerlink" title="常见的算法时间复杂度排序"></a>常见的算法时间复杂度排序</h4><p><code>Ο(1) ＜ Ο(logn) ＜ Ο(n) ＜ Ο(nlogn) ＜ Ο(n^2) ＜ … ＜ Ο(2^n) ＜ Ο(n!)</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第五章</title>
      <link href="/hNsvEFKo8ZJPUeMf/"/>
      <url>/hNsvEFKo8ZJPUeMf/</url>
      
        <content type="html"><![CDATA[<h4 id="第5章：实现"><a href="#第5章：实现" class="headerlink" title="第5章：实现"></a>第<code>5</code>章：实现</h4><h5 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款<code>26</code>：尽可能延后变量定义式的出现时间</h5><ul><li>应该延长变量的定义，直到非得使用它时</li><li>应该延后这份定义，直到能够给它初值实参</li></ul><p>对于循环存在的情况：</p><ul><li><p>做法<code>A</code>：定义于循环外</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    w = 取决于 i 的某个值；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>做法<code>B</code>：定义于循环内</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于 i 的某个值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这两种写法的成本如下：</p><ul><li><p>做法<code>A</code>：<code>1</code>个构造函数 + <code>1</code>个析构函数 + <code>n</code>个赋值操作</p></li><li><p>做法<code>B</code>：<code>n</code>个构造函数 + <code>n</code>个析构函数</p></li><li><p>做法<code>A</code>会造成名称<code>w</code>的作用域比做法<code>B</code>更大</p><p>除非（1）你知道赋值成本比构造 + 析构成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法<code>B</code>。</p></li></ul></li></ul><a id="more"></a><h5 id="条款27：尽量少做转型操作"><a href="#条款27：尽量少做转型操作" class="headerlink" title="条款27：尽量少做转型操作"></a>条款<code>27</code>：尽量少做转型操作</h5><p>旧式<code>C</code>转型：</p><ul><li><code>T(expression)</code></li><li><code>(T)expression</code></li></ul><p>新式<code>C++</code>转型：</p><ul><li><p><code>const_cast&lt;T&gt;(expression)</code></p><p>  用来将对象的常量性（<code>const</code>）转除（只有它能办到）。</p></li><li><p><code>dynamic_cast&lt;T&gt;(expression)</code></p><p>  用来执行安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型。</p></li><li><p><code>reinterpret_cast&lt;T&gt;(expression)</code></p><p>  用来执行低级转型，如将一个<code>pointer to in</code>t 转为一个<code>int</code>。很少使用（在条款<code>50</code>中使用过一次）。</p></li><li><p><code>static_cast&lt;T&gt;(expression)</code></p><p>  用来强迫隐式转换，例如将<code>non-const</code>对象转为<code>const</code>对象，将<code>int</code>转为<code>double</code>，将<code>void*</code>指针转为<code>typed</code>指针，或将<code>pointer to base</code>转为<code>pointer to derived</code>。</p></li></ul><p>任何一种类型转换（无论显式转换还是隐式转换）往往都会令编译器编译出运行期间执行的码。如将<code>int</code>转为<code>double</code>会产生一些代码，因为<code>int</code>的底层表述不同于<code>double</code>的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> z = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">// 隐喻的将 Derived* 转换为 Base*</span></span><br></pre></td></tr></table></figure><p>这种情况下有时候会有一个偏移量在运行期被施行于<code>Derived*</code>身上，用来取得正确的<code>Base*</code>指针值。这个例子表明单一对象可能有一个以上的地址（以<code>Base*</code>指向它时的地址和以<code>Derived*</code>指向它时的地址）。</p><p>假设我们有个<code>base class Window</code>和一个<code>derived class Specialwindow</code>，两者都定义了<code>virtual</code>函数<code>onResize</code>。进一步假设<code>Specialwindow</code>的<code>onResize</code>函数被要求首先调用<code>Window</code>的<code>onResize</code>。下面实际上是错的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span> <span class="params">()</span> </span>&#123;...&#125; <span class="comment">// base onResize实现代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Specialwindow</span>:</span> <span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">// derived onResize 实现代码</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).onResize(); <span class="comment">// 将 *this 转型为 Window,</span></span><br><span class="line"><span class="comment">// 然后调用其 onResize;</span></span><br><span class="line">        <span class="comment">// 这不可行!</span></span><br><span class="line">... <span class="comment">// 这里进行 Specialwindow 专属行为</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“<code>*this</code>对象之<code>base class</code>成分”的<strong>暂时副本</strong>身上的<code>onResize</code>！如果<code>Window::onResize</code>修改了对象内容，当前对象其实没被改动，改动的是副本。然而<code>SpecialWindow::onResize</code>内如果也修改对象，当前对象真的会被改动。这使当前对象进入一种“伤残”状态：其<code>base class</code>成分的更改没有落实，而<code>derived class</code>成分的更改倒是落实了。</p><p>正确的做法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Specialwindow</span>:</span> <span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Window::onResize();<span class="comment">// 调用 Window::onResize 作用于 *this 身上</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code>的实现版本执行速度相当慢，应该在注重效率的代码中保持对<code>dynamic_cast</code>的警觉</li><li>优良的<code>C++</code>代码很少使用转型，我们应该尽可能隔离转型动作，通过将它隐藏在某个函数内，使得客户可以调用该函数而不需要将转型放进他们自己代码内</li><li>宁可使用新式转型，也不要使用旧式转型，前者很容易辨识出来</li></ul><h5 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款<code>28</code>：避免返回<code>handles</code>指向对象内部成分</h5><ul><li><code>handles</code>指指针、引用和迭代器</li><li>成员变量的封装性最多只等于“返回其<code>reference</code>”的函数的访问级别</li><li>如果<code>const</code>成员函数不得不传出去一个<code>reference</code>，则最好将返回类型限定为<code>const</code></li><li>有可能会导致空悬的<code>handles</code>，它的生命期却长于其所指对象</li></ul><h5 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款<code>29</code>：为“异常安全”而努力是值得的</h5><p>当异常被抛出时，带有异常安全性的函数会：</p><ul><li>不泄露任何资源</li><li>不允许数据败坏</li></ul><p>较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也少。异常安全码必须提供以下三个保证之一：</p><ul><li><p>基本承诺</p><p>  如果异常被抛出，程序内的任何事物仍然保证在有效状态（只要那是个合法状态）下，没有任何对象或数据结构会因此而败坏，所有对象处于一种内部前后一致的状态。</p></li><li><p>强烈保证</p><p>  如果异常被抛出，程序状态不改变。</p></li><li><p>不抛掷保证</p><p>  承诺绝不抛出异常，因为它们总能完成原先承诺的功能。</p></li></ul><p>可以实现强烈保证的<code>copy and swap</code>技术：为你打算修改的对象做出<code>copy</code>一份副本，然后在副本身上做一切修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。带所有改变都成功后，再将修改后的副本和原对象<code>swap</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之所以实现为 struct 是因为其 PrettyMenu 的数据封装性</span></span><br><span class="line"><span class="comment">// 已经由 pImpl 是 private 获得了保证</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> &#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PMImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pImpl; <span class="comment">// pimpl idiom 详细描述见条款 31</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"><span class="comment">// 见条款25</span></span><br><span class="line"><span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line"><span class="comment">// 获得mutex的副本数据</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc)); <span class="comment">// 修改副本</span></span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">swap(pImpl, pNew); <span class="comment">// 置换(swap)数据, 释放 mutex</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意，并非所有函数都可实现强烈保证或其具备现实意义。</p></blockquote><p>函数提供的”异常安全保证“通常最高只等于其所调用各个函数提供的”异常安全保证“中的最弱者。</p><h5 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款<code>30</code>：透彻了解<code>inlining</code>的里里外外</h5><p><code>inline</code>函数是指将对此函数的每一个调用都以函数本体替换之。这将导致两种情况：</p><ul><li>目标码增加（显然）</li><li>如果<code>inline</code>函数的体积很小，编译器对“函数本体”所产出的码可能比“函数调用”所产出的码小</li></ul><p><code>inline</code>只是对编译器的一个申请，不是强制命令，也就是说编译器可以拒绝将太过复杂（带有递归或循环）的函数进行<code>inline</code>。通过对函数使用<code>inline</code>关键字属于明确提出申请，将函数定义于类内属于隐喻申请。</p><ul><li><p>将大多数<code>inline</code>限制在小型、被频繁调用的函数身上</p></li><li><p><code>inline</code>函数通常一定被置于头文件内</p><p>  因为大多数构建环境在编译过程中进行<code>inlining</code>，而为了将一个函数调用替换为被调用函数的本体，编译器必须知道那个函数长什么样子。</p></li><li><p>所有对<code>virtual</code>函数的<code>inline</code>申请都会被拒绝（因为对<code>virtual</code>函数的调用在运行期才确定）</p></li></ul><h5 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款<code>31</code>：将文件间的编译依存关系降至最低</h5><ul><li><p>将接口从实现中分离</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> theName; <span class="comment">// 实现细目</span></span><br><span class="line">Date theBirthDate; <span class="comment">// 实现细目</span></span><br><span class="line">Address theAddress; <span class="comment">// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这里的<code>class</code>无法通过编译，因为编译器没有取得其实现代码所用到的<code>class string</code>，<code>Date</code>，<code>Address</code>的定义式，通常应该在<code>Person</code>定义文件的最上方存在<code>include</code>头文件。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"date.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"address.h"</span></span></span><br></pre></td></tr></table></figure><p>  不幸的是，这么一来便是在<code>Person</code>定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其他头文件有任何改变，那么每一个含入<code>Person class</code>的文件就得重新编译，任何使用<code>person class</code>的文件也必须重新编译。这样的连串编译依存关系（<code>cascading compilation dependencies</code>）会对许多项目造成难以形容的灾难。</p></li><li><p><code>Handle classes</code>：<code>pimpl idiom</code>(<code>pointer to implenmentation</code>) + 前向声明</p><p>  把<code>Person</code>分割成两个<code>class</code>，一个只提供接口，另一个负责实现接口。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //标准程序库组件不该被前向声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向声明而不是包含头文件, 这个很关键</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span> <span class="comment">// Person 实现类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 接口用到的 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl; <span class="comment">// 指针, 指向实现物</span></span><br><span class="line">    <span class="comment">// 如果不这样做的话, 编译器在编译 Person 类的时候，必须知道 Person 类的大小</span></span><br><span class="line">    <span class="comment">// 就不得不包含这三个实现细目</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    string theName; // 实现细目</span></span><br><span class="line"><span class="comment">Date theBirthDate; // 实现细目</span></span><br><span class="line"><span class="comment">Address theAddress; // 实现细目</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 然而一旦这样写, 前面的前向声明就没用了, 必须包含头文件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这样一来，<code>Person</code>类的使用者就完全于<code>Date</code>，<code>Address</code>以及<code>Person</code>的实现细目相分离了。这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：实现上让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。</p><p>  几个简单的设计策略：</p><ul><li><p>如果使用<code>object reference</code>或<code>object pointer</code>可以完成任务，就不要使用<code>object</code></p><p>  你可以只靠一个类型声明式就定义出指向该类型的<code>reference</code>和<code>pointer</code>；但如果定义某类型的<code>object</code>，就需要用到该类型的定义式。</p></li><li><p>如果能够，尽量以<code>class</code>声明式替换<code>class</code>定义式</p><p>  注意，当你声明一个函数而它用到某个<code>class</code>时，你并不需要该<code>class</code>的定义。</p></li><li><p>为声明式和定义式提供不同的头文件</p><p>  对于前面代码中的前向声明，最好是提供一个声明式头文件，包含全部的前向声明。</p><p>下面式<code>Person.cpp</code>文件的部分实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Person.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;PersonImpl.h&gt; </span></span></span><br><span class="line"><span class="comment">// 注意，Person 和PersonImpl的成员函数完全相同, 两者接口完全相同</span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span><br><span class="line"><span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line"><span class="keyword">const</span> Address&amp; addr) : pImpl(<span class="keyword">new</span> PersonImpl(name, birthday,addr)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::narne</span><span class="params">( )</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pImpl-&gt;name();&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Interface classes</code>：<code>abstract base class</code> + <code>factory</code>函数</p><p>  <code>abstract base class</code>通常没有成员变量，也没有构造函数，只有一个<code>virtual</code>析构函数和一组<code>pure virtual</code>函数。但<code>Interface class</code>的客户必须有办法为这种<code>class</code>创建新对象。他们通常调用一个特殊函数，此函数创建实际实现的<code>derived class</code>，这样的函数通常称为<code>factory</code>(工厂）函数（见条款<code>13</code>），它们返回智能指针指向动态分配所得对象，而该对象支持<code>Interface class</code>的接口。这样的函数又往往在<code>Interface class</code>内被声明为<code>static</code>：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 Person.h</span></span><br><span class="line"><span class="comment">// 抽象基类, 只有声明</span></span><br><span class="line"><span class="comment">// 提供给客户使用的头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> strng <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> strng <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// static 的 factory 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Address&amp; addr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于 Person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RealPerson(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span><br><span class="line">               <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="keyword">const</span> Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~RealPerson() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 虚函数的实现码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>Handle classes</code>和<code>Interface classes</code>解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第四章</title>
      <link href="/S0Qfg61EKNlwLo15/"/>
      <url>/S0Qfg61EKNlwLo15/</url>
      
        <content type="html"><![CDATA[<h4 id="第4章：设计与声明"><a href="#第4章：设计与声明" class="headerlink" title="第4章：设计与声明"></a>第<code>4</code>章：设计与声明</h4><h5 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款<code>18</code>：让接口容易被正确使用，不容易被误用</h5><ul><li>如果客户企图使用某个接口却没有获得所预期的行为，这个代码不应该通过编译；如果代码通过了编译，则它的行为就应该是客户想要的</li><li>欲达“让接口容易被正确使用，不容易被误用”的目的，必须考虑客户调用接口时可能做出什么样的错误</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型兼容</li><li>“阻止误用”的办法包括建立新类型、限制在类型上的操作，束缚对象值以及消除客户的资源管理责任</li></ul><a id="more"></a><h5 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款<code>19</code>：设计class犹如设计<code>type</code></h5><p>你应该带着“语言设计者当初设计语言内置类型时”一样的谨慎来研讨每一个<code>class</code>的设计。因为，重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结…全都在你手上。</p><ul><li><p>新的<code>type</code>的对象应该如何创建和销毁？</p><p>  设计函数为类的构造函数和析构函数以及内存分配函数和释放函数（见条款<code>49-52</code>）。</p></li><li><p>对象的初始化和对象的赋值该有什么样的差别？</p><p>  决定了构造函数和赋值操作符的行为以及差异。</p></li><li><p>新<code>type</code>的对象被<code>passed by value</code>，意味着什么？</p><p>  取决于<code>copy</code>构造函数的实现。</p></li><li><p>什么新<code>type</code>的合法值？</p></li><li><p>你的新<code>type</code>需要配合某个继承图系吗？</p><p>  见条款<code>7</code>、<code>34</code>、<code>36</code>。</p></li><li><p>你的新<code>type</code>需要什么样的转换？</p><p>  <code>explicit</code>和<code>operator</code>关键字的使用。见条款<code>15</code>。</p></li><li><p>什么样的操作符和函数对此新<code>type</code>而言时合理的？</p><p>  见条款<code>23</code>、<code>24</code>、<code>46</code>。</p></li><li><p>什么样的标准函数应该驳回？</p><p>  见条款<code>6</code>。</p></li><li><p>谁该取用新<code>type</code>的成员？</p><p>  决定了数据成员是<code>public</code>、<code>private</code>还是<code>protected</code>，以及<code>friend</code>关键的使用。</p></li><li><p>什么是新<code>type</code>的“未声明接口”？</p><p>  见条款<code>29</code>。</p></li><li><p>你的新<code>type</code>有多么一般化？</p><p>  决定<code>class template</code>的使用。</p></li><li><p>你真的需要一个新<code>type</code>吗？</p></li></ul><h5 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass by reference to const替换pass by value"></a>条款<code>20</code>：宁以<code>pass by reference to const</code>替换<code>pass by value</code></h5><ul><li>当把具有继承关系的类作为参数传递时，如果<code>pass by value</code>可能会出现“截断”问题。</li></ul><h5 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款<code>21</code>：必须返回对象时，别妄想返回其<code>reference</code></h5><ul><li>绝不要返回指向一个<code>local stack</code>对象的<code>pointer</code>或<code>reference</code></li><li>绝不要返回指向一个<code>heap allocated</code>对象的<code>reference</code></li><li>除非有单例模式的设计要求，否则绝对不要返回指向一个<code>local static</code>对象的<code>pointer</code>或<code>reference</code></li></ul><h5 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款<code>22</code>：将成员变量声明为<code>private</code></h5><ul><li><p>客户访问数据的一致性</p><p>  <code>public</code>里都是函数。</p></li><li><p>可以对成员变量有更精确的控制</p><p>  可以实现成员变量的不可访问，只读、只写、读写访问。</p></li><li><p>封装性</p><p>  将成员变量隐藏在函数接口背后，可以为所有可能的实现提供弹性。</p></li><li><p>从封装的角度看，只有两种权限：<code>private</code>（提供封装）和其它</p><p>  <code>protected</code>并不比<code>private</code>更具封装性。</p></li></ul><h5 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款<code>23</code>：宁以<code>non-member</code>、<code>non-friend</code>替换<code>member</code>函数</h5><p>考虑一个用来表示网页浏览器的<code>class</code>，这个<code>class</code>提供的众多成员函数中，有用来清除下载元素高速缓冲区的，有用来清除访问过的历史记录的，有用来移除系统中所有<code>cookies</code>的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleatCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户想一整个执行所有的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以提供一个 member 函数的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverthing</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以提供一个 non-member 函数的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wb.clearCache();</span><br><span class="line">    wb.clearHistory();</span><br><span class="line">    wb.cleatCookies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后者比较好。因为：</p><ul><li><p>增加封装性</p><p>  <code>non-member non-friend</code>将提供较大的封装性，因为它并不增加能够访问<code>class</code>内的<code>private</code>成分的函数数量。<code>friend</code>函数对<code>class private</code>成员的访问权力和<code>member</code>函数相同，两者对封装的冲击力度是一样的。</p></li><li><p>增加扩充机能性</p><p>  在<code>C++</code>中，正确且自然的做法是：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span>...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>; <span class="comment">// 为 WebBrowser “提供便利”的函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>namespace</code>和<code>class</code>的不同是，前者可跨越多个源码文件而后者不能。</p><p>像<code>WebBrowser</code>这样的类可能有大量的“提供便利”函数，某些与书签有关，与打印有关，与<code>cookie</code>有关… 分离它们最直接的做法就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 WebBrowser.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span>...&#125;;</span><br><span class="line">    ... <span class="comment">// 核心机能, 例如所有客户都想要的 non-member 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件 WebBrowserBookmarks.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 与书签相关的 non-member 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件 WebBrowserCookies.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 与 cookie 相关的 non-member 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有“便利函数”放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组“便利函数”。</p></li></ul></li></ul><h5 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款<code>24</code>：若所有参数皆需类型转换，请为此采用<code>non-member</code>函数</h5><ul><li><p>有理数类<code>Rational</code>的实现</p><p>  重点关注用来将两个有理数相乘的<code>operator*</code>操作符重载函数的实现方式。</p></li></ul><h5 id="条款25：考虑写出一个不抛异常的swap函数"><a href="#条款25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛异常的swap函数"></a>条款<code>25</code>：考虑写出一个不抛异常的<code>swap</code>函数</h5><p>标准程序库提供的<code>swap</code>算法的典型实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要<code>T</code>类型支持<code>copying</code>函数（<code>copy</code>构造函数和<code>copy assignment</code>操作符）。对于用户自定义类型，效率低下（需要三次复制）。</p><p>现在考虑所谓的<code>pimpl(pointer to implementation)</code>实现手法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这是个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 细节不重要</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ... <span class="comment">// 有很多数据, 意味着复制时间很长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这是个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&lt;T&gt;&amp; rhs);</span><br><span class="line"><span class="comment">// 关于 operator= 的一般性实现参考条款 10, 11, 12</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl&lt;T&gt;* pImpl; <span class="comment">// 指向实际实现的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一旦需要置换两个<code>Widget</code>对象值，我们实际唯一需要的是置换两个指针即可。但缺省的<code>swap</code>函数不知道这一点！</p><p>下面是正确的实现步骤：</p><ol><li><p>令<code>Widget</code>实现一个名为<code>swap</code>的<code>public</code>成员函数做真正的置换工作</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 必须的</span></span><br><span class="line">        swap(pImpl, other.pImpl); <span class="comment">// 直接置换指针即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>std::swap</code>特化，令它调用该成员函数<strong>（当<code>Widget</code>是类时。这里的例子中，<code>Widget</code>是个模板类则不要这一步）</strong></p><ul><li><p>因为，<code>C++</code>只允许对<code>class template</code>偏特化，不允许对<code>function template</code>进行偏特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">a.swap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>声明一个<code>non-member swap</code>，令它调用<code>member swap</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意, 要将它放在和 Widget&lt;T&gt; 同一个空间内(全局或者自定义的 namespace)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编程时，在调用<code>swap</code>置换对象的语句之前加上<code>using std::swap</code>声明</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户代码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1. T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 令 std::swap 在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    swap(obj1, obj2); <span class="comment">// 这样一来, 编译器将为 T 类型对象调用最佳版本 swap</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译器首先在全局作用域或<code>T</code>所在命名空间内寻找<code>T</code>（在这里，<code>T</code>就是例子中的<code>Widget</code>哦）专属的<code>swap</code>（也就是步骤<code>3</code>中实现的）。如果没有实现这些，则调用<code>std</code>内的<code>swap</code>，如果步骤<code>2</code>还实现了特化版本，将会选中特化版本。</p></li></ol><ul><li><p>劝告，<code>member swap</code>绝不可抛出异常</p><p>  具体参考条款29。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第三章</title>
      <link href="/ojSMOM86r5rbvAqL/"/>
      <url>/ojSMOM86r5rbvAqL/</url>
      
        <content type="html"><![CDATA[<h4 id="第3章：资源管理"><a href="#第3章：资源管理" class="headerlink" title="第3章：资源管理"></a>第<code>3</code>章：资源管理</h4><h5 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款<code>13</code>：以对象管理资源</h5><ul><li><p><code>RAII</code>(<code>Resource Acquisition Is Initialization</code>)</p><p>  使用<code>new</code>获取资源后于同一条语句内以它初始化某个资源管理对象。利用当管理对象离开作用域被销毁时自动调用其析构函数的机制确保资源被释放。不直接用<code>new</code>和<code>delete</code>，多用智能指针。</p></li><li><p>智能指针在其析构函数中做<code>delete</code>动作而非<code>delete[]</code>动作</p><p>  因此，不要在动态分配来的数组身上使用智能指针（虽然它仍然会通过编译）。</p></li></ul><a id="more"></a><h5 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款<code>14</code>：在资源管理类中小心<code>copying</code>行为</h5><ul><li>当不想<code>RAII</code>类被复制时可以继承<code>Uncopyable</code>类</li></ul><p>将智能指针施于<code>heap-based</code>资源身上是个好主意，但并不是所有资源都是<code>heap-based</code>的，比如互斥器<code>mutex</code>，<code>mutex</code>就不可复制。</p><h5 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款<code>15</code>：在资源管理类中提供对原始资源的访问</h5><ul><li><p>显示转换（安全）</p><p>  例如，<code>shared_ptr</code>类就提供可一个<code>get</code>成员函数来返回智能指针内部的原始指针。</p></li><li><p><code>operator</code>隐式转换（调用方便）</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// operator 可以实现隐式转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B b; <span class="comment">// B 类型对象成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受 B 类型对象的一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(B b)</span></span>;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">func(a); <span class="comment">// a 会被编译器隐式转换为 B 类型对象</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="条款16：使用new和delete时要采用相同的形式"><a href="#条款16：使用new和delete时要采用相同的形式" class="headerlink" title="条款16：使用new和delete时要采用相同的形式"></a>条款<code>16</code>：使用<code>new</code>和<code>delete</code>时要采用相同的形式</h5><ul><li><p>编译器在给数组分配内存时，会包括数组大小的记录</p><p>  这样的好处是，<code>delete[]</code>时知道需要调用多少次析构函数。</p></li><li><p>不要对数组形式进行<code>typedef</code>动作</p></li></ul><h5 id="条款17：以独立语句将new来的对象置入智能指针"><a href="#条款17：以独立语句将new来的对象置入智能指针" class="headerlink" title="条款17：以独立语句将new来的对象置入智能指针"></a>条款<code>17</code>：以独立语句将<code>new</code>来的对象置入智能指针</h5><p>考虑这样两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>; <span class="comment">// 调用这个函数不排除会发生异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><p>如果这样调用编译不通过，因为<code>shared_ptr</code>接收原始指针的构造函数是<code>explicit</code>的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="keyword">new</span> Widget, priority());</span><br></pre></td></tr></table></figure><p>如果这样调用可能会造成内存泄漏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure><p>因为编译器在编译这条语句时，实际上会创建三个动作：</p><ul><li>调用<code>priority()</code></li><li>执行<code>new Widget</code></li><li>调用<code>shared_ptr</code>的构造函数</li></ul><p>而<code>C++</code>编译器安排这三个动作的次序是不确定的。</p><p>如果执行次序是这样：</p><ol><li>执行<code>new Widget</code></li><li>调用<code>priority()</code></li><li>调用<code>shared_ptr</code>的构造函数</li></ol><p>一旦中途<code>priority()</code>导致异常，那么<code>new</code>返回的原始指针并未交给智能指针保管，将造成资源泄露。</p><p>正确的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure><p>因为，编译器对“跨越语句的各项操作”没有重新排列执行次序的自由。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第二章</title>
      <link href="/MeCvwFxjI4asjddf/"/>
      <url>/MeCvwFxjI4asjddf/</url>
      
        <content type="html"><![CDATA[<h4 id="第2章：构造、析构、赋值运算"><a href="#第2章：构造、析构、赋值运算" class="headerlink" title="第2章：构造、析构、赋值运算"></a>第<code>2</code>章：构造、析构、赋值运算</h4><h5 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款<code>05</code>：了解<code>C++</code>默默编写并调用哪些函数</h5><ul><li><p>编译器会暗自为<code>class</code>创建<code>default</code>构造函数、<code>copy</code>构造函数、<code>copy assignment</code>操作符以及析构函数</p></li><li><p>对于<code>class</code>内含<code>reference</code>成员或<code>const</code>成员，编译器拒绝为其生成<code>copy</code>构造函数和<code>copy assignment</code>操作符</p><blockquote><p>因为<code>C++</code>不允许<code>reference</code>改指向不同的对象以及更改<code>const</code>成员。 </p></blockquote></li></ul><a id="more"></a><h5 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款<code>06</code>：若不想使用编译器自动生成的函数，就该明确拒绝</h5><ul><li><p>为驳回编译器自动提供的函数，可将相应的成员函数声明为<code>private</code>并且不予实现。</p></li><li><p>掌握<code>Uncopyable</code>类的实现机制</p><ul><li><p>将构造函数和析构函数设置为<code>protected</code>的</p></li><li><p>将拷贝构造函数和拷贝赋值运算符设置为<code>private</code>的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable() &#123;&#125;</span><br><span class="line">    ~Uncopyable() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">    <span class="keyword">const</span> Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款<code>07</code>：为多态基类声明<code>virtual</code>析构函数</h5><ul><li><p>带多态性质的<code>base class</code>应该声明一个<code>virtual</code>析构函数</p></li><li><p>当<code>class</code>内至少含有一个<code>virtual</code>函数，才为它声明<code>virtual</code>析构函数</p></li><li><p><code>class</code>的设计目的如果不是作为<code>base class</code>使用，或不是为了具备多态性，就不该声明<code>virtual</code>析构函数</p></li><li><p>然而，有时候你希望拥有一个抽象类，但没有任何需要的<code>pure virtual</code>方法，怎么办？</p><p>  由于<code>abstract class</code>（不能实例化）总是被期望当作多态基类，多态基类又需要<code>virtual</code>析构函数，而<code>pure virtual</code>函数会导致<code>abstract class</code>，因此可将析构函数声明为<code>pure virtual</code>并且给出默认实现。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小技巧:pure virtual 析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AWOV::~AWOV() &#123;<span class="comment">/* default */</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款<code>08</code>：别让异常逃离析构函数</h5><ul><li>析构函数绝对不要吐出异常</li></ul><p>假设有一个类负责数据库的连接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; <span class="comment">// 关闭联机, 失败则抛出异常</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了确保客户不忘记在<code>DBConnection</code>对象上调用<code>close</code>函数，一个合理的想法是创建一个用来管理<code>DBConnection</code>资源的类，并在析构函数中调用<code>close</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">~DBConn()</span><br><span class="line">    &#123;</span><br><span class="line">        db.close();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户可以写出这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 区块作用域结束，调用析构函数销毁对象</span></span><br></pre></td></tr></table></figure><p>如果被析构函数调用的函数<code>close</code>可能抛出异常，析构函数应该捕获异常然后吞下它们或者结束程序。</p><p>一个好的策略是，开放一个<code>close</code>接口供用户调用，把调用<code>close</code>的责任从<code>DBConn</code>析构函数手上移到用户手上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.close();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">~DBConn()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                 db.close(); <span class="comment">// 关闭连接（如果客户没做的话）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(...)</span><br><span class="line">            &#123;</span><br><span class="line">                日志记录下对 close 调用的失败;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，如果客户需要对某个操作函数运行期间的异常作出反应，那么<code>class</code>应该提供一个接口执行该操作。如果<code>close</code>的确发生了异常，而客户没有调用<code>close</code>接口进行处理，<code>DBConn</code>只能吞下或结束程序。</p><h5 id="条款09：绝不在析构和构造函数中调用virtual函数"><a href="#条款09：绝不在析构和构造函数中调用virtual函数" class="headerlink" title="条款09：绝不在析构和构造函数中调用virtual函数"></a>条款<code>09</code>：绝不在析构和构造函数中调用<code>virtual</code>函数</h5><ul><li>派生类对象内的基类成分会在派生类自身成分被构造之前先被构造</li><li>基类构造期间，虚函数绝不会下降到派生类层</li></ul><p>需要注意的是，有时类有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复时会把相同的初始化代码放到一个<code>init</code>函数中实现，如果这时在<code>init</code>函数中同样调用了虚函数，情况是一样的但<strong>比较隐秘</strong>。 </p><h5 id="条款10：令赋值操作符operator-返回一个reference-to-this"><a href="#条款10：令赋值操作符operator-返回一个reference-to-this" class="headerlink" title="条款10：令赋值操作符operator=返回一个reference to *this"></a>条款<code>10</code>：令赋值操作符<code>operator=</code>返回一个<code>reference to *this</code></h5><ul><li>为了实现连续赋值</li></ul><h5 id="条款11：在operator-中处理自我赋值"><a href="#条款11：在operator-中处理自我赋值" class="headerlink" title="条款11：在operator=中处理自我赋值"></a>条款<code>11</code>：在<code>operator=</code>中处理自我赋值</h5><ul><li>有些自我赋值并不明显，如通过指针或引用</li></ul><p>假设你建立一个<code>class</code>来保存一个指针指向一块动态分配的位图（<code>bitmap</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb; <span class="comment">// 指向一个从 heap 分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>错误的<code>operator=</code>实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自我赋值不安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过一个“证同测试”来检验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自我赋值安全, 但不具备异常安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的异常安全指的是，如果<code>new Bitmap</code>发生异常，会导致<code>Widget</code>最终会持有一个指针指向一块被删除的<code>Bitmap</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具备异常安全, 则自动具备自我赋值安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* oldPb = pb; <span class="comment">// 记住之前的 pb</span></span><br><span class="line">    </span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">delete</span> oldPb;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用更好的<code>copy and swap</code>技术：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 交换 *this 和 rhs 的数据, 见条款 25</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提升点效率 ?</span></span><br><span class="line">    <span class="comment">// if(this == &amp;rhs)</span></span><br><span class="line">    <span class="comment">//     return *this;</span></span><br><span class="line">    </span><br><span class="line">    Widget temp(rhs); <span class="comment">// copy</span></span><br><span class="line">    </span><br><span class="line">    swap(temp); <span class="comment">// swap</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="条款12：复制对象时勿忘每一个成分"><a href="#条款12：复制对象时勿忘每一个成分" class="headerlink" title="条款12：复制对象时勿忘每一个成分"></a>条款<code>12</code>：复制对象时勿忘每一个成分</h5><ul><li>每一个成分包括对象内所有成员变量以及所继承的<strong>基类成分</strong><ul><li>在拷贝构造函数中的初始化列表中调用所继承的类的拷贝构造函数</li><li>在拷贝赋值操作符函数中调用所继承的类的拷贝赋值操作符函数</li></ul></li><li>不要尝试让拷贝构造函数和拷贝赋值操作符函数互相调用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第一章</title>
      <link href="/l4snoL8SUW9lGasI/"/>
      <url>/l4snoL8SUW9lGasI/</url>
      
        <content type="html"><![CDATA[<h4 id="第1章：让自己习惯C"><a href="#第1章：让自己习惯C" class="headerlink" title="第1章：让自己习惯C++"></a>第<code>1</code>章：让自己习惯<code>C++</code></h4><h5 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款<code>01</code>：视<code>C++</code>为一个语言联邦</h5><ul><li>将<code>C++</code>视为由<code>4</code>个次语言组成的联邦：<ul><li><code>C</code>：没有模板、没有异常、没有重载…</li><li><code>Object-Oriented C++</code>：类、封装、继承、多态、虚函数、动态绑定等等；</li><li><code>Template C++</code>：泛型编程部分；</li><li><code>STL</code>：是一个<code>Template</code>程序库，容器、迭代器、算法以及函数对象。</li></ul></li></ul><p>从某个此语言切换到另一个时，高效编程守则可能会发生变化。比如，<code>C-like</code>类型（内置类型）<code>pass by value</code>更好；对于<code>Object-Oriented C++</code>而言，<code>pass by reference to-const</code>更好；再切换到<code>STL</code>，由于迭代器和函数对象都是在<code>C</code>指针之上塑造出来的，<code>pass by value</code>守则再次适用。</p><a id="more"></a><h5 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款<code>02</code>：尽量以<code>const</code>，<code>enum</code>，<code>inline</code>替换<code>#define</code></h5><ul><li><p>对于单纯常量，最好以<code>const</code>对象或<code>enum hack</code>替换<code>#define</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记号名称未进入符号表, 难以调试</span></span><br><span class="line"><span class="comment">// 在多处出现目标码, 尤其浮点常量</span></span><br><span class="line"><span class="comment">// 无作用域概念, 不提供任何封装性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量会被编译器看到, 进入符号表</span></span><br><span class="line"><span class="comment">// 导致较小量的目标码, 因为只有一份</span></span><br><span class="line"><span class="comment">// 可放置在类内或 namespace 中限制其作用域</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以放在类或 namespace 中</span></span><br><span class="line"><span class="comment">// 令 NumTurns 成为 5 的记号名称, 一般用在类中做常量用</span></span><br><span class="line"><span class="comment">// 行为像 #define, 对 const 取地址合法，对 enum 和 #define 取地址就不合法</span></span><br><span class="line"><span class="keyword">enum</span> &#123;NumTurns = <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>对于形似函数的宏，最好用<code>inline</code>（或模板）函数替换</p><p>  宏中的变量有可能会被运算多次。</p></li></ul><h5 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款<code>03</code>：尽可能使用<code>const</code></h5><ul><li><p><code>const</code>作用于迭代器</p><p>  <code>STL</code>迭代器是以指针为根据塑模出来的，其作用就像个<code>T*</code>指针。声明迭代器为<code>const</code>只是声明一个<code>const</code>指针（作用就像<code>T* const</code>），表明的是迭代器本身不可变，但其所指的值是可以改动的。如果希望迭代器所指的值不可改动，需要的是<code>const_iterator</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line">*iter = <span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">++iter; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator citer = vec.begin();</span><br><span class="line">*citer = <span class="number">10</span>; <span class="comment">// 错误</span></span><br><span class="line">++citer; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>将<code>operator*</code>的返回类型声明为<code>const-by-value</code></p></li><li><p><code>const</code>可被施加于任何作用域内的对象、函数参数（常用<code>pass-by-reference-to-const</code>），函数返回类型、类成员函数本体</p></li><li><p><code>const</code>施加于成员函数</p><p>  成员函数上的<code>const</code>限定符意味着不能修改<code>non-mutable</code>，<code>non-static</code>类数据成员。</p></li><li><p>当<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>成员函数调用<code>const</code>版本可避免代码重复</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验</span></span><br><span class="line">        ... <span class="comment">// 日记数据访问</span></span><br><span class="line">        ... <span class="comment">// 检验数据完整性</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    char&amp; operator[](std::size_t position)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ... // 边界检验</span></span><br><span class="line"><span class="comment">        ... // 日记数据访问</span></span><br><span class="line"><span class="comment">        ... // 检验数据完整性</span></span><br><span class="line"><span class="comment">        return text[position];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用 const_cast 移除对象身上的 const</span></span><br><span class="line">        <span class="comment">// 调用 static_cast 为 *this 加上 cosnt</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBook&amp;&gt;(*<span class="keyword">this</span>)[position]</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>const</code>版本成员函数调用<code>non-const</code>版本不合法</p></li></ul><h5 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款<code>04</code>：确定对象被使用前已先被初始化</h5><ul><li><p>为内置型对象进行手工初始化，因为<code>C++</code>并不保证初始化它们</p></li><li><p>构造函数使用成员初始化列表，初始化顺序与在类中声明顺序一致</p></li><li><p>为避免“跨编译单元内定义的<code>non-local static</code>对象的初始化问题”，以<code>local</code>对象替换<code>non-local static</code>对象</p><ul><li><code>static</code>对象包括<code>global</code>对象、定义与<code>namespace</code>作用域内的对象、在<code>class</code>内、函数内、以及在<code>file</code>作用域内被声明为static的对象</li><li>函数内的<code>static</code>被称为<code>local static</code>对象，其它<code>static</code>对象被称为<code>non-local static</code>对象</li><li>程序结束时，<code>static</code>对象会被自动销毁，也就是它们的析构函数在<code>main</code>函数结束时被自动调用</li><li>编译单元是指产出单一目标文件的源码文件以及所含入的头文件</li></ul></li></ul><p>现在有两个源码文件，每个至少含入一个<code>non-local static</code>对象，其中一个<code>non-local static</code>对象用到了另一个<code>non-local static</code>对象，而被用到的尚未被初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 FileSystem.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span><span class="keyword">const</span></span>; <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs; <span class="comment">// 预备给客户使用的对象, non-local static 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 Directory.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(); <span class="comment">// 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks(); <span class="comment">// 使用 tfs 对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在客户决定创建一个Directory对象，用来放置临时文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Directory tempDir; <span class="comment">// 为临时文件而做出的目录</span></span><br></pre></td></tr></table></figure><p>这个时候就会出现初始化次序带来的问题。由于<code>tfs</code>和<code>tempDir</code>是不同的人在不同的时间于不同的源码文件中创建出来的，因此初始化次序不一定。</p><p>解决方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 FileSystem.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> <span class="comment">// 用于创建预备给客户使用的对象的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs; <span class="comment">// local static 对象</span></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 Directory.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(); <span class="comment">// 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这样就保证了被使用对象先被初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks(); <span class="comment">// 使用 tfs() 创建对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
