<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章是leetcode刷题系列的第5部分——队列和栈。这里把有代表性的题目发出来，共计22道。主要涉及BFS算法、DFS算法、单调栈以及单调队列技巧的应用。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题系列之队列和栈">
<meta property="og:url" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="这篇文章是leetcode刷题系列的第5部分——队列和栈。这里把有代表性的题目发出来，共计22道。主要涉及BFS算法、DFS算法、单调栈以及单调队列技巧的应用。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/ex2v3.png">
<meta property="og:image" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/250px-Sudoku-by-L2G-20050714.svg.png">
<meta property="og:image" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/250px-Sudoku-by-L2G-20050714_solution.svg.png">
<meta property="og:image" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/2-1616932759606.jpeg">
<meta property="og:image" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/133_clone_graph_question.png">
<meta property="og:image" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/2.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/sample_3_1610.png">
<meta property="og:image" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/sample_4_1610.png">
<meta property="article:published_time" content="2021-03-18T13:35:42.000Z">
<meta property="article:modified_time" content="2021-03-18T13:35:42.000Z">
<meta property="article:author" content="Liu Y.L.">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/ex2v3.png">

<link rel="canonical" href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode刷题系列之队列和栈 | LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode刷题系列之队列和栈
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-18 21:35:42" itemprop="dateCreated datePublished" datetime="2021-03-18T21:35:42+08:00">2021-03-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章是<code>leetcode</code>刷题系列的第<code>5</code>部分——队列和栈。这里把有代表性的题目发出来，共计<code>22</code>道。主要涉及<code>BFS</code>算法、<code>DFS</code>算法、单调栈以及单调队列技巧的应用。</p>
<p>接下来这几个月，计划完成的<code>leetcode</code>刷题系列其组织如下：</p>
<p><code>1</code>. 数组</p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. 字符串</p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. 动态规划</p>
<p><code>7</code>. 数据结构设计</p>
<p>预计涉及题目至少<code>300</code>道！</p>
<a id="more"></a>

<h4 id="Queue-and-Stack"><a href="#Queue-and-Stack" class="headerlink" title="Queue and Stack"></a><code>Queue and Stack</code></h4><h5 id="1660-Correct-a-Binary-Tree"><a href="#1660-Correct-a-Binary-Tree" class="headerlink" title="1660. Correct a Binary Tree"></a><a href="https://leetcode.com/problems/correct-a-binary-tree/" target="_blank" rel="noopener">1660. Correct a Binary Tree</a></h5><blockquote>
<p>你有一棵二叉树，这棵二叉树有个小问题，其中有且只有一个无效节点，它的右子节点错误地指向了与其在同一层且在其右侧的一个其他节点。</p>
<p>给定一棵这样的问题二叉树的根节点<code>root</code>，将该无效节点及其所有子节点移除（不移除被错误指向的节点），然后返回新二叉树的根结点。</p>
<p><strong>示例:</strong></p>
<img src="ex2v3.png" alt="img" style="zoom: 33%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode &#x3D; 7, toNode &#x3D; 4</span><br><span class="line">输出: [8,3,1,null,null,9,4,null,null,5,6]</span><br><span class="line">解释: 值为 7 的节点是无效的，所以移除这个节点及其子节点 2。</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助层序遍历的思想</span></span><br><span class="line"><span class="comment">// 如果遍历到某一个节点, 发现其右孩子已经访问过了</span></span><br><span class="line"><span class="comment">// 就说明当前节点就是无效节点</span></span><br><span class="line"><span class="comment">// 但此时需要记录已经访问过的节点</span></span><br><span class="line"><span class="comment">// 如果要把此无效节点删除, 还要知道当前节点的父节点</span></span><br><span class="line"><span class="comment">// 因此, 使用一个哈希表记录所有访问过的节点以及这些节点的父节点</span></span><br><span class="line"><span class="comment">// 哈希表的映射有点特殊, 因为我们想达到这样的效果 mapping[node] == node's parent</span></span><br><span class="line"><span class="comment">// 因此, 每次访问一个节点 node 时</span></span><br><span class="line"><span class="comment">// 以 node 为值, 分别以其左右孩子(如果存在的话)为键加入哈希表</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">correctBinaryTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 队列仅仅用于完成层序遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="comment">// 当前节点和其父亲的映射的哈希表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt; mapping;</span><br><span class="line">    <span class="keyword">if</span>(root) q.push(root);</span><br><span class="line">    <span class="comment">// 标记是否找到了无效节点, 可用于提前结束遍历</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty() &amp;&amp; !flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 以上都是标准的层序遍历迭代实现的固定框架</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前节点的右孩子已经遍历过了</span></span><br><span class="line">            <span class="comment">// 说明找到无效节点</span></span><br><span class="line">            <span class="keyword">if</span>(mapping.count(node-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mapping[node]-&gt;left == node)</span><br><span class="line">                    <span class="comment">// 如果当前节点是其父节点的左孩子</span></span><br><span class="line">                    mapping[node]-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 否则是右孩子</span></span><br><span class="line">                    mapping[node]-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 否则继续遍历就是了</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) </span><br><span class="line">                &#123;</span><br><span class="line">                    mapping[node-&gt;left] = node;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    mapping[node-&gt;right] = node;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="394-Decode-String"><a href="#394-Decode-String" class="headerlink" title="394. Decode String"></a><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener">394. Decode String</a></h5><blockquote>
<p>  给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>  编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的<code>encoded_string</code>正好重复<code>k</code>次。注意<code>k</code>保证为正整数。</p>
<p>  你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>  此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数<code>k</code> ，例如不会出现像<code>3a</code>或<code>2[4]</code>的输入。</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.size() &lt;= 30</code></li>
<li><code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.</li>
<li><code>s</code> is guaranteed to be <strong>a valid</strong> input.</li>
<li>All the integers in <code>s</code> are in the range <code>[1, 300]</code>.</li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">Output: &quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeatString</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = str;</span><br><span class="line">    <span class="keyword">while</span>(--count) str = s + str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; isdigits&#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">']'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> substr;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() != <span class="string">"["</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                substr = s.top() + substr;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.pop(); <span class="comment">// pop 掉相匹配的那个 '['</span></span><br><span class="line">            <span class="comment">// 获取 [] 前面的那个数字, 注意可能是多位数</span></span><br><span class="line">            <span class="built_in">string</span> numstr;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; isdigits.count(s.top()))</span><br><span class="line">            &#123;</span><br><span class="line">                numstr = s.top() + numstr;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 [] 中的字串重复指定次</span></span><br><span class="line">            repeatString(substr, stoi(numstr));</span><br><span class="line">            <span class="comment">// 新串再次入栈</span></span><br><span class="line">            s.push(substr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> s.push(<span class="built_in">string</span>(<span class="number">1</span>, c));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这时从栈底到栈顶的所有串连在一起其实就是答案了</span></span><br><span class="line">    <span class="comment">// 但是要转为 string 返回</span></span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        res = s.top() + res;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="752-Open-the-Lock"><a href="#752-Open-the-Lock" class="headerlink" title="752. Open the Lock"></a><a href="https://leetcode.com/problems/open-the-lock/" target="_blank" rel="noopener">752. Open the Lock</a></h5><blockquote>
<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有<code>10</code>个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code>。每个拨轮可以自由旋转：例如把<code>&#39;9&#39;</code>变为<code>&#39;0&#39;</code>，<code>&#39;0&#39;</code>变为<code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为<code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p>
<p>列表<code>deadends</code>包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串<code>target</code>代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回<code>-1</code>。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target &#x3D; &quot;0202&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.</span><br><span class="line">Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,</span><br><span class="line">because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends &#x3D; [&quot;8888&quot;], target &#x3D; &quot;0009&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宽度优先遍历 BFS 通常用来解决最小(距离)、最短(路径)、最少(步数)等问题</span></span><br><span class="line"><span class="comment">// 先给出 BFS 算法框架</span></span><br><span class="line"><span class="comment">// 计算从 [开始状态] 到 [目标状态]的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(STATE startState, STATE targetState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;STATE&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;STATE&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.push(startState); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.insert(startState);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有状态分别向其所有相邻状态转换 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            STATE curState = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 下面代码是需要你根据实际问题的逻辑做调整的</span></span><br><span class="line">            <span class="comment">/***************************************/</span></span><br><span class="line">            <span class="comment">/* 划重点: 这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (curState is targetState) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的所有相邻状态加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (STATE state : all adjacent states of curState )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (state <span class="keyword">not</span> in visited)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(state);</span><br><span class="line">                    visited.insert(state);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/***************************************/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点: 更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于我们这题打开密码锁的问题</span></span><br><span class="line"><span class="comment">// 就是穷举所有的密码组合, 直到到达目标密码</span></span><br><span class="line"><span class="comment">// 密码锁初始值(开始状态)为 "0000", 一共四个位置, 每个位置可以向上或向下拨动, 也就是有 8 个相邻状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; deads;</span><br><span class="line">    <span class="comment">// 将死亡密码加入哈希集合</span></span><br><span class="line">    <span class="comment">// 其实这里是可以直接用 visited, 就是说直接把死亡密码看作已经被访问过了, 一样的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : deadends)</span><br><span class="line">        deads.insert(elem);</span><br><span class="line"></span><br><span class="line">    q.push(<span class="string">"0000"</span>);</span><br><span class="line">    visited.insert(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> qSize = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从队列中取出一个状态访问</span></span><br><span class="line">            <span class="built_in">string</span> curLock = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 如果当前状态在死亡状态里面</span></span><br><span class="line">            <span class="comment">// 说明我们不能够到达这个状态</span></span><br><span class="line">            <span class="comment">// 因此也就不可能从这个状态向其它相邻状态转换</span></span><br><span class="line">            <span class="comment">// 继续取出队列中的下一个状态</span></span><br><span class="line">            <span class="keyword">if</span>(deads.count(curLock)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果当前状态是目标状态了</span></span><br><span class="line">            <span class="keyword">if</span>(curLock == target) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 否则, 向相邻的 8 个状态转换</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将第 j 个字符向上拨动</span></span><br><span class="line">                <span class="built_in">string</span> upRotate = rotate(curLock, j, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!visited.count(upRotate))</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(upRotate);</span><br><span class="line">                    visited.insert(upRotate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将第 j 个字符向下拨动</span></span><br><span class="line">                <span class="built_in">string</span> downRotate = rotate(curLock, j, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(!visited.count(downRotate))</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(downRotate);</span><br><span class="line">                    visited.insert(downRotate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// direction 为 1 向上拨动, 为 0 则向下拨动</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">rotate</span><span class="params">(<span class="built_in">string</span> theLock, <span class="keyword">int</span> position, <span class="keyword">bool</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(direction)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(theLock[position] == <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            theLock[position] = <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">return</span> theLock;</span><br><span class="line">        &#125;</span><br><span class="line">        theLock[position]++;</span><br><span class="line">        <span class="keyword">return</span> theLock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(theLock[position] == <span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            theLock[position] = <span class="string">'9'</span>;</span><br><span class="line">            <span class="keyword">return</span> theLock;</span><br><span class="line">        &#125;</span><br><span class="line">        theLock[position]--;</span><br><span class="line">        <span class="keyword">return</span> theLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. Sudoku Solver</a></h5><blockquote>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>一个数独的解法需遵循如下规则：</p>
<ol>
<li>数字<code>1-9</code>在每一行只能出现一次。</li>
<li>数字<code>1-9</code>在每一列只能出现一次。</li>
<li>数字<code>1-9</code>在每一个以粗实线分隔的<code>3x3</code>宫内只能出现一次。空白格用<code>&#39;.&#39;</code>表示。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">一个数独</th>
<th align="center">红色为答案</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></td>
<td align="center"><img src="250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></td>
</tr>
</tbody></table>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是深度优先搜索算法应用的典型题目</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前行填写完了, 就到下一行</span></span><br><span class="line">    <span class="keyword">if</span>(col == board.size()) <span class="keyword">return</span> dfs(board, row + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果最后一行也填完了, 就说明找到了数独的一个解</span></span><br><span class="line">    <span class="keyword">if</span>(row == board.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果当前格子中已经有数了就跳过这个格子</span></span><br><span class="line">    <span class="keyword">if</span>(board[row][col] != <span class="string">'.'</span>) <span class="keyword">return</span> dfs(board, row, col + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 针对当前格子</span></span><br><span class="line">    <span class="comment">// 从数字 1 到 9 依次尝试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前格子放置这个数字不符合那 3 条规则就跳过</span></span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, row, col, c)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = c;</span><br><span class="line">        <span class="comment">// 这里的 if 语句可以在找到一组解的时候立即返回</span></span><br><span class="line">        <span class="comment">// 不至于找到所有可能的解</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(board, row, col + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前行不能有数字重复</span></span><br><span class="line">        <span class="keyword">if</span>(board[row][i] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当前列不能有数字重复</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][col] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当前格子所在的九宫格不能有数字重复</span></span><br><span class="line">        <span class="comment">// 这特么还真不好写, 看不懂就背下吧</span></span><br><span class="line">        <span class="keyword">if</span>(board[(row / <span class="number">3</span>) * <span class="number">3</span> + i / <span class="number">3</span>][(col / <span class="number">3</span>) * <span class="number">3</span> + i % <span class="number">3</span>] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">279. Perfect Squares</a></h5><blockquote>
<p>给定正整数<code>n</code>，找到若干个完全平方数（比如<code>1, 4, 9, 16, ...</code>）使得它们的和等于<code>n</code>。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数<code>n</code> ，返回和为<code>n</code>的完全平方数的最少数量。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 12</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DP 递推式: numSquares(n) = min(numSquares(n - k)) + 1</span></span><br><span class="line"><span class="comment">// 有点 找零钱 那题的那味儿</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; squares;</span><br><span class="line">    <span class="comment">// 先计算出所有符合条件的完全平方数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)</span><br><span class="line">        squares.push_back(i * i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> square : squares)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - square &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            dp[i] = min(dp[i], dp[i - square]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 穷举所有完全平方数相加的组合, 直到一组的和等于目标数</span></span><br><span class="line"><span class="comment">// 因为要找用到的 [最少的] 完全平方数, 所以使用 BFS</span></span><br><span class="line"><span class="comment">// 第 1 轮: 搜索所有 1 位数字判断是否满足</span></span><br><span class="line"><span class="comment">// 将 0 + (1, 2, 4, 9, ...) 的数字依次放进队列中</span></span><br><span class="line"><span class="comment">// 第 2 轮: 搜索所有 2 位数字的和并判断是否满足</span></span><br><span class="line"><span class="comment">// 将 1 + (1, 2, 4, 9, ...) 的数字依次放进队列中</span></span><br><span class="line"><span class="comment">// 将 2 + (1, 2, 4, 0, ...) 的数字依次放进队列中</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 第 3 轮: 搜索所有 3 位数字和并判断是否满足</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 你会发现我们穷举的时候遇到了大量同样的数字组合, 因此使用一个哈希集合来跳过它们</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur == n) <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 直到完全平方数大于目标数</span></span><br><span class="line">            <span class="comment">// 这里的循环相当于是找当前值的所有可能的邻居</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = cur + j * j;</span><br><span class="line">                <span class="comment">// 如果完全平方数的和还小于目标数</span></span><br><span class="line">                <span class="comment">// 或者这个和没有被访问, 才加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(temp &lt;= n &amp;&amp; !visited.count(temp))</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp);</span><br><span class="line">                    visited.insert(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">155. Min Stack</a></h5><blockquote>
<p>  设计一个支持<code>push</code>，<code>pop</code>，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p>
<p>  <code>push(x)</code> —— 将元素<code>x</code>推入栈中。<br>  <code>pop()</code> —— 删除栈顶的元素。<br>  <code>top()</code> —— 获取栈顶元素。<br>  <code>getMin()</code> —— 检索栈中的最小元素。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() : _minVal(INT_MIN) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; _minVal || _data.empty()) _minVal = x;</span><br><span class="line">        _data.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(_data.back() == _minVal)</span><br><span class="line">            _minVal = *min_element(_data.begin(), _data.end() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        _data.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _minVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">    <span class="keyword">int</span> _minVal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a><a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. Daily Temperatures</a></h5><blockquote>
<p>  请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用<code>0</code>来代替。</p>
<p>  例如，给定一个列表<code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是<code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题本质上就是找到当前元素的下一个比它大的元素</span></span><br><span class="line"><span class="comment">// 然后两者的索引相减即可</span></span><br><span class="line"><span class="comment">// 像这样和下一个更大元素有关的问题都需要使用一种单调栈的技巧</span></span><br><span class="line"><span class="comment">// 就是说维护一个栈, 使其中的元素保持单调的次序</span></span><br><span class="line"><span class="comment">// 下面的代码就是单调栈的模板</span></span><br><span class="line"><span class="comment">// 这里维护着从栈底到栈顶递减的次序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 倒着遍历入栈, 因此也就是正着出栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = T.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素比栈首元素大</span></span><br><span class="line">        <span class="comment">// 那么栈的首元素出栈让出位子</span></span><br><span class="line">        <span class="comment">// 直到首元素比当前元素大了才把当前元素压入栈</span></span><br><span class="line">        <span class="comment">// 注意这里栈内放的是索引</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; T[s.top()] &lt;= T[i])</span><br><span class="line">            s.pop();</span><br><span class="line">        <span class="comment">// 更新数组中第 i 个元素的下一个更大的元素</span></span><br><span class="line">        <span class="comment">// 就在栈首</span></span><br><span class="line">        res[i] = s.empty() ? <span class="number">0</span> : (s.top() - i);</span><br><span class="line">        s.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="496-Next-Greater-Element-I"><a href="#496-Next-Greater-Element-I" class="headerlink" title="496. Next Greater Element I"></a><a href="https://leetcode.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. Next Greater Element I</a></h5><blockquote>
<p>  给你两个没有重复元素的数组<code>nums1</code>和<code>nums2</code>，其中<code>nums1</code>是<code>nums2</code>的子集。</p>
<p>  请你找出<code>nums1</code>中每个元素在<code>nums2</code>中的下一个比其大的值。</p>
<p>  <code>nums1</code>中数字<code>x</code>的下一个更大元素是指<code>x</code>在<code>nums2</code>中对应位置的右边的第一个比<code>x</code>大的元素。如果不存在，对应位置输出<code>-1</code> 。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2]</span><br><span class="line">Output: [-1,3,-1]</span><br><span class="line">Explanation:</span><br><span class="line">For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</span><br><span class="line">For number 1 in the first array, the next greater number for it in the second array is 3.</span><br><span class="line">For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接套用单调栈的模板</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里用哈希表来存放答案</span></span><br><span class="line">    <span class="comment">// 记录着 nums2 数组中的每个元素与其下一个更大的元素之间的映射</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums2.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt;= nums2[i])</span><br><span class="line">            s.pop();</span><br><span class="line">        mapping[nums2[i]] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line">    <span class="comment">// 直接从哈希表中获取 nums1 数组中元素的下一个更大元素即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++)</span><br><span class="line">        res[i] = mapping[nums1[i]];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="503-Next-Greater-Element-II"><a href="#503-Next-Greater-Element-II" class="headerlink" title="503. Next Greater Element II"></a><a href="https://leetcode.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. Next Greater Element II</a></h5><blockquote>
<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字<code>x</code>的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出<code>-1</code>。</p>
<img src="2-1616932759606.jpeg" alt="2" style="zoom: 33%;" />

<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: [1,2,1]</span><br><span class="line">&gt;Output: [2,-1,2]</span><br><span class="line">&gt;Explanation: The first 1&#39;s next greater number is 2; The number 2 can&#39;t find next greater number; The second 1&#39;s next greater number needs to search circularly, which is also 2.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里和 I 题的区别是, 数组可以循环</span></span><br><span class="line"><span class="comment">// 也就是说从当前位置一直向后看去, 直到找到下一个更大元素为止</span></span><br><span class="line"><span class="comment">// 如果找到了尾元素则从首元素开始继续找</span></span><br><span class="line"><span class="comment">// 可以看作在原始数组后面又接了一段原始数组(见上图)</span></span><br><span class="line"><span class="comment">// 你当然可以申请一段两倍的数组空间来这放元素</span></span><br><span class="line"><span class="comment">// 但是, 下面来学习一个循环遍历数组的技巧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先直接套用单调栈的模板</span></span><br><span class="line"><span class="comment">// 其中改动的地方就是能够循环遍历数组的技巧</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])</span><br><span class="line">            s.pop();</span><br><span class="line">        res[i % n] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums[i % n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="556-Next-Greater-Element-III"><a href="#556-Next-Greater-Element-III" class="headerlink" title="556. Next Greater Element III"></a><a href="https://leetcode.com/problems/next-greater-element-iii/" target="_blank" rel="noopener">556. Next Greater Element III</a></h5><blockquote>
<p>  给你一个正整数<code>n</code>，请你找出符合条件的最小整数，其由重新排列<code>n</code>中存在的每位数字组成，并且其值大于<code>n</code>。如果不存在这样的正整数，则返回<code>-1</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 320241</span><br><span class="line">Output: 320412</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 321</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要想到的是先把数字转成字符串, 方便处理</span></span><br><span class="line"><span class="comment">// 然后再试想一下, 影响数值前后发生大小变化的决定因素什么</span></span><br><span class="line"><span class="comment">// 不知道你脑子里有没有蹦出 [逆序对] 三个字</span></span><br><span class="line"><span class="comment">// 注意我这里的 [逆序对] 是指, 原本降序排列的数, 其中相邻的一对数字是升序</span></span><br><span class="line"><span class="comment">// 如果你想到了这个, 那问题就很简单了</span></span><br><span class="line"><span class="comment">// 对于数字其中的一个逆序对</span></span><br><span class="line"><span class="comment">// 如果你把这两个数字交换, 值是不是就变大了？</span></span><br><span class="line"><span class="comment">// 但这题要找变大之后的数中最小的数</span></span><br><span class="line"><span class="comment">// 那就只需要对最后边的一个逆序对操作嘛</span></span><br><span class="line"><span class="comment">// 但是还是不能简单的将逆序对的数字交换</span></span><br><span class="line"><span class="comment">// 需要将逆序对的前一个元素和它后面的最后一个比它大的数交换才行</span></span><br><span class="line"><span class="comment">// 交换完之后还要将逆序对后面的所有元素进行一次反转</span></span><br><span class="line"><span class="comment">// 因为此时后面的那些元素必定是降序排列的, 反转之后值会进一步变小</span></span><br><span class="line"><span class="comment">// 说起来太抽象了, 下面直接看代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(to_string(n))</span></span>;</span><br><span class="line">    <span class="comment">// 从后往前走</span></span><br><span class="line">    <span class="comment">// 定位到第一个逆序对, pivot 指向逆序对的第一个元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = s.size() - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(; pivot &gt;= <span class="number">0</span>; pivot--)</span><br><span class="line">        <span class="keyword">if</span>(s[pivot] &lt; s[pivot + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 如果没有逆序对, 说明不可能组合成比原来大的数</span></span><br><span class="line">    <span class="keyword">if</span>(pivot == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 从后往前走, 定位到第一个比 pivot 指向元素大的元素</span></span><br><span class="line">    <span class="keyword">int</span> larger = s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; larger &gt; pivot; larger--)</span><br><span class="line">        <span class="keyword">if</span>(s[pivot] &lt; s[larger]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 交换二者</span></span><br><span class="line">    swap(s[pivot], s[larger]);</span><br><span class="line">    <span class="comment">// 这时候 pivot 之后的所有元素肯定是降序排列的</span></span><br><span class="line">    <span class="comment">// 反转它们, 以求数值最小</span></span><br><span class="line">    reverse(s.begin() + pivot + <span class="number">1</span>, s.end());</span><br><span class="line">    <span class="comment">// 如果这个数比 int 类型数值范围, 就不符合题目要求了</span></span><br><span class="line">    <span class="keyword">if</span>(stol(s) &gt; INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> stoi(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="133-Clone-Graph"><a href="#133-Clone-Graph" class="headerlink" title="133. Clone Graph"></a><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">133. Clone Graph</a></h5><blockquote>
<p>  给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。</p>
<p>  图中的每个节点都包含它的值<code>val</code>（<code>int</code>）和其邻居的列表<code>list[Node]</code>。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   <span class="built_in">vector</span>&lt;Node *&gt; neighbors;</span><br><span class="line">   Node(<span class="keyword">int</span> _val)</span><br><span class="line">   &#123;</span><br><span class="line">       val = _val;</span><br><span class="line">       neighbors = <span class="built_in">vector</span>&lt;Node *&gt;();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  <strong>Example:</strong></p>
  <img src="133_clone_graph_question.png" alt="img" style="zoom: 25%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Output: [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Explanation: There are 4 nodes in the graph.</span><br><span class="line">1st node (val &#x3D; 1)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">2nd node (val &#x3D; 2)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br><span class="line">3rd node (val &#x3D; 3)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">4th node (val &#x3D; 4)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接深度优先搜索即可</span></span><br><span class="line"><span class="comment">// 只是需要使用一个哈希表来记录已经 new 过的节点</span></span><br><span class="line"><span class="comment">// 哈希表中记录的是原节点和拷贝节点之间的映射</span></span><br><span class="line"><span class="comment">// 下次通过某节点的邻居遍历到相同的节点直接从哈希表中取就可以了</span></span><br><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; visited;</span><br><span class="line">    <span class="keyword">return</span> dfs(node, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node, <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果这个节点已经 被克隆过了</span></span><br><span class="line">    <span class="comment">// 直接从哈希表中返回其映射</span></span><br><span class="line">    <span class="keyword">if</span>(visited.count(node)) <span class="keyword">return</span> visited[node];</span><br><span class="line">    <span class="comment">// 克隆当前节点</span></span><br><span class="line">    Node* res = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">    <span class="comment">// 记录映射</span></span><br><span class="line">    visited[node] = res;</span><br><span class="line">    <span class="comment">// 深度遍历其所有邻居</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; neighbors = node-&gt;neighbors;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; neighbors.size(); i++)</span><br><span class="line">        <span class="comment">// 将其一一添加进拷贝节点的邻居中</span></span><br><span class="line">        res-&gt;neighbors.push_back(dfs(neighbors[i], visited));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">494. Target Sum</a></h5><blockquote>
<p>  给定一个非负整数数组，<code>a1, a2, ..., an</code>和一个目标数<code>S</code>。现在你有两个符号<code>+</code>和<code>-</code>。对于数组中的任意一个整数，你都可以从<code>+</code>或<code>-</code>中选择一个符号添加在前面。</p>
<p>  返回可以使最终数组和为目标数<code>S</code>的所有添加符号的方法数。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先上暴力搜索 (dfs) 穷举所有添加方法的结果</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(2^n), n 为数组长度</span></span><br><span class="line"><span class="comment">// 空间复杂度为 O(n) 递归调用栈的空间</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs(nums, <span class="number">0</span>, S);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意这里用到的一个技巧是</span></span><br><span class="line"><span class="comment">// 等式左边的数相加或相减起来 = S, 等价于 S + 等式左边的那些数相加或相减 = 0</span></span><br><span class="line"><span class="comment">// 它们的个数肯定相等嘛</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos, <span class="keyword">long</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="number">0</span>) count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// S += nums[pos]; // 做选择</span></span><br><span class="line">    <span class="comment">// dfs(nums, pos + 1, S);</span></span><br><span class="line">    <span class="comment">// S -= nums[pos]; // 撤销选择</span></span><br><span class="line">    dfs(nums, pos + <span class="number">1</span>, S + nums[pos]); <span class="comment">// 函数进入自动做选择, 返回自动撤销选择</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// S -= nums[pos]; // 做选择</span></span><br><span class="line">    <span class="comment">// dfs(nums, pos + 1, S);</span></span><br><span class="line">    <span class="comment">// S += nums[pos]; // 撤销选择</span></span><br><span class="line">    dfs(nums, pos + <span class="number">1</span>, S - nums[pos]); <span class="comment">// 函数进入自动做选择, 返回自动撤销选择</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们从上面可以注意到递归过程中出现了许多的重复计算</span></span><br><span class="line"><span class="comment">// 比如, nums[pos] == 0 的时候, dfs(num, pos + 1, S) 要计算 2 次</span></span><br><span class="line"><span class="comment">// 除了这种特殊情况还有许多</span></span><br><span class="line"><span class="comment">// 这里我们就使用备忘录来消除重叠子问题</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums, <span class="number">0</span>, S);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要修改一下递归函数的定义</span></span><br><span class="line"><span class="comment">// int dfs(vector&lt;int&gt;&amp; nums, pos, int S)</span></span><br><span class="line"><span class="comment">// 表示在 pos 位置加正负号使其和等于 S 有多少种方法</span></span><br><span class="line"><span class="comment">// 这样递推式就是 dfs(.., pos, S) = </span></span><br><span class="line"><span class="comment">// dfs(.., pos + 1, S + nums[pos]) /* pos 位置加正号的话 */</span></span><br><span class="line"><span class="comment">//  + dfs(.., pos + 1, S - nums[pos]) /* pos 位置加负号的话 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos, <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要将这两个参数转为字符串作为哈希表的键</span></span><br><span class="line">    <span class="comment">// 把 [状态] 转化为字符串作为键是一种小技巧</span></span><br><span class="line">    <span class="built_in">string</span> key = to_string(pos) + <span class="string">","</span> + to_string(S);</span><br><span class="line">    <span class="keyword">if</span>(memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line">    <span class="keyword">int</span> res = dfs(nums, pos + <span class="number">1</span>, S + nums[pos]) + dfs(nums, pos + <span class="number">1</span>, S - nums[pos]);</span><br><span class="line">    memo[key] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面使用的优化方法来看</span></span><br><span class="line"><span class="comment">// 似乎有 [动态规划] 的影子</span></span><br><span class="line"><span class="comment">// 现在让我们再转化一下思路</span></span><br></pre></td></tr></table></figure>

<h5 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. Implement Queue using Stacks</a></h5><blockquote>
<p>  请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作：</p>
<p>  实现<code>MyQueue</code>类：</p>
<p>  <code>void push(int x)</code>：将元素x推到队列的末尾；<br>  <code>int pop()</code>：从队列的开头移除并返回元素；<br>  <code>int peek()</code>：返回队列开头的元素；<br>  <code>bool empty()</code>：如果队列为空，返回<code>true</code>；否则，返回<code>false</code>。</p>
  <img src="2.jpg" alt="img" style="zoom: 33%;" />
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如上图, 将两个栈这样放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 入栈的时候直接放进右边的栈即可</span></span><br><span class="line">        _back.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 出栈的时候从左边出</span></span><br><span class="line">        <span class="comment">// 如果为空, 需要把右边栈的元素搬过来</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) moveData();</span><br><span class="line">        <span class="comment">// 搬过来之后直接 pop 左边的栈即可</span></span><br><span class="line">        <span class="keyword">int</span> res = _front.top();</span><br><span class="line">        _front.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 取的时候和 pop 的情况一样</span></span><br><span class="line">        <span class="keyword">if</span>(_front.empty()) moveData();</span><br><span class="line">        <span class="comment">// 只是不出栈, 只取元素</span></span><br><span class="line">        <span class="keyword">return</span> _front.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _front.empty() &amp;&amp; _back.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _front;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _back;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 搬移数据就是简单的将右边栈出栈</span></span><br><span class="line">        <span class="comment">// 左边栈接收元素压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(!_back.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            _front.push(_back.top());</span><br><span class="line">            _back.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. Implement Stack using Queues</a></h5><blockquote>
<p>  请你仅使用两个队列实现一个后入先出的栈，并支持普通队列的全部四种操作。</p>
<p>  实现<code>MyStack</code>类：</p>
<p>  <code>void push(int x)</code>：将元素<code>x</code>压入栈顶；<br>  <code>int pop()</code>：移除并返回栈顶元素；<br>  <code>int top()</code>：返回栈顶元素；<br>  <code>bool empty()</code>：如果栈是空的，返回<code>true</code>；否则，返回<code>false</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列实现栈</span></span><br><span class="line"><span class="comment">// 入栈操作很简单, 调用队列的 push 即可</span></span><br><span class="line"><span class="comment">// 出栈麻烦点, 因为队列只能从对头出列, 对头相当于栈的栈底</span></span><br><span class="line"><span class="comment">// 但我们是想 pop 掉队尾元素</span></span><br><span class="line"><span class="comment">// 这时很暴力, 直接把队列中除了队尾之外的所有元素依次出队并依次入队即可</span></span><br><span class="line"><span class="comment">// 这时对头就是原队尾元素了, 再出队就行</span></span><br><span class="line"><span class="comment">// 获取栈顶元素的话, 为了实现 O(1) 复杂度</span></span><br><span class="line"><span class="comment">// 使用一个变量实时记录队尾 (栈顶) 元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 入队的时候要更新栈顶变量</span></span><br><span class="line">        _top = x;</span><br><span class="line">        _queue.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _queue.size();</span><br><span class="line">        <span class="keyword">while</span>(sz-- &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _top = _queue.front();</span><br><span class="line">            _queue.pop();</span><br><span class="line">            _queue.push(_top);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = _queue.front();</span><br><span class="line">        _queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _top;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line">    <span class="keyword">int</span> _top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands</a></h5><blockquote>
<p>给定一个<code>m x n</code>字符栅格网格，该栅格网格表示<code>&#39;1&#39;</code>（土地）和<code>&#39;0&#39;</code>（水）的地图，请返回岛的数量。</p>
<p>一个岛屿被水包围，是通过水平或垂直连接相邻的土地而形成的。 您可以假设网格的所有四个边缘都被水包围。</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code></li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思想是</span></span><br><span class="line"><span class="comment">// 1. 依次遍历网格中的每一个字符</span></span><br><span class="line"><span class="comment">// 2. 如果当前字符是 '1' 说明踏上了一座岛, 进行下一步, 如果为 '0'，回到步骤 1</span></span><br><span class="line"><span class="comment">// 3. 然后骚操作来了, 将当前字符赋值为 '0'</span></span><br><span class="line"><span class="comment">// 4. 然后遍历当前字符的上下左右四个邻居</span></span><br><span class="line"><span class="comment">// 5. 每到一个邻居重复对当前字符的操作</span></span><br><span class="line"><span class="comment">// 6. 直到某一个邻居 (可以是邻居的邻居) 的四个邻居都为'0'</span></span><br><span class="line"><span class="comment">// 7. 说明这座岛的每一个陆地都走过了, 此时岛数量 +1</span></span><br><span class="line"><span class="comment">// 8. 接下来再到下一个字符, 回到步骤 1</span></span><br><span class="line"><span class="comment">// 遍历邻居的时候有两种方法, dfs 和 bfs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs 借助队列的迭代实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中保存的是当前陆地的坐标</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                count++;</span><br><span class="line">                q.push(&#123;i, j&#125;);</span><br><span class="line">                <span class="comment">// while 循环的目的是把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                <span class="keyword">while</span>(!q.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = q.front().first;</span><br><span class="line">                    <span class="keyword">int</span> c = q.front().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size()</span><br><span class="line">                       	|| c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 淹没陆地</span></span><br><span class="line">                    grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="comment">// 判断左邻居</span></span><br><span class="line">                    q.push(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="comment">// 判断右邻居</span></span><br><span class="line">                    q.push(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="comment">// 判断上邻居</span></span><br><span class="line">                    q.push(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="comment">// 判断下邻居</span></span><br><span class="line">                    q.push(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="694-Number-of-Distinct-Islands"><a href="#694-Number-of-Distinct-Islands" class="headerlink" title="694. Number of Distinct Islands"></a><a href="https://leetcode.com/problems/number-of-distinct-islands/" target="_blank" rel="noopener">694. Number of Distinct Islands</a></h5><blockquote>
<p>  给定一个非空<code>01</code>二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的<code>1</code>组成，你可以认为网格的四周被海水包围。</p>
<p>  请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。</p>
<p>  <strong>示例 1：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00011</span><br><span class="line">00011</span><br><span class="line">给定上图，返回结果 1 。</span><br></pre></td></tr></table></figure>

<p>  <strong>示例 2：</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11011</span><br><span class="line">10000</span><br><span class="line">00001</span><br><span class="line">11011</span><br><span class="line">给定上图，返回结果 3 。</span><br></pre></td></tr></table></figure>

<p>  注意：</p>
<p>  11<br>  1</p>
<p>  和</p>
<p>  1<br>  11<br>  是不同的岛屿，因为我们不考虑旋转、翻转操作。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; setting;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                <span class="comment">// isLand 用于记录这座岛的所有陆地坐标</span></span><br><span class="line">                <span class="comment">// 实际记录的是相对陆地坐标, 即其他陆地相对于左上角的那块陆地</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; isLand;</span><br><span class="line">                <span class="comment">// 更新当前岛屿的相对坐标</span></span><br><span class="line">                x = i;</span><br><span class="line">                y = j;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, isLand, i, j);</span><br><span class="line">                <span class="comment">// set 有自动排序和去重的功能</span></span><br><span class="line">                setting.insert(isLand);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setting.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; isLand, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    isLand.push_back(&#123;r - x, c - y&#125;);</span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, isLand, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, isLand, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, isLand, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, isLand, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1254-Number-of-Closed-Islands"><a href="#1254-Number-of-Closed-Islands" class="headerlink" title="1254. Number of Closed Islands"></a><a href="https://leetcode.com/problems/number-of-closed-islands/" target="_blank" rel="noopener">1254. Number of Closed Islands</a></h5><blockquote>
<p>  有一个二维矩阵<code>grid</code>，每个位置要么是陆地（记号为<code>0</code>）要么是水域（记号为<code>1</code>）。</p>
<p>  我们从一块陆地出发，每次可以往上下左右<code>4</code>个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。</p>
<p>  如果一座岛屿完全由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。</p>
<p>  请返回封闭岛屿的数目。</p>
<p>  <strong>Example 1:</strong></p>
<p>  <img src="sample_3_1610.png" alt="img"></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Islands in gray are closed because they are completely surrounded by water (group of 1s).</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
<p>  <img src="sample_4_1610.png" alt="img"></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这题 1 代表水域而 0 代表陆地</span></span><br><span class="line"><span class="comment">// 和岛屿数量 I 题的区别在于边界上的岛屿不算岛屿</span></span><br><span class="line"><span class="comment">// 所以如果搜索出来的岛屿在边界上就不更新岛屿数</span></span><br><span class="line"><span class="keyword">bool</span> flag; <span class="comment">// 是否是封闭岛的标志</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowLength = grid.size();</span><br><span class="line">    <span class="keyword">int</span> colLength = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colLength; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛</span></span><br><span class="line">                <span class="comment">// 看它是否是边界岛</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                <span class="keyword">if</span>(flag) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 能到达边界, 说明不是封闭岛</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(grid[r][c] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="695-Max-Area-of-Island"><a href="#695-Max-Area-of-Island" class="headerlink" title="695. Max Area of Island"></a><a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener">695. Max Area of Island</a></h5><blockquote>
<p>  给定一个包含了一些<code>0</code>和<code>1</code>的非 空二维数组<code>grid</code>。</p>
<p>  一个岛屿是由一些相邻的<code>1</code>(代表土地) 构成的组合，这里的「相邻」要求两个<code>1</code>必须在水平或者竖直方向上相邻。你可以假设<code>grid</code>的四个边缘都被<code>0</code>（代表水）包围着。</p>
<p>  找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为<code>0</code> )</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">[0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line">[0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line">[0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">Given the above grid, return &#96;6&#96;. Note the answer is not 11, because the island must be connected 4-directionally.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line"></span><br><span class="line">Given the above grid, return &#96;0&#96;.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="keyword">int</span> area; <span class="comment">// 用于记录每个岛的面积</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 踏上了一座岛就把先前岛屿面积清零</span></span><br><span class="line">                area = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 递归函数的目的把这座岛的所有陆地变成水 (淹没)</span></span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res = max(res, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.size() || c == grid[<span class="number">0</span>].size() || grid[r][c] != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 淹没陆地</span></span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    area++;</span><br><span class="line">    <span class="comment">// 判断左邻居</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断右邻居</span></span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="comment">// 判断上邻居</span></span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断下邻居</span></span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="733-Flood-Fill"><a href="#733-Flood-Fill" class="headerlink" title="733. Flood Fill"></a><a href="https://leetcode.com/problems/flood-fill/" target="_blank" rel="noopener">733. Flood Fill</a></h5><blockquote>
<p>  有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在<code>0</code>到<code>65535</code>之间。</p>
<p>  给你一个坐标<code>(sr, sc)</code>表示图像渲染开始的像素值（行 ，列）和一个新的颜色值<code>newColor</code>，让你重新上色这幅图像。</p>
<p>  为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p>
<p>  最后返回经过上色渲染后的图像。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected </span><br><span class="line">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class="line">to the starting pixel.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和前面那个岛屿数量 I 的题思路差不多</span></span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(image[sr][sc] != newColor)</span><br><span class="line">        dfs(image, sr, sc, image[sr][sc], newColor);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> srcColor, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == image.size() || c == image[<span class="number">0</span>].size() || image[r][c] != srcColor)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    image[r][c] = newColor;</span><br><span class="line">    dfs(image, r + <span class="number">1</span>, c, srcColor, newColor);</span><br><span class="line">    dfs(image, r - <span class="number">1</span>, c, srcColor, newColor);</span><br><span class="line">    dfs(image, r, c + <span class="number">1</span>, srcColor, newColor);</span><br><span class="line">    dfs(image, r, c - <span class="number">1</span>, srcColor, newColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">floodFill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> srcColor = image[sr][sc];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(&#123;sr, sc&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> c = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == image.size() || c == image[<span class="number">0</span>].size() || image[r][c] != srcColor)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            image[r][c] = newColor;</span><br><span class="line">            q.push(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">            q.push(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">            q.push(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">            q.push(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="542-01-Matrix"><a href="#542-01-Matrix" class="headerlink" title="542. 01 Matrix"></a><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener">542. 01 Matrix</a></h5><blockquote>
<p>给定一个由<code>0</code>和<code>1</code>组成的矩阵，找出每个元素到最近的<code>0</code>的距离。</p>
<p>两个相邻元素间的距离为<code>1</code>。矩阵中的元素只在四个方向上相邻：上、下、左、右。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[0,0,0]]</span><br><span class="line"></span><br><span class="line">&gt;Output:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[0,0,0]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[1,1,1]]</span><br><span class="line"></span><br><span class="line">&gt;Output:</span><br><span class="line">&gt;[[0,0,0],</span><br><span class="line">&gt;[0,1,0],</span><br><span class="line">&gt;[1,2,1]]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为要寻找 [最近] 距离, 所以显然使用 BFS</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rSize = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> cSize = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(rSize, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cSize))</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为要对矩阵中的所有元素进行寻找最近的 0</span></span><br><span class="line">    <span class="comment">// 所以外面的两层循环实际上是处理这个问题的</span></span><br><span class="line">    <span class="comment">// 如果只需要对一个元素进行寻找就不需要这两层循环, 和传统的 BFS 模板一样</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            step = <span class="number">0</span>;</span><br><span class="line">            q.push(&#123;i, j&#125;);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sz = q.size();</span><br><span class="line">                <span class="keyword">while</span>(sz--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 从当前位置出发, 遍历其所有邻居</span></span><br><span class="line">                    <span class="keyword">int</span> r = q.front().first;</span><br><span class="line">                    <span class="keyword">int</span> c = q.front().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    <span class="comment">// 如果 走到了 0, 那么它离 0 的最近距离就是已经走的 step</span></span><br><span class="line">                    <span class="keyword">if</span>(matrix[r][c] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        res[i][j] = step;</span><br><span class="line">                        <span class="comment">// 更新完 step 之后还要将队列清空方便对下一位置进行搜索时使用</span></span><br><span class="line">                        <span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将其上下左右四个邻居入栈等待搜索</span></span><br><span class="line">                    <span class="keyword">if</span>(r + <span class="number">1</span> &lt; rSize) q.push(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(r - <span class="number">1</span> &gt;= <span class="number">0</span>) q.push(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(c + <span class="number">1</span> &lt; cSize) mq.push(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="keyword">if</span>(c - <span class="number">1</span> &gt;= <span class="number">0</span>) q.push(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="841-Keys-and-Rooms"><a href="#841-Keys-and-Rooms" class="headerlink" title="841. Keys and Rooms"></a><a href="https://leetcode.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. Keys and Rooms</a></h5><blockquote>
<p>  有<code>N</code>个房间，开始时你位于<code>0</code>号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p>
<p>  在形式上，对于每个房间<code>i</code>都有一个钥匙列表<code>rooms[i]</code>，每个钥匙<code>rooms[i][j]</code>由<code>[0,1，...，N-1]</code>中的一个整数表示，其中<code>N = rooms.length</code>。 钥匙<code>rooms[i][j] = v</code>可以打开编号为<code>v</code>的房间。</p>
<p>  最初，除<code>0</code>号房间外的其余所有房间都被锁住。</p>
<p>  你可以自由地在房间之间来回走动。</p>
<p>  如果能进入每个房间返回<code>true</code>，否则返回<code>false</code>。</p>
<p>  <strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= rooms.length &lt;= 1000</code></li>
<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>
<li>The number of keys in all rooms combined is at most <code>3000</code>.</li>
</ol>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&#39;t enter the room with number 2.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为最多就 1000 个房间</span></span><br><span class="line"><span class="comment">// 需要对已经访问过的房间进行标记</span></span><br><span class="line"><span class="comment">// 所以这里我们使用一个 bitset</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 所有房间初始化全未被访问</span></span><br><span class="line">    <span class="built_in">bitset</span>&lt;1000&gt; bits;</span><br><span class="line">    <span class="comment">// 从 0 号房间开始</span></span><br><span class="line">    <span class="keyword">return</span> dfs(rooms, <span class="number">0</span>, bits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为我们是想要搜索到一种可能满足的访问次序就可以</span></span><br><span class="line"><span class="comment">// 所以这里的 dfs 函数有 bool 返回值来提前结束搜索</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms, <span class="keyword">int</span> room, <span class="built_in">bitset</span>&lt;<span class="number">1000</span>&gt;&amp; bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 访问当前房间, 标记为已访问</span></span><br><span class="line">    bits.<span class="built_in">set</span>(room);</span><br><span class="line">    <span class="comment">// 如果访问的房间总数等于所有房间数</span></span><br><span class="line">    <span class="keyword">if</span>(bits.count() == rooms.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 否则, 从当前房间获取其它房间钥匙, 依次进行访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curRoom = rooms[room];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> key : curRoom)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果这把钥匙对应的房间已经被访问过, 就不过去了</span></span><br><span class="line">        <span class="keyword">if</span>(bits.test(key)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 否则去访问</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(rooms, key, bits)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/wF5qv4uNKgDG1SUa/" rel="prev" title="操作系统之malloc底层原理">
      <i class="fa fa-chevron-left"></i> 操作系统之malloc底层原理
    </a></div>
      <div class="post-nav-item">
    <a href="/tRettVqCkfzWbulf/" rel="next" title="操作系统之进程间通信（含内核实现）">
      操作系统之进程间通信（含内核实现） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80OTQ0NS8yNTkzNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue-and-Stack"><span class="nav-number">1.</span> <span class="nav-text">Queue and Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1660-Correct-a-Binary-Tree"><span class="nav-number">1.1.</span> <span class="nav-text">1660. Correct a Binary Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#394-Decode-String"><span class="nav-number">1.2.</span> <span class="nav-text">394. Decode String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#752-Open-the-Lock"><span class="nav-number">1.3.</span> <span class="nav-text">752. Open the Lock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#37-Sudoku-Solver"><span class="nav-number">1.4.</span> <span class="nav-text">37. Sudoku Solver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#279-Perfect-Squares"><span class="nav-number">1.5.</span> <span class="nav-text">279. Perfect Squares</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#155-Min-Stack"><span class="nav-number">1.6.</span> <span class="nav-text">155. Min Stack</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#739-Daily-Temperatures"><span class="nav-number">1.7.</span> <span class="nav-text">739. Daily Temperatures</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#496-Next-Greater-Element-I"><span class="nav-number">1.8.</span> <span class="nav-text">496. Next Greater Element I</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#503-Next-Greater-Element-II"><span class="nav-number">1.9.</span> <span class="nav-text">503. Next Greater Element II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#556-Next-Greater-Element-III"><span class="nav-number">1.10.</span> <span class="nav-text">556. Next Greater Element III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#133-Clone-Graph"><span class="nav-number">1.11.</span> <span class="nav-text">133. Clone Graph</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#494-Target-Sum"><span class="nav-number">1.12.</span> <span class="nav-text">494. Target Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#232-Implement-Queue-using-Stacks"><span class="nav-number">1.13.</span> <span class="nav-text">232. Implement Queue using Stacks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#225-Implement-Stack-using-Queues"><span class="nav-number">1.14.</span> <span class="nav-text">225. Implement Stack using Queues</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#200-Number-of-Islands"><span class="nav-number">1.15.</span> <span class="nav-text">200. Number of Islands</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#694-Number-of-Distinct-Islands"><span class="nav-number">1.16.</span> <span class="nav-text">694. Number of Distinct Islands</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1254-Number-of-Closed-Islands"><span class="nav-number">1.17.</span> <span class="nav-text">1254. Number of Closed Islands</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#695-Max-Area-of-Island"><span class="nav-number">1.18.</span> <span class="nav-text">695. Max Area of Island</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#733-Flood-Fill"><span class="nav-number">1.19.</span> <span class="nav-text">733. Flood Fill</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#542-01-Matrix"><span class="nav-number">1.20.</span> <span class="nav-text">542. 01 Matrix</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#841-Keys-and-Rooms"><span class="nav-number">1.21.</span> <span class="nav-text">841. Keys and Rooms</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

      <!-- 音乐播放器 -->
      <div>
      
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=300 height="400" src="//music.163.com/outchain/player?type=0&id=6679290542&auto=1&height=400"></iframe>
      
      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>