<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章是leetcode刷题系列的第1部分——队列和栈。这里把有代表性的题目发出来，共计30道。主要涉及滑动窗口、哈希表、堆、二分搜索等技术的应用。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题系列之数组">
<meta property="og:url" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="这篇文章是leetcode刷题系列的第1部分——队列和栈。这里把有代表性的题目发出来，共计30道。主要涉及滑动窗口、哈希表、堆、二分搜索等技术的应用。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/hint_valid_mountain_array.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/title.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/question_11.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/rainwatertrap.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/searchgrid.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/searchgrid2.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/diag1-grid.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/sample_1_1784.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/sample_2_1784.png">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/spiral1.jpg">
<meta property="og:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/spiral.jpg">
<meta property="article:published_time" content="2021-04-10T13:35:42.000Z">
<meta property="article:modified_time" content="2021-04-10T13:35:42.000Z">
<meta property="article:author" content="Liu Y.L.">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/hint_valid_mountain_array.png">

<link rel="canonical" href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode刷题系列之数组 | LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode刷题系列之数组
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 21:35:42" itemprop="dateCreated datePublished" datetime="2021-04-10T21:35:42+08:00">2021-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>39k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>36 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章是<code>leetcode</code>刷题系列的第<code>1</code>部分——队列和栈。这里把有代表性的题目发出来，共计<code>30</code>道。主要涉及滑动窗口、哈希表、堆、二分搜索等技术的应用。</p>
<p>接下来这几个月，计划完成的<code>leetcode</code>刷题系列其组织如下：</p>
<p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. 字符串</p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. 动态规划</p>
<p><code>7</code>. 数据结构设计</p>
<p>预计涉及题目至少<code>300</code>道！</p>
<a id="more"></a>

<h5 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. Two Sum II - Input array is sorted</a></h5><blockquote>
<p>给定一个<strong>有序整数数组</strong>和一个目标数，在数组中找到总和等于目标数的两个元素，返回它们的索引。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左右指针</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span>(sum == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left, right&#125;);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum</a></h5><blockquote>
<p>给定一个<strong>无序整数数组</strong>和一个目标数，在数组中找到总和等于目标数的两个元素，返回它们的索引。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助 hashtable 记录元素的存在情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(target - nums[i]) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;mapping[target - nums[i]], i&#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mapping[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Design-a-TwoSum-Class"><a href="#Design-a-TwoSum-Class" class="headerlink" title="Design a TwoSum Class"></a><code>Design a TwoSum Class</code></h5><blockquote>
<p>设计一个<code>TwoSum</code>类，拥有两个<code>API</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span></span></span><br><span class="line"><span class="class">&gt;&#123;</span></span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">&gt;<span class="comment">// 向数据结构中添加一个数 number</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此种解法适用于频繁 add 的情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向数据结构中添加一个数 number</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mapping[number]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : mapping)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> other = value - elem.first;</span><br><span class="line">            <span class="comment">// 处理两个相同的数相加等于 value 的情况</span></span><br><span class="line">            <span class="comment">// 因为这个数出现了两次以上</span></span><br><span class="line">            <span class="keyword">if</span>(other == elem.first &amp;&amp; mapping.count(other) &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这是不同的两个数相加为 value</span></span><br><span class="line">            <span class="keyword">if</span>(other != elem.first &amp;&amp; mapping.count(other) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此种解法适用于频繁 find 的情况</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向数据结构中添加一个数 number</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 记录所有可能的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums) setting.insert(n + number);</span><br><span class="line">        nums.push_back(number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找当前数据结构中是否存在两个数的和为 value</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> setting.count(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="560-Subarray-Sum-Equals-K"><a href="#560-Subarray-Sum-Equals-K" class="headerlink" title="560. Subarray Sum Equals K"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. Subarray Sum Equals K</a></h5><blockquote>
<p>给定一个整数数组和一个目标数，返回数组中其总和等于目标数的<strong>连续子数组的个数</strong>。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为这题数组中可以存在负数, 所有不能使用滑动窗口方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前缀和数组的暴力解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefixSum</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 计算前缀和数组</span></span><br><span class="line">    <span class="comment">// 子数组和 nums[i..j] = prefixSum[j + 1] - prefixSum[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        prefixSum[i + <span class="number">1</span>] = prefixSum[i] + nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(prefixSum[i] - prefixSum[j] == k)</span><br><span class="line">                res++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助前缀和思想</span></span><br><span class="line"><span class="comment">// 使用 hashtable 记录所有的前缀和及其对应的数目</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须存在的 base case</span></span><br><span class="line">    <span class="comment">// 表示 sum 直接等于 k 的情况</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(sum - k) &gt; <span class="number">0</span>)</span><br><span class="line">            res += mapping[sum - k];</span><br><span class="line">        mapping[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="724-Find-Pivot-Index"><a href="#724-Find-Pivot-Index" class="headerlink" title="724. Find Pivot Index"></a><a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">724. Find Pivot Index</a></h5><blockquote>
<p>给定一个整数数组，请计算该数组的枢轴索引。枢轴索引使得该索引左侧的所有数字的总和等于在该索引右侧的所有数字的总和。</p>
<p>如果索引在数组的左边缘，则左总和为<code>0</code>，因为左侧没有元素，这也适用于数组的右边缘。如果存在多个枢轴索引，返回最左边的。 如果不存在这样的索引，则返回<code>-1</code>。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,7,3,6,5,6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The pivot index is 3.</span><br><span class="line">Left sum &#x3D; nums[0] + nums[1] + nums[2] &#x3D; 1 + 7 + 3 &#x3D; 11</span><br><span class="line">Right sum &#x3D; nums[4] + nums[5] &#x3D; 5 + 6 &#x3D; 11</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">There is no index that satisfies the conditions in the problem statement.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,1,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">The pivot index is 0.</span><br><span class="line">Left sum &#x3D; 0 (no elements to the left of index 0)</span><br><span class="line">Right sum &#x3D; nums[1] + nums[2] &#x3D; 1 + -1 &#x3D; 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(N), S: O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefixSum</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 计算前缀和数组</span></span><br><span class="line">    <span class="comment">// 子数组和 nums[i..j] = prefixSum[j + 1] - prefixSum[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        prefixSum[i + <span class="number">1</span>] = prefixSum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">if</span>((prefixSum[i] - prefixSum[<span class="number">0</span>]) == (prefixSum[nums.size()] - prefixSum[i + <span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(N), S: O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum - leftSum - nums[i] == leftSum)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="523-Continuous-Subarray-Sum"><a href="#523-Continuous-Subarray-Sum" class="headerlink" title="523. Continuous Subarray Sum"></a><a href="https://leetcode.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. Continuous Subarray Sum</a></h5><blockquote>
<p>给定一个非负整数数组和目标整数<code>k</code>，编写一个函数以检查该数组是否具有大小至少为<code>2</code>的连续子数组，该子数组的总和为<code>k</code>的倍数。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: [23, 2, 4, 6, 7],  k &#x3D; 6</span><br><span class="line">&gt;Output: True</span><br><span class="line">&gt;Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: [23, 2, 6, 4, 7],  k &#x3D; 6</span><br><span class="line">&gt;Output: True</span><br><span class="line">&gt;Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数学知识 (a - b) % c = 0 --&gt; a % c = b % c</span></span><br><span class="line"><span class="comment">// 借助前缀和思想</span></span><br><span class="line"><span class="comment">// 使用哈希表记录所有的 (前缀和对 k 的余数) 及其 (对应的索引)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 必须存在的 base case</span></span><br><span class="line">    <span class="comment">// 表示 0 对 k 取余为 0. 索引为 -1</span></span><br><span class="line">    <span class="comment">// 为了处理 sum 本身 对 k 取余为 0 的情况</span></span><br><span class="line">    <span class="comment">// 也就是说这时满足条件的数组是首元素打头的子数组</span></span><br><span class="line">    mapping[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">int</span> mod = sum % k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记住对于前缀和数组</span></span><br><span class="line">        <span class="comment">// 子数组和 nums[i..j] = prefixSum[j + 1] - prefixSum[i]</span></span><br><span class="line">        <span class="comment">// 就理解了为什么是 &gt; 1 而不是 &gt;= 1 了</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(mod) &gt; <span class="number">0</span> &amp;&amp; (i - mapping[mod] &gt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 已经存在了就不更新它</span></span><br><span class="line">        <span class="comment">// 因为记录最靠前的比较好</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(mod) == <span class="number">0</span>) mapping[mod] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1089-Duplicate-Zeros"><a href="#1089-Duplicate-Zeros" class="headerlink" title="1089. Duplicate Zeros"></a><a href="https://leetcode.com/problems/duplicate-zeros/" target="_blank" rel="noopener">1089. Duplicate Zeros</a></h5><blockquote>
<p>给定固定长度的整数数组<code>arr</code>，请复制每次出现的零，将其余元素向右移动。请注意，不会写入超出原始数组长度的元素。</p>
<p>对输入数组进行就地修改，不要从函数中返回任何内容。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2,3,0,4,5,0]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,2,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 两种方法都要从后向前遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力解法, 最坏时间复杂度为 O(n2)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.size() - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的解法, 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 提前计算出原始数组中 0 的个数</span></span><br><span class="line">    <span class="keyword">int</span> zerosCnt = count(arr.begin(), arr.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 计算非零元素的新索引</span></span><br><span class="line">            <span class="comment">// 在此处, 保证 zerosCnt 变量始终是大于 0 的</span></span><br><span class="line">            <span class="comment">// 且表示此非零元素前面的 0 的个数</span></span><br><span class="line">            <span class="keyword">int</span> newPos = i + zerosCnt;</span><br><span class="line">            <span class="comment">// 如果有效就搬过去</span></span><br><span class="line">            <span class="keyword">if</span>(newPos &lt; arr.size())</span><br><span class="line">                arr[newPos] = arr[i];</span><br><span class="line">            <span class="comment">// 原索引处赋 0</span></span><br><span class="line">            arr[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(--zerosCnt &lt;= <span class="number">0</span>) <span class="comment">// 每次遇到一个 0, 就减 1</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 前面没有 0 了, 就不需要搬移了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="941-Valid-Mountain-Array"><a href="#941-Valid-Mountain-Array" class="headerlink" title="941. Valid Mountain Array"></a><a href="https://leetcode.com/problems/valid-mountain-array/" target="_blank" rel="noopener">941. Valid Mountain Array</a></h5><blockquote>
<p>给定一个整数数组<code>arr</code>，当且仅当它是有效的山峰数组时，才返回<code>true</code>。当且仅当满足以下条件时，<code>arr</code>是一个山峰数组：</p>
<ul>
<li><code>arr.size() &gt;= 3</code></li>
<li>There exists some <code>i</code> with <code>0 &lt; i &lt; arr.size() - 1</code></li>
</ul>
<p>such that：</p>
<ul>
<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>
<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.size() - 1]</code></li>
</ul>
<img src="hint_valid_mountain_array.png" alt="img" style="zoom: 50%;" />

<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [3,5,5]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr &#x3D; [0,3,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == arr[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 判断拐点的位置</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果一开始就下降</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果一直是上升期</span></span><br><span class="line">            <span class="keyword">if</span>(i == (arr.size() - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断下降期</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; arr[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. Find All Numbers Disappeared in an Array</a></h5><blockquote>
<p>给定一个整数数组，其中<code>1 ≤ a[i] ≤ n (n = 数组大小)</code>，某些元素出现两次，而另一些元素出现一次。查找<code>[1，n]</code>包含的所有未出现在此数组中的元素。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将所有出现过的值作为索引 (值减 1 ), 将该索引所在处的值映射为负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">            nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 最后没被映射为负数的值, 其对应的索引 +1 就是未出现的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) res.push_back(i + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="442-Find-All-Duplicates-in-an-Array"><a href="#442-Find-All-Duplicates-in-an-Array" class="headerlink" title="442. Find All Duplicates in an Array"></a><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">442. Find All Duplicates in an Array</a></h5><blockquote>
<p>给定一个整数数组，即<code>1 ≤ a[i] ≤ n (n = 数组大小)</code>，某些元素出现一次，而一些元素没有出现。查找在此数组中出现两次的所有元素。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 将所有出现过的值作为索引 (值减 1 ), 将该索引所在处的值映射为负数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果已经被映射为负数, 说明之前这个数出现过一次了</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] &lt; <span class="number">0</span>) res.push_back(<span class="built_in">abs</span>(nums[i]));</span><br><span class="line">        <span class="keyword">else</span> nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="380-Insert-Delete-GetRandom-O-1-和381-Insert-Delete-GetRandom-O-1-Duplicates-allowed"><a href="#380-Insert-Delete-GetRandom-O-1-和381-Insert-Delete-GetRandom-O-1-Duplicates-allowed" class="headerlink" title="380. Insert Delete GetRandom O(1)和381. Insert Delete GetRandom O(1) - Duplicates allowed"></a><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">380. Insert Delete GetRandom O(1)</a>和<a href="https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">381. Insert Delete GetRandom O(1) - Duplicates allowed</a></h5><blockquote>
<p><img src="title.jpg" alt="title"></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是集合中元素唯一的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了使得能够以 O(1) 的复杂度随机访问元素, 用于存储数据的结构必须为 vector</span></span><br><span class="line"><span class="comment">// 为了使得删除元素的复杂度为 O(1), 可以通过将被删除元素与末尾元素互换, 再 pop_back()</span></span><br><span class="line"><span class="comment">// 但这必须能够知道每个元素对应的索引</span></span><br><span class="line"><span class="comment">// 所以, 使用一个哈希表来记录 (元素) 和其 (索引)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedSet() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        mapping[val] = nums.size();</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = mapping[val];</span><br><span class="line">        <span class="comment">// 先更新映射, 再操作数据</span></span><br><span class="line">        <span class="comment">// 接下来两条语句的顺序不可颠倒</span></span><br><span class="line">        <span class="comment">// 防止待删除的值就位于尾元素, 即 val == nums.back()</span></span><br><span class="line">        mapping[nums.back()] = i;</span><br><span class="line">        mapping.erase(val);</span><br><span class="line">        </span><br><span class="line">        swap(nums[i], nums.back());</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % nums.size();</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是集合中元素允许重复的情况</span></span><br><span class="line"><span class="comment">// 由于要记录所有重复元素的索引, 就就不能采用 1 对 1 映射了</span></span><br><span class="line"><span class="comment">// 需要采用 1 对 多 映射, 所以使用一个 unordered_map&lt;int, unordered_set&lt;int&gt;&gt;</span></span><br><span class="line"><span class="comment">// 为什么映射到的是一个 unordered_set&lt;int&gt; 而不是 vector&lt;int&gt; 呢?</span></span><br><span class="line"><span class="comment">// 原因是, 交换后, 需要 O(1) 删除末尾元素所对应的索引, 而这个索引值不一定存储在最后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedCollection() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) &gt; <span class="number">0</span>) res = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        mapping[val].insert(nums.size());</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mapping.count(val) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = *(mapping[val].begin()); <span class="comment">// 这个 i 相当于随机选的其中一个</span></span><br><span class="line">        <span class="keyword">if</span>(val == nums.back())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果要删除的值正好位于末元素的话</span></span><br><span class="line">            <span class="comment">// 直接在索引集合中删掉索引即可</span></span><br><span class="line">            <span class="comment">// 这是防止执行 else 中的 mapping[nums.back()].insert(i); 语句</span></span><br><span class="line">            <span class="comment">// 插入另一个和尾元素值相等的位于其他位置的索引</span></span><br><span class="line">            mapping[nums.back()].erase(nums.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 比如说数组中元素为 [2, 2, 2], 索引 set 中为 [0, 1, 2]</span></span><br><span class="line">            <span class="comment">// 现在删除 val == 2, 此时 i 为 0, nums.back() == val, 执行下面三条语句</span></span><br><span class="line">            <span class="comment">// 语句 1 --&gt; set 变为 [0, 1]</span></span><br><span class="line">            <span class="comment">// 语句 2 --&gt; set 变为 [0, 0, 1] --&gt; [0, 1]</span></span><br><span class="line">            <span class="comment">// 语句 3 --&gt; set 变为 [1]</span></span><br><span class="line">            <span class="comment">// 但显然预期的结果为 [0, 1]</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 否则, 需要删除末元素原本对应的索引, 插入新索引</span></span><br><span class="line">        	mapping[nums.back()].erase(nums.size() - <span class="number">1</span>);</span><br><span class="line">        	mapping[nums.back()].insert(i);</span><br><span class="line">            <span class="comment">// 删掉待删除元素的索引之一</span></span><br><span class="line">            mapping[val].erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果待删除元素只有一个, 还要删除整个映射项</span></span><br><span class="line">        <span class="keyword">if</span>(mapping[val].empty()) mapping.erase(val);</span><br><span class="line">        </span><br><span class="line">        swap(nums[i], nums.back());</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % nums.size();</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="710-Random-Pick-with-Blacklist"><a href="#710-Random-Pick-with-Blacklist" class="headerlink" title="710. Random Pick with Blacklist"></a><a href="https://leetcode.com/problems/random-pick-with-blacklist/" target="_blank" rel="noopener">710. Random Pick with Blacklist</a></h5><blockquote>
<p>给你输入一个正整数<code>N</code>，代表左闭右开区间<code>[0,N)</code>，再给你输入一个数组<code>blacklist</code>，其中包含一些「黑名单数字」，且<code>blacklist</code>中的数字都是区间<code>[0,N)</code>中的数字。</p>
<p>编写一个函数以随机返回<code>[0，N)</code>中的一个整数，该整数不在<code>blacklist</code>中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本思路是记录下实际有效的数字的个数 actual</span></span><br><span class="line"><span class="comment">// 通过一个哈希表将黑名单中的在 [0, actual) 范围内的数字映射到 [actual N) 中不在黑名单中的数字身上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; blacklist)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先把黑名单中的所有数字放在哈希表中</span></span><br><span class="line">        <span class="comment">// 便于快速得到 [actual N) 范围内的数字是否在黑名单中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : blacklist)</span><br><span class="line">            mapping[val] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        actual = N - blacklist.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : blacklist)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 黑名单中在 [0, actual) 范围内的数字才需要映射</span></span><br><span class="line">            <span class="keyword">if</span>(val &lt; actual)</span><br><span class="line">            &#123;</span><br><span class="line">                N--;</span><br><span class="line">                <span class="comment">// 从后向前映射</span></span><br><span class="line">                <span class="comment">// 如果映射为的数字已经在黑名单中了</span></span><br><span class="line">                <span class="comment">// 就跳过</span></span><br><span class="line">                <span class="keyword">while</span>(mapping.count(N)) N--;</span><br><span class="line">            	mapping[val] = N;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand() % actual;</span><br><span class="line">        <span class="comment">// 如果这个数字在黑名单中, 需要返回其映射</span></span><br><span class="line">        <span class="keyword">if</span>(mapping.count(i) &gt; <span class="number">0</span>) <span class="keyword">return</span> mapping[i];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> actual;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="528-Random-Pick-with-Weight"><a href="#528-Random-Pick-with-Weight" class="headerlink" title="528. Random Pick with Weight"></a><a href="https://leetcode.com/problems/random-pick-with-weight/" target="_blank" rel="noopener">528. Random Pick with Weight</a></h5><blockquote>
<p>给定一个正整数数组<code>w</code>，其中<code>w[i]</code>描述第<code>i</code>个索引的权重。</p>
<p>我们需要调用函数<code>pickIndex()</code>，该函数随机返回范围为<code>[0，w.size())</code>的整数。 <code>pickIndex()</code>应该返回与其在<code>w</code>数组中的权重成比例的数。 例如，对于<code>w = [1，3]</code>，选择索引<code>0</code>的概率为<code>1 / (1 + 3) = 0.25</code>，而选择索引<code>1</code>的概率为<code>3 / (1 + 3)  = 0.75</code>。或者说，选择索引<code>i</code>的概率为<code>w[i] / sum(w)</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用前缀和数组</span></span><br><span class="line"><span class="comment">// 从 [0, sum(w)) 区间内随机产生一个数</span></span><br><span class="line"><span class="comment">// 看这个随机数落在前缀和数组的哪个区间内</span></span><br><span class="line"><span class="comment">// 比如 w = &#123;1, 4, 7, 2&#125;;</span></span><br><span class="line"><span class="comment">// prefixSum = &#123;0, 1, 5, 12, 14&#125;;</span></span><br><span class="line"><span class="comment">// 从 [0, 14) 区间内随机产生一个数</span></span><br><span class="line"><span class="comment">// 落在 [0, 1) 区间返回 0</span></span><br><span class="line"><span class="comment">// 落在 [1, 5) 区间返回 1</span></span><br><span class="line"><span class="comment">// 落在 [5, 12) 区间返回 2</span></span><br><span class="line"><span class="comment">// 落在 [12, 14) 区间返回 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w) : prefixSum(w.size() + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.size(); i++)</span><br><span class="line">            prefixSum[i + <span class="number">1</span>] = prefixSum[i] + w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = rand() % prefixSum.back();</span><br><span class="line">        <span class="comment">// 通过二分搜索加快搜索速度</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = prefixSum.size();</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = (hi + lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(r &gt;= prefixSum[mi])</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(r &lt; prefixSum[mi])</span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefixSum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water</a></h5><blockquote>
<p>给你<code>n</code>个非负整数<code>a1, a2, ..., an</code>，每个数代表坐标中的一个点<code>(i, ai)</code> 。在坐标内画<code>n</code>条垂直线，垂直线<code>i</code>的两个端点分别为<code>(i, ai)</code>和<code>(i, 0)</code> 。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。</p>
<p>返回容纳的水量。</p>
<p><strong>Example:</strong></p>
<img src="question_11.jpg" alt="img" style="zoom: 67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 左右指针解法</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt;= height[right])</span><br><span class="line">        &#123;</span><br><span class="line">            res = max(res, (right - left) * height[left]);</span><br><span class="line">            <span class="comment">// 小的变化, 大的不变</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = max(res, (right - left) * height[right]);</span><br><span class="line">            <span class="comment">// 小的变化, 大的不变</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. Trapping Rain Water</a></h5><blockquote>
<p>给定<code>n</code>个表示海拔图的非负整数，其中每个条的宽度为<code>1</code>，计算下雨后它可以捕集多少水。</p>
<p><strong>Example:</strong></p>
<img src="rainwatertrap.png" alt="img"  />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本思想是, 对于每一个槽, 它所能接的水量取决于它左边最高的柱子和右边最高的柱子中的较低者</span></span><br><span class="line"><span class="comment">// 较低的值减去自身的高度就为该槽所能接的水量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了备忘录的方法</span></span><br><span class="line"><span class="comment">// 提前计算出每个槽左边最高的柱子和右边最高的柱子</span></span><br><span class="line"><span class="comment">// left_max[i] 表示第 i 个槽左边最高的柱子的高度</span></span><br><span class="line"><span class="comment">// right_max[i] 表示第 i 个槽右边最高的柱子的高度</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n), 但空间复杂度也为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left_max</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_max</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    left_max.front() = height.front();</span><br><span class="line">    right_max.back() = height.back();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.size(); i++)</span><br><span class="line">        left_max[i] = max(height[i], left_max[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = height.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        right_max[i] = max(height[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++)</span><br><span class="line">        res += min(left_max[i], right_max[i]) - height[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用双指针解法</span></span><br><span class="line"><span class="comment">// 边走边记录左边柱子最高值和右边柱子最高值</span></span><br><span class="line"><span class="comment">// 优化后的时间复杂度为 O(n), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(height.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left_max = height.front();</span><br><span class="line">    <span class="keyword">int</span> right_max = height.back();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        left_max = max(left_max, height[left]);</span><br><span class="line">        right_max = max(right_max, height[right]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left_max &lt; right_max)</span><br><span class="line">        &#123;</span><br><span class="line">            res += left_max - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += right_max - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1395-Count-Number-of-Teams"><a href="#1395-Count-Number-of-Teams" class="headerlink" title="1395. Count Number of Teams"></a><a href="https://leetcode.com/problems/count-number-of-teams/" target="_blank" rel="noopener">1395. Count Number of Teams</a></h5><blockquote>
<p><code>n</code>名士兵站成一排。每个士兵都有一个<strong>独一无二的评分</strong><code>rating</code>。每<code>3</code>个士兵可以组成一个作战单位，分组规则如下：</p>
<ol>
<li>从队伍中选出下标分别为<code>i、j、k</code>的<code>3</code>名士兵，他们的评分分别为<code>rating[i]、rating[j]、rating[k]</code>；</li>
<li>作战单位需满足：<code>rating[i] &lt; rating[j] &lt; rating[k]</code>或者<code>rating[i] &gt; rating[j] &gt; rating[k]</code>，其中<code>0 &lt;= i &lt; j &lt; k &lt; n</code>。</li>
</ol>
<p>你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。</p>
<p><strong>Example 1</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [2,5,3,4,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). </span><br></pre></td></tr></table></figure>

<p><strong>Example 2</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [2,1,3]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: We can&#39;t form any team given the conditions.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rating &#x3D; [1,2,3,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs 出现 Time Limit Exceeded</span></span><br><span class="line"><span class="comment">// 穷举的时间复杂度为 O(n3), 空间复杂度为 O(1)</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; team;</span><br><span class="line">    dfs(rating, team, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; team, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(team.size() == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; rating.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isValid(rating, team, i)) <span class="keyword">continue</span>;</span><br><span class="line">        team.push_back(rating[i]);</span><br><span class="line">        dfs(rating, team, i + <span class="number">1</span>);</span><br><span class="line">        team.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; team, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(team.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(team[<span class="number">0</span>] &lt; team[<span class="number">1</span>] &amp;&amp; rating[i] &lt; team[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(team[<span class="number">0</span>] &gt; team[<span class="number">1</span>] &amp;&amp; rating[i] &gt; team[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前求得每个元素右边的比它大的元素个数和比它小的元素个数</span></span><br><span class="line"><span class="comment">// 通过两次 O(n2) 的循环, 将时间复杂度减少到 O(n2), 但空间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_max</span><span class="params">(rating.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_min</span><span class="params">(rating.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rating.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; rating.size(); j++)</span><br><span class="line">            <span class="keyword">if</span>(rating[i] &lt; rating[j])</span><br><span class="line">                right_max[i]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right_min[i]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rating.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; rating.size(); j++)</span><br><span class="line">            <span class="keyword">if</span>(rating[i] &lt; rating[j])</span><br><span class="line">                res += right_max[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += right_min[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. Sliding Window Maximum</a></h5><blockquote>
<p>  给你一个整数数组<code>num</code>，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的<code>k</code>个数字。滑动窗口每次只向右移动一位。</p>
<p>  返回滑动窗口中的最大值。</p>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line">1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line">1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line">1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line">1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line">1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列保证从队头到队尾是递减的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonoQ</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 如果入队的值比队尾的值大, 就把队尾元素 pop 掉, 这样保证是递减的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!monoQ.empty() &amp;&amp; monoQ.back() &lt; val)</span><br><span class="line">            monoQ.pop_back();</span><br><span class="line">        monoQ.push_back(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pop 的时候如果不是队头元素就什么也不做</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(monoQ.front() == val)</span><br><span class="line">            monoQ.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大值就是队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> monoQ.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; monoQ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 维护一个大小为 k 的递减队列</span></span><br><span class="line"><span class="comment">// 这个队列就相当于是题目中的滑动窗口</span></span><br><span class="line"><span class="comment">// 只是单调之后取其中的最大值很方便</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MonoQ monoQ;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        monoQ.push(nums[i]);</span><br><span class="line">        <span class="comment">// 如果窗口内的元素数等于 k</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 最大值就是队头元素</span></span><br><span class="line">            res.push_back(monoQ.maxVal());</span><br><span class="line">            <span class="comment">// pop 掉最左边的将要出窗口的元素</span></span><br><span class="line">            monoQ.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当然也可以不先写好一个单调队列类</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用 deque 模拟队列</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; monoQ;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!monoQ.empty() &amp;&amp; monoQ.back() &lt; nums[i])</span><br><span class="line">            monoQ.pop_back();</span><br><span class="line">        monoQ.push_back(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(monoQ.front());</span><br><span class="line">            <span class="keyword">if</span>(monoQ.front() == nums[i - k + <span class="number">1</span>])</span><br><span class="line">                monoQ.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="912-Sort-an-Array"><a href="#912-Sort-an-Array" class="headerlink" title="912. Sort an Array"></a><a href="https://leetcode.com/problems/sort-an-array/" target="_blank" rel="noopener">912. Sort an Array</a></h5><blockquote>
<p>  Given an array of integers<code>nums</code>, sort the array in ascending order.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(i) ((i - 1) / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(i) ((2 * i) + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(i) (LC(i) + 1)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">    <span class="keyword">int</span> i = P(sz - <span class="number">1</span>); <span class="comment">// 获取末元素的父亲, 也就是最后一个内部节点</span></span><br><span class="line">    <span class="comment">// 建堆操作, 复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">        downFilter(nums, i--, sz); <span class="comment">// 从最后一个内部节点自后向前 依次下滤</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时最大元素是首元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(nums[<span class="number">0</span>], nums[i]); <span class="comment">// 首尾交换, 末元素就位</span></span><br><span class="line">        downFilter(nums, <span class="number">0</span>, i);      <span class="comment">// 将新首元素下滤</span></span><br><span class="line">        <span class="comment">// 依次缩短未排序数组的长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下滤操作, 复杂度正比于完全二叉树的高度为 log(n)</span></span><br><span class="line"><span class="comment">// 参数 len 代表 [有效堆] 数组的长度, 可用于验证待下滤元素 i 的左右孩子节点的合法性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downFilter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = nums[i]; <span class="comment">// 先保存待下滤的值, i 就可代表洞号</span></span><br><span class="line">    <span class="keyword">int</span> rc = RC(i);    <span class="comment">// 待下滤元素的右孩子</span></span><br><span class="line">    <span class="comment">// 如果右孩子存在</span></span><br><span class="line">    <span class="keyword">while</span> (rc &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果右子节点的值小于左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (nums[rc] &lt;= nums[rc - <span class="number">1</span>])</span><br><span class="line">            rc--;</span><br><span class="line">        <span class="comment">// 此时, rc 指向孩子节点中较大的那一个</span></span><br><span class="line">        <span class="comment">// 如果待下滤的值比孩子中较大的还大, 就不需要下滤了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[rc] &lt;= val)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[i] = nums[rc];</span><br><span class="line">        i = rc;     <span class="comment">// 产生新的洞号</span></span><br><span class="line">        rc = RC(i); <span class="comment">// 获得新洞号的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右孩子不存在, 但如果左孩子存在且其值大于待下滤的值</span></span><br><span class="line">    <span class="keyword">if</span> (rc - <span class="number">1</span> &lt; len &amp;&amp; nums[rc - <span class="number">1</span>] &gt; val)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = nums[rc - <span class="number">1</span>];</span><br><span class="line">        i = rc - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右孩子都不存在了</span></span><br><span class="line">    nums[i] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序, 自顶向下递归实现</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 排序 [0, nums.size()) 之间的元素</span></span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 单元素自动有序</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, lo, mi);</span><br><span class="line">    mergeSort(nums, mi + <span class="number">1</span>, hi);</span><br><span class="line">    merge(nums, lo, mi, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="comment">// [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mi, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 辅助空间, 存储 [mi + 1, hi] 元素</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(nums.begin() + mi + <span class="number">1</span>, nums.begin() + hi + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对两个数组中的元素, 依次从后向前比较</span></span><br><span class="line">    <span class="comment">// 从后向前放置元素, 先放较大者</span></span><br><span class="line">    <span class="keyword">int</span> i = mi;</span><br><span class="line">    <span class="keyword">int</span> j = helper.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = hi;</span><br><span class="line">    <span class="comment">// 注意 i 的终止条件</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= lo &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 注意, 这里如果是 &gt;= 就不稳定了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; helper[j])</span><br><span class="line">            nums[k--] = nums[i--];</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        	nums[k--] = helper[j--];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        nums[k--] = helper[j--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 归并排序, 自底向上迭代实现 */</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = nums.size();</span><br><span class="line">    <span class="comment">// 中间节点相对于起点的位置是 1 个 step</span></span><br><span class="line">    <span class="comment">// 终点相对于起点是 2 个 step</span></span><br><span class="line">    <span class="comment">// step 从 1 开始直到等于数组的长度 sz </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= sz; step *= <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 注意, 这里 lo 从 0 开始直到等于 sz - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; sz; lo += <span class="number">2</span> * step)</span><br><span class="line">            <span class="comment">// 因为 merge 函数实现的原因, 都是闭区间, 而且 [lo, mi] 和 [mi + 1, hi] 分别是有序的</span></span><br><span class="line">            <span class="comment">// 所以这里求出的 mi 和 hi 都需要减 1</span></span><br><span class="line">            merge(nums, lo, min(lo + step - <span class="number">1</span>, sz - <span class="number">1</span>), min(lo + <span class="number">2</span> * step - <span class="number">1</span>, sz - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(nums, lo, hi);</span><br><span class="line">    quickSort(nums, lo, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, pivot + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以首元素为轴点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = lo;</span><br><span class="line">    <span class="keyword">while</span> (++j &lt;= hi)</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[lo])</span><br><span class="line">            <span class="built_in">std</span>::swap(nums[++i], nums[j]);</span><br><span class="line">    <span class="built_in">std</span>::swap(nums[lo], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. Find First and Last Position of Element in Sorted Array</a></h5><blockquote>
<p>给定一个以升序排列的整数<code>nums</code>数组，请找到给定目标值的开始和结束位置。如果在数组中未找到目标，则返回<code>[-1，-1]</code>。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = nums.size();</span><br><span class="line">    <span class="keyword">int</span> mi;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[mi])</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt; nums.size() &amp;&amp; nums[lo] == target)</span><br><span class="line">        res.push_back(lo);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    lo = <span class="number">0</span>;</span><br><span class="line">    hi = nums.size();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target &gt;= nums[mi])</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = mi;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(lo - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. Search a 2D Matrix II</a></h5><blockquote>
<p>  编写一个高效的算法来搜索<code>m x n</code>矩阵<code>matrix</code>中的一个目标值<code>target</code>。该矩阵具有以下特性：</p>
<ol>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ol>
<p>  <strong>Example 1:</strong></p>
  <img src="searchgrid.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <img src="searchgrid2.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(matrix, <span class="number">0</span>, matrix[<span class="number">0</span>].size() - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(r &gt;= matrix.size() || c &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == matrix[r][c])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(target &gt; matrix[r][c])</span><br><span class="line">        res = helper(matrix, r + <span class="number">1</span>, c, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res = helper(matrix, r, c - <span class="number">1</span>, target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; matrix.size() &amp;&amp; c &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; matrix[r][c])</span><br><span class="line">            c--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[r][c])</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">162. Find Peak Element</a></h5><blockquote>
<p>  峰值元素是指其值严格大于左右相邻值的元素。给你一个输入数组<code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回<strong>任何一个峰值</strong>所在位置即可。</p>
<p>  你可以假设<code>nums[-1] = nums[n] = -∞</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mi] &gt; nums[mi + <span class="number">1</span>])</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="658-Find-K-Closest-Elements"><a href="#658-Find-K-Closest-Elements" class="headerlink" title="658. Find K Closest Elements"></a><a href="https://leetcode.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. Find K Closest Elements</a></h5><blockquote>
<p>  给定一个排序好的数组<code>arr</code>，两个整数<code>k</code>和<code>x</code>，从数组中找到最靠近<code>x</code>（两数之差最小）的<code>k</code>个数。返回的结果必须要是按升序排好的。</p>
<p>  整数<code>a</code>比整数<code>b</code>更接近<code>x</code>需要满足：</p>
<ul>
<li>|a - x| &lt; |b - x| 或者</li>
<li>|a - x| == |b - x| 且 a &lt; b.</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照与 x 差值的绝对值进行排序</span></span><br><span class="line"><span class="comment">// 返回排序后数组的前 k 个元素的原始顺序即可</span></span><br><span class="line"><span class="comment">// 时间复杂度为排序的复杂度 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(arr)</span></span>;</span><br><span class="line">    sort(res.begin(), res.end(),</span><br><span class="line">         [x](<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">abs</span>(a - x) == <span class="built_in">abs</span>(b - x) ? a &lt; b : <span class="built_in">abs</span>(a - x) &lt; <span class="built_in">abs</span>(b - x);</span><br><span class="line">         &#125;);</span><br><span class="line">    res.resize(k);</span><br><span class="line">    sort(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为数组已经是有序的, 先通过二分搜索找到 x 在数组中的位置</span></span><br><span class="line"><span class="comment">// 根据 x 的位置不同有几种情况</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findClosestElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 里面这段二分搜索是左边界搜索</span></span><br><span class="line">    <span class="comment">// lo 最后指向第一个大于等于 x 的元素</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = arr.size();</span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= arr[mi])</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; arr[mi])</span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 小于等于数组中的任何数, 那离 x 最近的就是前 k 个元素</span></span><br><span class="line">    <span class="keyword">if</span>(lo == <span class="number">0</span>)</span><br><span class="line">        copy_n(arr.begin(), k, res.begin());</span><br><span class="line">    <span class="comment">// 如果 x 大于等于数组中的任何数, 那离 x 最近的就是后 k 个元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lo == arr.size())</span><br><span class="line">        copy_n(arr.end() - k, k, res.begin());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果在中间, 就设置两个指针</span></span><br><span class="line">        <span class="comment">// 左右指针离 lo 的位置都为 k, 组成一个窗口</span></span><br><span class="line">        <span class="comment">// 在窗口中移动双指针使得窗口内元素数缩减为最接近 x 的 k 个数即可</span></span><br><span class="line">        <span class="keyword">int</span> left = max(lo - k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right = min(lo + k, <span class="keyword">int</span>(arr.size()) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(right - left &gt; k - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(arr[left] - x) &lt;= <span class="built_in">abs</span>(arr[right] - x))</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        copy_n(arr.begin() + left, k, res.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="719-Find-K-th-Smallest-Pair-Distance"><a href="#719-Find-K-th-Smallest-Pair-Distance" class="headerlink" title="719. Find K-th Smallest Pair Distance"></a><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/" target="_blank" rel="noopener">719. Find K-th Smallest Pair Distance</a></h5><blockquote>
<p>  给定一个整数数组，返回所有数对之间的第<code>k</code>个最小<strong>距离</strong>。一对<code>(A, B)</code> 的距离被定义为<code>A</code>和<code>B</code>之间的绝对差值。</p>
<p>  <strong>Note:</strong></p>
<ol>
<li><code>2 &lt;= len(nums) &lt;= 10000</code>.</li>
<li><code>0 &lt;= nums[i] &lt; 1000000</code>.</li>
<li><code>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2</code>.</li>
</ol>
<p>  <strong>Example:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums &#x3D; [1,3,1]</span><br><span class="line">k &#x3D; 1</span><br><span class="line">Output: 0 </span><br><span class="line">Explanation:</span><br><span class="line">Here are all the pairs:</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">Then the 1st smallest distance pair is (1,1), and its distance is 0.</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力解法</span></span><br><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distances;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</span><br><span class="line">            distances.push_back(<span class="built_in">abs</span>(nums[i] - nums[j]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = distances.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(distances, lo, hi);</span><br><span class="line">        <span class="keyword">if</span>(pivot == k - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> distances[pivot];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pivot &lt; k - <span class="number">1</span>)</span><br><span class="line">            lo = pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi = pivot - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = lo;</span><br><span class="line">    <span class="keyword">while</span>(++j &lt;= hi)</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &lt; nums[lo])</span><br><span class="line">            swap(nums[++i], nums[j]);</span><br><span class="line">    swap(nums[lo], nums[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用一个 multiset 实现起来更简单, 但还是 Time Limit Exceeded!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="comment">// 因为核心在这, 计算所有的 pair 复杂度为 O(n2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</span><br><span class="line">            setting.insert(<span class="built_in">abs</span>(nums[i] - nums[j]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = next(setting.begin(), k - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binary search, a good idea.</span></span><br><span class="line"><span class="comment">// another problem, 373. Find K Pairs with Smallest Sums</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先把数组排序</span></span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="comment">// pairs 之间的差值最小无非就是 0</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最大就是尾元素减去首元素嘛</span></span><br><span class="line">    <span class="keyword">int</span> hi = nums.back() - nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 问题转化为在这个范围内找到一个差值</span></span><br><span class="line">    <span class="comment">// 使得有 k - 1 个 pair 的差值不比它大</span></span><br><span class="line">    <span class="comment">// 这种在有序的数值范围内搜索一个特定值就是典型的二分搜索的应用</span></span><br><span class="line">    <span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取差值的中间</span></span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 下面应用一个滑动窗口算法计算有多少个比 mi 小的差值</span></span><br><span class="line">        <span class="comment">// 不要被两个 while 循环吓到了, 实际复杂度只有 O(n), 不清楚看最下面注释</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[right] - nums[left] &gt; mi)</span><br><span class="line">                left++;</span><br><span class="line">            count += right - left;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// count == number of pairs with distance &lt;= mi</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt;= count)</span><br><span class="line">            hi = mi;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. Time Complexity:O(NlogW + NlogN), where N is the length of nums, and W is equal to nums[nums.length - 1] - nums[0]. The logW factor comes from our binary search, and we do O(N) work inside our call to possible (or to calculate count). The final O(NlogN) factor comes from sorting.</span></span><br><span class="line"><span class="comment">2. Space Complexity: O(1). No additional space is used except for integer variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">It is O(N). the possible function is a classic sliding windowing solution, left and right would always increment in each outer loop iteration, that is 'left' and 'right' sweeps elements in the array only once. So time complexity is O(2N) = O(N).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/" target="_blank" rel="noopener">373. Find K Pairs with Smallest Sums</a></h5><blockquote>
<p>  给定两个以升序排列的整形数组<code>nums1</code>和<code>nums2</code>，以及一个整数<code>k</code>。</p>
<p>  定义一对值<code>(u,v)</code>，其中第一个元素来自<code>nums1</code>，第二个元素来自<code>nums2</code>。</p>
<p>  找到和最小的<code>k</code>对数字<code>(u1,v1),(u2,v2)...(uk,vk)</code>。</p>
<p>  <strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li>
<li><code>nums1</code> and <code>nums2</code> both are sorted in <strong>ascending order</strong>.</li>
<li><code>1 &lt;= k &lt;= 1000</code></li>
</ul>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3</span><br><span class="line">Output: [[1,2],[1,4],[1,6]]</span><br><span class="line">Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,1,2], nums2 &#x3D; [1,2,3], k &#x3D; 2</span><br><span class="line">Output: [[1,1],[1,1]]</span><br><span class="line">Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [3], k &#x3D; 3</span><br><span class="line">Output: [[1,3],[2,3]]</span><br><span class="line">Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">kSmallestPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123; <span class="keyword">return</span> a.first + a.second &lt; b.first + b.second; &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; pq(cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num1 : nums1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num2 : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            pq.push(&#123;num1, num2&#125;);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k)</span><br><span class="line">                pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!pq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(&#123;pq.top().first, pq.top().second&#125;);</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. Minimum Size Subarray Sum</a></h5><blockquote>
<p>  给定一个含有<code>n</code>个正整数的数组和一个正整数<code>target</code>。</p>
<p>  找出该数组中满足其和<code>≥ target</code>的长度最小的连续子数组<code>[numsl, numsl+1, ..., numsr-1, numsr]</code>，并返回其长度。如果不存在符合条件的子数组，返回<code>0</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 4, nums &#x3D; [1,4,4]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(n), S: O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(nums.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(prefix[right] - prefix[left] &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            res = min(res, right - left);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(n), S: O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            res = min(res, right - left);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: O(nlogn), S: O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefixSum</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++)</span><br><span class="line">        prefixSum[i] = prefixSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to_find = target + prefixSum[i];</span><br><span class="line">        <span class="comment">// auto it = lower_bound(prefixSum.begin(), prefixSum.end(), to_find);</span></span><br><span class="line">        <span class="comment">// if(it != prefixSum.end())</span></span><br><span class="line">        <span class="comment">//     res = min(res, int(distance(prefixSum.begin(), it)) - i);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> it = _lower_bound(prefixSum, to_find);</span><br><span class="line">        <span class="keyword">if</span>(it != prefixSum.size())</span><br><span class="line">            res = min(res, it - i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _lower_bound(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mi = lo + (hi - lo &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[mi])</span><br><span class="line">            hi = mi - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mi + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"></a><a href="https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</a></h5><blockquote>
<p>给你一个整数数组<code>nums</code>，和一个表示限制的整数<code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于<code>limit</code>。如果不存在满足条件的子数组，则返回<code>0</code>。</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
<li><code>0 &lt;= limit &lt;= 109</code></li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">&gt;Output: 2 </span><br><span class="line">&gt;Explanation: All subarrays are: </span><br><span class="line">&gt;[8] with maximum absolute diff |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">&gt;[8,2] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">&gt;[8,2,4] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">&gt;[8,2,4,7] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">&gt;[2] with maximum absolute diff |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">&gt;[2,4] with maximum absolute diff |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">&gt;[2,4,7] with maximum absolute diff |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">&gt;[4] with maximum absolute diff |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">&gt;[4,7] with maximum absolute diff |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">&gt;[7] with maximum absolute diff |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">&gt;Therefore, the size of the longest subarray is 2.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">&gt;Output: 4 </span><br><span class="line">&gt;Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| &#x3D; 5 &lt;&#x3D; 5.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">&gt;Output: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这题使用一个滑动窗口是毋庸置疑的</span></span><br><span class="line"><span class="comment">// 关键是我们希望实时的知道窗口内元素的最大值和最小值</span></span><br><span class="line"><span class="comment">// 那么我们要将窗口内的元素存储在哪种合适的数据结构中</span></span><br><span class="line"><span class="comment">// 满足我们要求的同时还能保证效率呢</span></span><br><span class="line"><span class="comment">// 1. 二叉搜索树, 我们可以方便的获得其中的最大值和最小值, 并且插入的效率为 o(logn)</span></span><br><span class="line"><span class="comment">//    最小值在树的最左边, 最大值在树的最右边</span></span><br><span class="line"><span class="comment">// 2. 单调队列, 使用两个单调队列, 一个是从队首到队尾递减的顺序, 一个是从队首到队尾递增的顺序</span></span><br><span class="line"><span class="comment">//    这样最大值和最小值分别都在它们的队首, 插入的效率为 O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意窗口中可能存在的重复值的情况</span></span><br><span class="line"><span class="comment">// 这些重复值在搜索树或者在队列中都要同时存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口 + multiset</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; setting;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        setting.insert(nums[right++]);</span><br><span class="line">        <span class="keyword">while</span>(*setting.rbegin() - *setting.begin() &gt; limit)</span><br><span class="line">            setting.erase(setting.find(nums[left++]));</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小技巧: 对于需要实时获取序列中最大值或最小值的问题, 单调队列是非常适合的数据结构!</span></span><br><span class="line"><span class="comment">// 滑动窗口 + 单调队列</span></span><br><span class="line"><span class="comment">// 时间复杂度为 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; minQ;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxQ;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!minQ.empty() &amp;&amp; minQ.back() &gt; nums[right])</span><br><span class="line">            minQ.pop_back();</span><br><span class="line">        <span class="keyword">while</span>(!maxQ.empty() &amp;&amp; maxQ.back() &lt; nums[right])</span><br><span class="line">            maxQ.pop_back();</span><br><span class="line"></span><br><span class="line">        minQ.push_back(nums[right]);</span><br><span class="line">        maxQ.push_back(nums[right]);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span>(!minQ.empty() &amp;&amp; !maxQ.empty() &amp;&amp; (maxQ.front() - minQ.front() &gt; limit))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(minQ.front() == nums[left])</span><br><span class="line">                minQ.pop_front();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(maxQ.front() == nums[left])</span><br><span class="line">                maxQ.pop_front();</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一个数组模拟两个单调队列是真的秀啊</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// minL 和 minR 是最小值区间的左右指针, maxL 和 maxR 是最大值区间的左右指针</span></span><br><span class="line">    <span class="keyword">int</span> minL = <span class="number">0</span>, minR = <span class="number">-1</span>, maxL = nums.size(), maxR = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// l, r 是 nums 的左右指针</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个数组用来记录最小值和最大值</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ascending</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="comment">// 开始遍历 nums</span></span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果遍历到的数字在最小值区间内, 就收缩最小值区间</span></span><br><span class="line">        <span class="keyword">while</span>(minR &gt;= minL &amp;&amp; nums[r] &lt; ascending[minR])</span><br><span class="line">            minR--;</span><br><span class="line">        <span class="comment">// 如果遍历到的数字在最大值区间内, 就收缩最大值区间</span></span><br><span class="line">        <span class="keyword">while</span>(maxR &gt;= maxL &amp;&amp; nums[r] &gt; ascending[maxL])</span><br><span class="line">            maxL++;</span><br><span class="line">        <span class="comment">// 拓展最小值和最大值区间</span></span><br><span class="line">        ascending[++minR] = nums[r];</span><br><span class="line">        ascending[--maxL] = nums[r];</span><br><span class="line">        r++;</span><br><span class="line">        <span class="comment">// 判断子集长度是否符合 limit 的要求, 如果不符合要求, 就收缩子集</span></span><br><span class="line">        <span class="keyword">while</span>(ascending[maxR] - ascending[minL] &gt; limit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 开始收缩子集, 使子集左指针右移</span></span><br><span class="line">            <span class="comment">// 如果子集左指针是最小值, 那么最小值将被移除, 所以更新存储最小值的区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == ascending[minL])</span><br><span class="line">                minL++;</span><br><span class="line">            <span class="comment">// 如果子集左指针是最大值, 那么最大值将被移除, 所以更新存储最大值的区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == ascending[maxR])</span><br><span class="line">                maxR--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, r - l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="220-Contains-Duplicate-III"><a href="#220-Contains-Duplicate-III" class="headerlink" title="220. Contains Duplicate III"></a><a href="https://leetcode.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. Contains Duplicate III</a></h5><blockquote>
<p>  给你一个整数数组<code>nums</code>和两个整数<code>k</code>和<code>t</code>。请你判断是否存在两个不同下标<code>i</code>和<code>j</code>，使得<code>abs(nums[i] - nums[j]) &lt;= t</code>，同时又满足<code>abs(i - j) &lt;= k</code>。如果存在则返回<code>true</code>，不存在返回<code>false</code>。</p>
<p>  <strong>Example 1:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,0,1,1], k &#x3D; 1, t &#x3D; 2</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 3:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口 + 二叉搜索树</span></span><br><span class="line"><span class="comment">// 在 set 中维护一个元素数为 k 的滑动窗口</span></span><br><span class="line"><span class="comment">// 这可保证在 set 中的元素的索引满足 abs(i - j) &lt;= k</span></span><br><span class="line"><span class="comment">// 我们每迭代到数组中的下一个元素 [nums[i], 在更新 set 前</span></span><br><span class="line"><span class="comment">// 都要在其中找到一个在 [nums[i] - k, nums[i] + k] 范围内的值</span></span><br><span class="line"><span class="comment">// 如果存在, 那么就满足 abs(nums[i] - nums[j]) &lt;= t</span></span><br><span class="line"><span class="comment">// 为什么选择 multiset?</span></span><br><span class="line"><span class="comment">// 因为 set 具有自动排序的特性, 并且每次查找、删除和插入的复杂度都为</span></span><br><span class="line"><span class="comment">// 高效的 log(n). 因为我们要频繁地查找在范围 [nums[i] - k,</span></span><br><span class="line"><span class="comment">// nums[i] + k] 内的值, 还要频繁地删除和插入元素以维持固定地滑动窗口大小</span></span><br><span class="line"><span class="comment">// 注意一点, 在计算 nums[i] - k 和 nums[i] + k 的时候可能会出现数值溢出</span></span><br><span class="line"><span class="comment">// 所以要全部用 long</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">long</span>&gt; ms;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意此时 nums[i] 是不包含在窗口内的</span></span><br><span class="line">        <span class="comment">// 并且窗口内的元素数量 ? &lt;= k, 我们以第 ? + 1 个元素为对象</span></span><br><span class="line">        <span class="comment">// 寻找满足条件的另一个元素, 这样每一个元素都会 [被看作对象] 一次</span></span><br><span class="line">        <span class="keyword">long</span> valMin = (<span class="keyword">long</span>)nums[i] - (<span class="keyword">long</span>)t;</span><br><span class="line">        <span class="comment">// iter 指向首次进入 [nums[i] - k, ... 范围的数</span></span><br><span class="line">        <span class="comment">// 因此还要验证这个数是否也在 ..., nums[i] + k] 范围内</span></span><br><span class="line">        <span class="keyword">auto</span> iter = ms.lower_bound(valMin);</span><br><span class="line">        <span class="comment">// 如果存在这么一个数, 就找到满足条件的两个数了</span></span><br><span class="line">        <span class="keyword">if</span>(iter != ms.end() &amp;&amp; *iter &lt;= (<span class="keyword">long</span>)nums[i] + (<span class="keyword">long</span>)t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前对象已经处理过了, 将它放进窗口</span></span><br><span class="line">        <span class="comment">// 如果窗口大小超过 k 了, 还要将最左边的那个数剔出窗口</span></span><br><span class="line">        ms.insert(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(ms.size() &gt; k)</span><br><span class="line">            ms.erase(nums[i - k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口 + 分桶</span></span><br><span class="line"><span class="comment">// 将数组中的数值按照映射函数分配到相应桶中</span></span><br><span class="line"><span class="comment">// 映射函数为 桶号 id = value / (t + 1)</span></span><br><span class="line"><span class="comment">// 这样可保证</span></span><br><span class="line"><span class="comment">// 1. 映射到同一个桶的数值之差一定小于等于 t</span></span><br><span class="line"><span class="comment">// 2. 相邻桶中也有可能存在差值小于等于 t 的情况</span></span><br><span class="line"><span class="comment">// 3. 不相邻的桶中元素差值必定大于 t</span></span><br><span class="line"><span class="comment">// 如数组为 [1 5 9 1 3 7 8], k = 2, t = 3, 桶宽度为 t + 1 = 4</span></span><br><span class="line"><span class="comment">// 0 号桶: [1 1 3], 1 号桶: [5 7], 2 号桶: [9 8]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bucketsWidth = <span class="keyword">long</span>(t) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">long</span>&gt; buckets;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = getKey(nums[i], bucketsWidth);</span><br><span class="line">        <span class="comment">// 在一个桶中一定满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.count(id)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 在左边相邻桶中, 再判断差值是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.count(id - <span class="number">1</span>) &amp;&amp; nums[i] - buckets[id - <span class="number">1</span>] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 在右边相邻桶中, 再判断差值是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.count(id + <span class="number">1</span>) &amp;&amp; buckets[id + <span class="number">1</span>] - nums[i] &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        buckets[id] = nums[i];</span><br><span class="line">        <span class="comment">// 保证所有桶中的元素小于等于 k 个</span></span><br><span class="line">        <span class="comment">// 如果大于 k, 就将窗口最左边的元素剔除</span></span><br><span class="line">        <span class="keyword">if</span>(buckets.size() &gt; k)</span><br><span class="line">            buckets.erase(getKey(nums[i - k], bucketsWidth));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKey</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">long</span> bucketsWidth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = value / bucketsWidth;</span><br><span class="line">    <span class="comment">// 注意这里如果 value 为负数, 需要将桶号减 1</span></span><br><span class="line">    <span class="comment">// 保证 0 号桶的正确性</span></span><br><span class="line">    <span class="keyword">if</span>(value &lt; <span class="number">0</span>) id--;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="498-Diagonal-Traverse"><a href="#498-Diagonal-Traverse" class="headerlink" title="498. Diagonal Traverse"></a><a href="https://leetcode.com/problems/diagonal-traverse/" target="_blank" rel="noopener">498. Diagonal Traverse</a></h5><blockquote>
<p>  给定一个含有<code>m x n</code>个元素的矩阵（<code>m</code>行，<code>n</code>列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p>
<p>  <strong>Example 1:</strong></p>
  <img src="diag1-grid.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat &#x3D; [[1,2],[3,4]]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">v</span><span class="params">(m + n - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            v[i + j].push_back(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            reverse(v[i].begin(), v[i].end());</span><br><span class="line">        res.insert(res.end(), v[i].begin(), v[i].end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].size(); j++)</span><br><span class="line">            mapping[i + j].push_back(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: mapping)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.first % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            res.insert(res.end(), p.second.rbegin(), p.second.rend());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res.insert(res.end(), p.second.begin(), p.second.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1424-Diagonal-Traverse-II"><a href="#1424-Diagonal-Traverse-II" class="headerlink" title="1424. Diagonal Traverse II"></a><a href="https://leetcode.com/problems/diagonal-traverse-ii/" target="_blank" rel="noopener">1424. Diagonal Traverse II</a></h5><blockquote>
<p>给你一个列表<code>num</code>，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回<code>num</code>中对角线上的整数。</p>
<p><strong>Example 1:</strong></p>
<p><img src="sample_1_1784.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">&gt;Output: [1,4,2,7,5,3,8,6,9]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<p><img src="sample_2_1784.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">&gt;Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mapping;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].size(); j++)</span><br><span class="line">            mapping[i + j].push_back(nums[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: mapping)</span><br><span class="line">        res.insert(res.end(), p.second.rbegin(), p.second.rend());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a><a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. Spiral Matrix</a></h5><blockquote>
<p>  给你一个<code>m</code>行<code>n</code>列的矩阵<code>matrix</code>，请按照<strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p>
<p>  <strong>Example 1:</strong></p>
  <img src="spiral1.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p>  <strong>Example 2:</strong></p>
  <img src="spiral.jpg" alt="img" style="zoom:67%;" />

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Traverse the matrix in the spiral order by keeping four variables</span></span><br><span class="line"><span class="comment">// u for the uppermost row, d for the downmost row</span></span><br><span class="line"><span class="comment">// l for the leftmost column, r for the rightmost column.</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>, d = m - <span class="number">1</span>, l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">order</span><span class="params">(m * n)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (u &lt;= d &amp;&amp; l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = l; col &lt;= r; col++)</span><br><span class="line">            order[p++] = matrix[u][col];</span><br><span class="line">        <span class="keyword">if</span>(++u &gt; d) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = u; row &lt;= d; row++)</span><br><span class="line">            order[p++] = matrix[row][r];</span><br><span class="line">        <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = r; col &gt;= l; col--)</span><br><span class="line">            order[p++] = matrix[d][col];</span><br><span class="line">        <span class="keyword">if</span>(--d &lt; u) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = d; row &gt;= u; row--)</span><br><span class="line">            order[p++] = matrix[row][l];</span><br><span class="line">        <span class="keyword">if</span>(l++ &gt; r) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/rakjPpyIOCsd0MoJ/" rel="prev" title="重要知识点详细解读之僵尸进程和孤儿进程">
      <i class="fa fa-chevron-left"></i> 重要知识点详细解读之僵尸进程和孤儿进程
    </a></div>
      <div class="post-nav-item">
    <a href="/ZUdtS6UUmrVCKLed/" rel="next" title="牛客2021年4月15号模拟笔试题">
      牛客2021年4月15号模拟笔试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80OTQ0NS8yNTkzNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#167-Two-Sum-II-Input-array-is-sorted"><span class="nav-number">1.</span> <span class="nav-text">167. Two Sum II - Input array is sorted</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">2.</span> <span class="nav-text">1. Two Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Design-a-TwoSum-Class"><span class="nav-number">3.</span> <span class="nav-text">Design a TwoSum Class</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#560-Subarray-Sum-Equals-K"><span class="nav-number">4.</span> <span class="nav-text">560. Subarray Sum Equals K</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#724-Find-Pivot-Index"><span class="nav-number">5.</span> <span class="nav-text">724. Find Pivot Index</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#523-Continuous-Subarray-Sum"><span class="nav-number">6.</span> <span class="nav-text">523. Continuous Subarray Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1089-Duplicate-Zeros"><span class="nav-number">7.</span> <span class="nav-text">1089. Duplicate Zeros</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#941-Valid-Mountain-Array"><span class="nav-number">8.</span> <span class="nav-text">941. Valid Mountain Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#448-Find-All-Numbers-Disappeared-in-an-Array"><span class="nav-number">9.</span> <span class="nav-text">448. Find All Numbers Disappeared in an Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#442-Find-All-Duplicates-in-an-Array"><span class="nav-number">10.</span> <span class="nav-text">442. Find All Duplicates in an Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#380-Insert-Delete-GetRandom-O-1-和381-Insert-Delete-GetRandom-O-1-Duplicates-allowed"><span class="nav-number">11.</span> <span class="nav-text">380. Insert Delete GetRandom O(1)和381. Insert Delete GetRandom O(1) - Duplicates allowed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#710-Random-Pick-with-Blacklist"><span class="nav-number">12.</span> <span class="nav-text">710. Random Pick with Blacklist</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#528-Random-Pick-with-Weight"><span class="nav-number">13.</span> <span class="nav-text">528. Random Pick with Weight</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-Container-With-Most-Water"><span class="nav-number">14.</span> <span class="nav-text">11. Container With Most Water</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#42-Trapping-Rain-Water"><span class="nav-number">15.</span> <span class="nav-text">42. Trapping Rain Water</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1395-Count-Number-of-Teams"><span class="nav-number">16.</span> <span class="nav-text">1395. Count Number of Teams</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#239-Sliding-Window-Maximum"><span class="nav-number">17.</span> <span class="nav-text">239. Sliding Window Maximum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#912-Sort-an-Array"><span class="nav-number">18.</span> <span class="nav-text">912. Sort an Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="nav-number">19.</span> <span class="nav-text">34. Find First and Last Position of Element in Sorted Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#240-Search-a-2D-Matrix-II"><span class="nav-number">20.</span> <span class="nav-text">240. Search a 2D Matrix II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#162-Find-Peak-Element"><span class="nav-number">21.</span> <span class="nav-text">162. Find Peak Element</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#658-Find-K-Closest-Elements"><span class="nav-number">22.</span> <span class="nav-text">658. Find K Closest Elements</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#719-Find-K-th-Smallest-Pair-Distance"><span class="nav-number">23.</span> <span class="nav-text">719. Find K-th Smallest Pair Distance</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#373-Find-K-Pairs-with-Smallest-Sums"><span class="nav-number">24.</span> <span class="nav-text">373. Find K Pairs with Smallest Sums</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#209-Minimum-Size-Subarray-Sum"><span class="nav-number">25.</span> <span class="nav-text">209. Minimum Size Subarray Sum</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><span class="nav-number">26.</span> <span class="nav-text">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#220-Contains-Duplicate-III"><span class="nav-number">27.</span> <span class="nav-text">220. Contains Duplicate III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#498-Diagonal-Traverse"><span class="nav-number">28.</span> <span class="nav-text">498. Diagonal Traverse</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1424-Diagonal-Traverse-II"><span class="nav-number">29.</span> <span class="nav-text">1424. Diagonal Traverse II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#54-Spiral-Matrix"><span class="nav-number">30.</span> <span class="nav-text">54. Spiral Matrix</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

      <!-- 音乐播放器 -->
      <div>
      
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=300 height="400" src="//music.163.com/outchain/player?type=0&id=6679290542&auto=1&height=400"></iframe>
      
      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>