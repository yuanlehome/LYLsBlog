<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>教你用python实现一个在windows平台的定时更换壁纸的工具</title>
      <link href="/20200614/"/>
      <url>/20200614/</url>
      
        <content type="html"><![CDATA[<p>有没有感觉到自己的电脑桌面一成不变让人厌倦？虽然有一些诸如360桌面之类的软件可以使用，但弹窗、广告又太多！本文就教你用 <em>python</em> 实现一个简洁清爽的桌面壁纸定时更换工具。</p><a id="more"></a><p>本文使用的方法是用 <em>python</em> 实现一个定时更换壁纸的脚本，壁纸来源与自定义的文件夹内，因此你可以搜集一些你喜欢的壁纸图片放于该文件夹下，这样脚本程序便可以使你的电脑桌面轮流展示这些图片了。</p><p>比如我就把我喜欢的壁纸都收集在了 <em>E:/wallpapers/</em> 文件夹下。</p><p><img src="2020-06-14.png" alt=""></p><p>这里推荐几个好的壁纸来源网站 <a href="https://wallhaven.cc/" target="_blank" rel="noopener">https://wallhaven.cc/</a> ，<a href="https://www.artstation.com/wlop" target="_blank" rel="noopener">https://www.artstation.com/wlop</a> 。</p><p>下面直接看代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getImages</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 这里的路径就是你放图片的文件夹路径</span></span><br><span class="line">    images_path = <span class="string">'E:\\wallpapers\\'</span></span><br><span class="line">    files = os.listdir(images_path)</span><br><span class="line">    <span class="keyword">return</span> images_path, files</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_wallpaper</span><span class="params">(it)</span>:</span></span><br><span class="line">    path, images = getImages()</span><br><span class="line">    image = path + images[it]</span><br><span class="line">    it = (it + <span class="number">1</span>) % len(images)</span><br><span class="line">    win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, image, <span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">global</span> timer</span><br><span class="line">    <span class="comment"># 我设置的是每60s更换一次，你可以根据需要自定义设置</span></span><br><span class="line">    timer = threading.Timer(<span class="number">60.0</span>, set_wallpaper, (it,))</span><br><span class="line">    timer.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    set_wallpaper(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>为了方便运行，我们可以使用 <em>pyinstaller</em> 工具将该脚本程序转成 <em>.exe</em> 可执行文件。具体的方法可以看这篇文章 <a href="https://blog.csdn.net/zengxiantao1994/article/details/76578421" target="_blank" rel="noopener">Python程序打包成exe可执行文件</a> 。</p><p>生成可执行文件之后，运行就可以了。不过，为了每次开机程序都可以自动运行，我们需要进行一些设置。首先按 <em>win+R</em> 键打开运行窗口，输入 <em>shell:startup</em> 回车，这样会打开一个启动文件夹，这个文件夹下的软件在开机时都会自动启动，将你的可执行文件或其快捷方式放在这里就可以了。</p><p>这里可以直接下载我已经生成的可执行程序：</p><p><a href="https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q</a><br>提取码：v9ng </p><p>使用方法就是在E盘下新建一个名为wallpapers的文件夹，然后把自己喜欢的照片放进去就好，即<em>E:/wallpapers/</em> 。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桌面壁纸工具 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你实现一个简易的Linux平台下的划词翻译工具</title>
      <link href="/20200612/"/>
      <url>/20200612/</url>
      
        <content type="html"><![CDATA[<p>这里将要介绍的是一种在 <em>Linux</em> 平台实现的划词翻译工具，当然在考虑自己实现一个如此功能的工具前，本人也是在网上搜索了一些在 <em>Linux</em> 平台实现的类似的开源工具，例如 <a href="https://github.com/axipo/pdfTranslator" target="_blank" rel="noopener">pdfTranslator</a>，<a href="https://github.com/bianjp/popup-dict" target="_blank" rel="noopener">popup-dict</a>，但它们的安装和配置都显得比较麻烦，而且使用起来也并不方便。</p><p>本人实现这个工具的初衷本是方便自己看一些英文文献和书籍的，极为方便，考虑到分享出去可以让更多人受惠，因此这里详细介绍一下它的实现步骤。</p><a id="more"></a><p>本文所实现的划词翻译工具主要有以下特性：</p><ul><li>支持英文单词和短语到中文的翻译</li><li>划词翻译，终端显示</li><li>自动过滤选中文本中的换行等特殊字符</li><li>只依赖少数几个 <em>Linux</em> 命令工具</li></ul><p>下面有动图进行演示。</p><p><img src="iKnVA63lpy.gif" alt=""></p><p>本人所使用的环境是运行在 <em>VMware</em> 虚拟机下的 <em>Linux</em> 发行版 <em>Ubuntu 18.04.3 LTS</em> ，因此这里介绍的步骤可能与其他 <em>Linux</em> 发行版中的实现略有不同。下面就来一步一步的实现它吧。</p><h4 id="一-安装必要的命令"><a href="#一-安装必要的命令" class="headerlink" title="一. 安装必要的命令"></a>一. 安装必要的命令</h4><ol><li><em>xclip</em></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install xclip</span></span><br></pre></td></tr></table></figure><p><em>xclip</em> 命令建立了终端和剪切板之间通道，可以用命令的方式将终端输出或文件的内容保存到剪切板中，也可以将剪切板的内容输出到终端或文件。详细的用法可以使用 <em>man xclip</em>，见其手册。这里介绍几个常用的用法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xclip file_name <span class="comment"># 文件内容保存到X window剪切板</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection c file_name <span class="comment">#文件内容保存到外部剪切板</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -o <span class="comment"># X window剪切板内容输出到终端显示</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xclip -selection c -o <span class="comment"># 外部剪切板内容输出到终端显示</span></span></span><br></pre></td></tr></table></figure><p>值得强调的是，这里所说的 <em>X window</em> 剪切板，简单的说就是你用鼠标选择的文本会实时的存放在这个剪切板，使用鼠标中键可以粘贴。而外部剪切板是保存你用 <em>ctrl+c</em> 复制的文本，<em>ctrl+v</em> 可以粘贴。这两个地方是不一样的。</p><ol start="2"><li><em>translate-shell</em></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install translate-shell</span></span><br></pre></td></tr></table></figure><p>这是命令行版的谷歌翻译工具，之前叫做 <em>Google Translate CLI</em> 是一款借助谷歌翻译（默认）、必应翻译等来翻译的命令行翻译器。它让你可以在终端访问这些翻译引擎。 <em>translate-shell</em> 在大多数 <em>Linux</em> 发行版中都能使用。常用的方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trans en:zh [word] <span class="comment"># 英文到中文的单词翻译</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> trans en:zh -b [text] <span class="comment"># 简要的输出，进行文本翻译</span></span></span><br></pre></td></tr></table></figure><p>需要注意的是，使用这个翻译工具需要你能够<strong>访问外网</strong>，或者通过修改 <em>translate-shell</em> 的默认翻译引擎，具体的方法这里就不阐述了。</p><h4 id="二-编程实现"><a href="#二-编程实现" class="headerlink" title="二. 编程实现"></a>二. 编程实现</h4><p>这个工具整体的思路就是 <em>C</em> 程序实时检测鼠标按键的动态，当检测到用户使用鼠标选择一段文本之后，调用 <em>shell</em> 脚本获取 <em>X window</em> 剪切板的内容进行翻译后输出到终端显示。</p><p><strong>1. 定位鼠标设备文件</strong></p><p>鼠标作为输入设备。其信息可以在文件 <em>/proc/bus/input/devices</em> 中，使用下列命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /proc/bus/input/devices</span></span><br><span class="line">I: Bus=0011 Vendor=0002 Product=0013 Version=0006</span><br><span class="line">N: Name="VirtualPS/2 VMware VMMouse"</span><br><span class="line">P: Phys=isa0060/serio1/input1</span><br><span class="line">S: Sysfs=/devices/platform/i8042/serio1/input/input4</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mouse0 event2 </span><br><span class="line">B: PROP=0</span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=70000 0 0 0 0</span><br><span class="line">B: ABS=3</span><br></pre></td></tr></table></figure><p>其中的 <em>Handlers</em> 的值 <em>event2</em> 表示可以在 <em>/dev/input/event2</em> 文件下读取鼠标的状态。需要注意的是，对于不同的设备，读取鼠标的状态的文件可能不一样，比如也可能是 <em>/dev/input/event3</em>。我们可以使用下面的命令找到你的鼠标对应的是哪一个 <em>event</em>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cat /dev/input/event2 | hexdump <span class="comment"># 测试时改变数字即可</span></span></span><br></pre></td></tr></table></figure><p>比如，当我运行上面这条命令之后，我移动鼠标、按鼠标左键/中键/右键，终端都会输出一些值，这就说明 <em>event2</em> 文件就是对应着我的鼠标。如果操作鼠标没有反应，说明这个就不是。你可以通过这种方法找到你的鼠标对应的 <em>event</em> 文件。</p><p><strong>2. Linux 下获取按键响应</strong></p><p>在 <em>Linux</em> 内核中，<em>input</em> 设备用 <em>input_dev</em> 结构体描述，使用 <em>input</em> 子系统实现输入设备驱动的时候，驱动的核心工作就是向系统报告按键、触摸屏、键盘、鼠标等输入事件（<em>event*，通过 *input_event</em> 结构体描述），不再需要关心文件操作接口，因为 <em>input</em> 子系统已经完成了文件操作接口 <em>Linux/input.h</em> 这个文件定义了 <em>event</em> 事件的结构体，<em>API</em> 和标准按键的编码等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义见 input.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">// 按键时间</span></span><br><span class="line">    __u16 type;          <span class="comment">// 事件类型</span></span><br><span class="line">    __u16 code;          <span class="comment">// 要模拟成什么按键</span></span><br><span class="line">    __s32 value;         <span class="comment">// 是按下还是释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面宏定义见 input-event-coses.h</span></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_KEY 0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_REL 0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ABS 0x03</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_LEFT 0x110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_RIGHT 0x111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTN_MIDDLE 0x112</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSC_SERIAL 0x00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSC_PULSELED 0x01</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里稍微介绍一下 <em>type</em>，指事件类型，常见的事件类型有：<br><em>EV_KEY</em>，按键事件，如键盘的按键（按下哪个键），鼠标的左键右键（是否击下）等；<br><em>EV_REL</em>，相对坐标，主要是指鼠标的移动事件（相对位移）；<br><em>EV_ABS</em>， 绝对坐标，主要指触摸屏的移动事件 。</p><p><strong>3. 编写 <em>C</em> 程序</strong></p><p>下面就可以编写程序来检测鼠标的动态了。首先在你的用户~目录下建立文件夹 <em>Translator*。在 *Translator</em> 里建立一个 <em>ct.c</em> 源文件，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里打开的文件根据你自己的设备情况作相应的改变</span></span><br><span class="line">    keys_fd = <span class="built_in">open</span>(<span class="string">"/dev/input/event2"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (keys_fd &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open /dev/input/event2 error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(keys_fd, &amp;t, <span class="keyword">sizeof</span>(t));</span><br><span class="line">        <span class="keyword">if</span> (t.type == EV_KEY)              <span class="comment">// 有键按下</span></span><br><span class="line">            <span class="keyword">if</span> (t.code == BTN_LEFT)        <span class="comment">// 鼠标左键</span></span><br><span class="line">                <span class="keyword">if</span> (t.value == MSC_SERIAL) <span class="comment">// 松开</span></span><br><span class="line">                    <span class="comment">// 调用外部shell脚本</span></span><br><span class="line">                    system(<span class="string">"~/Translator/goTranslate.sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(keys_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是调用 <em>gcc</em> 编译器生成可执行文件 <em>ct</em>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ct.c -o ct</span></span><br></pre></td></tr></table></figure><p><strong>4. 编写 <em>shell</em> 脚本翻译剪切板内容</strong></p><p>在 <em>Translator</em> 里建立 <em>goTranslate.sh</em> 文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str_old=$(cat ~/Translator/lastContent)</span><br><span class="line">str_new=$(xclip -o 2&gt;/dev/null | xargs)</span><br><span class="line">if [[ "$str_new" != "$str_old" &amp;&amp; $str_new ]]; then</span><br><span class="line">    echo -e "\n"</span><br><span class="line">    count=$(echo "$str_new" | wc -w)</span><br><span class="line">    if [ "$count" == "1" ]; then</span><br><span class="line">        echo -n -e "$str_new " &gt;&gt;~/Translator/words</span><br><span class="line">        echo "$str_new" | trans :zh-CN | tail -1 | cut -c 5- | sed "s,\x1b\[[0-9;]*[a-zA-Z],,g" | tee -a ~/Translator/words</span><br><span class="line">    else</span><br><span class="line">        echo "$str_new" | trans :zh-CN -b</span><br><span class="line">    fi</span><br><span class="line">    echo "$str_new" &gt;~/Translator/lastContent</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>原理非常简单，读者自行了解。这里我们还要在 <em>Translator</em> 里建立一个 <em>lastContent.txt</em> 文件作为缓存，目的是本次调用脚本时能够获取上一次调用时翻译的文本内容，如果和本次调用的翻译文本一样，则本次就不进行翻译。</p><p><em>*5. 设置 *ct</em> 别名 **</p><p>这里已经可以通过下面的命令运行程序了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ~/Translator/ct</span></span><br></pre></td></tr></table></figure><p>但是由于每次运行都要输出这么长的命令，因此我们在 <em>~/.bashrc</em> 文件中加入下面一条命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ct='sudo ~/Translator/ct'</span><br></pre></td></tr></table></figure><p>这样，以后每次看英文文献时就可以在命令行下输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ct</span></span><br></pre></td></tr></table></figure><h4 id="三-结束语"><a href="#三-结束语" class="headerlink" title="三. 结束语"></a>三. 结束语</h4><p>这里有一些小技巧。可以更方便的使用这个工具。比如，把终端设为置顶并缩小到合适的尺寸，这样在阅读文献划词翻译时终端屏幕不会遮挡我们的视线。</p><p>值得说明的是，由于本人完全是为了方便自己的使用，而且在搞出这么个工具时仅仅接触 <em>Linux</em> 系统才不到两周，所以里面的实现对于有经验的朋友来说略显的有些笨拙了，请理解哈。</p><p>个人觉得这个工具使用起来还是很方便的，你觉得呢？</p><p>参考文章：</p><ol><li><a href="https://blog.csdn.net/liang12360640/article/details/50350648" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/50350648</a></li><li><a href="https://www.cnblogs.com/yangwindsor/articles/3454955.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangwindsor/articles/3454955.html</a></li><li><a href="https://blog.csdn.net/liang12360640/article/details/50s350648" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/50s350648</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 划词翻译 </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第七章</title>
      <link href="/20200418/"/>
      <url>/20200418/</url>
      
        <content type="html"><![CDATA[<h4 id="第7章：模板与泛型编程"><a href="#第7章：模板与泛型编程" class="headerlink" title="第7章：模板与泛型编程"></a>第<code>7</code>章：模板与泛型编程</h4><h5 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款<code>41</code>：了解隐式接口和编译期多态</h5><ul><li><p>哪一个重载函数被调用——发生在编译期</p></li><li><p>哪一个<code>virtual</code>函数被绑定——发生在运行期</p></li><li><p><code>class</code>和<code>template</code>都支持接口和多态</p><p>  对<code>class</code>而言，接口是显式的，以成员函数的签名为中心，多态则通过<code>virtual</code>函数发生在运行期。对<code>template</code>而言，接口是隐式的，以有效表达式为中心，多态则通过<code>template</code>具现化和函数重载解析发生于编译期。</p></li></ul><a id="more"></a><h5 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款<code>42</code>：了解<code>typename</code>的双重意义</h5><ul><li><p>当我们声明模板类型参数，<code>class</code>和<code>typename</code>的意义完全相同</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>typename</code>用来标识嵌套从属类型名称</p><p>  <code>template</code>内出现的名称如果相依于某个<code>template</code>参数，称这个名称为从属名称，如果丛属名称在<code>class</code>内呈嵌套状，称为嵌套从属名称。如果嵌套从属名称还指涉某种类型名称为嵌套从属类型名称</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::iterator_traits&lt;IterT&gt;::value_type 就是嵌套从属类型名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须使用 typename 关键字标识</span></span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 typedef 少打几个字</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 必须使用 typename 关键字标识</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不允许在<code>base class list</code>或<code>member initialization list</code>内使用<code>typename</code>作为<code>base class</code>的标识符</p></li></ul><h5 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款<code>43</code>：学习处理模板化基类内的名称</h5><p>假设我们需要撰写一个<code>MsgSender</code>类，它能够传送信息到若干不同的<code>Company</code>去。信息要不进行加密后的密文，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于<code>template</code>的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 针对其他公司设计的 class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgInfo</span> &#123;</span>...&#125;; <span class="comment">// 这个 class 以备将来产生信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">//构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">string</span> msg;</span><br><span class="line">... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">c.sendCleartext(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">c.sendEncrypted(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在假设我们想要在每次送出信息时<code>log</code>某些信息。<code>derived class</code>可轻易提供解决方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">sendClear(info); <span class="comment">// 调用 base class 函数, 这段码无法通过编译!</span></span><br><span class="line">... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译器会抱怨<code>sendClear</code>函数不存在，明明在那里，为什么？</p><p>问题在于，当编译器看见<code>class template LoggingMsgSender</code>定义式时，并不知道它继承什么样的<code>class</code>。当然它继承的是<code>MsgSender&lt;Company&gt;</code>，但其中的<code>Company</code>是个<code>template</code>参数，不当<code>LoggingMsgSender</code>被具现化之前无法确切知道它是什么。而如果不知道<code>Company</code>是什么，就无法知道<code>class MsgSender&lt;Company&gt;</code>看起来像什么——更明确地说是没办法知道它是否有个<code>sendClear</code>函数。</p><p>具体点说，假设现在有个<code>CompanyZ</code>坚持只使用加密通讯：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不提供 sendCleartext 函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyZ</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般性的<code>MsgSender template</code>对<code>CompanyZ</code>并不合适，因为那个<code>template</code>提供了一个<code>sendClearMsg</code>函数，而这对<code>CompanyZ</code>对象并不合理。欲矫正这个问题，我们可以针对<code>CompanyZ</code>产生一个<code>MsgSender</code>特化版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全特化版本只提供 sendSecret 函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span>&lt;CompanyZ&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">//构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> msg;</span><br><span class="line">... <span class="comment">// 在这儿, 根据 info 产生信息</span></span><br><span class="line">        Company c;</span><br><span class="line">c.sendEncrypted(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就解释了前面编译器拒绝那个调用的原因：它知道<code>base class template</code>有可能被特化，而那个特化版本可能不提供和一般性<code>template</code>相同的接口。因此它往往拒绝在<code>templatized base class</code>（本例的<code>MsgSender&lt;Company&gt;</code>）内寻找继承而来的名称（本例的<code>SendClear</code>)。</p><ul><li>当我们从<code>Object Oriented C++</code>跨进<code>Template C++</code>（见条款<code>1</code>) ，继承就不像以前那样畅行无阻了</li></ul><p>有三个解决令<code>C++</code>编译器“不进入<code>templatized base class</code>观察”的行为失效的办法：</p><ol><li><p>使用<code>this</code>指针</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line"><span class="keyword">this</span>-&gt;sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>using</code>声明</p><p> 虽然<code>using</code>声明式在在条款<code>33</code>或在这里都可有效运作，但两处解决的问题其实不相同。前者是<code>base class</code>名称被<code>derived class</code>名称遮掩，而后者是编译器不进入<code>base class</code>作用域内查找，于是我们通过<code>using</code>告诉它，请它那么做。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用作用域运算符<code>::</code>明确指定</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">... <span class="comment">// 构造函数、析构函数等等</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 将“传送前”的信息写至 log</span></span><br><span class="line">MsgSender&lt;Company&gt;::sendClear(info); <span class="comment">// 调用 base class 函数</span></span><br><span class="line">... <span class="comment">// 将“传送后”的信息写至 log</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>即使如此，如果稍后这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoggingMsgSender&lt;Companyz&gt;zMsgSender;</span><br><span class="line">MsgInfo msgData;</span><br><span class="line">...</span><br><span class="line">zMsgSender.sendClearMsg(msgData); <span class="comment">// 仍然无法通过编译</span></span><br></pre></td></tr></table></figure><p>其中对<code>sendClearMsg</code>的调用动作将无法通过编译，因为在那个点上，编译器知道<code>base class</code>是个<code>template</code>特化版本<code>MsgSender&lt;CompanyZ&gt;</code>，而且它知道那个<code>class</code>不提供<code>sendClear</code>函数，而<code>sendClear</code>却是<code>sendClearMsg</code>尝试调用的函数。 </p><h5 id="条款44：将与基类无关的代码抽离template"><a href="#条款44：将与基类无关的代码抽离template" class="headerlink" title="条款44：将与基类无关的代码抽离template"></a>条款<code>44</code>：将与基类无关的代码抽离<code>template</code></h5><p>当你编写某个函数，其中某些部分的实现码和另一个函数的实现码实质相同，你会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。如果你正在编写某个<code>class</code>，而你明白其中某些部分和另一个<code>class</code>的某些部分相同，你也不会重复这共同的部分。你会把共同部分搬移到新<code>class</code>去，然后使用继承或复合（见条款<code>32</code>，<code>38</code>，<code>39</code>) ，令原先的<code>class</code>取用这共同特性。而原<code>class</code>的互异部分仍然留在原位置不动。</p><p>编写<code>template</code>时，也是做相同的分析，以相同的方式避免重复。然而在<code>template</code>代码中，重复是隐晦的：毕竟只存在一份<code>template</code>源码，所以你必须训练自己去感受当<code>template</code>被具现化多次时可能发生的重复。</p><p>举个例子，假设你想为固定尺寸的正方矩阵编写一个<code>template</code>。该矩阵的性质之一是支持逆矩阵运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template 支持 n x n 矩阵, 元素类型为 T</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">squareMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">( )</span></span>; <span class="comment">// 求逆矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; sml;</span><br><span class="line">...</span><br><span class="line">sm1.invert(); <span class="comment">// 调用 SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line">sSquareMatrix&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.invert(); <span class="comment">// 调用 SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure><p>这会具现化两份<code>invert</code>。这些函数并非完完全全相同，因为其中一个操作的是<code>5x5</code>矩阵而另一个操作的是<code>10x10</code>矩阵，但除了常量<code>5</code>和<code>10</code>，两个函数的其他部分完全相同。这是<code>template</code>引出代码膨胀的一个典型例子。</p><p>第一次修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与尺寸无关的 base class</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">size_t</span> matrixSize)</span> <span class="comment">// 以给定的尺寸求逆矩阵</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明为 private 是为了不让客户看见</span></span><br><span class="line"><span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert; <span class="comment">// 避免遮掩 base 版的 invert, 见条款 33</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invert(n);<span class="comment">// inline 调用 base class 版的 invert</span></span><br><span class="line">        <span class="comment">// 为什么这儿出现 this-&gt; 见条款 43</span></span><br><span class="line">        <span class="comment">// LYL 认为前面已经使用了 using, this-&gt; 应该也不需要了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>base class</code>只是为了帮助<code>derived class</code>实现，不是为了表现<code>SquareMatrix</code>和<code>SquareMatrixBase</code>之间的<code>is-a</code>关系（关于<code>private</code>继承，见条款<code>39</code>)。</p><p>目前为止一切都好，但还有一些棘手的题目没有解决。<code>SquareMatrixBase::invert</code>如何知道该操作什么数据？虽然它从参数中知道矩阵尺寸，但它如何知道哪个特定矩阵的数据在哪儿？想必只有<code>derived class</code>知道。<code>derived class</code>如何联络其<code>base class</code>做逆运算动作？一个可能的做法是为<code>SquareMatrixBase::invert</code>添加另一个参数，可以是个指针，指向一块用来放置矩阵数据的内存地址。</p><p>第二次修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 存储矩阵大小和一个指针, 指向矩阵数值</span></span><br><span class="line">squareMatrixBase(<span class="keyword">size_t</span> n, T* pMem) : size(n), pData(pMem) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span> <span class="comment">// 不用指定尺寸了</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">size_t</span> size; <span class="comment">// 矩阵的大小</span></span><br><span class="line">T* pData; <span class="comment">// 指针, 指向矩阵内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SquareMatrix() : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T data[n * n];<span class="comment">// 这里直接将数据矩阵存储在 SquareMatrix 对象内部</span></span><br><span class="line"><span class="comment">// 也可以使用动态内存分配的方案</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个条款只讨论由<code>non-type template parameter</code>（非类型模板参数）带来的膨胀，其实<code>type parameter</code>（类型参数）也会导致膨胀。例如在许多平台上<code>int</code>和 <code>long</code>有相同的二进制表述，所以像<code>vector&lt;int&gt;</code>和<code>vector&lt;long&gt;</code>的成员函数有可能完全相同。某些链接器（<code>linker</code>）会合并完全相同的函数实现码，但有些不会，后者意味某些<code>template</code>被具现化为<code>int</code>和<code>long</code>两个版本，并因此造成代码膨胀。类似情况，所有指针类型都有相同的二进制表述，因此凡<code>template</code>持有指针者（例如<code>list&lt;int*&gt;</code>，<code>list&lt;const int*&gt;</code>，<code>list&lt;SquareMatrix&lt;long, 3&gt;*&gt;</code>等等）往往应该对每一个成员函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它们操作强型指针（<code>strongly typed pointer</code>，即<code>T*</code>），你应该令它们调用另一个操作无类型指针（<code>untyped pointer</code>，即<code>void*</code>）的函数，由后者完成实际工作。某些<code>C++</code>标准程序库实现版本的确为<code>vector</code>，<code>deque</code>和<code>list</code>等<code>template</code>做了这件事。</p><h5 id="条款45：成员函数模板接受所有兼容类型"><a href="#条款45：成员函数模板接受所有兼容类型" class="headerlink" title="条款45：成员函数模板接受所有兼容类型"></a>条款<code>45</code>：成员函数模板接受所有兼容类型</h5><p>内置指针是支持隐式转换的，比如<code>derived class</code>的指针可以隐式转换为<code>base class</code>指针，指向<code>non-const</code>对象的指针可以转换为指向<code>const</code>对象等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> :</span> <span class="keyword">public</span> Top &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> :</span> <span class="keyword">public</span> Middle &#123;...&#125;;</span><br><span class="line">Top* pt1 = <span class="keyword">new</span> Middle; <span class="comment">// 将 Middle* 转换为 Top*</span></span><br><span class="line">Top* pt2 = <span class="keyword">new</span> Bottom; <span class="comment">// 将 Bottom* 转换为 Top*</span></span><br><span class="line"><span class="keyword">const</span> Top* = pt1; <span class="comment">// Top* 转换为 const Top*</span></span><br></pre></td></tr></table></figure><p>但是我们自己实现的智能指针模板类，想做到这样就稍稍有点麻烦了。我们希望下面的代码能够通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">temmplate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* realPtr)</span></span>; <span class="comment">// 智能指针通常以内置指针完成初始化</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Middle&gt;转 换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(<span class="keyword">new</span> Middle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Bottom&gt; 转换为 SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SmartPtr&lt;Top&gt; 转换为 SmartPtr&lt;const Top&gt;</span></span><br><span class="line">SmartPtr&lt;<span class="keyword">const</span> Top&gt; pct2 = ptl;</span><br></pre></td></tr></table></figure><p><strong>注意，这些赋值表达式需要调用的都是<code>copy</code>构造函数。</strong>这里的代码不能通过编译，因为如果以带有<code>base-derived</code>关系的<code>B</code>，<code>D</code>两类型分别具现化某个<code>template</code>，产生出来的两个具现体并不带有<code>base-derived</code>关系，所以编译器视<code>SmartPtr&lt;Middle&gt;</code>和<code>SmartPtr&lt;Top&gt;</code>为完全不同的<code>class</code>，为了获得我们希望获得的<code>SmartPtr class</code>之间的转换能力，我们必须将它们明确地编写出来。</p><p>我们应该为它写一个<strong>构造模板</strong>。这样的模板是所谓<code>member function template</code>，其作用是为<code>class</code>生成函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// member template, 为了生成 copy 构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们称之为泛化（<code>generalized</code>）<code>copy</code>构造函数。它并未被声明为<code>explicit</code>，那是因为内置指针类型之间的转换（例如从<code>derived class</code>指针转为<code>base class指针</code>）是隐式转换，所以让智能指针按照这种形式也属合理。</p><p>但是，这个为<code>SmartPtr</code>而写的“泛化<code>copy</code>构造函数”提供的东西比我们需要的更多。我们只希望根据一个<code>SmartPtr&lt;Bottom&gt;</code>创建一个<code>SmartPtr&lt;Top&gt;</code>，却不希望根据一个<code>SmartPtr&lt;Top&gt;</code>创建一个<code>SmartPtr&lt;Bottomr&gt;</code>，因为那对<code>public</code>继承而言（见条款32）是矛盾的。我们也不希望根据一个<code>SmartPtr&lt;double&gt;</code>创建一个<code>SmartPtr&lt;int&gt;</code>，我们必须从某方面对这一<code>member template</code>所创建的成员函数群进行挑拣。</p><p>假设<code>SmartPtr</code>遵循<code>std::shared_ptr</code>也提供一个<code>get</code>成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以 other 的 heldPtr 初始化 this 的 heldPtr</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) : heldPtr(other.get()) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* heldPtr; <span class="comment">// 这个 SmartPtr 持有的内置指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个行为只有当“存在某个隐式转换可将一个<code>U*</code>指针转为一个<code>T*</code>指针”时才能通过编译，而这正是我们想要的。</p><p><code>member function template</code>（成员函数模板）的效用不限于构造函数，<strong>它常扮演的另一个角色是支持赋值操作。</strong>例如<code>std::shared_ptr</code>同时支持所有“来自兼容之内置指针、<code>std::shared_ptr</code>、<code>std::weak_ptr</code>”的构造行为以及赋值操作（<code>std::weak_ptr</code>除外）。赋值操作符和<code>copy</code>构造函数实现类似，故省略。</p><ul><li>如果你声明<code>member template</code>用于“泛化<code>copy</code>构造”或“泛化<code>assignment</code>操作”你还是需要声明正常的<code>copy</code>构造函数和<code>copy assignment</code>操作符</li></ul><p>条款<code>5</code>说过，编译器可能为我们产生四个成员函数，其中两个是<code>copy</code>构造函数和<code>copy assignment</code>操作符。现在，<code>SmartPtr</code>声明了一个泛化<code>copy</code>构造函数，而显然一旦类型<code>T</code>和<code>U</code>相同，泛化<code>copy</code>构造函数会被具现化为“正常的”<code>copy</code>构造函数。那么究竟编译器会暗自为<code>SmartPtr</code>生成一个<code>copy</code>构造函数呢？或当某个<code>SmartPtr</code>对象根据另一个同型的<code>SmartPtr</code>对象展开构造行为时，编译器会将“泛化copy构造函数模板”具现化呢？</p><p><code>member template</code>并不改变语言规则：“如果程序需要一个<code>copy</code>构造函数，你却没有声明它，编译器会为你暗自生成一个”。在<code>class</code>内声明泛化<code>copy</code>构造函数（是个<code>member template</code>）并不会阻止编译器生成它们自己的<code>copy</code>构造函数（一个<code>non-template</code>），所以如果你想要控制<code>copy</code>构造的方方面面，你必须同时声明泛化<code>copy</code>构造函数和“正常的”<code>copy</code>构造函数。相同规则也适用于赋值操作。</p><h5 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款<code>46</code>：需要类型转换时请为模板定义非成员函数</h5><p>条款<code>24</code>讨论过为什么惟有<code>non-member</code>函数才有能力“在所有实参身上实施隐式类型转换”，该条款并以<code>Rational class</code>的<code>operator*</code>函数为例。本条款将<code>Rational</code>和<code>operator*</code>模板化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 条款 20 告诉你为什么参数以 passed by reference 方式传递</span></span><br><span class="line">Rational(<span class="keyword">const</span> T&amp; numerator = <span class="number">0</span>, <span class="keyword">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 条款 28 告诉你为啥返回值以 passed by value 方式传递</span></span><br><span class="line"><span class="comment">// 条款 3 告诉你为啥它们是 const</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像条款<code>24</code>一样，我们也希望支持混合式算术运算，然而以下代码却不能通过编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;int&gt; oneHalf(1, 2);</span><br><span class="line">Rational&lt;int&gt; result &#x3D; oneHalf * 2; &#x2F;&#x2F; 错误!无法通过编译</span><br></pre></td></tr></table></figure><p>在这里，编译器不知道我们想要调用哪个函数！它们试图找到什么函数被名为<code>operator*</code>的<code>template</code>具现化出来。它们知道它们应该可以具现化某个“名为<code>operator*</code>并接受两个<code>Rational&lt;T&gt;</code>参数”的函数，但为完成这一具现化行动，必须先算出<code>T</code>是什么。</p><p>为了推导<code>T</code>，它们看了看<code>operator*</code>调用动作中的实参类型。分别是<code>Rational&lt;int&gt;</code>（<code>oneHalf</code>的类型）和<code>int</code>（<code>2</code>的类型）。</p><p>以<code>oneHalf</code>进行推导，过程并不困难。第二参数的推导则没有这么顺利。<code>operator*</code>的第二参数被声明为<code>Rational&lt;T&gt;</code>，但传递给<code>operator*</code>的类型是<code>int</code>（<code>2</code>）。编译器如何根据这个<code>2</code>推算出<code>T</code>？你或许会期盼编译器使用<code>Rational&lt;int&gt;</code>的<code>non-explicit</code>构造函数将转换为<code>Rational&lt;int&gt;</code>，进而将<code>T</code>推导为<code>int</code>，然而<strong><code>template</code>实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。</strong></p><p><code>template class</code>内的<code>friend</code>声明式可以指涉某个特定函数。这意味<code>class Rational&lt;T&gt;</code>可以声明<code>operator*</code>是它的一个<code>friend</code>函数。<code>class template</code>并不倚赖<code>template</code>实参推导，所以编译器总是能够在<code>class Rational&lt;T&gt;</code>具现化时得知<code>T</code>。因此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在当对象<code>oneHalf</code>被声明为一个<code>Rational&lt;int&gt;</code>，<code>class Rational&lt;int&gt;</code>于是被具现化出来，而作为过程的一部分，<code>friend</code>函数<code>operator*</code>（接受<code>Rational&lt;int&gt;</code>参数）也就被自动声明出来。后者身为一个函数而非<code>function template</code>，因此编译器可在调用它时使用隐式转换函数（例如调用<code>Rational</code>的<code>non-explicit</code>构造函数）。                                                        </p><p>但是，虽然这段代码通过编译，却无法连接。</p><p>因为这个友元函数只被声明于<code>Rational</code>内，并没有被定义出来。我们意图令此<code>class</code>外部的<code>operator* template</code>提供定义式，是行不通的。既然我们没有提供定义式，连接器当然找不到它！</p><p>最简单的方法就是，将函数本体放进<code>class</code>内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                        lhs.denominator() * rhs.denominator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了让类型转换可能发生于所有实参身上，我们需要一个<code>non-member</code>函数（条款<code>24</code>）；为了令这个函数被自动具现化，我们需要将它声明在<code>class</code>内部；而在class内部声明<code>non-member</code>函数的唯一办法就是：令它成为一个<code>friend</code>。因此我们就这样做了。</p><ul><li><p>当此<code>friend</code>函数过于复杂时，令其调用类外的辅助函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rational</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Rational&lt;T&gt;&amp;rhs)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Rational&lt;T&gt;(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                       lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">friend</span></span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt;<span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                                <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> doMultiply(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  作为一个<code>template</code>，<code>doMultiply</code>当然不支持混合式乘法，但它其实也不需要。它只被<code>operator*</code>调用，而<code>operator*</code>支持混合式操作。</p></li></ul><h5 id="条款47：traits-classes表现类型信息"><a href="#条款47：traits-classes表现类型信息" class="headerlink" title="条款47：traits classes表现类型信息"></a>条款<code>47</code>：<code>traits classes</code>表现类型信息</h5><p><code>STL</code>迭代器分类：</p><ol><li><p><code>input</code>迭代器</p><p> 只能向前移动，一次一步，用户只能读取它所指的东西，而且只能读取一次，读完立即自动向前一步。程序库中的输入流迭代器<code>istream_iterator</code>就属于这一类。</p></li><li><p><code>output</code>迭代器</p><p> 只能向前移动，一次一步，用户只能涂写它所指的东西，而且只能涂写一次，写完立即自动向前一步。程序库中的输出流迭代器<code>ostream_iterator</code>就属于这一类。</p></li><li><p><code>forward</code>迭代器</p><p> 可以做上述两种迭代器做的事情，而且支持多次读写，读写完由用户自行决定是否前进。单向链表<code>slist</code>提供的迭代器就属于这一类。</p></li><li><p><code>bidirectional</code>迭代器</p><p> 除了能做<code>forward</code>迭代器做的事情，还可以向后移动。双向链表<code>list</code>以及<code>set</code>，<code>mutilset</code>，<code>map</code>，<code>mutilmap</code>提供的迭代器属于这一类。</p></li><li><p><code>random access</code>迭代器</p><p> 功能类似于内置指针，可以进行算数操作。<code>vector</code>，<code>deque</code>和<code>string</code>提供的迭代器属于这一类。</p></li><li><p><em>迭代器适配器</em></p><ul><li><em><code>reverse</code>迭代器</em></li><li><em><code>insert</code>迭代器</em><ul><li><em><code>back inserter</code></em></li><li><em><code>front inserter</code></em></li><li><em><code>general inserter</code></em></li></ul></li><li><em><code>stream</code>迭代器</em></li><li><em><code>move</code>迭代器</em></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional</span> <span class="title">iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这些<code>struct</code>之间的继承关系是有效的<code>is-a</code>关系：所有<code>forward</code>迭代器都是<code>input</code>迭代器，依此类推。</p><p>关于<code>iterator_trait</code>的实现技术（参考书籍<code>P227-P232</code>）</p><h5 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款<code>48</code>：认识<code>template</code>元编程</h5><ul><li>如题，以后买本书再专门去学吧！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第六章</title>
      <link href="/20200410/"/>
      <url>/20200410/</url>
      
        <content type="html"><![CDATA[<h4 id="第6章：继承与面向对象设计"><a href="#第6章：继承与面向对象设计" class="headerlink" title="第6章：继承与面向对象设计"></a>第<code>6</code>章：继承与面向对象设计</h4><h5 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款<code>32</code>：确定你的<code>public</code>继承塑模出<code>is-a</code>关系</h5><ul><li>“<code>public</code>继承”意味<code>is-a</code>。适用于<code>base class</code>身上的每一件事情一定也适用于<code>derived class</code>身上，因为每一个<code>derived class</code>对象也都是一个<code>base class</code>对象</li></ul><a id="more"></a><h5 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款<code>33</code>：避免遮掩继承而来的名称</h5><ul><li><p><code>derived class</code>的作用域被嵌套在<code>base class</code>作用域内</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); <span class="comment">// 没问题, 调用 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 错误! 因为 Derived::mf1 遮掩了 Base::mf1</span></span><br><span class="line">d.mf2(); <span class="comment">// 没问题, 调用 Derived::mf2</span></span><br><span class="line">d.mf2(x); <span class="comment">// 错误! 因为 Derived::mf2 遮掩了 Base::mf2</span></span><br></pre></td></tr></table></figure><p>  这段代码中<code>base class</code>内所有名为<code>mf1</code>和<code>mf2</code>的函数都被<code>derived class</code>内的<code>mf1</code>和<code>mf2</code>函数遮掩掉了。从名称查找观点来看，<code>Base::mf1</code>和<code>Base::mf2</code>不再被<code>Derived</code>继承！</p><p>  实际上如果你正在使用<code>public</code>继承而又不继承那些重载函数，就是违反<code>base</code>和<code>derived class</code>之间的<code>is-a</code>关系，而条款<code>32</code>说过<code>is-a</code>是<code>public</code>继承的基石。因此你几乎总会想要推翻<code>C++</code>对“继承而来的名称”的缺省遮掩行为。</p><ul><li><p>使用<code>using</code>声明式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::mf1; <span class="comment">// 让 Base class 内名为 mf1 和 mf2 的所有东西</span></span><br><span class="line"><span class="keyword">using</span> Base::mf2; <span class="comment">// 在 Derived 作用域内都可见, 并且 public</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); <span class="comment">// 没问题, 调用 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 现在没问题了, 调用 Based::mf1</span></span><br><span class="line">d.mf2(); <span class="comment">// 没问题, 调用 Derived::mf2</span></span><br><span class="line">d.mf2(x); <span class="comment">// 现在没问题了, 调用 Based::mf2</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>inline</code>转交函数（<code>forwarding function</code>）</p><p>  然而在<code>private</code>继承之下（见条款<code>39</code>），有时候你并不想继承<code>base class</code>的所有函数。假设<code>Derived</code>以<code>private</code>形式继承<code>Base</code>，而<code>Derived</code>唯一想继承的<code>mf1</code>是那个无参数版本。<code>using</code>声明式在这里派不上用场，因为<code>using</code>声明式会令继承而来的某给定名称之所有同名函数在<code>derived class</code>中都可见。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">... <span class="comment">// 与前同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> <span class="comment">// 转交函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base::mf1(); <span class="comment">// 暗自成为 inline (见条款 30)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">d.mf1(); <span class="comment">// 很好, 调用的是 Derived::mf1</span></span><br><span class="line">d.mf1(x); <span class="comment">// 错误! Base::mf1 被遮掩</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款<code>34</code>：区分接口继承和实现继承</h5><p>身为<code>class</code>设计者，有时候你会希望<code>derived class</code>只继承成员函数的接口，也就是声明；有时候你又会希望<code>derived class</code>同时继承函数的接口和实现，但又希望能够覆写（<code>override</code>）它们所继承的实现；又有时候你希望<code>derived class</code>同时继承函数的接口和实现，并且不允许覆写任何东西。</p><p><code>base</code>类强烈影响以<code>public</code>形式继承它的<code>derived class</code>，因为：</p><ul><li><p>成员函数的接口总是会被继承</p></li><li><p>声明一个<code>pure virtual</code>函数的目的是为了让<code>derived</code>类只继承函数接口</p><p>  含有<code>pure virtual</code>函数的类属于抽象基类，不能被实例化。继承了它们的类必须重新声明此函数接口并给予实现。抽象基类可以给<code>pure virtual</code>函数提供定义，但调用它的唯一途径是“调用时指定其<code>class</code>的名称”。</p></li><li><p>声明<code>impure</code>函数的目的是让<code>derived class</code>继承该函数的接口和缺省实现</p><p>  但是，允许<code>impure virtual</code>函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑<code>XYZ</code>航空公司设计的飞机继承体系。该公司只有<code>A</code>型和<code>B</code>型两种飞机，两者都以相同方式飞行。因此<code>XYZ</code>设计出这样的继承体系：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span> &#123;</span>...&#125;; <span class="comment">// 用以表现机场</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省代码, 将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span> <span class="keyword">public</span> Airplane &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span>:</span> <span class="keyword">public</span> Airplane &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>  为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的<code>fly</code>实现”，<code>Airplane::fly</code>被声明为<code>virtual</code>。然而为了避免在<code>ModelA</code>和<code>ModelB</code>中撰写相同代码，缺省飞行行为由<code>Airplane::fly</code>提供，它同时被<code>ModelA</code>和<code>ModelB</code>继承。</p><p>  现在，<code>XYZ</code>航空公司决定购买一种新式<code>C</code>型飞机。<code>C</code>型和<code>A</code>型以及<code>B</code>型的飞行方式不同。<code>XYZ</code>公司的程序员在继承体系中针对<code>C</code>型飞机添加了一个<code>class</code>，但由于他们急着让新飞机上线服务，竟忘了重新定义其<code>fly</code>函数：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 未声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Airport <span class="title">PDX</span><span class="params">(... )</span></span>; <span class="comment">// PDX 是我家附近的机场</span></span><br><span class="line">Airplane* pa= <span class="keyword">new</span> ModelC;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这将酿成大灾难</span></span><br><span class="line">pa-&gt;fly(PDX); <span class="comment">// 调用 Airplane::fly</span></span><br></pre></td></tr></table></figure><p>  一种解救办法为切断“<code>virtual</code>函数接口”和其“缺省实现”之间的连接。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 现在是 pure virtual 函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span> <span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">... <span class="comment">// 缺省行为, 将飞机飞至指定的目的地。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        defaultFly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        defaultFly (destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 ModelC class 不可能意外继承不正确的 fly 实现代码了</span></span><br><span class="line"><span class="comment">// 因为 Airplane 中的 pure virtual 函数追使 ModelC 必须提供自己的 f1y 版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span>:</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">... <span class="comment">// 将 C 型飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  另一种解救方法是，利用“<code>pure virtual</code>函数必须在<code>derived class</code>中重新声明，但它们也可以拥有自己的实现”这一事实。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 现在是 pure virtual 函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给予 pure virtual 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省行为, 将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Airplane::fly(destination); <span class="comment">// 通过指定其类名调用它</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">virtuai <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Airplane::fly(destination); <span class="comment">// 通过指定其类名调用它</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">... <span class="comment">// 将 C 型飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明<code>non-virtual</code>函数的目的是为了<code>derived class</code>继承函数的接口及其强制性实现</p><p>  <code>non-virtual</code>函数为其所属<code>class</code>建立的意义是不变性凌驾其特异性，所以它不该在<code>derived class</code>中被重新定义。</p></li></ul><h5 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款<code>35</code>：考虑<code>virtual</code>函数以外的其他选择</h5><p>假设你正在写一个视频游戏软件，你的游戏属于暴力砍杀类型，剧中人物存在被伤害而降低健康状态的情况。因此你决定提供一个成员函数 <code>healthvalue</code>，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将<code>healthvalue</code>声明为<code>virtual</code>似乎是再明白不过的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 返回人物的健康指数,</span></span><br><span class="line"><span class="comment">// derived classes 可重新定义它</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在考虑一些其它解法：</p><ul><li><p>借助<code>non-virtual interface</code>(<code>NVI</code>)手法实现<code>Template Method</code>模式</p><p>  保留<code>healthvalue</code>为<code>public</code>成员函数，但让它成为<code>non-virtual</code>，并调用一个<code>private virtual</code>函数进行实际工作：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// derived class 不重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">... <span class="comment">// 做一些事前工作</span></span><br><span class="line"><span class="keyword">int</span> retval = doHealthvalue(); <span class="comment">// 做真正的工作</span></span><br><span class="line">... <span class="comment">// 做一些事后工作</span></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NVI 手法下没必要让 virtual 函数一定是 private</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">// derived class 可重新定义它</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    ... <span class="comment">// 缺省算法, 计算健康指数。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这一基本设计，“令客户通过<code>public non-virtual</code>成员函数间接调用<code>private virtual</code>函数”，称为<code>non-virtual interface</code>(<code>NVI</code>)手法。它是所谓<code>Template Method</code>设计模式的一个独特表现形式。我把这个<code>non-virtual</code>函数（<code>healthvalue</code>）称为<code>virtual</code>函数的外覆器（<code>wrapper</code>) 。</p><p>  <code>NVI</code>手法的一个优点隐藏在上述代码注释“做一些事前工作”和“做一些事后工作”之中。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证 <code>class</code>约束条件、验证函数先决条件等。“事后工作”可以包括互斥器解除锁定、验证函数的事后条件、再次验证<code>class</code>约束条件等。如果你让客户直接调用<code>virtual</code>函数，就没有任何好办法可以做这些事。</p></li><li><p>借助<code>Function Pointer</code>实现<code>Strategy</code>模式</p><p>  另一个设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个函数指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"><span class="comment">// 以下函数是计算健康指数的缺省算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span> <span class="params">(HealthCalcFunc hcf = defaultFealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">healthFunc</span><span class="params">(hcf)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这种设计策略和前面介绍的方法相比提供了一些有趣的弹性：</p><ul><li><p>同一人物类型的不同实体可以有不同的健康计算函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span> :</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">GameCharacter</span><span class="params">(hcf)</span> </span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 健康指数计算函数 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>; <span class="comment">// 健康指数计算函数 2</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>; <span class="comment">// 相同类型的人物搭配</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>; <span class="comment">// 不同的健康计算方式</span></span><br></pre></td></tr></table></figure></li><li><p>某已知人物之健康指数计算函数可在运行期变更</p><p>  例如<code>GameCharacter</code>可提供一个成员函数<code>setHealthcalculator</code>，用来替换当前的健康指数计算函数。</p><p>然而这种策略意味着，计算函数并不能访问“被计算健康指数的”那个对象的内部（<code>non-public</code>）成分。如果需要访问<code>non-public</code>成分进行精确计算，这就有问题了。</p><p>唯一能够解决的办法就是：弱化<code>class</code>的封装。例如，将健康计算函数声明为<code>friend</code>。或是为其实现的某一部分提供<code>public</code>访问函数。这需要你来权衡利弊进行抉择。</p></li></ul></li><li><p>借助<code>std::function</code>实现<code>Strategy</code>模式</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不同之处</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span> <span class="params">(HealthCalcFunc hcf = defaultFealthCalc)</span></span></span><br><span class="line"><span class="function">: <span class="title">healthFunc</span><span class="params">(hcf)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> healthFunc (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  那个签名代表的函数是“接受一个<code>reference</code>指向<code>const GameCharacter</code>，并返回<code>int</code>”。这个<code>std::function</code>类型（也就是我们所定义的<code>HealthCalcFunc</code>类型）产生的对象可以持有（保存）任何与此签名式<strong>兼容的</strong>可调用物。所谓兼容，意思是这个可调用物的参数可被<strong>隐式转换</strong>为<code>const GameCharacter&amp;</code>，而其返回类型可被<strong>隐式转换</strong>为<code>int</code>。</p><p>  这就提供了很大的灵活性：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">short <span class="title">calcHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;<span class="comment">// 健康计算函数</span></span><br><span class="line">                                        <span class="comment">// 注意其返回类型为 non-int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HealthCalculator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 为计算健康而设计的函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameLevel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">health</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span>;<span class="comment">// 成员函数, 用以计算健康</span></span><br><span class="line">    <span class="comment">// 注意其 non-int 返回类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物类型 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span>:</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line">... <span class="comment">// 同前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物类型 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EyeCandyCharacter</span>:</span> <span class="keyword">public</span> GameCharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 假设其构造函数与 EvilBadGuy 同</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物 1, 使用某个函数计算健康指数</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人物 2, 使用某个函数对象计算健康指数</span></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator())</span></span>;</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 人物 3, 使用某个成员函数计算健康指数</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(<span class="built_in">std</span>::bind(&amp;GameLevel::health, &amp;currentLevel, _1))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>传统的<code>Strategy</code>模式</p><p>  <img src="strategy.png" alt=""></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~HealthCalcFunc() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlowHealthLoser</span> :</span> HealthCalcFunc</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastHealthLoser</span> :</span> HealthCalcFunc</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf)</span> : <span class="title">pHealthCalc</span><span class="params">(phcf)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc-&gt;calc(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款<code>36</code>：绝不重新定义继承而来的<code>non-virtual</code>函数</h5><ul><li>如题</li></ul><h5 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款<code>37</code>：绝不重新定义继承而来的缺省参数值</h5><p>本条款的讨论局限于“继承一个带有缺省参数值的<code>virtual</code>函数”：<code>virtual</code>函数是动态绑定（后期绑定，延迟绑定），而缺省参数值却是静态绑定（前期绑定，早绑定）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个用以描述几何形状的class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> ShapeColor&#123;Red, Green, Blue&#125;;</span><br><span class="line">    <span class="comment">// 所有形状都必须提供一个函数, 用来绘出自己</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 注意, 赋予不同的缺省参数值, 这真糟糕!</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">// 请注意，以上这么写则当客户以 对象 调用此函数一定要指定参数值</span></span><br><span class="line">    <span class="comment">// 因为静态绑定下这个函数并不从其 base 继承缺省参数值</span></span><br><span class="line">    <span class="comment">// 但若以指针或 reference 调用此函数, 可以不指定参数值</span></span><br><span class="line">    <span class="comment">// 因为动态绑定下这个函数会从其 base 继承缺省参数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>对象的静态类型就是它在程序中所声明的类型，对象的动态类型则是指“目前所指对象的类型”</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shape* ps; <span class="comment">// 静态类型为 shape*, 无动态类型</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle; <span class="comment">// 静态类型为 Shape*, 动态类型是 Circle*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle; <span class="comment">// 静态类型为 shape*, 动态类型是 Rectangle*</span></span><br></pre></td></tr></table></figure><p>  动态类型可在程序执行过程中改变（通常是经由赋值动作）：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = pc; <span class="comment">// ps 的动态类型如今是 circle*</span></span><br><span class="line">ps = pr; <span class="comment">// ps 的动态类型如今是 Rectangle*</span></span><br></pre></td></tr></table></figure></li></ul><p><code>virtual</code>函数系动态绑定而来，意思是调用一个<code>virtual</code>函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pr-&gt;draw(); <span class="comment">// 调用的是 Rectangle::draw(shape::Red)!</span></span><br><span class="line"><span class="comment">// 注意缺省参数是 Red 而不是 Green</span></span><br></pre></td></tr></table></figure><p>此例之中，<code>pr</code>的动态类型是<code>Rectangle*</code>，所以调用的是<code>Rectangle</code>的<code>virtual</code>函数。<code>Rectangle::draw</code>函数的缺省参数值应该是<code>Green</code>，但由于<code>pr</code>的静态类型是<code>shape*</code>，所以此一调用的缺省参数值来自<code>Shape class</code>而非<code>Rectangle class</code>！这不符合预期。</p><p>解救方法是利用条款<code>35</code>中介绍的<code>NVI</code>手法替代<code>virtual</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum</span> shapeColor&#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span><span class="comment">// 如今它是 non-virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">doDraw(color); <span class="comment">// 调用一个 virtual</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 真正的工作在此处完成</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span> <span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>; <span class="comment">// 注意, 不须指定缺省参数值</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个设计很清楚地使得<code>draw</code>函数的<code>color</code>缺省参数值总是<code>Red</code>。</p><h5 id="条款38：通过复合塑模出has-a或is-implemented-in-terms-of"><a href="#条款38：通过复合塑模出has-a或is-implemented-in-terms-of" class="headerlink" title="条款38：通过复合塑模出has-a或is-implemented-in-terms-of"></a>条款<code>38</code>：通过复合塑模出<code>has-a</code>或<code>is-implemented-in-terms-of</code></h5><p>当某种类型的对象内含其它对象时便形成了复合关系。</p><ul><li><p>应用域</p><p>  程序中的对象其实相当于你所塑造出来的世界中的某些事物。比如人，汽车，高楼大厦等。这样的对象属于应用域部分。</p></li><li><p>实现域</p><p>  其它对象如缓冲区，互斥器，搜索树等纯粹是实现细节上的工具。这些对象相当于软件中的实现域。</p></li></ul><p>当复合发生于应用域对象之间表现出<code>has-a</code>关系，当它发生于实现域内则表现出<code>is-implemented-in-terms-of</code>（根据某物实现出）的关系。</p><ul><li><p>复合的意义和<code>public</code>继承完全不同</p><p>  注意区分<code>is-a</code>和<code>is-implemented-in-terms-of</code>这两种对象关系。</p></li></ul><h5 id="条款39：明智而谨慎地使用private继承"><a href="#条款39：明智而谨慎地使用private继承" class="headerlink" title="条款39：明智而谨慎地使用private继承"></a>条款<code>39</code>：明智而谨慎地使用<code>private</code>继承</h5><p>一个<code>derived</code>类继承<code>base</code>类有<code>public</code>、<code>protected</code>或<code>private</code>三种继承方式。</p><ul><li><p>公有继承（<code>public</code>）（普遍使用）</p><p>  <code>base</code>类的<code>public</code>成员也是<code>derived</code>类的<code>public</code>成员，<code>base</code>类的<code>protected</code>成员也是<code>derived</code>类的<code>protected</code>成员</p></li><li><p>保护继承（<code>protected</code>）（基本不使用）</p><p>  <code>base</code>类的<code>public</code>和<code>protected</code>成员将成为<code>derived</code>类的<code>protected</code>成员。</p></li><li><p>私有继承（<code>private</code>）（少的情况使用）</p><p>  <code>base</code>类的<code>public</code>和<code>protected</code>成员将成为<code>derived</code>类的<code>private</code>成员。</p></li></ul><p>无论哪一种继承方式，<code>base</code>类的<code>private</code>成员都不能直接被<code>derived</code>类访问，但是可以通过调用<code>base</code>类的<code>public</code>和<code>protected</code>成员间接来访问（如果<code>base</code>类提供了访问接口的话）。</p><ul><li><p><code>private</code>继承意味着<code>is-implemented-in-terms-of</code></p><p>  <code>private</code>继承只限于软件实现层面，这就是为什么<code>private</code>继承后，<code>base class</code>的所有成分（除了<code>private</code>）在你的<code>class</code>内都是<code>private</code>，因为它们都只是实现细节而已。</p></li><li><p>尽可能使用复合，<strong>必要时</strong>才使用<code>private</code>继承</p><ol><li><p>当<code>derived</code>类想要访问<code>base class</code>的<code>protected</code>成员时</p></li><li><p>当<code>derived</code>类为了重新定义<code>base class</code>的<code>virtual</code>函数时</p><p> 现在考虑一个<code>Widget</code>类，它需要用到另一个计时器<code>Timer</code>类来实现一些业务。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> tickFrequecy)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 定时器每滴答一次, 此函数就调用一次</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p> 为了让<code>Widget</code>重新定义<code>Timer</code>内的<code>virtual</code>函数，<code>Widget</code>必须继承自<code>Timer</code>。因为<code>Widget</code>不是个<code>Timer</code>，因此<code>public</code>继承不合适。必须以<code>private</code>方式继承：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 通过<code>private</code>继承，<code>Timer</code>的<code>public onTick</code>函数在<code>Widget</code>内变成<code>private</code>，而我们重新声明（定义）时仍然把它留在那儿。如果把<code>onTick</code>放进<code>public</code>内会误导客户以为他们可以调用它，那就违反了条款<code>18</code>。</p><p> 另一种设计方案是采用复合 + <code>public</code>继承：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在 Widget 内声明一个嵌套式 private class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetTimer</span> :</span> <span class="keyword">public</span> Timer</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 以 public 方式继承并重新定义 virtual 函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">WidgetTimer timer;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 采用第二种较为复杂的方式的两点理由：</p><ul><li>你或许会想设计<code>Widget</code>使它得以拥有<code>derived class</code>，但同时你可能会想阻止<code>derived class</code>重新定义<code>onTick</code>。如果<code>Widget</code>继承自<code>Timer</code>，上面的想法就不可能实现，即使是<code>private</code>继承也不可能。但如果<code>WidgetTimer</code>是<code>Widget</code>内部的一个<code>private</code>成员并继承自<code>Timer</code>，<code>Widget</code>的<code>derived class</code>将无法取用<code>WidgetTimer</code>，因此无法继承它或重新定义它的<code>virtual</code>函数。</li><li>你或许会想要将<code>Widget</code>的编译依存性降至最低（条款<code>31</code>）。如果<code>Widget</code>继承<code>Timer</code>，当<code>Widget</code>被编译时<code>Timer</code>的定义必须可见，所以定义<code>Widget</code>的那个文件恐怕必须<code>#include Timer.h</code>。但如果<code>WidgetTimer</code>移出<code>Widget</code>所在文件之外而<code>Widget</code>内含指针指向一个<code>WidgetTimer</code>，<code>Widget</code>可以只带着一个简单的<code>WidgetTimer</code>前向声明式，不再需要<code>#include</code>任何与<code>Timer</code>有关的东西。很容易就实现了解耦。</li></ul></li><li><p><code>EBO</code>（<code>empty base optimization</code>）</p><p> <code>empty class</code>指的是没有<code>non-static</code>成员变量，没有<code>virtual</code>函数，也没有<code>virtual base class</code>。于是这种<code>class</code>不占用理论上不占用任何内存空间。然而在实现技术上，<code>C++</code>要求<strong>独立（非附属）对象</strong>都必须有非零大小。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;; <span class="comment">// 没有任何需要存储的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 理论上 sizeof(HoldAnInt) = 4 字节(就一个 int)</span></span><br><span class="line"><span class="comment">// 实际上 sizeof(HoldAnInt) = 8 字节</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 字节</span></span><br><span class="line">    Empty e; <span class="comment">// 理论上应该不占据内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>C++</code>编译器默认为<code>empty class</code><strong>独立对象</strong>安插一个<code>char</code>（<code>1</code>字节）</p></li><li><p>由于内存对齐<code>HoldAnInt</code>的实际大小为<code>4 + 1(内存对齐至 4) = 8</code></p><p>但这个约束不适用于<code>derived class</code>对象的<code>base class</code>成分（非独立）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理论和实际上 sizeof(HoldAnInt) = 4 字节(就一个 int)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldAnInt</span> :</span> <span class="keyword">public</span> Empty</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 4 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现实中的<code>empty class</code>并非真是<code>empty</code>。往往内含<code>typedef</code>，<code>enum</code>，<code>static</code>成员变量，或<code>non-virtual</code>函数。<code>STL</code>就有许多技术用途的<code>empty class</code>，其中内含有用的成员（通常是<code>typedef</code>），包括<code>base class unary_function</code>和<code>binary_function</code>，这些是“用户自定义之函数对象”通常会继承的<code>class</code>。由于<code>EBO</code>，这样的继承很少增加<code>derived class</code>的大小。</p></li></ul></li></ol></li></ul><h5 id="条款40：明智而谨慎地使用多重继承"><a href="#条款40：明智而谨慎地使用多重继承" class="headerlink" title="条款40：明智而谨慎地使用多重继承"></a>条款<code>40</code>：明智而谨慎地使用多重继承</h5><ul><li><p>多重继承较单一继承复杂，可能导致歧义性</p><p>  当继承的多个<code>base</code>具有同名成员函数时，<code>derived</code>类调用时会出现歧义。</p></li><li><p>有时多重继承不得不需要<code>virtual</code>继承，而这会带来额外的体积、运行速度、初始化复杂度等成本</p><p>  比如这样的钻石继承体系：</p><p>  <img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.png" alt=""></p><p>  这个继承体系中某个<code>base class</code>和某个<code>derived class</code>之间有一条以上的相通路线，假设<code>File class</code>有个成员变量<code>fileName</code>，那么<code>IOFile</code>从每一个<code>base class</code>各继承一份，所以其对象内会有两份<code>fileName</code>成员变量。然而<code>IOFile</code>对象只该有一个文件名称，所以名称<code>fileName</code>不该重复。</p><p>  解决办法就是采用<code>virtual</code>继承：</p><p>  <img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BFvirtual%E7%BB%A7%E6%89%BF.png" alt=""></p><p>  <code>virtual</code>继承带来的后果是：</p><ul><li><p>使用<code>virtual</code>继承的那些<code>class</code>所产生的对象往往比使用<code>non-virtual</code>继承的<code>class</code>体积大</p></li><li><p>访问<code>virtual base class</code>的成员变量时，也比访问<code>non-virtual base class</code>的成员变量速度慢</p></li><li><p>另外，支配“<code>virtual base class</code>初始化”的规则比起<code>non-virtual base class</code>的情况远为复杂且不直观。<code>virtual base class</code>的初始化责任是由继承体系中的最低层（<code>most derived</code>）<code>class</code>负责的，这意味着：</p><ol><li><code>class</code>若派生自<code>virtual base</code>而需要初始化，必须知道其<code>virtual base class</code>——不论那些<code>base class</code>距离多远。</li><li>当一个新的<code>derived class</code>加入继承体系中，它必须承担其<code>virtual base class</code>的初始化责任。</li></ol><p>关于<code>virtual</code>继承的忠告：</p></li></ul><ol><li>非必要不使用<code>virtual base</code>。平常请使用<code>non-virtual</code>继承。</li><li>如果必须使用<code>virtual base class</code>，尽可能避免在其中放置数据。这么一来你就不需担心这些<code>class</code>身上的初始化（和赋值）所带来的诡异事情了。</li></ol></li></ul><p>最后看一个多重继承的应用例子——<code>public</code>继承某个<code>Interface class</code>和<code>private</code>继承某个协助实现的<code>class</code>。</p><p><img src="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90.png" alt=""></p><p>（参考书籍<code>P195-P198</code>）</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法之概论</title>
      <link href="/20200404/"/>
      <url>/20200404/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>相互之间存在一种或多种特定关系的数据元素的集合。研究数据结构，关心的是数据对象的描述以及相关操作函数的实现。</p><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如整型、浮点型等数值类型，以及声音、图像等非数值类型。</p><h4 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h4><p>是组成数据的、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。</p><a id="more"></a><h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p>一个数据元素可以由若干个数据项组成。它是数据不可分割的最小单位。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p>是性质相同的数据元素（即有相同的数量和类型的数据项）的集合，是数据的子集。</p><h4 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h4><ul><li><p>线性数据结构：向量<code>vector</code>（顺序存储）、链表<code>list</code>（链式存储）、栈<code>stack</code>和队列<code>queue</code>（优先队列）。</p></li><li><p>半线性数据结构：二叉树、搜索树（二叉搜索树<code>BST</code>、<code>AVL</code>树、<code>B</code>树、红黑树）、竞赛树等。</p></li><li><p>非线性数据结构：图。</p></li><li><p>哈希表<code>hashtable</code>、字典<code>dictionary</code>。</p></li></ul><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><ul><li><p>数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p></li><li><p>抽象数据类型：指一个数学模型及定义在该模型上的一组操作。可以理解为<code>C++</code>中的类<code>class</code>。它体现的是程序设计中问题分解、抽象和信息隐藏的特性。</p></li></ul><h4 id="抽象数据类型的标准格式"><a href="#抽象数据类型的标准格式" class="headerlink" title="抽象数据类型的标准格式"></a>抽象数据类型的标准格式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">操作<span class="number">1</span></span><br><span class="line">操作<span class="number">2</span></span><br><span class="line">...</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是解决指定问题求解步骤的描述。在计算机中是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。</p><h4 id="计算或信息处理"><a href="#计算或信息处理" class="headerlink" title="计算或信息处理"></a>计算或信息处理</h4><p>指借助某种工具，按照一定的规则，以明确而机械的形式进行。</p><p>算法中的计算模型就是计算机，即信息处理工具。</p><h4 id="算法必须具备的几大要素"><a href="#算法必须具备的几大要素" class="headerlink" title="算法必须具备的几大要素"></a>算法必须具备的几大要素</h4><ol><li>输入：待处理的信息或问题。</li><li>输出：经处理的信息，即答案。</li><li>正确性：的确可以解决指定的问题。</li><li>确定性：任何一个算法都可以描述为一个由基本操作组成的序列。</li><li>可行性：每一基本操作都可实现，且能在常数时间内完成。</li><li>有穷性：对于任何输入，经有限次的基本操作，都可以得到输出。</li></ol><h4 id="一个好的算法"><a href="#一个好的算法" class="headerlink" title="一个好的算法"></a>一个好的算法</h4><ol><li><p>正确，即符合语法，能够编译、链接。</p><blockquote><p>能够正确处理<strong>简单的</strong>、<strong>大规模的</strong>、<strong>一般性的</strong>、<strong>退化的</strong>、<strong>任意合法</strong>的输入。</p></blockquote></li><li><p>健壮，能够辨别不合法的输入并做适当处理，而不致非正常退出。</p></li><li><p>可读，结构化 <code>+</code> 准确命名 <code>+</code> 注释 <code>+</code> …。</p></li><li><p>效率，运行速度尽可能快，用到的存储空间尽可能少。</p></li></ol><h4 id="常见的算法"><a href="#常见的算法" class="headerlink" title="常见的算法"></a>常见的算法</h4><ol><li><p>查找</p><p> 顺序查找、二分查找、插值查找、斐波那契查找、分块查找和哈希查找等。</p></li><li><p>排序</p><p> 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序和希尔排序等。</p></li><li><p>递归、分而治之、动态规划、回溯法和分支定界法等。</p></li></ol><p>要对数据结构和算法设计方法给予评价，就必须能够计算程序性能。</p><h4 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h4><ul><li><p>数据结构(<code>data structures</code>) + 算法(<code>algorithms</code>) = 程序(<code>programs</code>)</p></li><li><p><code>(data structures + algorithms) x efficiency = computation</code></p></li></ul><h3 id="程序性能分析"><a href="#程序性能分析" class="headerlink" title="程序性能分析"></a>程序性能分析</h3><p>是指分析一个程序对于内存空间和运行时间的需求。</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>指程序运行时临时占用内存的大小。广义上的概念是包括存储算法本身所占用的空间、算法的输入输出数据所占用的空间以及算法在运行过程中临时占用的存储空间这三个方面。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>指运行程序所需要的时间。这里度量的是程序中基本操作执行的次数，它是问题规模<code>n</code>的函数<code>f(n)</code>。记<code>T(n)=O(f(n))</code>，它表示随问题规模<code>n</code>的增大，算法执行时间的增长率和<code>f(n)</code>相同，称作算法的渐进时间复杂度。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>这里的复杂度分析通常指的是最坏时间复杂度分析。</p><ul><li>常数阶<code>O(1)</code></li></ul><p><img src="image-20200101210400776.png" alt=""></p><p>取前三个元素<code>x = S[0]</code>、<code>y = S[1]</code>和<code>z = S[2]</code>，这一步只需执行三次（从特定单元读取元素的）基本操作，耗费<code>O(3)</code>时间。接下来，为确定这三个元素的大小次序，最多需要做三次比较，也需<code>O(3)</code>时间。最后，输出居中的非极端元素只需<code>O(1)</code>时间。因此，上面取非极端元素算法的时间复杂度为：<br><code>T(n) = O(3) + O(3) + O(1) = O(7) = O(1)</code>。</p><ul><li>对数阶<code>O(logn)</code></li></ul><p><img src="image-20200101210742484.png" alt=""></p><p>根据右移运算的性质，每右移一位，<code>n</code>都至少缩减一半。也就是说，至多经过<code>1 + log2n</code>次循环，<code>n</code>必然缩减至<code>0</code>，从而算法终止。因此时间复杂度为：<code>O(1 + log2n) = O(log2n)</code> 。</p><ul><li>线性阶<code>O(n)</code></li></ul><p><img src="image-20200101211150536.png" alt=""></p><ul><li>平方阶<code>O(n)</code></li></ul><p><img src="image-20200101211909446.png" alt=""></p><p>时间复杂度为：<code>O(2n^2 + n + 1) = O(n^2)</code>。</p><h4 id="常见的算法时间复杂度排序"><a href="#常见的算法时间复杂度排序" class="headerlink" title="常见的算法时间复杂度排序"></a>常见的算法时间复杂度排序</h4><p><code>Ο(1) ＜ Ο(logn) ＜ Ο(n) ＜ Ο(nlogn) ＜ Ο(n^2) ＜ … ＜ Ο(2^n) ＜ Ο(n!)</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第五章</title>
      <link href="/20200401/"/>
      <url>/20200401/</url>
      
        <content type="html"><![CDATA[<h4 id="第5章：实现"><a href="#第5章：实现" class="headerlink" title="第5章：实现"></a>第<code>5</code>章：实现</h4><h5 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款<code>26</code>：尽可能延后变量定义式的出现时间</h5><ul><li>应该延长变量的定义，直到非得使用它时</li><li>应该延后这份定义，直到能够给它初值实参</li></ul><p>对于循环存在的情况：</p><ul><li><p>做法<code>A</code>：定义于循环外</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    w = 取决于 i 的某个值；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>做法<code>B</code>：定义于循环内</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(取决于 i 的某个值)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这两种写法的成本如下：</p><ul><li><p>做法<code>A</code>：<code>1</code>个构造函数 + <code>1</code>个析构函数 + <code>n</code>个赋值操作</p></li><li><p>做法<code>B</code>：<code>n</code>个构造函数 + <code>n</code>个析构函数</p></li><li><p>做法<code>A</code>会造成名称<code>w</code>的作用域比做法<code>B</code>更大</p><p>除非（1）你知道赋值成本比构造 + 析构成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法<code>B</code>。</p></li></ul></li></ul><a id="more"></a><h5 id="条款27：尽量少做转型操作"><a href="#条款27：尽量少做转型操作" class="headerlink" title="条款27：尽量少做转型操作"></a>条款<code>27</code>：尽量少做转型操作</h5><p>旧式<code>C</code>转型：</p><ul><li><code>T(expression)</code></li><li><code>(T)expression</code></li></ul><p>新式<code>C++</code>转型：</p><ul><li><p><code>const_cast&lt;T&gt;(expression)</code></p><p>  用来将对象的常量性（<code>const</code>）转除（只有它能办到）。</p></li><li><p><code>dynamic_cast&lt;T&gt;(expression)</code></p><p>  用来执行安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型。</p></li><li><p><code>reinterpret_cast&lt;T&gt;(expression)</code></p><p>  用来执行低级转型，如将一个<code>pointer to in</code>t 转为一个<code>int</code>。很少使用（在条款<code>50</code>中使用过一次）。</p></li><li><p><code>static_cast&lt;T&gt;(expression)</code></p><p>  用来强迫隐式转换，例如将<code>non-const</code>对象转为<code>const</code>对象，将<code>int</code>转为<code>double</code>，将<code>void*</code>指针转为<code>typed</code>指针，或将<code>pointer to base</code>转为<code>pointer to derived</code>。</p></li></ul><p>任何一种类型转换（无论显式转换还是隐式转换）往往都会令编译器编译出运行期间执行的码。如将<code>int</code>转为<code>double</code>会产生一些代码，因为<code>int</code>的底层表述不同于<code>double</code>的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> z = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;...&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d; <span class="comment">// 隐喻的将 Derived* 转换为 Base*</span></span><br></pre></td></tr></table></figure><p>这种情况下有时候会有一个偏移量在运行期被施行于<code>Derived*</code>身上，用来取得正确的<code>Base*</code>指针值。这个例子表明单一对象可能有一个以上的地址（以<code>Base*</code>指向它时的地址和以<code>Derived*</code>指向它时的地址）。</p><p>假设我们有个<code>base class Window</code>和一个<code>derived class Specialwindow</code>，两者都定义了<code>virtual</code>函数<code>onResize</code>。进一步假设<code>Specialwindow</code>的<code>onResize</code>函数被要求首先调用<code>Window</code>的<code>onResize</code>。下面实际上是错的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span> <span class="params">()</span> </span>&#123;...&#125; <span class="comment">// base onResize实现代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Specialwindow</span>:</span> <span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">// derived onResize 实现代码</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).onResize(); <span class="comment">// 将 *this 转型为 Window,</span></span><br><span class="line"><span class="comment">// 然后调用其 onResize;</span></span><br><span class="line">        <span class="comment">// 这不可行!</span></span><br><span class="line">... <span class="comment">// 这里进行 Specialwindow 专属行为</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“<code>*this</code>对象之<code>base class</code>成分”的<strong>暂时副本</strong>身上的<code>onResize</code>！如果<code>Window::onResize</code>修改了对象内容，当前对象其实没被改动，改动的是副本。然而<code>SpecialWindow::onResize</code>内如果也修改对象，当前对象真的会被改动。这使当前对象进入一种“伤残”状态：其<code>base class</code>成分的更改没有落实，而<code>derived class</code>成分的更改倒是落实了。</p><p>正确的做法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Specialwindow</span>:</span> <span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Window::onResize();<span class="comment">// 调用 Window::onResize 作用于 *this 身上</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code>的实现版本执行速度相当慢，应该在注重效率的代码中保持对<code>dynamic_cast</code>的警觉</li><li>优良的<code>C++</code>代码很少使用转型，我们应该尽可能隔离转型动作，通过将它隐藏在某个函数内，使得客户可以调用该函数而不需要将转型放进他们自己代码内</li><li>宁可使用新式转型，也不要使用旧式转型，前者很容易辨识出来</li></ul><h5 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款<code>28</code>：避免返回<code>handles</code>指向对象内部成分</h5><ul><li><code>handles</code>指指针、引用和迭代器</li><li>成员变量的封装性最多只等于“返回其<code>reference</code>”的函数的访问级别</li><li>如果<code>const</code>成员函数不得不传出去一个<code>reference</code>，则最好将返回类型限定为<code>const</code></li><li>有可能会导致空悬的<code>handles</code>，它的生命期却长于其所指对象</li></ul><h5 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款<code>29</code>：为“异常安全”而努力是值得的</h5><p>当异常被抛出时，带有异常安全性的函数会：</p><ul><li>不泄露任何资源</li><li>不允许数据败坏</li></ul><p>较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也少。异常安全码必须提供以下三个保证之一：</p><ul><li><p>基本承诺</p><p>  如果异常被抛出，程序内的任何事物仍然保证在有效状态（只要那是个合法状态）下，没有任何对象或数据结构会因此而败坏，所有对象处于一种内部前后一致的状态。</p></li><li><p>强烈保证</p><p>  如果异常被抛出，程序状态不改变。</p></li><li><p>不抛掷保证</p><p>  承诺绝不抛出异常，因为它们总能完成原先承诺的功能。</p></li></ul><p>可以实现强烈保证的<code>copy and swap</code>技术：为你打算修改的对象做出<code>copy</code>一份副本，然后在副本身上做一切修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。带所有改变都成功后，再将修改后的副本和原对象<code>swap</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之所以实现为 struct 是因为其 PrettyMenu 的数据封装性</span></span><br><span class="line"><span class="comment">// 已经由 pImpl 是 private 获得了保证</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> &#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PMImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pImpl; <span class="comment">// pimpl idiom 详细描述见条款 31</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"><span class="comment">// 见条款25</span></span><br><span class="line"><span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line"><span class="comment">// 获得mutex的副本数据</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc)); <span class="comment">// 修改副本</span></span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">swap(pImpl, pNew); <span class="comment">// 置换(swap)数据, 释放 mutex</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意，并非所有函数都可实现强烈保证或其具备现实意义。</p></blockquote><p>函数提供的”异常安全保证“通常最高只等于其所调用各个函数提供的”异常安全保证“中的最弱者。</p><h5 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款<code>30</code>：透彻了解<code>inlining</code>的里里外外</h5><p><code>inline</code>函数是指将对此函数的每一个调用都以函数本体替换之。这将导致两种情况：</p><ul><li>目标码增加（显然）</li><li>如果<code>inline</code>函数的体积很小，编译器对“函数本体”所产出的码可能比“函数调用”所产出的码小</li></ul><p><code>inline</code>只是对编译器的一个申请，不是强制命令，也就是说编译器可以拒绝将太过复杂（带有递归或循环）的函数进行<code>inline</code>。通过对函数使用<code>inline</code>关键字属于明确提出申请，将函数定义于类内属于隐喻申请。</p><ul><li><p>将大多数<code>inline</code>限制在小型、被频繁调用的函数身上</p></li><li><p><code>inline</code>函数通常一定被置于头文件内</p><p>  因为大多数构建环境在编译过程中进行<code>inlining</code>，而为了将一个函数调用替换为被调用函数的本体，编译器必须知道那个函数长什么样子。</p></li><li><p>所有对<code>virtual</code>函数的<code>inline</code>申请都会被拒绝（因为对<code>virtual</code>函数的调用在运行期才确定）</p></li></ul><h5 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款<code>31</code>：将文件间的编译依存关系降至最低</h5><ul><li><p>将接口从实现中分离</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> theName; <span class="comment">// 实现细目</span></span><br><span class="line">Date theBirthDate; <span class="comment">// 实现细目</span></span><br><span class="line">Address theAddress; <span class="comment">// 实现细目</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这里的<code>class</code>无法通过编译，因为编译器没有取得其实现代码所用到的<code>class string</code>，<code>Date</code>，<code>Address</code>的定义式，通常应该在<code>Person</code>定义文件的最上方存在<code>include</code>头文件。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"date.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"address.h"</span></span></span><br></pre></td></tr></table></figure><p>  不幸的是，这么一来便是在<code>Person</code>定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其他头文件有任何改变，那么每一个含入<code>Person class</code>的文件就得重新编译，任何使用<code>person class</code>的文件也必须重新编译。这样的连串编译依存关系（<code>cascading compilation dependencies</code>）会对许多项目造成难以形容的灾难。</p></li><li><p><code>Handle classes</code>：<code>pimpl idiom</code>(<code>pointer to implenmentation</code>) + 前向声明</p><p>  把<code>Person</code>分割成两个<code>class</code>，一个只提供接口，另一个负责实现接口。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //标准程序库组件不该被前向声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前向声明而不是包含头文件, 这个很关键</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span> <span class="comment">// Person 实现类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 接口用到的 class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday, <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl; <span class="comment">// 指针, 指向实现物</span></span><br><span class="line">    <span class="comment">// 如果不这样做的话, 编译器在编译 Person 类的时候，必须知道 Person 类的大小</span></span><br><span class="line">    <span class="comment">// 就不得不包含这三个实现细目</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    string theName; // 实现细目</span></span><br><span class="line"><span class="comment">Date theBirthDate; // 实现细目</span></span><br><span class="line"><span class="comment">Address theAddress; // 实现细目</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 然而一旦这样写, 前面的前向声明就没用了, 必须包含头文件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  这样一来，<code>Person</code>类的使用者就完全于<code>Date</code>，<code>Address</code>以及<code>Person</code>的实现细目相分离了。这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：实现上让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。</p><p>  几个简单的设计策略：</p><ul><li><p>如果使用<code>object reference</code>或<code>object pointer</code>可以完成任务，就不要使用<code>object</code></p><p>  你可以只靠一个类型声明式就定义出指向该类型的<code>reference</code>和<code>pointer</code>；但如果定义某类型的<code>object</code>，就需要用到该类型的定义式。</p></li><li><p>如果能够，尽量以<code>class</code>声明式替换<code>class</code>定义式</p><p>  注意，当你声明一个函数而它用到某个<code>class</code>时，你并不需要该<code>class</code>的定义。</p></li><li><p>为声明式和定义式提供不同的头文件</p><p>  对于前面代码中的前向声明，最好是提供一个声明式头文件，包含全部的前向声明。</p><p>下面式<code>Person.cpp</code>文件的部分实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Person.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;PersonImpl.h&gt; </span></span></span><br><span class="line"><span class="comment">// 注意，Person 和PersonImpl的成员函数完全相同, 两者接口完全相同</span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span><br><span class="line"><span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line"><span class="keyword">const</span> Address&amp; addr) : pImpl(<span class="keyword">new</span> PersonImpl(name, birthday,addr)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::narne</span><span class="params">( )</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pImpl-&gt;name();&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Interface classes</code>：<code>abstract base class</code> + <code>factory</code>函数</p><p>  <code>abstract base class</code>通常没有成员变量，也没有构造函数，只有一个<code>virtual</code>析构函数和一组<code>pure virtual</code>函数。但<code>Interface class</code>的客户必须有办法为这种<code>class</code>创建新对象。他们通常调用一个特殊函数，此函数创建实际实现的<code>derived class</code>，这样的函数通常称为<code>factory</code>(工厂）函数（见条款<code>13</code>），它们返回智能指针指向动态分配所得对象，而该对象支持<code>Interface class</code>的接口。这样的函数又往往在<code>Interface class</code>内被声明为<code>static</code>：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 Person.h</span></span><br><span class="line"><span class="comment">// 抽象基类, 只有声明</span></span><br><span class="line"><span class="comment">// 提供给客户使用的头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> strng <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> strng <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// static 的 factory 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Address&amp; addr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于 Person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RealPerson(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span><br><span class="line">               <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="keyword">const</span> Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~RealPerson() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 虚函数的实现码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> Address&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>Handle classes</code>和<code>Interface classes</code>解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第四章</title>
      <link href="/20200321/"/>
      <url>/20200321/</url>
      
        <content type="html"><![CDATA[<h4 id="第4章：设计与声明"><a href="#第4章：设计与声明" class="headerlink" title="第4章：设计与声明"></a>第<code>4</code>章：设计与声明</h4><h5 id="条款18：让接口容易被正确使用，不容易被误用"><a href="#条款18：让接口容易被正确使用，不容易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不容易被误用"></a>条款<code>18</code>：让接口容易被正确使用，不容易被误用</h5><ul><li>如果客户企图使用某个接口却没有获得所预期的行为，这个代码不应该通过编译；如果代码通过了编译，则它的行为就应该是客户想要的</li><li>欲达“让接口容易被正确使用，不容易被误用”的目的，必须考虑客户调用接口时可能做出什么样的错误</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型兼容</li><li>“阻止误用”的办法包括建立新类型、限制在类型上的操作，束缚对象值以及消除客户的资源管理责任</li></ul><a id="more"></a><h5 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款<code>19</code>：设计class犹如设计<code>type</code></h5><p>你应该带着“语言设计者当初设计语言内置类型时”一样的谨慎来研讨每一个<code>class</code>的设计。因为，重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结…全都在你手上。</p><ul><li><p>新的<code>type</code>的对象应该如何创建和销毁？</p><p>  设计函数为类的构造函数和析构函数以及内存分配函数和释放函数（见条款<code>49-52</code>）。</p></li><li><p>对象的初始化和对象的赋值该有什么样的差别？</p><p>  决定了构造函数和赋值操作符的行为以及差异。</p></li><li><p>新<code>type</code>的对象被<code>passed by value</code>，意味着什么？</p><p>  取决于<code>copy</code>构造函数的实现。</p></li><li><p>什么新<code>type</code>的合法值？</p></li><li><p>你的新<code>type</code>需要配合某个继承图系吗？</p><p>  见条款<code>7</code>、<code>34</code>、<code>36</code>。</p></li><li><p>你的新<code>type</code>需要什么样的转换？</p><p>  <code>explicit</code>和<code>operator</code>关键字的使用。见条款<code>15</code>。</p></li><li><p>什么样的操作符和函数对此新<code>type</code>而言时合理的？</p><p>  见条款<code>23</code>、<code>24</code>、<code>46</code>。</p></li><li><p>什么样的标准函数应该驳回？</p><p>  见条款<code>6</code>。</p></li><li><p>谁该取用新<code>type</code>的成员？</p><p>  决定了数据成员是<code>public</code>、<code>private</code>还是<code>protected</code>，以及<code>friend</code>关键的使用。</p></li><li><p>什么是新<code>type</code>的“未声明接口”？</p><p>  见条款<code>29</code>。</p></li><li><p>你的新<code>type</code>有多么一般化？</p><p>  决定<code>class template</code>的使用。</p></li><li><p>你真的需要一个新<code>type</code>吗？</p></li></ul><h5 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass by reference to const替换pass by value"></a>条款<code>20</code>：宁以<code>pass by reference to const</code>替换<code>pass by value</code></h5><ul><li>当把具有继承关系的类作为参数传递时，如果<code>pass by value</code>可能会出现“截断”问题。</li></ul><h5 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款<code>21</code>：必须返回对象时，别妄想返回其<code>reference</code></h5><ul><li>绝不要返回指向一个<code>local stack</code>对象的<code>pointer</code>或<code>reference</code></li><li>绝不要返回指向一个<code>heap allocated</code>对象的<code>reference</code></li><li>除非有单例模式的设计要求，否则绝对不要返回指向一个<code>local static</code>对象的<code>pointer</code>或<code>reference</code></li></ul><h5 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款<code>22</code>：将成员变量声明为<code>private</code></h5><ul><li><p>客户访问数据的一致性</p><p>  <code>public</code>里都是函数。</p></li><li><p>可以对成员变量有更精确的控制</p><p>  可以实现成员变量的不可访问，只读、只写、读写访问。</p></li><li><p>封装性</p><p>  将成员变量隐藏在函数接口背后，可以为所有可能的实现提供弹性。</p></li><li><p>从封装的角度看，只有两种权限：<code>private</code>（提供封装）和其它</p><p>  <code>protected</code>并不比<code>private</code>更具封装性。</p></li></ul><h5 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款<code>23</code>：宁以<code>non-member</code>、<code>non-friend</code>替换<code>member</code>函数</h5><p>考虑一个用来表示网页浏览器的<code>class</code>，这个<code>class</code>提供的众多成员函数中，有用来清除下载元素高速缓冲区的，有用来清除访问过的历史记录的，有用来移除系统中所有<code>cookies</code>的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleatCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户想一整个执行所有的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以提供一个 member 函数的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverthing</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以提供一个 non-member 函数的方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wb.clearCache();</span><br><span class="line">    wb.clearHistory();</span><br><span class="line">    wb.cleatCookies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后者比较好。因为：</p><ul><li><p>增加封装性</p><p>  <code>non-member non-friend</code>将提供较大的封装性，因为它并不增加能够访问<code>class</code>内的<code>private</code>成分的函数数量。<code>friend</code>函数对<code>class private</code>成员的访问权力和<code>member</code>函数相同，两者对封装的冲击力度是一样的。</p></li><li><p>增加扩充机能性</p><p>  在<code>C++</code>中，正确且自然的做法是：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span>...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>; <span class="comment">// 为 WebBrowser “提供便利”的函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>namespace</code>和<code>class</code>的不同是，前者可跨越多个源码文件而后者不能。</p><p>像<code>WebBrowser</code>这样的类可能有大量的“提供便利”函数，某些与书签有关，与打印有关，与<code>cookie</code>有关… 分离它们最直接的做法就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 WebBrowser.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span>...&#125;;</span><br><span class="line">    ... <span class="comment">// 核心机能, 例如所有客户都想要的 non-member 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件 WebBrowserBookmarks.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 与书签相关的 non-member 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件 WebBrowserCookies.h 内</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// 与 cookie 相关的 non-member 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有“便利函数”放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组“便利函数”。</p></li></ul></li></ul><h5 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款<code>24</code>：若所有参数皆需类型转换，请为此采用<code>non-member</code>函数</h5><ul><li><p>有理数类<code>Rational</code>的实现</p><p>  重点关注用来将两个有理数相乘的<code>operator*</code>操作符重载函数的实现方式。</p></li></ul><h5 id="条款25：考虑写出一个不抛异常的swap函数"><a href="#条款25：考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛异常的swap函数"></a>条款<code>25</code>：考虑写出一个不抛异常的<code>swap</code>函数</h5><p>标准程序库提供的<code>swap</code>算法的典型实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要<code>T</code>类型支持<code>copying</code>函数（<code>copy</code>构造函数和<code>copy assignment</code>操作符）。对于用户自定义类型，效率低下（需要三次复制）。</p><p>现在考虑所谓的<code>pimpl(pointer to implementation)</code>实现手法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这是个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... <span class="comment">// 细节不重要</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ... <span class="comment">// 有很多数据, 意味着复制时间很长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这是个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&lt;T&gt;&amp; rhs);</span><br><span class="line"><span class="comment">// 关于 operator= 的一般性实现参考条款 10, 11, 12</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl&lt;T&gt;* pImpl; <span class="comment">// 指向实际实现的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一旦需要置换两个<code>Widget</code>对象值，我们实际唯一需要的是置换两个指针即可。但缺省的<code>swap</code>函数不知道这一点！</p><p>下面是正确的实现步骤：</p><ol><li><p>令<code>Widget</code>实现一个名为<code>swap</code>的<code>public</code>成员函数做真正的置换工作</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 必须的</span></span><br><span class="line">        swap(pImpl, other.pImpl); <span class="comment">// 直接置换指针即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>std::swap</code>特化，令它调用该成员函数<strong>（当<code>Widget</code>是类时。这里的例子中，<code>Widget</code>是个模板类则不要这一步）</strong></p><ul><li><p>因为，<code>C++</code>只允许对<code>class template</code>偏特化，不允许对<code>function template</code>进行偏特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">a.swap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>声明一个<code>non-member swap</code>，令它调用<code>member swap</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意, 要将它放在和 Widget&lt;T&gt; 同一个空间内(全局或者自定义的 namespace)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编程时，在调用<code>swap</code>置换对象的语句之前加上<code>using std::swap</code>声明</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户代码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1. T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap; <span class="comment">// 令 std::swap 在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    swap(obj1, obj2); <span class="comment">// 这样一来, 编译器将为 T 类型对象调用最佳版本 swap</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译器首先在全局作用域或<code>T</code>所在命名空间内寻找<code>T</code>（在这里，<code>T</code>就是例子中的<code>Widget</code>哦）专属的<code>swap</code>（也就是步骤<code>3</code>中实现的）。如果没有实现这些，则调用<code>std</code>内的<code>swap</code>，如果步骤<code>2</code>还实现了特化版本，将会选中特化版本。</p></li></ol><ul><li><p>劝告，<code>member swap</code>绝不可抛出异常</p><p>  具体参考条款29。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第三章</title>
      <link href="/20200315/"/>
      <url>/20200315/</url>
      
        <content type="html"><![CDATA[<h4 id="第3章：资源管理"><a href="#第3章：资源管理" class="headerlink" title="第3章：资源管理"></a>第<code>3</code>章：资源管理</h4><h5 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款<code>13</code>：以对象管理资源</h5><ul><li><p><code>RAII</code>(<code>Resource Acquisition Is Initialization</code>)</p><p>  使用<code>new</code>获取资源后于同一条语句内以它初始化某个资源管理对象。利用当管理对象离开作用域被销毁时自动调用其析构函数的机制确保资源被释放。不直接用<code>new</code>和<code>delete</code>，多用智能指针。</p></li><li><p>智能指针在其析构函数中做<code>delete</code>动作而非<code>delete[]</code>动作</p><p>  因此，不要在动态分配来的数组身上使用智能指针（虽然它仍然会通过编译）。</p></li></ul><a id="more"></a><h5 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款<code>14</code>：在资源管理类中小心<code>copying</code>行为</h5><ul><li>当不想<code>RAII</code>类被复制时可以继承<code>Uncopyable</code>类</li></ul><p>将智能指针施于<code>heap-based</code>资源身上是个好主意，但并不是所有资源都是<code>heap-based</code>的，比如互斥器<code>mutex</code>，<code>mutex</code>就不可复制。</p><h5 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款<code>15</code>：在资源管理类中提供对原始资源的访问</h5><ul><li><p>显示转换（安全）</p><p>  例如，<code>shared_ptr</code>类就提供可一个<code>get</code>成员函数来返回智能指针内部的原始指针。</p></li><li><p><code>operator</code>隐式转换（调用方便）</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// operator 可以实现隐式转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    B b; <span class="comment">// B 类型对象成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受 B 类型对象的一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(B b)</span></span>;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">func(a); <span class="comment">// a 会被编译器隐式转换为 B 类型对象</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="条款16：使用new和delete时要采用相同的形式"><a href="#条款16：使用new和delete时要采用相同的形式" class="headerlink" title="条款16：使用new和delete时要采用相同的形式"></a>条款<code>16</code>：使用<code>new</code>和<code>delete</code>时要采用相同的形式</h5><ul><li><p>编译器在给数组分配内存时，会包括数组大小的记录</p><p>  这样的好处是，<code>delete[]</code>时知道需要调用多少次析构函数。</p></li><li><p>不要对数组形式进行<code>typedef</code>动作</p></li></ul><h5 id="条款17：以独立语句将new来的对象置入智能指针"><a href="#条款17：以独立语句将new来的对象置入智能指针" class="headerlink" title="条款17：以独立语句将new来的对象置入智能指针"></a>条款<code>17</code>：以独立语句将<code>new</code>来的对象置入智能指针</h5><p>考虑这样两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>; <span class="comment">// 调用这个函数不排除会发生异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><p>如果这样调用编译不通过，因为<code>shared_ptr</code>接收原始指针的构造函数是<code>explicit</code>的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="keyword">new</span> Widget, priority());</span><br></pre></td></tr></table></figure><p>如果这样调用可能会造成内存泄漏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure><p>因为编译器在编译这条语句时，实际上会创建三个动作：</p><ul><li>调用<code>priority()</code></li><li>执行<code>new Widget</code></li><li>调用<code>shared_ptr</code>的构造函数</li></ul><p>而<code>C++</code>编译器安排这三个动作的次序是不确定的。</p><p>如果执行次序是这样：</p><ol><li>执行<code>new Widget</code></li><li>调用<code>priority()</code></li><li>调用<code>shared_ptr</code>的构造函数</li></ol><p>一旦中途<code>priority()</code>导致异常，那么<code>new</code>返回的原始指针并未交给智能指针保管，将造成资源泄露。</p><p>正确的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure><p>因为，编译器对“跨越语句的各项操作”没有重新排列执行次序的自由。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第二章</title>
      <link href="/20200308/"/>
      <url>/20200308/</url>
      
        <content type="html"><![CDATA[<h4 id="第2章：构造、析构、赋值运算"><a href="#第2章：构造、析构、赋值运算" class="headerlink" title="第2章：构造、析构、赋值运算"></a>第<code>2</code>章：构造、析构、赋值运算</h4><h5 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款<code>05</code>：了解<code>C++</code>默默编写并调用哪些函数</h5><ul><li><p>编译器会暗自为<code>class</code>创建<code>default</code>构造函数、<code>copy</code>构造函数、<code>copy assignment</code>操作符以及析构函数</p></li><li><p>对于<code>class</code>内含<code>reference</code>成员或<code>const</code>成员，编译器拒绝为其生成<code>copy</code>构造函数和<code>copy assignment</code>操作符</p><blockquote><p>因为<code>C++</code>不允许<code>reference</code>改指向不同的对象以及更改<code>const</code>成员。 </p></blockquote></li></ul><a id="more"></a><h5 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款<code>06</code>：若不想使用编译器自动生成的函数，就该明确拒绝</h5><ul><li><p>为驳回编译器自动提供的函数，可将相应的成员函数声明为<code>private</code>并且不予实现。</p></li><li><p>掌握<code>Uncopyable</code>类的实现机制</p><ul><li><p>将构造函数和析构函数设置为<code>protected</code>的</p></li><li><p>将拷贝构造函数和拷贝赋值运算符设置为<code>private</code>的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable() &#123;&#125;</span><br><span class="line">    ~Uncopyable() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">    <span class="keyword">const</span> Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款<code>07</code>：为多态基类声明<code>virtual</code>析构函数</h5><ul><li><p>带多态性质的<code>base class</code>应该声明一个<code>virtual</code>析构函数</p></li><li><p>当<code>class</code>内至少含有一个<code>virtual</code>函数，才为它声明<code>virtual</code>析构函数</p></li><li><p><code>class</code>的设计目的如果不是作为<code>base class</code>使用，或不是为了具备多态性，就不该声明<code>virtual</code>析构函数</p></li><li><p>然而，有时候你希望拥有一个抽象类，但没有任何需要的<code>pure virtual</code>方法，怎么办？</p><p>  由于<code>abstract class</code>（不能实例化）总是被期望当作多态基类，多态基类又需要<code>virtual</code>析构函数，而<code>pure virtual</code>函数会导致<code>abstract class</code>，因此可将析构函数声明为<code>pure virtual</code>并且给出默认实现。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小技巧:pure virtual 析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AWOV::~AWOV() &#123;<span class="comment">/* default */</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款<code>08</code>：别让异常逃离析构函数</h5><ul><li>析构函数绝对不要吐出异常</li></ul><p>假设有一个类负责数据库的连接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; <span class="comment">// 关闭联机, 失败则抛出异常</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了确保客户不忘记在<code>DBConnection</code>对象上调用<code>close</code>函数，一个合理的想法是创建一个用来管理<code>DBConnection</code>资源的类，并在析构函数中调用<code>close</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">~DBConn()</span><br><span class="line">    &#123;</span><br><span class="line">        db.close();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户可以写出这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 区块作用域结束，调用析构函数销毁对象</span></span><br></pre></td></tr></table></figure><p>如果被析构函数调用的函数<code>close</code>可能抛出异常，析构函数应该捕获异常然后吞下它们或者结束程序。</p><p>一个好的策略是，开放一个<code>close</code>接口供用户调用，把调用<code>close</code>的责任从<code>DBConn</code>析构函数手上移到用户手上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.close();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">~DBConn()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                 db.close(); <span class="comment">// 关闭连接（如果客户没做的话）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(...)</span><br><span class="line">            &#123;</span><br><span class="line">                日志记录下对 close 调用的失败;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，如果客户需要对某个操作函数运行期间的异常作出反应，那么<code>class</code>应该提供一个接口执行该操作。如果<code>close</code>的确发生了异常，而客户没有调用<code>close</code>接口进行处理，<code>DBConn</code>只能吞下或结束程序。</p><h5 id="条款09：绝不在析构和构造函数中调用virtual函数"><a href="#条款09：绝不在析构和构造函数中调用virtual函数" class="headerlink" title="条款09：绝不在析构和构造函数中调用virtual函数"></a>条款<code>09</code>：绝不在析构和构造函数中调用<code>virtual</code>函数</h5><ul><li>派生类对象内的基类成分会在派生类自身成分被构造之前先被构造</li><li>基类构造期间，虚函数绝不会下降到派生类层</li></ul><p>需要注意的是，有时类有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复时会把相同的初始化代码放到一个<code>init</code>函数中实现，如果这时在<code>init</code>函数中同样调用了虚函数，情况是一样的但<strong>比较隐秘</strong>。 </p><h5 id="条款10：令赋值操作符operator-返回一个reference-to-this"><a href="#条款10：令赋值操作符operator-返回一个reference-to-this" class="headerlink" title="条款10：令赋值操作符operator=返回一个reference to *this"></a>条款<code>10</code>：令赋值操作符<code>operator=</code>返回一个<code>reference to *this</code></h5><ul><li>为了实现连续赋值</li></ul><h5 id="条款11：在operator-中处理自我赋值"><a href="#条款11：在operator-中处理自我赋值" class="headerlink" title="条款11：在operator=中处理自我赋值"></a>条款<code>11</code>：在<code>operator=</code>中处理自我赋值</h5><ul><li>有些自我赋值并不明显，如通过指针或引用</li></ul><p>假设你建立一个<code>class</code>来保存一个指针指向一块动态分配的位图（<code>bitmap</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb; <span class="comment">// 指向一个从 heap 分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>错误的<code>operator=</code>实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自我赋值不安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过一个“证同测试”来检验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自我赋值安全, 但不具备异常安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的异常安全指的是，如果<code>new Bitmap</code>发生异常，会导致<code>Widget</code>最终会持有一个指针指向一块被删除的<code>Bitmap</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具备异常安全, 则自动具备自我赋值安全</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* oldPb = pb; <span class="comment">// 记住之前的 pb</span></span><br><span class="line">    </span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs,pb);</span><br><span class="line">    <span class="keyword">delete</span> oldPb;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用更好的<code>copy and swap</code>技术：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... <span class="comment">// 交换 *this 和 rhs 的数据, 见条款 25</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 提升点效率 ?</span></span><br><span class="line">    <span class="comment">// if(this == &amp;rhs)</span></span><br><span class="line">    <span class="comment">//     return *this;</span></span><br><span class="line">    </span><br><span class="line">    Widget temp(rhs); <span class="comment">// copy</span></span><br><span class="line">    </span><br><span class="line">    swap(temp); <span class="comment">// swap</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="条款12：复制对象时勿忘每一个成分"><a href="#条款12：复制对象时勿忘每一个成分" class="headerlink" title="条款12：复制对象时勿忘每一个成分"></a>条款<code>12</code>：复制对象时勿忘每一个成分</h5><ul><li>每一个成分包括对象内所有成员变量以及所继承的<strong>基类成分</strong><ul><li>在拷贝构造函数中的初始化列表中调用所继承的类的拷贝构造函数</li><li>在拷贝赋值操作符函数中调用所继承的类的拷贝赋值操作符函数</li></ul></li><li>不要尝试让拷贝构造函数和拷贝赋值操作符函数互相调用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 第一章</title>
      <link href="/lyl20200301/"/>
      <url>/lyl20200301/</url>
      
        <content type="html"><![CDATA[<h4 id="第1章：让自己习惯C"><a href="#第1章：让自己习惯C" class="headerlink" title="第1章：让自己习惯C++"></a>第<code>1</code>章：让自己习惯<code>C++</code></h4><h5 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款<code>01</code>：视<code>C++</code>为一个语言联邦</h5><ul><li>将<code>C++</code>视为由<code>4</code>个次语言组成的联邦：<ul><li><code>C</code>：没有模板、没有异常、没有重载…</li><li><code>Object-Oriented C++</code>：类、封装、继承、多态、虚函数、动态绑定等等；</li><li><code>Template C++</code>：泛型编程部分；</li><li><code>STL</code>：是一个<code>Template</code>程序库，容器、迭代器、算法以及函数对象。</li></ul></li></ul><p>从某个此语言切换到另一个时，高效编程守则可能会发生变化。比如，<code>C-like</code>类型（内置类型）<code>pass by value</code>更好；对于<code>Object-Oriented C++</code>而言，<code>pass by reference to-const</code>更好；再切换到<code>STL</code>，由于迭代器和函数对象都是在<code>C</code>指针之上塑造出来的，<code>pass by value</code>守则再次适用。</p><a id="more"></a><h5 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款<code>02</code>：尽量以<code>const</code>，<code>enum</code>，<code>inline</code>替换<code>#define</code></h5><ul><li><p>对于单纯常量，最好以<code>const</code>对象或<code>enum hack</code>替换<code>#define</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记号名称未进入符号表, 难以调试</span></span><br><span class="line"><span class="comment">// 在多处出现目标码, 尤其浮点常量</span></span><br><span class="line"><span class="comment">// 无作用域概念, 不提供任何封装性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量会被编译器看到, 进入符号表</span></span><br><span class="line"><span class="comment">// 导致较小量的目标码, 因为只有一份</span></span><br><span class="line"><span class="comment">// 可放置在类内或 namespace 中限制其作用域</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以放在类或 namespace 中</span></span><br><span class="line"><span class="comment">// 令 NumTurns 成为 5 的记号名称, 一般用在类中做常量用</span></span><br><span class="line"><span class="comment">// 行为像 #define, 对 const 取地址合法，对 enum 和 #define 取地址就不合法</span></span><br><span class="line"><span class="keyword">enum</span> &#123;NumTurns = <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>对于形似函数的宏，最好用<code>inline</code>（或模板）函数替换</p><p>  宏中的变量有可能会被运算多次。</p></li></ul><h5 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款<code>03</code>：尽可能使用<code>const</code></h5><ul><li><p><code>const</code>作用于迭代器</p><p>  <code>STL</code>迭代器是以指针为根据塑模出来的，其作用就像个<code>T*</code>指针。声明迭代器为<code>const</code>只是声明一个<code>const</code>指针（作用就像<code>T* const</code>），表明的是迭代器本身不可变，但其所指的值是可以改动的。如果希望迭代器所指的值不可改动，需要的是<code>const_iterator</code>。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.begin();</span><br><span class="line">*iter = <span class="number">10</span>; <span class="comment">// 正确</span></span><br><span class="line">++iter; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator citer = vec.begin();</span><br><span class="line">*citer = <span class="number">10</span>; <span class="comment">// 错误</span></span><br><span class="line">++citer; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>将<code>operator*</code>的返回类型声明为<code>const-by-value</code></p></li><li><p><code>const</code>可被施加于任何作用域内的对象、函数参数（常用<code>pass-by-reference-to-const</code>），函数返回类型、类成员函数本体</p></li><li><p><code>const</code>施加于成员函数</p><p>  成员函数上的<code>const</code>限定符意味着不能修改<code>non-mutable</code>，<code>non-static</code>类数据成员。</p></li><li><p>当<code>const</code>和<code>non-const</code>成员函数有着实质等价的实现时，令<code>non-const</code>成员函数调用<code>const</code>版本可避免代码重复</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// 边界检验</span></span><br><span class="line">        ... <span class="comment">// 日记数据访问</span></span><br><span class="line">        ... <span class="comment">// 检验数据完整性</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    char&amp; operator[](std::size_t position)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ... // 边界检验</span></span><br><span class="line"><span class="comment">        ... // 日记数据访问</span></span><br><span class="line"><span class="comment">        ... // 检验数据完整性</span></span><br><span class="line"><span class="comment">        return text[position];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用 const_cast 移除对象身上的 const</span></span><br><span class="line">        <span class="comment">// 调用 static_cast 为 *this 加上 cosnt</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBook&amp;&gt;(*<span class="keyword">this</span>)[position]</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>const</code>版本成员函数调用<code>non-const</code>版本不合法</p></li></ul><h5 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款<code>04</code>：确定对象被使用前已先被初始化</h5><ul><li><p>为内置型对象进行手工初始化，因为<code>C++</code>并不保证初始化它们</p></li><li><p>构造函数使用成员初始化列表，初始化顺序与在类中声明顺序一致</p></li><li><p>为避免“跨编译单元内定义的<code>non-local static</code>对象的初始化问题”，以<code>local</code>对象替换<code>non-local static</code>对象</p><ul><li><code>static</code>对象包括<code>global</code>对象、定义与<code>namespace</code>作用域内的对象、在<code>class</code>内、函数内、以及在<code>file</code>作用域内被声明为static的对象</li><li>函数内的<code>static</code>被称为<code>local static</code>对象，其它<code>static</code>对象被称为<code>non-local static</code>对象</li><li>程序结束时，<code>static</code>对象会被自动销毁，也就是它们的析构函数在<code>main</code>函数结束时被自动调用</li><li>编译单元是指产出单一目标文件的源码文件以及所含入的头文件</li></ul></li></ul><p>现在有两个源码文件，每个至少含入一个<code>non-local static</code>对象，其中一个<code>non-local static</code>对象用到了另一个<code>non-local static</code>对象，而被用到的尚未被初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 FileSystem.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span><span class="keyword">const</span></span>; <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs; <span class="comment">// 预备给客户使用的对象, non-local static 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 Directory.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(); <span class="comment">// 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks(); <span class="comment">// 使用 tfs 对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在客户决定创建一个Directory对象，用来放置临时文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Directory tempDir; <span class="comment">// 为临时文件而做出的目录</span></span><br></pre></td></tr></table></figure><p>这个时候就会出现初始化次序带来的问题。由于<code>tfs</code>和<code>tempDir</code>是不同的人在不同的时间于不同的源码文件中创建出来的，因此初始化次序不一定。</p><p>解决方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 FileSystem.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 众多成员函数之一</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> <span class="comment">// 用于创建预备给客户使用的对象的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs; <span class="comment">// local static 对象</span></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件 Directory.cpp 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory(); <span class="comment">// 构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这样就保证了被使用对象先被初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs().numDisks(); <span class="comment">// 使用 tfs() 创建对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Effective C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
