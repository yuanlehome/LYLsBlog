[{"title":"leetcode专题之链表","date":"2021-01-08T13:35:42.000Z","path":"20210108/","text":"这篇文章是leetcode刷题系列的第2部分——链表，链表的大部分题目难度都不大。leetcode上链表部分的题目也就40道左右，基本上都做了，这里就把有代表性的题目发出来，共计20道。每道题都给出了注释，有的题目还给出了另一种思路和解法。另外，博主是非常注重代码编写风格的，因此代码可读性较好。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少200道！ Linked List206. Reverse Linked List 给定一个单链表的头节点，反转链表，然后返回反转后的链表头节点。 1234567891011121314151617181920212223242526// 迭代解法ListNode* reverseList(ListNode* head)&#123; ListNode* p = nullptr; ListNode* q = p; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p;&#125;// 递归解法ListNode* reverseList(ListNode* head)&#123; if(!head || !head-&gt;next) return head; ListNode* q = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return q;&#125; 92. Reverse Linked List II 给定一个单链列表的头以及left和right两个整数，其中left &lt;= right，将列表的节点从left位置反转到right位置，然后返回反转的列表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* 纯递归解法 */// 反转整个链表ListNode* reverseList(ListNode* head)&#123; if(!head || !head-&gt;next) return head; ListNode* q = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return q;&#125;// 反转前 n 个节点ListNode* reverseN(ListNode* head, int n)&#123; ListNode* p = head; while(--n &gt; 0) p = p-&gt;next; ListNode* q = p-&gt;next; p-&gt;next = nullptr; ListNode* r = reverseList(head); head-&gt;next = q; return r;&#125;ListNode* reverseBetween(ListNode* head, int left, int right)&#123; if(left == 1) return reverseN(head, right); head-&gt;next = reverseBetween(head-&gt;next, left - 1, right - 1); return head;&#125;/* 纯迭代解法 */// 反转整个链表ListNode* reverseList(ListNode* head)&#123; ListNode* p = nullptr; ListNode* q = p; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p;&#125;// 反转前 n 个节点ListNode* reverseN(ListNode* head, int n)&#123; ListNode* p = head; while(--n &gt; 0) p = p-&gt;next; ListNode* q = p-&gt;next; p-&gt;next = nullptr; ListNode* r = reverseList(head); head-&gt;next = q; return r;&#125;ListNode* reverseBetween(ListNode* head, int left, int right)&#123; if(left == 1) return reverseN(head, right); // 计算反转的实际节点数 int n = right - left + 1; ListNode* p = head; left--; while(--left &gt; 0) p = p-&gt;next; // p 现在指向第 left 个节点的前一个节点 p-&gt;next = reverseN(p-&gt;next, n); return head;&#125; 25. Reverse Nodes in k-Group 给你一个链表，每k个节点一组进行翻转，请你返回翻转后的链表。k是一个正整数，它的值小于或等于链表的长度。如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺序。 进阶：你可以设计一个只使用常数额外空间的算法来解决此问题吗？不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 Example 1 Example 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 反转整个链表ListNode* reverseList(ListNode* head)&#123; ListNode* p = nullptr; ListNode* q = p; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p;&#125;// 反转前 n 个节点ListNode* reverseN(ListNode* head, int n)&#123; ListNode* p = head; while(--n &gt; 0) p = p-&gt;next; ListNode* q = p-&gt;next; p-&gt;next = nullptr; ListNode* r = reverseList(head); head-&gt;next = q; return r;&#125;ListNode* reverseKGroup(ListNode* head, int k)&#123; ListNode* q = head; int n = k; while(--n &amp;&amp; q) q = q-&gt;next; if(!q) return head; ListNode* p = head; // 这里先反转第一次是为了方便记录头节点 head = reverseN(head, k); while(1) &#123; ListNode* r = p-&gt;next; q = r; n = k; while(--n &amp;&amp; q) q = q-&gt;next; if(!q) break; p-&gt;next = reverseN(p-&gt;next, k); p = r; &#125; return head;&#125; 382. Linked List Random Node 给定一个单链表，从链表随机返回一个节点的值。 每个节点必须具有相同的被选择概率。 如果链表很大并且你不知道其长度怎么办？你能在不使用额外空间的情况下有效解决此问题吗？ 如果随机返回k个节点的值呢？ 水塘抽样算法：遇到第i个元素时，应该有1/i的概率选择该元素，1 - 1/i的概率保持原有的选择。 证明：假设总共有n个元素，我们要的随机性无非就是每个元素被选择的概率都是1/n ，那么对于第i个元素，它被选择的概率就是： 同理，如果要随机选择k个数，只要在第i个元素处以k/i的概率选择该元素，以1 - k/i的概率保持原有选择即可。 证明：略。 12345678910111213141516171819202122232425262728293031323334/* Returns a random node's value. */int getRandom(ListNode* head)&#123; int res = 0, i = 0; while(head) &#123; int j = rand() % ++i; // j 等于 0 的概率就为 1/i if(j == 0) res = head-&gt;val; head = head-&gt;next; &#125; return res;&#125;/* Returns k random node's value. */vector&lt;int&gt; getRandom(ListNode* head, int k)&#123; vector&lt;int&gt; res(k, 0); // 前 k 个值默认先选上 for(int i = 0; i &lt; k &amp;&amp; head; i++, head = head-&gt;next) res[i] = p-&gt;val; int i = k; while(head) &#123; int j = rand() % ++i; // j 小于 k 的概率就为 k/i if(j &lt; k) res[j] = head-&gt;val; head = head-&gt;next; &#125; return res;&#125; 2. Add Two Numbers 给定两个表示两个非负整数的非空链表。 这些数字以相反的顺序存储，即低位数在前，并且它们的每个节点都包含一个数字。 将两个数字相加并返回总和作为链接列表。 12345678910111213141516171819202122232425262728293031323334353637383940ListNode* addTwoNumbers(ListNode* p, ListNode* q)&#123; ListNode* head = new ListNode; ListNode* last = head; int sum = 0; int carry = 0; while(p &amp;&amp; q) &#123; sum = p-&gt;val + q-&gt;val + carry; carry = sum / 10; last-&gt;next = new ListNode(sum % 10); last = last-&gt;next; p = p-&gt;next; q = q-&gt;next; &#125; while(p) &#123; sum = p-&gt;val + carry; carry = sum / 10; last-&gt;next = new ListNode(sum % 10); last = last-&gt;next; p = p-&gt;next; &#125; while(q) &#123; sum = q-&gt;val + carry; carry = sum / 10; last-&gt;next = new ListNode(sum % 10); last = last-&gt;next; q = q-&gt;next; &#125; // 最后别忘了可能还有近位 if(carry &gt; 0) last-&gt;next = new ListNode(carry); return head-&gt;next;&#125; 445. Add Two Numbers II 给定两个表示两个非负整数的非空链表。 高位数字在前，并且它们的每个节点都包含一个数字。 将两个数字相加，然后将其作为链表返回。 如果无法修改输入列表怎么办？ 换句话说，不允许反转列表。 Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 借助栈后进先出的特性即可// 只不过插入新节点的时候注意插在头部// 另外将外面的两个 while 循环拿进去, 减少重复代码, 更优美ListNode* addTwoNumbers(ListNode* p, ListNode* q)&#123; stack&lt;ListNode*&gt; pStack, qStack; while(p) &#123; pStack.push(p); p = p-&gt;next; &#125; while(q) &#123; qStack.push(q); q = q-&gt;next; &#125; ListNode* head = nullptr; int sum = 0; int carry = 0; while(!pStack.empty() || !qStack.empty()) &#123; if(!pStack.empty() &amp;&amp; !qStack.empty()) &#123; sum = pStack.top()-&gt;val + qStack.top()-&gt;val + carry; pStack.pop(); qStack.pop(); &#125; else if(!pStack.empty()) &#123; sum = pStack.top()-&gt;val + carry; pStack.pop(); &#125; else &#123; sum = qStack.top()-&gt;val + carry; qStack.pop(); &#125; carry = sum / 10; // 插入时, 插在头部 head = new ListNode(sum % 10, head); &#125; // 最后别忘了可能还有近位 if(carry &gt; 0) head = new ListNode(carry, head); return head;&#125; 1721. Swapping Nodes in a Linked List 给定一个链表的头以及一个整数k。将从头开始第k个节点的值与从结尾开始第k个节点的值交换，返回链表的头。 Input: head = [1, 2, 3, 4, 5], k = 2Output: [1, 4, 3, 2, 5] 123456789101112131415161718192021// 左右双指针的解法ListNode* swapNodes(ListNode* head, int k)&#123; ListNode* left = nullptr; ListNode* p = head; while(--k) p = p-&gt;next; // 此时 left 指向从左边数第 k 个节点 left = p; ListNode* right = head; while(p-&gt;next) &#123; right = right-&gt;next; p = p-&gt;next; &#125; // 此时 right 指向从右边数边第 k 个节点 swap(left-&gt;val, right-&gt;val); return head;&#125; 109. Convert Sorted List to Binary Search Tree 给定一个单链表的头，其中元素按升序排序，请将其转换为高度平衡的BST。结果不唯一。 在此处，高度平衡的二叉树定义为这样一棵二叉树，其中每个节点的两个子树的深度相差不超过1。 123456789101112131415161718192021222324252627282930// 基本思想是将链表的左半部分节点作为 BST 的左子树, 右半部分节点作为 BST 的右子树,// 然后进行递归调用就可以了, 每次只需要处理中间节点即可// 这样可保证 BST 是高度平衡的// 同样的, 如果给的是有序数组, 也可以利用将中间元素构造成根节点的递归思路TreeNode* sortedListToBST(ListNode* head)&#123; // base case if(!head) return nullptr; if(!head-&gt;next) return new TreeNode(head-&gt;val); // 先定位到链表的中间节点 ListNode* slow = head; ListNode* fast = head; ListNode* preSlow = head; while(fast &amp;&amp; fast-&gt;next) &#123; preSlow = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; // 此时 slow 指向中间节点, preSlow 指向其前一节点 // 将左半部分子链表分离 preSlow-&gt;next = nullptr; // 将中间节点构建成 BST 的根节点 TreeNode* root = new TreeNode(slow-&gt;val); root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(slow-&gt;next); return root;&#125; 141. Linked List Cycle 给定链表的头节点，确定链表中是否有环。如果链表中有一个循环，则返回true。 否则，返回false。 123456789101112131415161718// 快慢指针bool hasCycle(ListNode* head)&#123; ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; // 慢指针每次走一步 slow = slow-&gt;next; // 快指针每次走两步 fast = fast-&gt;next-&gt;next; // 如果相遇就有环 if(slow == fast) return true; &#125; return false;&#125; 142. Linked List Cycle II 给定一个链表头节点，返回环开始的节点。 如果没有环，则返回null。 第一次相遇时，假设慢指针slow走了k步，那么快指针fast一定走了2k步： fast一定比slow多走了k步，这多走的k步其实就是fast指针在环里转圈圈，所以k的值就是环长度的「整数倍」。设相遇点距环的起点的距离为m，那么环的起点距头结点head的距离为k - m，也就是说如果从head前进k - m步就能到达环起点。 巧的是，如果从相遇点继续前进k - m步，也恰好到达环起点。你甭管fast在环里到底转了几圈，反正走k步可以到相遇点，那走k - m步一定就是走到环起点了： 1234567891011121314151617181920212223ListNode* detectCycle(ListNode* head)&#123; ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast) break; &#125; // 如果不是因为相遇才出循环的 if(!fast || !fast-&gt;next) return nullptr; slow = head; while(slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow;&#125; 876. Middle of the Linked List 给定一个链表头节点，返回链表的中间节点。 可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。当链表的长度是奇数时，slow恰巧停在中点位置；如果长度是偶数，slow最终的位置是中间偏右。 链表的归并排序：对于链表，合并两个有序链表是很简单的，难点就在于二分。但是现在知道了找到链表的中点的方法，就能实现链表的二分了。 123456789101112ListNode* middleNode(ListNode* head)&#123; ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; // slow 就在中间位置 return slow;&#125; 19. Remove Nth Node From End of List 给定一个链表，删除链表的倒数第n个节点，并且返回链表的头结点。 Example: 12&gt;Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2&gt;Output: [1,2,3,5] 1234567891011121314151617ListNode* removeNthFromEnd(ListNode* head, int n)&#123; ListNode* slow = head; ListNode* fast = head; while(n-- &gt; 0) fast = fast-&gt;next; if(!fast) return head-&gt;next; while(fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return head;&#125; 160. Intersection of Two Linked Lists 给定两个单链列表headA和headB的头，返回两个列表相交的节点。 如果两个链接列表完全没有交集，则返回null。 例如，以下两个链接列表开始在节点c1处相交： 123456789101112131415161718192021222324252627282930313233343536// 先制造出一个环来, 再借助前面讲过的返回环起点的思路ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)&#123; if(!headA || !headB) return nullptr; ListNode* p = headA; while(p-&gt;next) p = p-&gt;next; // 将 A 链表的首尾相连成环 p-&gt;next = headA; ListNode* slow = headB; ListNode* fast = headB; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast) break; &#125; // 如果没有相遇, 说明原先不存在交点 if(!fast || !fast-&gt;next) &#123; p-&gt;next = nullptr; return nullptr; &#125; slow = headB; while(slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; // 最后别忘了恢复链表 A p-&gt;next = nullptr; return slow;&#125; 328. Odd Even Linked List 给定一个单链列表的头，将所有具有奇数索引的节点组合在一起，然后再加上具有偶数索引的节点，然后返回重新排序的列表。 第一个节点被认为是奇数，第二个节点被认为是偶数，依此类推。请注意，偶数和奇数组中的相对顺序应保持输入中的原样。 Could you solve it in O(1) space complexity and O(nodes) time complexity? 12345678910111213141516171819202122ListNode* oddEvenList(ListNode* head)&#123; // 0, 1, 2 个节点直接返回即可 if(!head || !head-&gt;next || !head-&gt;next-&gt;next) return head; ListNode* p = head; ListNode* q = head-&gt;next; ListNode* r = q; while(q &amp;&amp; q-&gt;next) &#123; p-&gt;next = q-&gt;next; q-&gt;next = p-&gt;next-&gt;next; p = p-&gt;next; q = q-&gt;next; &#125; p-&gt;next = r; return head;&#125; 234. Palindrome Linked List 给定一个单链表的头节点，如果它是回文链表，则返回true。例如，下面这个就为回文链表： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 链表的后序遍历结合左右指针// 利用系统栈来后进先出节点ListNode* left = nullptr;bool isPalindrome(ListNode* head)&#123; left = head; return traverse(head);&#125;bool traverse(ListNode* right)&#123; if(!right) return true; bool res = traverse(right-&gt;next); res = res &amp;&amp; (left-&gt;val == right-&gt;val); // 左指针前进 left = left-&gt;next; // 结束一个递归实例后, 右指针会自动后退 return res;&#125;// 找到链表的中间节点// 再将后半部分链表反转, 判断ListNode* reverseList(ListNode* head)&#123; if(!head || !head-&gt;next) return head; ListNode* q = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return q;&#125;bool isPalindrome(ListNode* head)&#123; ListNode* slow = head; ListNode* fast = head; // 用于恢复被破坏结构的后半部分链表头节点的前一个节点 ListNode* preSlow = nullptr; while(fast &amp;&amp; fast-&gt;next) &#123; preSlow = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; if(fast) &#123; preSlow = slow; slow = slow-&gt;next; &#125; // 此后 slow 可以用于恢复被破坏结构的原链表 ListNode* slow = reverseList(slow); ListNode* last = slow; while(last) &#123; if(last-&gt;val != head-&gt;val) &#123; preSlow-&gt;next = reverseList(slow); return false; &#125; last = last-&gt;next; head = head-&gt;next; &#125; preSlow-&gt;next = reverseList(slow); return true;&#125; 21. Merge Two Sorted Lists 合并两个有序的链表，并将合并结果作为有序链表返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 迭代解法ListNode* mergeTwoLists(ListNode* p, ListNode* q)&#123; ListNode* head = new ListNode; // 辅助节点 ListNode* last = head; while(p &amp;&amp; q) &#123; if(p-&gt;val &lt;= q-&gt;val) &#123; last-&gt;next = p; p = p-&gt;next; &#125; else &#123; last-&gt;next = q; q = q-&gt;next; &#125; last = last-&gt;next; &#125; if(p) last-&gt;next = p; if(q) last-&gt;next = q; // 这里应该先释放辅助节点的空间 return head-&gt;next;&#125;// 递归解法ListNode* mergeTwoLists(ListNode* p, ListNode* q)&#123; if(!p) return q; if(!q) return p; ListNode* head = nullptr; if(p-&gt;val &lt;= q-&gt;val) &#123; head = p; head-&gt;next = mergeTwoLists(p-&gt;next, q); return head; &#125; head = q; head-&gt;next = mergeTwoLists(p, q-&gt;next); return head;&#125; 23. Merge k Sorted Lists 给定一个由k个链表头节点所组成的数组，每个链表以升序排列。将所有链表合并为一个排序的链表，然后将其返回。 Example 1: 12345678910Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]Explanation: The linked-lists are:[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]merging them into one sorted list:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 123456789101112131415161718192021222324252627// 将这 k 个头节点交给优先级队列管理// 优先级队列采用最小堆, 以节点内的值为排序对象// 这样每次 pop 的时候保证总是全局所有节点中最小的节点出队ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)&#123; // C++ 中提供的 priority_queue 默认采用最大堆, 这里需要定制成最小堆 auto cmp = [](ListNode* a, ListNode* b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq(cmp); // 所有头节点移交给 priority_queue 管理 for(int i = 0; i &lt; lists.size(); i++) if(lists[i]) pq.push(lists[i]); // 辅助节点 ListNode* head = new ListNode; ListNode* p = head; while(!pq.empty()) &#123; // 每次将全局最小节点入链出队 p-&gt;next = pq.top(); pq.pop(); p = p-&gt;next; // 放进去的将是最近入链出队的节点的下一个节点 // 这样才能保证在队列中的是全局最小的 k 个节点 if(p-&gt;next) pq.push(p-&gt;next); &#125; // 这里应该先释放辅助节点的空间 return head-&gt;next;&#125; 430. Flatten a Multilevel Doubly Linked List 给定一个双向链表，该链表除了拥有指向下一个节点和上一个节点的指针外，还具有一个孩子指针，该孩子指针可能指向也可能不指向单独的双向链接列表。 这些子链表可能有一个或多个自己的子链表，依此类推，以产生一个多级数据结构，如下面的示例所示： 展平链表，以便所有节点都出现在单级双链表中。 返回链表的头。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Definition for a Node.// class Node// &#123;// public:// int val;// Node* prev;// Node* next;// Node* child;// &#125;;// 将题目中的孩子节点看做左孩子, 下一节点看作右孩子Node* flatten(Node* p)&#123; if(!p) return p; // 申请并初始化辅助节点 Node* head = new Node; head-&gt;prev = nullptr; head-&gt;next = nullptr; head-&gt;child = nullptr; Node* q = head; stack&lt;Node*&gt; nodes; while(p) &#123; // 接纳新节点 q-&gt;next = p; p-&gt;prev = q; q = q-&gt;next; if(p-&gt;child) &#123; // 有左孩子就将其下一节点压入栈 // 并前进到左孩子 Node* temp = p; if(p-&gt;next) nodes.push(p-&gt;next); p = p-&gt;child; // 将此节点的左孩子指针置空 temp-&gt;child = nullptr; &#125; else p = p-&gt;next; // 没有左孩子就直接前进到下一节点 (右孩子) // 如果既没有左孩子也没有右孩子 // 就从栈中取下一节点 if(!p) &#123; if(nodes.empty()) break; p = nodes.top(); nodes.pop(); &#125; &#125; head-&gt;next-&gt;prev = nullptr; // 这里应该先释放辅助节点的空间 return head-&gt;next;&#125; 61. Rotate List 给定一个单链表的头节点，将链表向右旋转k个位置。 Example 1: 12Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2Output: [4,5,1,2,3] Example 2: 12Input: head &#x3D; [0,1,2], k &#x3D; 4Output: [2,0,1] Example 1 Example 2 123456789101112131415161718192021222324252627282930313233// 首先要注意到:// 1. 旋转了几次, 就会有末尾的几个节点整体次序不变的被平移到前面// 2. 如果旋转了链表长度的倍数次, 链表将恢复原样ListNode* rotateRight(ListNode* head, int k)&#123; if(!head || k == 0) return head; ListNode* p = head; // 首先获取链表的长度 int count = 1; while(p-&gt;next) &#123; p = p-&gt;next; count++; &#125; // 计算实际旋转的次数 k = k % count; // 如果待旋转次数为链表长度的倍数, 不需要旋转 if(k == 0) return head; // 计算新的头节点为第几个节点 k = count - k; // 将 q 定位到新的头节点的前一个节点 ListNode* q = head; while(--k) q = q-&gt;next; // start 为新的头节点 ListNode* start = q-&gt;next; // 前后接在一块即可 q-&gt;next = nullptr; p-&gt;next = head; return start;&#125; 138. Copy List with Random Pointer 给你一个长度为n的链表，每个节点包含一个额外增加的随机指针random，该指针可以指向链表中的任何节点或空节点。 构造这个链表的深拷贝。 深拷贝应该正好由n个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的next指针和random指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。 例如，如果原链表中有X和Y两个节点，其中X.random --&gt; Y。那么在复制链表中对应的两个节点x和y，同样有x.random --&gt; y。 返回复制链表的头节点。 用一个由n个节点组成的链表来表示输入/输出中的链表。每个节点用一个[val, random_index]表示： val：一个表示Node.val的整数。 random_index：随机指针指向的节点索引（范围从0到n - 1）；如果不指向任何节点，则为null。 你的代码只接受原链表的头节点head作为传入参数。 Example 1: 12Input: head &#x3D; [[3,null],[3,0],[3,null]]Output: [[3,null],[3,0],[3,null]] Example 2: 12Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Definition for a Node.// class Node// &#123;// public:// int val;// Node *next;// Node *random;// Node(int _val)// &#123;// val = _val;// next = NULL;// random = NULL;// &#125;// &#125;;// 直接从头节点通过 next 指针, 向后一个一个遍历就可以了// 先拷贝当前节点, 在判断当前节点的 random 指针是否为空// 如果为空, 直接跳到下一个节点就可以了// 如果不为空, 那就将 random 节点 new 一份// 注意当前节点的 random 节点可能已经遍历过或者啊还没有遍历// 1. 如果已经遍历过, 此时只需要将当前节点的拷贝节点的 random 指向它就可以了// 那么我们怎么获取已经遍历过的节点的拷贝节点的指针呢？// 2. 如果没有被遍历过, 直接 new 出来, 再将当前节点的拷贝节点的 random 指向它就行// 但是, 下次通过 next 指针遍历到它的时候, 不能再 new 了, 因为它已经存在了// 解决这个问题的方法就是借助哈希表在遍历的过程中记录当前节点和其拷贝节点之间的映射// 这样在每次遍历新节点的时候先判断是否已经被 new 出来过了// 下面直接看代码吧, 有详细注释Node* copyRandomList(Node* head)&#123; // 记录节点与其拷贝节点之间的映射 unordered_map&lt;Node*, Node*&gt; mapping; // 辅助节点, 方便插入新节点和最后返回 Node* helper = new Node(0); // last 之后一直指向新链表的尾节点 Node* last = helper; while(head) &#123; // 如果当前节点的辅助节点已经被 new 过了 if(mapping.count(head)) // 直接将映射值接在后面就行了 last-&gt;next = mapping[head]; else &#123; // 如果没有, 需要重新 new 一个 last-&gt;next = new Node(head-&gt;val); // 之后添加当前节点和被拷贝节点的映射 mapping[head] = last-&gt;next; &#125; // 如果当前节点指向了一个随机节点 // 就要为它的拷贝节点也要指向一个随机节点 if(head-&gt;random) &#123; // 如果这个随机节点已经 new 过了 if(mapping.count(head-&gt;random)) last-&gt;next-&gt;random = mapping[head-&gt;random]; else &#123; // 否则新 new 一个并添加映射 last-&gt;next-&gt;random = new Node(head-&gt;random-&gt;val); mapping[head-&gt;random] = last-&gt;next-&gt;random; &#125; &#125; // 新旧链表当前节点指针同步前进一步 head = head-&gt;next; last = last-&gt;next; &#125; // 这里应该先 free 辅助头节点的指针的 return helper-&gt;next;&#125; 1019. Next Greater Node In Linked List 给出一个以头节点head作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。 每个节点都可能有下一个更大值（next larger value）：对于node_i，如果其next_larger(node_i)是node_j.val，那么就有j &gt; i且node_j.val &gt; node_i.val，而j是可能的选项中最小的那个。如果不存在这样的j，那么下一个更大值为0。 Example 1: 12Input: [2,1,5]Output: [5,5,0] Example 2: 12Input: [2,7,4,3,5]Output: [7,0,5,5,0] 123456789101112131415161718192021222324252627282930313233// 像这种下一个最大元素之类的问题, 一定用的是单调栈的技巧// 有几道数组的题目是找下一个最大元素// 这里给换成了链表了, 换汤不换药// 这里主要学习的技术是链表的后序遍历// 对的, 链表就是一种特殊的二叉树嘛// 链表的后序遍历就是从后向前访问节点// 你当然可以用栈来完成// 这里用递归完成vector&lt;int&gt; nextLargerNodes(ListNode* head)&#123; // 存放答案的向量 vector&lt;int&gt; res; stack&lt;int&gt; s; helper(head, s, res); // 最后需要反转一下 vector // 因为递归函数是从后向前添加的 reverse(res.begin(), res.end()); return res;&#125;void helper(ListNode* head, stack&lt;int&gt;&amp; s, vector&lt;int&gt;&amp; res)&#123; // base case if(!head) return; // 先不访问节点, 递归去下一个节点 helper(head-&gt;next, s, res); // 后序遍历代码 // 下面代码都是是固定的单调栈算法的模板 while(!s.empty() &amp;&amp; s.top() &lt;= head-&gt;val) s.pop(); res.push_back(s.empty() ? 0 : s.top()); s.push(head-&gt;val);&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"认识C++内存管理的工具 （三）","date":"2020-07-18T13:35:42.000Z","path":"gMOP9F0b8zMZULMj/","text":"13. 重载类本身的operator new/delete1234567891011121314151617181920212223242526272829303132333435363738394041using namespace std;struct A&#123; A() &#123; cout &lt;&lt; \"A() : this:\" &lt;&lt; this &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A(): this: \" &lt;&lt; this &lt;&lt; endl; &#125; // 这个函数写不写 static 都会被编译器做成 static static void* operator new(size_t len) &#123; return malloc(len); &#125; static void operator delete(void* ptr, size_t len) &#123; return free(ptr); &#125;&#125;;int main()&#123; // 调用 A::operator new 版本 A* a = new A(); // 调用全局的 operator new, 如果想调用 A 的版本, 则需显式调用 A::operator new() void* b = operator new(sizeof(A)); A* c = ::new A(); // 调用全局的 operator new void* d = ::new A(); // 调用全局的 operator new delete a; // 先调用 A 的析构函数, 再调用 A 的 operator delete delete b; // 直接调用了全局的 operator delete ::delete c; ::delete d;&#125; 14. 本质就是重载newnew是关键字，编译器看到new，会转换成operator new的调用。 15. 重载new()/delete() 16. 关于多参new对应的delete 上面重载了参数不一的operator new()，那是不是要重载对应的operator delete()呢？ 理论上delete的工作只是为了释放内存，所以只需要一个指针就可以了，但C++在语法上支持多参的delete重载，但delete的调用格式只有delete ptr，所以关于重载的delete版本什么时候被调用，并不是用户手动调用，而是对应版本的Ctor发生异常后，会由crt来调用对应的delete。 17. basic_string使用new(extra)扩充申请量 18. new_handler","tags":[{"name":"C++内存管理","slug":"C-内存管理","permalink":"https://yuanlehome.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"认识C++内存管理的工具 （二）","date":"2020-07-08T13:35:42.000Z","path":"vgFO35JETZ2jRu74/","text":"7. 构造和析构的直接调用方式通过指针不可以直接调用构造函数，但可以直接调用析构函数。可以通过placement new来直接调用构造函数。 123456789101112131415161718192021struct A&#123; int a; int b; A(int _a, int _b) : a(_a), b(_b) &#123;&#125;&#125;;int main()&#123; A* tmp_a = new A(2, 8); // tmp-&gt;A::A(2, 8); // error! cannot call constructor 'A::A' directly tmp_a-&gt;~A(); // 可以的 // 虽然调用了析构函数, 但事实上 tmp_a 的空间并没有释放 // 因为没有 free 掉, 那块内存还在, 值没有被重写 // 所以可以访问 通过 tmp_a 访问原对象的值 // 如果是 delete tmp_a; 就不能访问 // 因为 delete 调用完析构函数之后, 还调用了 free 函数释放那块内存 cout &lt;&lt; tmp_a-&gt;a &lt;&lt; endl; // 所有这里访问的值看似没有变化&#125; 8. array new/deletenew []/delete[]本质调用malloc/free。malloc/free细节： 除了分配给定的内存之外，还会有cookie——用来记录分配数组的长度，查看cookie中的长度，然后调用适当次数的析构函数 所谓内存泄漏 对于一个new []，需要有相应的delete []，本质上cookie记录了free本身需要释放的内存大小，泄露则发生在调用的析构函数次数上：如果对象含有指针的data member，指向堆上的内存，则意味着析构函数是nontrival，需要再析构函数中释放指针指向的内存，反之则是trival的，而析构函数的调用次数，则会影响指针指向的内存部分的泄露。 9. placement new标准不允许直接用指针调用构造函数，但给出了另一种调用语法，可以在现有的对象的内存中调用构造函数，它不会分配新的内存。这也是没有对应的placement delete的原因。 10. C++程序分配内存的途径 从图中可以看出，当出现new Foo(x)后，编译器会检查Foo这个类有没有实现operator new(size_t)的static函数，如果有就会调用Foo这个版本的operator new，如果没有就调用全局的::operator new，delete也是如此。 所以可以为一个类单独实现operator new和operator delete。也可以重载全局的operator new/delete，但很少这么做，因为全局的版本是照顾所有的类。 11. 探究operator new12345678910111213int main()&#123; A* a = new A(); new (a) A(27, 224); void* b = ::operator new(sizeof(A)); cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; a-&gt;a &lt;&lt; endl; cout &lt;&lt; a-&gt;b &lt;&lt; endl;&#125;// 汇编代码如下: 12. 重载::operator new/delete上面说了，重载全局的operator new/delete影响深远，谨慎使用。但可以重载，方法是在非namespace中声明和全局版本相同的函数签名。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using namespace std;struct A&#123; int a; int b; A() &#123; cout &lt;&lt; \"A() : this:\" &lt;&lt; this &lt;&lt; endl; &#125; A(int _a, int _b) : a(_a), b(_b) &#123; cout &lt;&lt; \"A(int,int): this: \" &lt;&lt; this &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A(): this: \" &lt;&lt; this &lt;&lt; endl; &#125;&#125;;// 以下 4 个函数就在当前的文件中声明定义inline void* operator new(size_t len)&#123; return malloc(len); &#125;inline void* operator new[](size_t len)&#123; return malloc(len);&#125;inline void operator delete(void* ptr)&#123; return free(ptr);&#125;inline void operator delete[](void* ptr)&#123; return free(ptr);&#125;int main()&#123; A* a = new A(); // 调用到上面自定义的 operator new void* b = ::operator new(sizeof(A)); // 虽然指定的是 ::operator new, 但还是调用到上面自定义的版本 // 对于 a 是正确的释放, 先调用 A 的析构函数, 再调用上面的 operator delete delete a; // 对于 b, 释放的操作应该显示调用 operator delete // 这里用 delete 后, 并没有调用 A 的析构函数, 而是直接调用了 operator delete // 可见编译器对于 delete void* 的时候, 是直接转换为 opreator delete delete b;&#125;","tags":[{"name":"C++内存管理","slug":"C-内存管理","permalink":"https://yuanlehome.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"认识C++内存管理的工具 （一）","date":"2020-06-28T13:35:42.000Z","path":"kZo0999uFp6r1QI2/","text":"1. 内存管理函数的层次从下图中可以看到，C++程序员处于的位置是最上层的Applications，用的最多的是new，new[]，如果用容器，则内存基本不用管理。其次也可以调用malloc。至于最底层的操作系统级别的API，没有可移植性。它们之间的调用关系如上图的箭头所示。 2. Memory primitives分类 分配 释放 所属 可否重载 malloc free C函数 否 new delete C++表达式 否 ::operator new() ::operator delete() C++函数 可 allocator&lt;T&gt;::allocate() allocator&lt;T&gt;::deallocate() STL分配器 可以自己设计搭配容器 123456789101112131415161718void primitives_sample()&#123; // CRT 运行时函数 void *p1 = malloc( 512 ); free( p1 ); // new complex&lt;int&gt; *p2 = new complex&lt;int&gt;; delete p2; // ::operator new() 全局函数, 可被重载 void *p3 = ::operator new( sizeof( int ) ); // 内部调用 malloc ::operator delete( p3 ); //内部调用delete // allocator 分配器, STL 容器分配内存的方式 void *p4 = allocator&lt;int&gt;().allocate( 7 ); allocator&lt;int&gt;().deallocate( (int *)p4, 7 );&#125; 3. new的初步探究c++的程序员基本都会用new来为对象分配一个堆内存，并且new会调用对应的构造函数，构造函数是用来初始化对象的，所以总结出new的功能是： 在堆中分配一块指定对象大小的内存 将返回的指针转换为指向对象类型的指针 通过指针调用对象相应的构造函数 4. 测试new的调用流程12345678910111213struct A&#123; int a; int b; A() &#123;&#125; A(int _a, int _b): a(_a), b(_b) &#123;&#125;&#125;;int main()&#123; A* tmp_a = new A(2, 8); delete tmp_a;&#125; 上面的4张图是在MSVC中反汇编的运行时代码。从第1张图可以看出，new调用了operator new，从第3张图可以看出，operator new内部调用了malloc。实际上编译器是在new的地方调用了对应的构造函数，并不是在new的内部，new只是编译器识别的一个标识符，并不是函数，编译器看到new后会malloc，然后调用构造函数。 VS2019可以看到operator new的源码： 123456789101112131415161718192021222324_CRT_SECURITYCRITICAL_ATTRIBUTEvoid* __CRTDECL operator new(size_t const size)&#123; for (;;) &#123; if (void* const block = malloc(size)) &#123; return block; &#125; if (_callnewh(size) == 0) &#123; if (size == SIZE_MAX) &#123; __scrt_throw_std_bad_array_new_length(); &#125; else &#123; __scrt_throw_std_bad_alloc(); &#125; &#125; // The new handler was successful; try to allocate again... &#125;&#125; 上面的operator new的作用是调用malloc分配内存。当malloc成功后直接返回。当malloc失败后，并不会再次malloc，而是调用_callnewh() new_handler()，这个函数的作用是向自己定义的函数索取内存，所以new_handler可以理解为释放一些缓存，调用完new_handler后，可能释放了内存，这个时候再尝试调用malloc获取内存。 5. delete的初步探究 6. 测试delete的调用流程12345678910111213141516using namespace std;struct A&#123; int a; int b; A() &#123;&#125; A(int _a, int _b) : a(_a), b(_b) &#123;&#125; ~A() &#123;&#125;&#125;;int main()&#123; A* tmp_a = new A(2, 8); delete tmp_a;&#125;","tags":[{"name":"C++内存管理","slug":"C-内存管理","permalink":"https://yuanlehome.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"深度探索C++对象模型之构造、析构、拷贝语意学","date":"2020-06-18T13:35:42.000Z","path":"plA8MQtWi85PlNcz/","text":"第5章：构造、析构、拷贝语意学 可以定义和调用一个纯虚函数，不过只能被静态的调用（通过类作用域运算符），不能通过虚拟机制调用。 你声明了一个纯虚析构函数，就必须定义它。因为在你提供了声明前提下，每一个derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。因此，只要缺乏任何一个base class destructor的定义，就会导致链接失败。 读到这儿，你可能会有疑问，对于普通的类（没有虚机制参与进来，派生类的析构函数中也会逐一调用基类的析构函数）我们也没有提供它析构函数的，那为什么不会导致链接失败呢？这是因为你没有写析构函数，编译器会默默给你提供一个，以便于在后面的派生类的析构函数中调用它。这里的重点是你没有提供，也就是说你没有声明，如果你声明了，但没有提供定义，同样会导致链接失败。 对于基类该不该将虚函数定义为const的，作者不建议。因为derived class中可能会修改自己的数据成员。 5.1 无继承情况下的对象构造当编译器遇到这样的定义： 1Point global; 在C之中，global被视为一个“临时性的定义”，因为它没有明确的初始化操作。一个“临时性的定义”可以在程序中发生多次。那些实例会被链接器折叠起来，只留下单独一个实体，被放在程序data segment中一个“特别保留给未初始化之global objects使用”的空间。由于历史的缘故，这块空间被称为BSS，是Block Started by Symbol的缩写。 而global在C++中被视为完全定义（它会阻止第二个或更多个定义）。C和C++的一个差异就在于，BSS data segment在C++中相对地不重要。C++的所有全局对象都被当作“初始化过的数据”来对待。 为继承做准备 虚函数的引入不仅仅是每个类对象增加了一个vptr，而且会引发编译器对类产生膨胀作用。我们所定义的构造函数，编译器会附加一些代码，以便vptr初始化。合成一个copy constructor和一个copy assignment operator，它们都不是trival。因为，如果point类对象被初始化或以一个派生类对象赋值，bitwise操作就存在问题了，vptr设置会出错。 C++编译器要求编译器尽量延迟nontrivial members的实际合成操作，直到遇到使用场合为止。如果在你的设计中存在很多以传值的方式返回局部类对象，提供一个拷贝构造函数就比较合理，因为这会触发编译器的NRV优化。 5.2 继承体系下的对象构造constructor可能内带大量的隐藏码，因为编译器会扩充每一个constructor，扩充程度视class T的继承体系而定。一般而言编译器所做的扩充操作大约如下： 记录在member initialization list中的data members初始化操作会被放进constrector的函数本身，并以members的声明顺序为顺序。 如果有数据成员为类对象，并被列于member initialization list中，那么任何明确指定的参数都应该传递过去。 如果有一个member并没有出现在member initialization list之中，但它有一个default constructor，那么该default constructor必须被调用。 在那之前，如果class object有vptr，它（们）必须被设定初值，指向适当的virtual table(s)。 在那之前，所有上一层的base class constructors必须被调用，以base class的声明顺序为序： 如果basc class被列于member initialization list中，那么任何明确指定的参数都应该传递过去。 如果base class没有被列于member initialization list中，而它有default constructor(或default memberwise copy constructor)，那么就调用之。 如果base class是多重继承下的第二或后继的base class，那么this指针必须有所调整。 在那之前，所有virtual base class constructors必须被调用，从左到右，从最深到最浅： 如果class被列于member initialization list中，那么如果有任何明确指定的参数，都应该传递过去。若没有列于list之中，而class有一个default constructor，也应该调用之。 此外，class中的每一个virtual base class subobject的偏移量必须在执行期可被存取。 如果class object是最底层（most-derived）的class，其constructors可能被调用；某些用以支持这个行为的机制必须被放进来。 说明书中接下来的章节对上面这些做了详细的叙述。全是重点，就不做总结了，自行看书。 第6章：执行期语意学很重要，不做总结了，自行看书。","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"实现一个在windows平台的定时更换壁纸的工具","date":"2020-06-14T05:00:42.000Z","path":"JFfWe2Uugfh1u70r/","text":"有没有感觉到自己的电脑桌面一成不变让人厌倦？虽然有一些诸如360桌面之类的软件可以使用，但弹窗、广告又太多！本文就教你用 python 实现一个简洁清爽的桌面壁纸定时更换工具。 本文使用的方法是用 python 实现一个定时更换壁纸的脚本，壁纸来源与自定义的文件夹内，因此你可以搜集一些你喜欢的壁纸图片放于该文件夹下，这样脚本程序便可以使你的电脑桌面轮流展示这些图片了。 比如我就把我喜欢的壁纸都收集在了 E:/wallpapers/ 文件夹下。 这里推荐几个好的壁纸来源网站 https://wallhaven.cc/ ，https://www.artstation.com/wlop 。 下面直接看代码。 1234567891011121314151617181920212223import win32conimport win32guiimport threadingimport osdef getImages(): # 这里的路径就是你放图片的文件夹路径 images_path = 'E:\\\\wallpapers\\\\' files = os.listdir(images_path) return images_path, filesdef set_wallpaper(it): path, images = getImages() image = path + images[it] it = (it + 1) % len(images) win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, image, 1+2) global timer # 我设置的是每60s更换一次，你可以根据需要自定义设置 timer = threading.Timer(60.0, set_wallpaper, (it,)) timer.start()if __name__ == '__main__': set_wallpaper(0) 为了方便运行，我们可以使用 pyinstaller 工具将该脚本程序转成 .exe 可执行文件。具体的方法可以看这篇文章 Python程序打包成exe可执行文件 。 生成可执行文件之后，运行就可以了。不过，为了每次开机程序都可以自动运行，我们需要进行一些设置。首先按 win+R 键打开运行窗口，输入 shell:startup 回车，这样会打开一个启动文件夹，这个文件夹下的软件在开机时都会自动启动，将你的可执行文件或其快捷方式放在这里就可以了。 这里可以直接下载我已经生成的可执行程序： https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q提取码：v9ng 使用方法就是在E盘下新建一个名为wallpapers的文件夹，然后把自己喜欢的照片放进去就好，即E:/wallpapers/ 。","tags":[{"name":"桌面壁纸工具","slug":"桌面壁纸工具","permalink":"https://yuanlehome.github.io/tags/%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"https://yuanlehome.github.io/tags/python/"}]},{"title":"实现一个简易的Linux平台下的划词翻译工具","date":"2020-06-12T13:35:42.000Z","path":"KT2Sz9hHwziaJtFt/","text":"这里将要介绍的是一种在 Linux 平台实现的划词翻译工具，当然在考虑自己实现一个如此功能的工具前，本人也是在网上搜索了一些在 Linux 平台实现的类似的开源工具，例如 pdfTranslator，popup-dict，但它们的安装和配置都显得比较麻烦，而且使用起来也并不方便。 本人实现这个工具的初衷本是方便自己看一些英文文献和书籍的，极为方便，考虑到分享出去可以让更多人受惠，因此这里详细介绍一下它的实现步骤。 本文所实现的划词翻译工具主要有以下特性： 支持英文单词和短语到中文的翻译 划词翻译，终端显示 自动过滤选中文本中的换行等特殊字符 只依赖少数几个 Linux 命令工具 下面有动图进行演示。 本人所使用的环境是运行在 VMware 虚拟机下的 Linux 发行版 Ubuntu 18.04.3 LTS ，因此这里介绍的步骤可能与其他 Linux 发行版中的实现略有不同。下面就来一步一步的实现它吧。 一. 安装必要的命令 xclip 1$ sudo apt install xclip xclip 命令建立了终端和剪切板之间通道，可以用命令的方式将终端输出或文件的内容保存到剪切板中，也可以将剪切板的内容输出到终端或文件。详细的用法可以使用 man xclip，见其手册。这里介绍几个常用的用法。 1234$ xclip file_name # 文件内容保存到X window剪切板$ xclip -selection c file_name #文件内容保存到外部剪切板$ xclip -o # X window剪切板内容输出到终端显示$ xclip -selection c -o # 外部剪切板内容输出到终端显示 值得强调的是，这里所说的 X window 剪切板，简单的说就是你用鼠标选择的文本会实时的存放在这个剪切板，使用鼠标中键可以粘贴。而外部剪切板是保存你用 ctrl+c 复制的文本，ctrl+v 可以粘贴。这两个地方是不一样的。 translate-shell 1$ sudo apt install translate-shell 这是命令行版的谷歌翻译工具，之前叫做 Google Translate CLI 是一款借助谷歌翻译（默认）、必应翻译等来翻译的命令行翻译器。它让你可以在终端访问这些翻译引擎。 translate-shell 在大多数 Linux 发行版中都能使用。常用的方法如下： 12$ trans en:zh [word] # 英文到中文的单词翻译$ trans en:zh -b [text] # 简要的输出，进行文本翻译 需要注意的是，使用这个翻译工具需要你能够访问外网，或者通过修改 translate-shell 的默认翻译引擎，具体的方法这里就不阐述了。 二. 编程实现这个工具整体的思路就是 C 程序实时检测鼠标按键的动态，当检测到用户使用鼠标选择一段文本之后，调用 shell 脚本获取 X window 剪切板的内容进行翻译后输出到终端显示。 1. 定位鼠标设备文件 鼠标作为输入设备。其信息可以在文件 /proc/bus/input/devices 中，使用下列命令查看： 1234567891011$ sudo cat /proc/bus/input/devicesI: Bus=0011 Vendor=0002 Product=0013 Version=0006N: Name=\"VirtualPS/2 VMware VMMouse\"P: Phys=isa0060/serio1/input1S: Sysfs=/devices/platform/i8042/serio1/input/input4U: Uniq=H: Handlers=mouse0 event2 B: PROP=0B: EV=bB: KEY=70000 0 0 0 0B: ABS=3 其中的 Handlers 的值 event2 表示可以在 /dev/input/event2 文件下读取鼠标的状态。需要注意的是，对于不同的设备，读取鼠标的状态的文件可能不一样，比如也可能是 /dev/input/event3。我们可以使用下面的命令找到你的鼠标对应的是哪一个 event。 1$ sudo cat /dev/input/event2 | hexdump # 测试时改变数字即可 比如，当我运行上面这条命令之后，我移动鼠标、按鼠标左键/中键/右键，终端都会输出一些值，这就说明 event2 文件就是对应着我的鼠标。如果操作鼠标没有反应，说明这个就不是。你可以通过这种方法找到你的鼠标对应的 event 文件。 2. Linux 下获取按键响应 在 Linux 内核中，input 设备用 input_dev 结构体描述，使用 input 子系统实现输入设备驱动的时候，驱动的核心工作就是向系统报告按键、触摸屏、键盘、鼠标等输入事件（event*，通过 *input_event 结构体描述），不再需要关心文件操作接口，因为 input 子系统已经完成了文件操作接口 Linux/input.h 这个文件定义了 event 事件的结构体，API 和标准按键的编码等。 1234567891011121314151617181920212223242526// 结构体定义见 input.hstruct input_event&#123; struct timeval time; // 按键时间 __u16 type; // 事件类型 __u16 code; // 要模拟成什么按键 __s32 value; // 是按下还是释放&#125;;// 下面宏定义见 input-event-coses.h// type#define EV_KEY 0x01#define EV_REL 0x02#define EV_ABS 0x03// ...// code#define BTN_LEFT 0x110#define BTN_RIGHT 0x111#define BTN_MIDDLE 0x112// ...// value#define MSC_SERIAL 0x00#define MSC_PULSELED 0x01// ... 这里稍微介绍一下 type，指事件类型，常见的事件类型有：EV_KEY，按键事件，如键盘的按键（按下哪个键），鼠标的左键右键（是否击下）等；EV_REL，相对坐标，主要是指鼠标的移动事件（相对位移）；EV_ABS， 绝对坐标，主要指触摸屏的移动事件 。 3. 编写 C 程序 下面就可以编写程序来检测鼠标的动态了。首先在你的用户~目录下建立文件夹 Translator*。在 *Translator 里建立一个 ct.c 源文件，代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/input.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int keys_fd; struct input_event t; // 注意这里打开的文件根据你自己的设备情况作相应的改变 keys_fd = open(\"/dev/input/event2\", O_RDONLY); if (keys_fd &lt;= 0) &#123; printf(\"open /dev/input/event2 error!\\n\"); return -1; &#125; while (1) &#123; read(keys_fd, &amp;t, sizeof(t)); if (t.type == EV_KEY) // 有键按下 if (t.code == BTN_LEFT) // 鼠标左键 if (t.value == MSC_SERIAL) // 松开 // 调用外部shell脚本 system(\"~/Translator/goTranslate.sh\"); &#125; close(keys_fd); return 0;&#125; 然后就是调用 gcc 编译器生成可执行文件 ct： 1$ gcc ct.c -o ct 4. 编写 shell 脚本翻译剪切板内容 在 Translator 里建立 goTranslate.sh 文件，内容如下： 123456789101112131415#!/bin/bashstr_old=$(cat ~/Translator/lastContent)str_new=$(xclip -o 2&gt;/dev/null | xargs)if [[ \"$str_new\" != \"$str_old\" &amp;&amp; $str_new ]]; then echo -e \"\\n\" count=$(echo \"$str_new\" | wc -w) if [ \"$count\" == \"1\" ]; then echo -n -e \"$str_new \" &gt;&gt;~/Translator/words echo \"$str_new\" | trans :zh-CN | tail -1 | cut -c 5- | sed \"s,\\x1b\\[[0-9;]*[a-zA-Z],,g\" | tee -a ~/Translator/words else echo \"$str_new\" | trans :zh-CN -b fi echo \"$str_new\" &gt;~/Translator/lastContentfi 原理非常简单，读者自行了解。这里我们还要在 Translator 里建立一个 lastContent.txt 文件作为缓存，目的是本次调用脚本时能够获取上一次调用时翻译的文本内容，如果和本次调用的翻译文本一样，则本次就不进行翻译。 *5. 设置 *ct 别名 ** 这里已经可以通过下面的命令运行程序了： 1$ sudo ~/Translator/ct 但是由于每次运行都要输出这么长的命令，因此我们在 ~/.bashrc 文件中加入下面一条命令。 1alias ct='sudo ~/Translator/ct' 这样，以后每次看英文文献时就可以在命令行下输入： 1$ ct 三. 结束语这里有一些小技巧。可以更方便的使用这个工具。比如，把终端设为置顶并缩小到合适的尺寸，这样在阅读文献划词翻译时终端屏幕不会遮挡我们的视线。 值得说明的是，由于本人完全是为了方便自己的使用，而且在搞出这么个工具时仅仅接触 Linux 系统才不到两周，所以里面的实现对于有经验的朋友来说略显的有些笨拙了，请理解哈。 个人觉得这个工具使用起来还是很方便的，你觉得呢？ 参考文章： https://blog.csdn.net/liang12360640/article/details/50350648 https://www.cnblogs.com/yangwindsor/articles/3454955.html https://blog.csdn.net/liang12360640/article/details/50s350648","tags":[{"name":"划词翻译","slug":"划词翻译","permalink":"https://yuanlehome.github.io/tags/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/"},{"name":"Linux","slug":"Linux","permalink":"https://yuanlehome.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://yuanlehome.github.io/tags/shell/"}]},{"title":"深度探索C++对象模型之function语意学","date":"2020-06-08T13:35:42.000Z","path":"rRW3gD4CDal4WhRJ/","text":"第4章：Function语意学4.1 静态成员函数function的调用方式 nonmember function、static member function、nonstatic member function的调用效率完全一样，因为，在内部都被编译器处理成相同的形式。而virtual member function的调用需要通过vptr所指向的virtual table，因此，效率有所降低。 static member function的主要特性就是它没有this指针。以下的次要特性统统根源于其主要特性： 它不能够直接存取其class中的nonstatic members； 它不能够被声明为const、volatile或virtual； 它不需要经由class object才被调用——虽然大部分时候它是这样被调用的。 若取一个static member function的地址不会得到指向其class member function类型的指针（不是return_type (class_type::*)(parameter_types)）。而是一个non-member函数指针（类型为return_type (*)(parameter_types)）。 4.2 虚拟成员函数在C++中，多态表示以一个指向public base class类型的pointer或reference，寻址出一个derived class object的意思。多态机能体现在通过pointer或reference对虚函数的调用身上。因此，识别一个class是否支持多态，唯一适当的方法就是看看它是否有任何virtual function。 为了支持多态，需要在执行期决议出正确的virtual function实例，这需要如下执行期信息的支持： 它所引用的对象的地址，也就是当前它自身的值； 所引用对象的真实类型。这可使我们选择正确的虚函数所在的实体； virtual function实体位置，也就是函数地址，以便我能够调用它。 在实现上，在每一个多态的class object身上增加两个member： 一个字符串或数字，表示class的类型； 一个指针，指向某表格，表格中带有程序的virtual function的执行期地址。 virtual function的地址是固定不变的，执行期不可能新增或替换，而表格的大小和内容在执行期不会改变，因此其建构和存取皆在编译期就可以完成。 为了找到virtual function的地址，需要： 为了找到表格，每一个class object被安插上一个由编译器内部产生的指针，指向该表格； 为了找到函数地址，每一个virtual function被指派一个表格索引值。 这些工作都由编译器完成。执行期要做的，只是在特定的virtual table slot（记录着virtual function的地址）中调用virtual function。这些virtual function可以是： 这个class所定义的函数实体。它override了一个base class virtual function函数实体； 继承自base class的函数实体。这是在derived class中决定不override的virtual function时的情况； 一个pure_virtual_called()函数实体。它既可以扮演pure virtual function的空间保卫者角色，也可以当做执行期异常处理函数（有时候会用到）。 单一继承 例如，对于如下的单一继承体系： virtual destriucior被赋值slot 1，而mult()被赋值slot 2。此例并没有mult()的函数定义，因为它是一个pure virtual function，所以pure _virtual_called()的函数地址会被放在slot 2中。如果该函数意外地被调用，通常的操作是结束掉这个程序。y()被赋值slot 3而z()被赋值slot 4。x()没有slot，因为x()并非virtual function。 此时，一共有三种可能性： 它可以继承base class所声明的virtual function的函数实体。正确地说，是该函数实体的地址会被拷贝到derived class的virtual table相对应的slot之中； 它可以使用自己的函数实体。这表示它自己的函数实体地址必须放在对应的slot之中； 它可以加人一个新的virtual function。这时候virtual table的尺寸会增大一个slot，而新的函数实体地址会被放进该slot之中。 Point2d的virtual table在slot 1中指出destructor，而在slot 2中指出mult()取代pure virtual function。它自己的y()函数实体地址放在slot 3，继承自Point的z()函数实体地址则放在slot 4。 类似的情况： Point3d的virtual table中的slot 1放置Point3d的destructor，slot 2放置Point3d::mult()函数地址。slot 3放置继承自Point2d的y()函数地址，slot 4放置自己的z()函数地址。 这个继承体系中的三个类的virtual table布局如下所示： 现在，如果我们有这样的式子: 1ptr-&gt;z(); 那么，我如何有足够的知识在编译时期设定virtual function的调用呢？ 一般而言，我并不知道ptr所指对象的真正类型。然而我知道，经由ptr可以存取到该对象的virtual table； 虽然我不知道哪一个z()函数实体会被调用，但我知道每一个z()函数地址都被放在slot 4。 这些信息使得编译器可以将该调用转化为： 1(*ptr-&gt;vptr[4])(ptr); 在一个单一继承体系中，virtual function机制的行为十分良好，不但有效率而且很容易塑造出模型。但是在多重继承和虚拟继承之中，就呵呵了。 多重继承和虚拟继承 懒得总结了，看是看懂了，乱七八糟的！ 4.3 指向Member Function的指针取一个nonstatic member function的地址，如果该函数是nonvirtual，则得到的结果是它在内存中真正的地址。然而这个值也是不完全的，它也需要被绑定于某个class object的地址上，才能够通过它调用该函数（以参数this指出）。 回顾一下，一个指向member function的指针，其声明语法如下： 1double (Point::*pmf)(); 然后我们可以这样定义并初始化该指针： 1double (Point::*coord)() = &amp;Point::x; 也可以这样指定其值： 1coord = &amp;Point::y; 想调用它，可以这么做： 123(origin.*coord)();// 或(ptr-&gt;*coord)(); 这些操作会被编译器转化为： 123(coord)(&amp;origin);// 和(coord)(ptr); 获得该函数在内存中的地址。然而面对一个virtual function，其地址在编译时期是未知的，所能知道的仅是virtual function在其相关之virtual table中的索引值，也就是说，对一个virtual member function取其地址，所能获得的只是一个索引值。 那么问题来了，假设我们有以下的Point声明： 1234567class Point&#123;public: // ... virtual ~Point(); virtual float z();&#125;; 取z()函数的地址得到的索引值是2，而不是函数地址。 12float (Point::*pmf)() = &amp;Point::z;Point *ptr = new Point3d; 那么如果通过pmf来间接调用z()函数的话： 12345(ptr-&gt;*pmf)();// 转化为(*ptr-&gt;vptr[(int)pmf]5(ptr); 那么如何知道pmf指向的是virtual function还是nonvirtual function，毕竟pmf如果对nonvirtual function取地址的话得到的是在内存中的地址。也就是说，pmf的内部定义需要允许该函数能够寻址出nonvirtual和virtual两个member function。 同时为了让执行member function的指针也能支持多重继承和虚拟继承，实现方法为使用一个结构体： 1234567891011// 用以支持在多重继承之下指向 member function 的指针struct __mptr&#123; int delta; int index; // virtual 函数 在 virtual table 的索引, 当 index 不指向 virtual table 时值为 -1 union &#123; ptrtofunc faddr; // nonvirtual 函数的地址 int voffset; &#125;;&#125;; 在这样的模型下： 12345(ptr-&gt;*pmf)();// 转化为(pmf.inidex &lt; 0) ? (*pmf.faddr)(ptr) : (*ptr-&gt;vptr[pmf.index](ptr)); 4.4 inline函数","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"深度探索C++对象模型之data语意学","date":"2020-05-28T13:35:42.000Z","path":"ShyaVw4WHERlLCqZ/","text":"第3章：Data语意学The size of class 12345678class X&#123; // char c; // 此时, sizeof(X) == 1, sizeof(Y) == 8, sizeof(Z) == 8, sizeof(A) == 16 char c; // 此时, sizeof(X) == 1, sizeof(Y) == 16, sizeof(Z) == 16, sizeof(A) == 24&#125;;class Y : public virtual X &#123; &#125;;class Z : public virtual X &#123; &#125;;class A : public Y, public Z &#123; &#125;; 一个类的大小主要受三个因素的影响： 语言支持的特性所造成的负担 比如，含虚函数的类会额外多一个vptr指针，含virtual base class会再多一个额外的指针（它或者指向virtual base class subobject，或者指向一个相关表格；表格中存放的若不是virtual base class subobject地址，就是其偏移量）。 编译器对于特殊情况所提供的优化处理 现代编译器的对于空基类的优化处理：一个empty virtual base class被视为derived class object最开头的一部分，也就是说它并没有花费任何的额外空间。因为既然有了members，就不需要原本为了empty class而安插的一个char。 alignment（内存对齐） 就是将数值调整到某数的整数倍。在64位计算机上，通常alignment为8 bytes，以使bus的“运输量”达到最高效率。 nonstatic data members放置的是“个别的class object”感兴趣的数据，static data members则放置的是“整个class”感兴趣的数据。 static data members被放置在程序的一个global data segment中，不会影响个别的class object的大小。在程序之中，不管该class被产生出多少个objects（经由直接产生或间接派生），static data member永远只存在一份实体（即使该class没有任何object实体，其static data members也已存在）。 3.1 data member的绑定类成员函数的argument list中的名称会在它们第一次遭遇时被适当地决议（resolved）完成。因此在extern和nested type name之间的非直觉绑定操作还是会发生。例如在下面的程序片段： 12345678910111213141516typedef std::string length;class Test&#123;public: // 参数列表中的 length 被决议成 std::string!!! // 里面的 val_ 被正确决议成 int void setVal(length val) &#123; val_ = val; &#125;private: typedef int length; length val_;&#125;; 所以这需要使用防御性的程序风格：将nested type name写在class的起始处！ 3.2 数据成员的布局下面这个template function，接受两个data member，然后判断谁先出现在class object之中。如果两个member都是不同的access sections中的第一个被声明者，此函数就可以用来判断哪一个section先出现： 123456template&lt;class class_type, class data_typel, class data_type2&gt;std::string access_order(data_type1 class_type::* mem1, data_type2 class_type::* mem2)&#123; assert(mem1 != mem2); return mem1 &lt; mem2 ? \"member 1 occurs first\" : \"member 2 occurs first\";&#125; 上述函数可以这样被调用： 1access_order(&amp;Point3d::y, &amp;Point3d::z); 3.3 data member的存取static data member 对于类中的静态数据成员，通过一个指针和通过一个对象来存取，效率完全相同，不论这个静态数据成员经过了多么复杂的继承体系。 若取一个static data member的地址不会得到指向其class member的指针（不是value_type class_type::*类型）。而是指向其数据类型的指针（类型为value_type*）。 12345678910111213141516171819class Point&#123;public: static int x; void func1() &#123; &#125; static void func2(int a) &#123; &#125;&#125;;int Point::x = 0;int main()&#123; auto p = &amp;Point::func1; // p 的类型是 void (Point::*p)() auto q = &amp;Point::func2; // q 的类型是 void (*q)(int a) auto p = &amp;Point::x; // r 的类型是 int* r&#125; 构造函数不能是静态成员函数：如果构造函数是静态成员函数，那么将不能访问非静态变量，也没办法完成初始化的工作。 non static data member 对于类中的非静态数据成员，通过一个指针和通过一个对象来存取，当此数据成员属于继承而来的virtual base class时，使用指针效率较低。如果使用对象直接存取，就不会有这些问题，其类型无疑是确定的，而即使它继承自virtual base class，members的offset位置也在编译时期就固定了。 欲对一个nonstatic data member进行存取操作，编译器需要把class object的起始地址加上data member的偏移量。举个例子： 1&amp;origin._y == &amp;origin + (&amp;Point3d::_y - 1); 请注意其中的-1操作。指向data member的指针，其offset值总是被加上1，这样可以使编译系统区分出是用以指出class的第一个member还是没有指出任何member的两种情况。 3.4 C++对象布局 个别struct的数据布局 单一继承而且没有virtual function时的数据布局 C++语言保证——出现在derived class中的base class subobject有其完整原样性 单一继承并含虚拟函数情况下的数据布局 多重继承 虚拟继承，使用pointer strategy和virtual table offset strategy 3.5 指向data member成员的指针取一个nonstatic data member的地址，将会得到它在class中的offset（指针类型为data_type class_type::*），取一个“绑定于真正class object身上的data member”的地址，将会得到该member在内存中的真正地址（指针类型为data_type*）。","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"深度探索C++对象模型之构造函数语意学","date":"2020-05-18T13:35:42.000Z","path":"FXn6nXyz1FEw9e8Y/","text":"第2章：构造函数语意学在这一章中，主要介绍编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”的冲击。 2.1 Default Constructor的构造操作对于未声明构造函数的类，只有在以下四种情况下编译器才会为它们合成默认构造函数： 类有一个类对象（Member Class Object）成员，且该成员含有默认构造函数（Default Constructor） 继承自带有默认构造函数（Default Constructor）的基类（Base class） 带有虚函数（Virtual function）的类 继承自虚基类（Virtual base class）的类 对于以上四种情况，C++标准把合成的默认构造函数叫隐式的有意义默认构造函数(implicit nontrivial default constructors)。被合成的构造函数只能满足编译器（而非程序）的需要，它之所以能够完成任务，是借着调用成员对象或基类的默认构造函数（情况1/2），或是为每一个对象初始化其虚函数机制或虚基类机制（情况3/4）。 至于没有存在上述四种情况，而又没有声明任何构造函数的类，那么它们拥有的是隐式无意义默认构造函数(implicit trivial default constructors)，实际上它们并不会被合成出来。 Default Constructor会在编译器需要的时候被产生出来，被合成出来的Constructor只执行编译器所需要的行为。如果程序有需要，定制Default Constructor的行为是程序员的责任。 “带有Default Constructor”的Member Class Object 如果有多个class member objects都要求constructor初始化操作，将如何呢？C++语言要求以“member objects在class中的声明次序”来调用各个constructors。这一点由编译器完成，它为每一个constructor安插程序代码，以“member声明次序”调用每一个member所关联的default constructors。这些码将被安插在explicit user code之前。举个例子： 123456789101112131415161718192021222324252627282930313233class Dopey&#123;public: Dopey(); ...&#125;;class Sneezy&#123;public: Sneezy(int); Sneezy(); ...&#125;;class Bashful&#123;public: Bashful(); ...&#125;;class Snow_White&#123; ...private: Dopey dopey; Sneezy sneezy; Bashful bashful; int mumble;&#125;; 如果Snow_White没有定义default constructor，就会有一个nontrivial constructor被合成出来，依序调用Dopey、Sneezy、Bashful的default constructors。然而如果Snow_White定义了下面这样的default constructor： 12345// 程序员所写的 default constructorSnow_White::Snow_White() : sneezy(1024)&#123; mumble = 2048;&#125; 它会被扩张为： 1234567891011// 编译器扩张后的 C++ 伪码Snow_White::Snow_White()&#123; // 调用其 constructor dopey.Dopey::Dopey(); Sneezy.Sneezy::Sneezy(1024); bashful.Bashful::Bashful(); // explicit user code mumble = 2048;&#125; “带有Default Constructor”的Base Class 类似的道理，如果一个没有任何constructors的class派生自一个“带有default constructor”的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。它将调用上一层base classes的default constructor（根据它们的声明次序）。对一个后继派生的class而言，这个合成的constructor和一个“被明确提供的default constructor”没有什么差异。 如果设计者提供多个constructors，但其中都没有default constructor呢？编译器会扩张现有的每一个constructors，将“用以调用所有必要之default constructors”的程序代码加进去。它不会合成一个新的default constructor，这是因为其它“由user所提供的constructors”存在的缘故。如果同时亦存在着“带有default constructors”的member class objects，那些default constructor也会被调用。 “带有（声明或继承）一个Virtual Function”的Class 123456789101112131415161718192021class Widget&#123;public: virtual void flip() = 0; ...&#125;;void flip(const Widget&amp; widget)&#123; widget.flip();&#125;// 假设 Bell 和 Whistle 都派生自 Widgetvoid foo()&#123; Bell b; Whistle w; flip(b); flip(w);&#125; 下面两个扩张操作会在编译期间发生： 一个virtual function table会被编译器产生出来，内放class的virtual functions地址。 在每一个class object中，一个额外的pointer member会被编译器合成出来，内含相关的class vtbl的地址。 此外，widget.flip()的虚拟引发操作会被重新改写，以使用widget的vptr和vtbl中的flip()条目： 123// 1 表示 flip() 在 virtual table 的固定索引// &amp;widget 代表要交给\"被调用的某个 flip() 实体\"的 this 指针(*widget.vptr[1])(&amp;widget)); 为了让这个机制发挥功效，编译器必须为每一个Widget（或其派生类之）object的vptr设定初值，放置适当的virtual table地址。对于class所定义的每一个constructor，编译器会安插一些码来做这样的事情。对于那些未声明任何constructors的classes，编译器会为它们合成一个default constructor，以便正确地初始化每一个class object的vptr。 “带有一个Virtual Base Class”的Class 编译器必须使virtual base class在其每一个derived class object中的位置，能够在执行期准备妥当。一种可能的做法是在derived class中安插一个指向每一个virtual base class的指针，所有“经由reference和pointer来存取其中virtual base class中数据的操作”都通过此指针完成。 同样地，这个virtual base class指针是在class object构建期间完成的，编译器的默认行为和3中的vptr的处理方式一样。 2.2 Copy Constructor的构造操作有三种情况会调用copy constructor： 对一个class object做明确的初始化操作 12345class X &#123;...&#125;;X x;X xx(x);X xx = x; 当class object被当作参数交给某个函数时 1234567extern void foo(X x);void bar()&#123; X xx; foo(xx); ...&#125; 当函数返回一个class object 123456X foo_bar()&#123; X xx; ... return xx;&#125; Default Memberwise Initialization 如果class没有提供一个explicit copy constructor又当如何？当class object以“相同class的另一个object”作为初值时，其内部是以所谓的default memberwise initialization完成的，也就是把每一个内建的或派生的data member的值，从某个object拷贝一份到另一个object身上。不过它并不会拷贝其中的member class object，而是以递归的方式施行memberwise initialization。 一个良好的编译器可以为大部分class objects产生bitwise copies，因为它们有bitwise copy semantics。copy constructors在必要的时候才由编译器产生出来。这个句子中的“必要”意指当class不展现bitwise copy semantics时。 Bitwise Copy Semantics C++ Standard把copy constructor区分为trivial和nontrivial两种。只有nontrivial的实体才会被合成于程序之中。决定一个copy constructor是否为trivial的标准在于class是否展现出所谓的“bitwise copy semantics”。 什么时候一个class不展现出Bitwise Copy Semantics呢？ 当class内含一个member object而后者的class声明有一个copy constructor时（不论是被class设计者明确地声明；或是被编译器合成）。 当class继承自一个base class而后者存在有一个copy constructor（再次强调，不论是被明确声明或是被合成而得）。 当class声明了一个或多个virtual functions时。 当class派生自一个继承串链，其中有一个或多个virtual base classes时。 有一点很值得注意：在被合成出来的copy constructor中，如整数、指针、数组等等的nonclass members也都会被复制。 重新设定virtual table的指针vptr 当编译器导入一个vptr到class之中时，该class就不再展现bitwise semantics了。编译器需要合成出一个copy constructor，以求将vptr适当地初始化。 base class object以另一个base class object作为初值，或derived class object以另一个derived class object作为初值，都可以直接靠“bitwise copy semantics”完成。当一个base class object以其derived class的object内容做初始化操作时，其vptr复制操作必须保证安全。此时，合成出来的base copy constructor会明确设定object的vptr指向base class的virtual table，而不是直接从右手边的class object中将其vptr现值拷贝过来。 处理virtual base class subject 和3同理，需要合成copy constructor来明确的设定virtual base class pointer的初值。 2.3 程序转化语意学已知有这样的定义： 1X x0; 下面有三个定义，每一个都明显地以x0来初始化其class object： 123456void foo_bar()&#123; X xl(x0); X x2 = x0; X x3 = X(x0);&#125; 必要的程序转化有两个阶段： 重写每一个定义，其中的初始化操作会被剥除。 class的copy constructor调用操作会被安插进去。 举个例子，在明确的双阶段转化之后，foo_bar()可能看起来像这样： 1234567891011121314// 可能的程序转换// C++ 伪码void foo_bar()&#123; // 注意没有初始化操作 X x1; X x2; X x3; // 编译器安插X copy construction的调用操作 x1.X::X(x0); x2.X::X(x0); x3.X::X(x0);&#125; 参数的初始化 把一个class object当做参数传给一个函数，相当于以下形式的初始化操作： 12// xx 代表形式参数, arg 代表真正的参数值X xx = arg; 返回值的初始化 已知下面这个函数定义： 123456X bar()&#123; X xx; // 处理 xx ... return xx;&#125; 这里有一个双阶段转化： 首先加上一个额外参数，类型是class object的一个reference。这个参数将用来放置被“拷贝建构（copy constructed）”而得的返回值。 在return指令之前安插一个copy constructor调用操作，以便将欲传回之object的内容当做上述新增参数的初值。 根据这样的算法，bar()转换如下： 12345678910void bar(X &amp;_result)&#123; X xx; // 编译器所产生的 default constructor 调用操作 xx.X::X(); // ... 处理 xx // 编译器所产生的 copy constructor result.X::X(xx); return;&#125; 现在编译器必须转换每一个bar()调用操作，以反映其新定义。例如： 1X xx = bar(); 将被转换为下列两个指令句： 123// 注意, 不必施行 default constructorX xx;bar(xx); NRV优化 已知下面这个函数定义： 123456X bar()&#123; X xx; // 处理 xx ... return xx;&#125; 编译器会把它优化为： 123456789void bar(X &amp;_result)&#123; // default constructor 调用操作 _result.X::X(); // ... 直接处理 _result return;&#125; 只有当程序提供了explicit copy constructor，编译器才会实施NRV优化。没有提供的话（编译器自己合成的），是不会实施NRV优化的。 copy constructor要还是不要？ 对于下面的3D坐标点类，这个class的设计者应该提供一个explicit copy constructor吗？ 12345678class Point3d&#123;public: Point3d(float x, float y, float z); // ...private: float _x, _y, _z;&#125;; 除非你预见该class需要大量的memberwise初始化操作，例如函数以传值（by value）的方式传回objects，那么提供一个copy constructor的explicit inline函数实体就非常合理——可以激活编译器提供的NRV优化。否则，不提供explicit copy constructor既快速又安全。 2.4 Member initialization list为了让你的程序能够被顺利编译，必须使用member initialization list的情况： 当初始化一个refercnce member时； 当初始化一个const member时； 当调用一个base class的constructor，而它拥有一组参数时； 当调用一个member class的constructor，而它拥有一组参数时。 在这四种情况之外，不使用member initialization list，程序可以被正确编译并执行，但是效率不彰。例如： 123456789101112class Word&#123;public: Word() &#123; _name = 0; _cnt = 0; &#125;private: String _name; int _cnt;&#125;; 下面是编译器对constructor可能的内部扩张结果： 1234567891011121314151617// C++ 伪码Word::Word(/* this pointer goes here */)&#123; // 调用 String default constructor _name.String::String(); // 产生临时性对象 String temp = String(0); // memberwise 地拷贝 _name _name.String::operator=(temp); // 摧毁暂时性对象 temp.String::~String(); _cnt = 0;&#125; 更有效率的实现方法： 12345// 较佳的方式Word::Word : _name(0)&#123; cnt = 0;&#125; 它会被扩张成这个样子： 1234567// C++ 伪码Word::Word(/* this pointer goes here */)&#123; // 调用 String(int) constructor _name.String::String(0); _cnt = 0;&#125; 编译器会一一操作initialization list，以member声明次序（不是由initialization list中的排列次序决定的）在constructor之内的explicit user code之前安插初始化操作。 调用一个member function以设定一个member的初值是可以的，因为此时this指针已经被构造妥当。 12345678910// X::xfoo() 被调用X::X(int val) : i(xfoo(val)), j(val)&#123; &#125;// 会被扩张为X::X(/* this pointer */, int val)&#123; i = this-&gt;xfoo(val); i = val;&#125; 注意：如果一个derived class member function被调用，其返回值被当做base class constructor的一个参数，这不是一个好主意！！！","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"深度探索C++对象模型之前言","date":"2020-05-08T13:35:42.000Z","path":"jOQUhpad0yAY7aMb/","text":"前言Simplifier是编译器的一部分，处于type checking和code generation之间。它用来转换内部的程序表现。有3种转换是任何对象模型都需要的： 与编译器息息相关的转换（Implementation-dependent transformations） 例如，当parser看到这个表达式： 1fct(); 它并不知道是否（a）这是一个函数调用操作，或者（b）这是overloaded calloperator在class object fct上的一种应用。默认情况下，这个式子所代表的是一个函数调用，但是当（b）的情况出现，Simplifier就要重写并调换call subtree。 语言语意转换（Language semantics transformations） 这包括constructor/destructor的合成和扩展、memberwise初始化、对于memberwise copy的支持、在程序代码中安插conversion operators、临时性对象，以及对constructor/destructor的调用。 程序代码和对象模型的转换（Code and object model transformations） 这包括对virtual functions、virtual base class和inheritance的一般支持、new和delete运算符、class objects所组成的数组、local static class instances、带有非常量表达式（nonconstant cxpression）之global object的静态初始化操作。 什么是C++对象模型？ 语言中直接支持面向对象程序设计的部分 对于各种支持的底层实现机制 第1章：关于对象在C语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。 C++在布局以及存取时间上主要的额外负担是由virtual引起，包括： virtual function机制——用以支持一个有效率的“执行期绑定” virtual base class——用以实现“多次出现在继承体系中的base class，有一个单一而被共享的实体” 此外，还有一些多重继承下的额外负担，发生在“一个derived class和其第二或后继之base class的转换”之间。 1.1 C++对象模型在C++中，有两种class data members：static和nonstatic，以及三种class member functions：static、nonstatic和virtual。 在C++对象模型中，nonstatic data members被配置于每一个class object之内，static data members则被存放在所有的class object之外。static和nonstatic function members也被放在所有的class object之外。virtual functions则以两个步骤支持之： 每一个class产生出一堆指向virtual functions的指针，放在表格之中。这个表格被称为 vtbl。 每一个class object被添加了一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）由每一个class的constructor、destructor和copy assignment运算符自动完成。 在虚拟继承的情况下，base class不管在继承串链中被派生（derived）多少次，永远只会存在一个实体（称为subobject）。 C++最初采用的继承模型并不运用任何间接性: base class subobject的data members被直接放置于derived class object中。这提供了对base class members最紧凑而且最有效率的存取。缺点就是: base class members的任何改变，包括增加﹑移除或改变类型等等，都使得所有用到“此base class或其derived class之objects”者重新编译。 virtual base class的原始模型是在class object中为每一个有关联的virtual base class加上一个指针。 对象模型如何影响程序？ 不同的对象模型，会导致“现有的程序代码必须修改”以及“必须加人新的程序代码”两个结果。例如下面这个函数，其中class X定义了一个copy constructor，一个virtual destructor，和一个virtual function foo： 123456789101112X foobar()&#123; X xx; X* px = new X; // foo 是一个虚函数 xx.foo(); px-&gt;foo(); delete px; return xx; // 这里会用到 copy constructor&#125; 这个函数有可能在内部被转化为： 1234567891011121314151617181920212223242526272829void foobar(X&amp; _result)&#123; // 构造 _result // _result 用来取代 local xx... _result.X::X(); // 扩展 ×* px= new x; px = _new(sizeof(X)); if(px != 0) px-&gt;X::X(); // 扩展 xx.foo() 但不使用 virtual 机制 // 以 _result 取代 xx foo(&amp;_result); // 使用 virtual 机制扩展 px-&gt;foo() (*px-&gt;vtbl[2])(px); // 扩展 delete px; if(px != 0) &#123; (*px-&gt;vtbl[1])(px); // destructor _delete(px); &#125; //不需使用 named return statement //不需要摧毁 local object xx return;&#125; 1.2 关键词所带来的差异 掌握struct和class关键字的差异 struct关键词的使用实现了C的数据萃取概念，而class关键词实现的是C++的ADT（Abstract Data Type）概念。 C程序员的巧计（C++中不可用）。例如把单一元素的数组放在一个struct的尾端，于是每个struct objects可以拥有可变大小的数组： 1234567891011struct mumble&#123; // stuff char pc[1];&#125;;// 从档案或标准输入装置中取得一个字符串 str// 然后为 struct 本身和该字符串配置足够的内存struct mumble *pmumble = (struct mumble*) malloc(sizeof(struct mumble) + strlen(str) + 1);strcpy(&amp;(pmumble-&gt;pc), str); C++中凡处于同一个access section的数据，必定保证以其声明次序出现在内存布局当中。然而被放置在多个access sections中的各笔数据，排列次序就不一定了。组合（composition)，而非继承，才是把C和C++结合在一起的唯一可行方法（conversion运算符提供了一个十分便利的萃取方法）： 12345678struct C_point &#123; ... &#125;;class Point&#123;public: operator C_point() &#123; return c_point_; &#125; // ...private: C_point c_point_; C struct在C++中的一个合理用途，是当你要传递“一个复杂的class object的全部或部分”到某个C函数中去时，struct声明可以将数据封装起来，并保证拥有与C兼容的空间布局。然而这项保证只在组合的情况下才存在。 1.3 对象的差异C++支持3种程序设计模型： 程序模型（面向过程） 抽象数据类型模型（基于对象模型）（封装） 面向对象模型（继承、多态） 在C++，多态只存在于一个个的public class体系中。nonpublic的派生行为以及类型为void*的指针可以说是多态，但它们并没有被语言明白地支持，也就是说它们必须由程序员通过明白的转型操作来管理。C++以下列方法支持多态： 经由一组隐含的转化操作。例如把一个derived class指针转化为一个指向其public base type的指针 1Shape *ps = new Circle(); 经由virtual function机制 经由dynamic_cast和typeid运算符 12if(Circle* pc = dynamic_cast&lt;Circle*&gt;(ps)) ... virtual function机制不只使得“当类型有所增加、修改、或删减时，我们的程序代码不需改变”。而且也使一个新的subtype的供应者不需要重新写出“对继承体系中的所有类型都共通”的行为和操作。 需要多少内存才能够表现一个class object？ nonstatic data members的总和大小 加上任何alignment（内存对齐） 加上为了支持virtual（function，base class）而由内部产生的额外负担 转型（cast）其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。 一个Base指针pb和一个Derived指针pd有什么不同？ 123Derived d;Base* pb = &amp;d;Derived* pd = &amp;d; 它们每个都指向Base object的第一个byte。其间的差别是，pd所涵盖的地址包含整个Derived object，而pb所涵盖的地址只包含Derived object中的Base subobject。 除了Base subobject中出现的members，你不能使用pb来直接处理Derived的任何members。例外是通过virtual机制或转型操作。 当一个base class object被直接初始化为（或是被指定为）一个derived class object时，derived object就会被切割，以塞人较小的base type内存中，derived type将没有留下任何蛛丝马迹。 下面这一组定义，其可能的内存布局为： 12345ZooAnimal za;ZooAnimal *pza;Bear b;Panda* pp = new Panda;pza = &amp;b;","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"Effective C++之模板与泛型编程","date":"2020-04-18T13:35:42.000Z","path":"MBICE5WlMJtd4Rku/","text":"第7章：模板与泛型编程条款41：了解隐式接口和编译期多态 哪一个重载函数被调用——发生在编译期 哪一个virtual函数被绑定——发生在运行期 class和template都支持接口和多态 对class而言，接口是显式的，以成员函数的签名为中心，多态则通过virtual函数发生在运行期。对template而言，接口是隐式的，以有效表达式为中心，多态则通过template具现化和函数重载解析发生于编译期。 条款42：了解typename的双重意义 当我们声明模板类型参数，class和typename的意义完全相同 12template&lt;typename T&gt;template&lt;class T&gt; typename用来标识嵌套从属类型名称 template内出现的名称如果相依于某个template参数，称这个名称为从属名称，如果丛属名称在class内呈嵌套状，称为嵌套从属名称。如果嵌套从属名称还指涉某种类型名称为嵌套从属类型名称 123456789101112131415161718// std::iterator_traits&lt;IterT&gt;::value_type 就是嵌套从属类型名称template&lt;typename IterT&gt;void workWithIterator(IterT iter)&#123; // 必须使用 typename 关键字标识 typename std::iterator_traits&lt;IterT&gt;::value_type temp(*iter); ...&#125;// 使用 typedef 少打几个字template&lt;typename IterT&gt;void workWithIterator(IterT iter)&#123; // 必须使用 typename 关键字标识 typedef typename std::iterator_traits&lt;IterT&gt;::value_type value_type; value_type temp(*iter); ...&#125; 不允许在base class list或member initialization list内使用typename作为base class的标识符 条款43：学习处理模板化基类内的名称假设我们需要撰写一个MsgSender类，它能够传送信息到若干不同的Company去。信息要不进行加密后的密文，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于template的解法： 1234567891011121314151617181920212223242526272829303132333435363738394041class CompanyA&#123;public: ... void sendCleartext(const string&amp; msg); void sendEncrypted(const string&amp; msg);&#125;;class CompanyB&#123;public: ... void sendCleartext(const string&amp; msg); void sendEncrypted(const string&amp; msg);&#125;;... // 针对其他公司设计的 classclass MsgInfo &#123;...&#125;; // 这个 class 以备将来产生信息template&lt;typename Company&gt;class MsgSender&#123;public: ... //构造函数、析构函数等等 void sendClear(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendCleartext(msg); &#125; void sendSecret(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendEncrypted(msg); &#125;&#125;; 现在假设我们想要在每次送出信息时log某些信息。derived class可轻易提供解决方法： 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log sendClear(info); // 调用 base class 函数, 这段码无法通过编译! ... // 将“传送后”的信息写至 log &#125; ...&#125;; 编译器会抱怨sendClear函数不存在，明明在那里，为什么？ 问题在于，当编译器看见class template LoggingMsgSender定义式时，并不知道它继承什么样的class。当然它继承的是MsgSender&lt;Company&gt;，但其中的Company是个template参数，不当LoggingMsgSender被具现化之前无法确切知道它是什么。而如果不知道Company是什么，就无法知道class MsgSender&lt;Company&gt;看起来像什么——更明确地说是没办法知道它是否有个sendClear函数。 具体点说，假设现在有个CompanyZ坚持只使用加密通讯： 12345678// 不提供 sendCleartext 函数class CompanyZ&#123;public: ... void sendEncrypted(const string&amp; msg); ...&#125;; 一般性的MsgSender template对CompanyZ并不合适，因为那个template提供了一个sendClearMsg函数，而这对CompanyZ对象并不合理。欲矫正这个问题，我们可以针对CompanyZ产生一个MsgSender特化版： 123456789101112131415// 全特化版本只提供 sendSecret 函数template&lt;&gt;class MsgSender&lt;CompanyZ&gt;&#123;public: ... //构造函数、析构函数等等 void sendSecret(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendEncrypted(msg); &#125; ...&#125;; 这就解释了前面编译器拒绝那个调用的原因：它知道base class template有可能被特化，而那个特化版本可能不提供和一般性template相同的接口。因此它往往拒绝在templatized base class（本例的MsgSender&lt;Company&gt;）内寻找继承而来的名称（本例的SendClear)。 当我们从Object Oriented C++跨进Template C++（见条款1) ，继承就不像以前那样畅行无阻了 有三个解决令C++编译器“不进入templatized base class观察”的行为失效的办法： 使用this指针 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log this-&gt;sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 使用using声明 虽然using声明式在在条款33或在这里都可有效运作，但两处解决的问题其实不相同。前者是base class名称被derived class名称遮掩，而后者是编译器不进入base class作用域内查找，于是我们通过using告诉它，请它那么做。 1234567891011121314template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: using MsgSender&lt;Company&gt;::sendClear; ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 使用作用域运算符::明确指定 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log MsgSender&lt;Company&gt;::sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 即使如此，如果稍后这样做： 1234LoggingMsgSender&lt;Companyz&gt;zMsgSender;MsgInfo msgData;...zMsgSender.sendClearMsg(msgData); // 仍然无法通过编译 其中对sendClearMsg的调用动作将无法通过编译，因为在那个点上，编译器知道base class是个template特化版本MsgSender&lt;CompanyZ&gt;，而且它知道那个class不提供sendClear函数，而sendClear却是sendClearMsg尝试调用的函数。 条款44：将与基类无关的代码抽离template当你编写某个函数，其中某些部分的实现码和另一个函数的实现码实质相同，你会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。如果你正在编写某个class，而你明白其中某些部分和另一个class的某些部分相同，你也不会重复这共同的部分。你会把共同部分搬移到新class去，然后使用继承或复合（见条款32，38，39) ，令原先的class取用这共同特性。而原class的互异部分仍然留在原位置不动。 编写template时，也是做相同的分析，以相同的方式避免重复。然而在template代码中，重复是隐晦的：毕竟只存在一份template源码，所以你必须训练自己去感受当template被具现化多次时可能发生的重复。 举个例子，假设你想为固定尺寸的正方矩阵编写一个template。该矩阵的性质之一是支持逆矩阵运算。 123456789101112131415// template 支持 n x n 矩阵, 元素类型为 Ttemplate&lt;typename T, size_t n&gt;class squareMatrix&#123;public: ... void invert( ); // 求逆矩阵&#125;;SquareMatrix&lt;double, 5&gt; sml;...sm1.invert(); // 调用 SquareMatrix&lt;double, 5&gt;::invertsSquareMatrix&lt;double, 10&gt; sm2;...sm2.invert(); // 调用 SquareMatrix&lt;double, 10&gt;::invert 这会具现化两份invert。这些函数并非完完全全相同，因为其中一个操作的是5x5矩阵而另一个操作的是10x10矩阵，但除了常量5和10，两个函数的其他部分完全相同。这是template引出代码膨胀的一个典型例子。 第一次修改： 1234567891011121314151617181920212223242526// 与尺寸无关的 base classtemplate&lt;typename T&gt;class SquareMatrixBase&#123;protected: void invert(size_t matrixSize) // 以给定的尺寸求逆矩阵 &#123; ... &#125;&#125;;template&lt;typename T, size_t n&gt;class SquareMatrix : private SquareMatrixBase&lt;T&gt;&#123;private: // 声明为 private 是为了不让客户看见 using SquareMatrixBase&lt;T&gt;::invert; // 避免遮掩 base 版的 invert, 见条款 33public: ... void invert() &#123; this-&gt;invert(n); // inline 调用 base class 版的 invert // 为什么这儿出现 this-&gt; 见条款 43 // LYL 认为前面已经使用了 using, this-&gt; 应该也不需要了 &#125;&#125;; 这里的base class只是为了帮助derived class实现，不是为了表现SquareMatrix和SquareMatrixBase之间的is-a关系（关于private继承，见条款39)。 目前为止一切都好，但还有一些棘手的题目没有解决。SquareMatrixBase::invert如何知道该操作什么数据？虽然它从参数中知道矩阵尺寸，但它如何知道哪个特定矩阵的数据在哪儿？想必只有derived class知道。derived class如何联络其base class做逆运算动作？一个可能的做法是为SquareMatrixBase::invert添加另一个参数，可以是个指针，指向一块用来放置矩阵数据的内存地址。 第二次修改： 1234567891011121314151617181920212223242526272829303132template&lt;typename T&gt;class SquareMatrixBase&#123;protected: // 存储矩阵大小和一个指针, 指向矩阵数值 squareMatrixBase(size_t n, T* pMem) : size(n), pData(pMem) &#123;&#125; void invert() // 不用指定尺寸了 &#123; ... &#125; ...private: size_t size; // 矩阵的大小 T* pData; // 指针, 指向矩阵内容&#125;;template&lt;typename T, size_t n&gt;class SquareMatrix : private SquareMatrixBase&lt;T&gt;&#123;private: using SquareMatrixBase&lt;T&gt;::invert;public: SquareMatrix() : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125; void invert() &#123; this-&gt;invert(n); &#125; ...private: T data[n * n]; // 这里直接将数据矩阵存储在 SquareMatrix 对象内部 // 也可以使用动态内存分配的方案&#125;; 这个条款只讨论由non-type template parameter（非类型模板参数）带来的膨胀，其实type parameter（类型参数）也会导致膨胀。例如在许多平台上int和 long有相同的二进制表述，所以像vector&lt;int&gt;和vector&lt;long&gt;的成员函数有可能完全相同。某些链接器（linker）会合并完全相同的函数实现码，但有些不会，后者意味某些template被具现化为int和long两个版本，并因此造成代码膨胀。类似情况，所有指针类型都有相同的二进制表述，因此凡template持有指针者（例如list&lt;int*&gt;，list&lt;const int*&gt;，list&lt;SquareMatrix&lt;long, 3&gt;*&gt;等等）往往应该对每一个成员函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它们操作强型指针（strongly typed pointer，即T*），你应该令它们调用另一个操作无类型指针（untyped pointer，即void*）的函数，由后者完成实际工作。某些C++标准程序库实现版本的确为vector，deque和list等template做了这件事。 条款45：成员函数模板接受所有兼容类型内置指针是支持隐式转换的，比如derived class的指针可以隐式转换为base class指针，指向non-const对象的指针可以转换为指向const对象等等。 123456class Top &#123;...&#125;;class Middle : public Top &#123;...&#125;;class Bottom : public Middle &#123;...&#125;;Top* pt1 = new Middle; // 将 Middle* 转换为 Top*Top* pt2 = new Bottom; // 将 Bottom* 转换为 Top*const Top* = pt1; // Top* 转换为 const Top* 但是我们自己实现的智能指针模板类，想做到这样就稍稍有点麻烦了。我们希望下面的代码能够通过编译： 12345678910111213141516temmplate&lt;typename T&gt;class SmartPtr&#123;public: explicit SmartPtr(T* realPtr); // 智能指针通常以内置指针完成初始化 ...&#125;;// 将 SmartPtr&lt;Middle&gt;转 换为 SmartPtr&lt;Top&gt;SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(new Middle);// 将 SmartPtr&lt;Bottom&gt; 转换为 SmartPtr&lt;Top&gt;SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(new Bottom);// 将 SmartPtr&lt;Top&gt; 转换为 SmartPtr&lt;const Top&gt;SmartPtr&lt;const Top&gt; pct2 = ptl; 注意，这些赋值表达式需要调用的都是copy构造函数。这里的代码不能通过编译，因为如果以带有base-derived关系的B，D两类型分别具现化某个template，产生出来的两个具现体并不带有base-derived关系，所以编译器视SmartPtr&lt;Middle&gt;和SmartPtr&lt;Top&gt;为完全不同的class，为了获得我们希望获得的SmartPtr class之间的转换能力，我们必须将它们明确地编写出来。 我们应该为它写一个构造模板。这样的模板是所谓member function template，其作用是为class生成函数： 123456789template&lt;typename T&gt;class SmartPtr&#123;public: // member template, 为了生成 copy 构造函数 template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other); ...&#125;; 我们称之为泛化（generalized）copy构造函数。它并未被声明为explicit，那是因为内置指针类型之间的转换（例如从derived class指针转为base class指针）是隐式转换，所以让智能指针按照这种形式也属合理。 但是，这个为SmartPtr而写的“泛化copy构造函数”提供的东西比我们需要的更多。我们只希望根据一个SmartPtr&lt;Bottom&gt;创建一个SmartPtr&lt;Top&gt;，却不希望根据一个SmartPtr&lt;Top&gt;创建一个SmartPtr&lt;Bottomr&gt;，因为那对public继承而言（见条款32）是矛盾的。我们也不希望根据一个SmartPtr&lt;double&gt;创建一个SmartPtr&lt;int&gt;，我们必须从某方面对这一member template所创建的成员函数群进行挑拣。 假设SmartPtr遵循std::shared_ptr也提供一个get成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望： 12345678910111213template&lt;typename T&gt;class SmartPtr&#123;public: // 以 other 的 heldPtr 初始化 this 的 heldPtr template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other) : heldPtr(other.get()) &#123;...&#125; T* get() const &#123; return heldPtr; &#125; ...private: T* heldPtr; // 这个 SmartPtr 持有的内置指针&#125;; 这个行为只有当“存在某个隐式转换可将一个U*指针转为一个T*指针”时才能通过编译，而这正是我们想要的。 member function template（成员函数模板）的效用不限于构造函数，它常扮演的另一个角色是支持赋值操作。例如std::shared_ptr同时支持所有“来自兼容之内置指针、std::shared_ptr、std::weak_ptr”的构造行为以及赋值操作（std::weak_ptr除外）。赋值操作符和copy构造函数实现类似，故省略。 如果你声明member template用于“泛化copy构造”或“泛化assignment操作”你还是需要声明正常的copy构造函数和copy assignment操作符 条款5说过，编译器可能为我们产生四个成员函数，其中两个是copy构造函数和copy assignment操作符。现在，SmartPtr声明了一个泛化copy构造函数，而显然一旦类型T和U相同，泛化copy构造函数会被具现化为“正常的”copy构造函数。那么究竟编译器会暗自为SmartPtr生成一个copy构造函数呢？或当某个SmartPtr对象根据另一个同型的SmartPtr对象展开构造行为时，编译器会将“泛化copy构造函数模板”具现化呢？ member template并不改变语言规则：“如果程序需要一个copy构造函数，你却没有声明它，编译器会为你暗自生成一个”。在class内声明泛化copy构造函数（是个member template）并不会阻止编译器生成它们自己的copy构造函数（一个non-template），所以如果你想要控制copy构造的方方面面，你必须同时声明泛化copy构造函数和“正常的”copy构造函数。相同规则也适用于赋值操作。 条款46：需要类型转换时请为模板定义非成员函数条款24讨论过为什么惟有non-member函数才有能力“在所有实参身上实施隐式类型转换”，该条款并以Rational class的operator*函数为例。本条款将Rational和operator*模板化： 123456789101112131415161718192021template&lt;typename T&gt;class Rational&#123;public: // 条款 20 告诉你为什么参数以 passed by reference 方式传递 Rational(const T&amp; numerator = 0, const T&amp; denominator = 1); // 条款 28 告诉你为啥返回值以 passed by value 方式传递 // 条款 3 告诉你为啥它们是 const const T numerator() const; const T denominator() const; ...&#125;;template&lt;typename T&gt;const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 就像条款24一样，我们也希望支持混合式算术运算，然而以下代码却不能通过编译： 12Rational&lt;int&gt; oneHalf(1, 2);Rational&lt;int&gt; result &#x3D; oneHalf * 2; &#x2F;&#x2F; 错误!无法通过编译 在这里，编译器不知道我们想要调用哪个函数！它们试图找到什么函数被名为operator*的template具现化出来。它们知道它们应该可以具现化某个“名为operator*并接受两个Rational&lt;T&gt;参数”的函数，但为完成这一具现化行动，必须先算出T是什么。 为了推导T，它们看了看operator*调用动作中的实参类型。分别是Rational&lt;int&gt;（oneHalf的类型）和int（2的类型）。 以oneHalf进行推导，过程并不困难。第二参数的推导则没有这么顺利。operator*的第二参数被声明为Rational&lt;T&gt;，但传递给operator*的类型是int（2）。编译器如何根据这个2推算出T？你或许会期盼编译器使用Rational&lt;int&gt;的non-explicit构造函数将转换为Rational&lt;int&gt;，进而将T推导为int，然而template实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。 template class内的friend声明式可以指涉某个特定函数。这意味class Rational&lt;T&gt;可以声明operator*是它的一个friend函数。class template并不倚赖template实参推导，所以编译器总是能够在class Rational&lt;T&gt;具现化时得知T。因此： 12345678910111213141516template&lt;typename T&gt;class Rational&#123;public: ... friend const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs);&#125;;template&lt;typename T&gt;const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 现在当对象oneHalf被声明为一个Rational&lt;int&gt;，class Rational&lt;int&gt;于是被具现化出来，而作为过程的一部分，friend函数operator*（接受Rational&lt;int&gt;参数）也就被自动声明出来。后者身为一个函数而非function template，因此编译器可在调用它时使用隐式转换函数（例如调用Rational的non-explicit构造函数）。 但是，虽然这段代码通过编译，却无法连接。 因为这个友元函数只被声明于Rational内，并没有被定义出来。我们意图令此class外部的operator* template提供定义式，是行不通的。既然我们没有提供定义式，连接器当然找不到它！ 最简单的方法就是，将函数本体放进class内： 12345678910111213template&lt;typename T&gt;class Rational&#123;public: ... friend template&lt;typename T&gt; const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) &#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); &#125;&#125;; 为了让类型转换可能发生于所有实参身上，我们需要一个non-member函数（条款24）；为了令这个函数被自动具现化，我们需要将它声明在class内部；而在class内部声明non-member函数的唯一办法就是：令它成为一个friend。因此我们就这样做了。 当此friend函数过于复杂时，令其调用类外的辅助函数 12345678910111213141516171819202122template&lt;typename T&gt; class Rational; // 前向声明template&lt;typename T&gt;const Rational&lt;T&gt; doMultiply(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp;rhs);&#123; return Rational&lt;T&gt;(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125;template&lt;typename T&gt;class Rational&#123;public: ... friend const Rational&lt;T&gt;operator* (const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) &#123; return doMultiply(lhs, rhs); &#125; ...&#125;; 作为一个template，doMultiply当然不支持混合式乘法，但它其实也不需要。它只被operator*调用，而operator*支持混合式操作。 条款47：traits classes表现类型信息STL迭代器分类： input迭代器 只能向前移动，一次一步，用户只能读取它所指的东西，而且只能读取一次，读完立即自动向前一步。程序库中的输入流迭代器istream_iterator就属于这一类。 output迭代器 只能向前移动，一次一步，用户只能涂写它所指的东西，而且只能涂写一次，写完立即自动向前一步。程序库中的输出流迭代器ostream_iterator就属于这一类。 forward迭代器 可以做上述两种迭代器做的事情，而且支持多次读写，读写完由用户自行决定是否前进。单向链表slist提供的迭代器就属于这一类。 bidirectional迭代器 除了能做forward迭代器做的事情，还可以向后移动。双向链表list以及set，mutilset，map，mutilmap提供的迭代器属于这一类。 random access迭代器 功能类似于内置指针，可以进行算数操作。vector，deque和string提供的迭代器属于这一类。 迭代器适配器 reverse迭代器 insert迭代器 back inserter front inserter general inserter stream迭代器 move迭代器 12345struct input_iterator_tag &#123;&#125;;struct output_iterator_tag &#123;&#125;;struct forward_iterator_tag : public input_iterator_tag &#123;&#125;;struct bidirectional iterator_tag : public forward_iterator_tag &#123;&#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag &#123;&#125;; 这些struct之间的继承关系是有效的is-a关系：所有forward迭代器都是input迭代器，依此类推。 关于iterator_trait的实现技术（参考书籍P227-P232） 条款48：认识template元编程 如题，以后买本书再专门去学吧！","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之继承与面向对象设计","date":"2020-04-10T13:35:42.000Z","path":"5pPP61A5gGyfCrjb/","text":"第6章：继承与面向对象设计条款32：确定你的public继承塑模出is-a关系 “public继承”意味is-a。适用于base class身上的每一件事情一定也适用于derived class身上，因为每一个derived class对象也都是一个base class对象 条款33：避免遮掩继承而来的名称 derived class的作用域被嵌套在base class作用域内 12345678910111213141516171819202122232425class Base&#123;private: int x;public: virtual void mf1() = 0; virtual void mf1(int); void mf2(); void mf2(double);&#125;;class Derived : public Base&#123;public: virtual void mf1(); void mf2();&#125;;Derived d;int x;...d.mf1(); // 没问题, 调用 Derived::mf1d.mf1(x); // 错误! 因为 Derived::mf1 遮掩了 Base::mf1d.mf2(); // 没问题, 调用 Derived::mf2d.mf2(x); // 错误! 因为 Derived::mf2 遮掩了 Base::mf2 这段代码中base class内所有名为mf1和mf2的函数都被derived class内的mf1和mf2函数遮掩掉了。从名称查找观点来看，Base::mf1和Base::mf2不再被Derived继承！ 实际上如果你正在使用public继承而又不继承那些重载函数，就是违反base和derived class之间的is-a关系，而条款32说过is-a是public继承的基石。因此你几乎总会想要推翻C++对“继承而来的名称”的缺省遮掩行为。 使用using声明式 1234567891011121314151617181920212223242526272829class Base&#123;private: int x; public: virtual void mf1() = 0; virtual void mf1(int); void mf2(); void mf2(double); ...&#125;;class Derived : public Base&#123;public: using Base::mf1; // 让 Base class 内名为 mf1 和 mf2 的所有东西 using Base::mf2; // 在 Derived 作用域内都可见, 并且 public virtual void mf1(); void mf2();&#125;;Derived d;int x;...d.mf1(); // 没问题, 调用 Derived::mf1d.mf1(x); // 现在没问题了, 调用 Based::mf1d.mf2(); // 没问题, 调用 Derived::mf2d.mf2(x); // 现在没问题了, 调用 Based::mf2 使用inline转交函数（forwarding function） 然而在private继承之下（见条款39），有时候你并不想继承base class的所有函数。假设Derived以private形式继承Base，而Derived唯一想继承的mf1是那个无参数版本。using声明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名函数在derived class中都可见。 1234567891011121314151617181920212223class Base&#123;public: virtual void mf1() = 0; virtual void mf1(int); ... // 与前同&#125;;class Derived : private Base&#123;public: virtual void mf1() // 转交函数 &#123; Base::mf1(); // 暗自成为 inline (见条款 30) &#125; ...&#125;;Derived d;int x;d.mf1(); // 很好, 调用的是 Derived::mf1d.mf1(x); // 错误! Base::mf1 被遮掩 条款34：区分接口继承和实现继承身为class设计者，有时候你会希望derived class只继承成员函数的接口，也就是声明；有时候你又会希望derived class同时继承函数的接口和实现，但又希望能够覆写（override）它们所继承的实现；又有时候你希望derived class同时继承函数的接口和实现，并且不允许覆写任何东西。 base类强烈影响以public形式继承它的derived class，因为： 成员函数的接口总是会被继承 声明一个pure virtual函数的目的是为了让derived类只继承函数接口 含有pure virtual函数的类属于抽象基类，不能被实例化。继承了它们的类必须重新声明此函数接口并给予实现。抽象基类可以给pure virtual函数提供定义，但调用它的唯一途径是“调用时指定其class的名称”。 声明impure函数的目的是让derived class继承该函数的接口和缺省实现 但是，允许impure virtual函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑XYZ航空公司设计的飞机继承体系。该公司只有A型和B型两种飞机，两者都以相同方式飞行。因此XYZ设计出这样的继承体系： 1234567891011121314class Airport &#123;...&#125;; // 用以表现机场class Airplane&#123;public: virtual void fly(const Airport&amp; destination); ...&#125;;void Airplane::fly(const Airport&amp; destination) &#123; ... // 缺省代码, 将飞机飞至指定的目的地&#125;class ModelA: public Airplane &#123;...&#125;;class ModelB: public Airplane &#123;...&#125;; 为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的fly实现”，Airplane::fly被声明为virtual。然而为了避免在ModelA和ModelB中撰写相同代码，缺省飞行行为由Airplane::fly提供，它同时被ModelA和ModelB继承。 现在，XYZ航空公司决定购买一种新式C型飞机。C型和A型以及B型的飞行方式不同。XYZ公司的程序员在继承体系中针对C型飞机添加了一个class，但由于他们急着让新飞机上线服务，竟忘了重新定义其fly函数： 12345678910class ModelC : public Airplane&#123; // 未声明fly函数&#125;;Airport PDX(... ); // PDX 是我家附近的机场Airplane* pa= new ModelC;...// 这将酿成大灾难pa-&gt;fly(PDX); // 调用 Airplane::fly 一种解救办法为切断“virtual函数接口”和其“缺省实现”之间的连接。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Airplane&#123;public: // 现在是 pure virtual 函数 virtual void fly(const Airport&amp; destination) = 0;protected: void defaultFly (const Airport&amp; destination);&#125;;void Airplane::defaultFly(const Airport&amp; destination)&#123; ... // 缺省行为, 将飞机飞至指定的目的地。&#125;class ModelA : public Airplane &#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly(destination); &#125;&#125;;class ModelB : public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly (destination); &#125;&#125;;// 现在 ModelC class 不可能意外继承不正确的 fly 实现代码了// 因为 Airplane 中的 pure virtual 函数追使 ModelC 必须提供自己的 f1y 版本class ModelC: public Airplane&#123;public: virtual void fly(const Airport&amp; destination);&#125;;void ModelC::fly(const Airport&amp; destination)&#123; ... // 将 C 型飞机飞至指定的目的地&#125; 另一种解救方法是，利用“pure virtual函数必须在derived class中重新声明，但它们也可以拥有自己的实现”这一事实。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Airplane&#123;public: // 现在是 pure virtual 函数 virtual void fly(const Airport&amp; destination) = 0;&#125;;// 给予 pure virtual 函数实现void Airplane::fly(const Airport&amp; destination)&#123; ... // 缺省行为, 将飞机飞至指定的目的地&#125;class ModelA : public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; Airplane::fly(destination); // 通过指定其类名调用它 &#125; ...&#125;;class ModelB : public Airplane&#123;public: virtuai void fly(const Airport&amp; destination) &#123; Airplane::fly(destination); // 通过指定其类名调用它 &#125; ...&#125;;class ModelC : public Airplane&#123;public: virtual void fly(const Airport&amp; destination);&#125;;void ModelC::fly(const Airport&amp; destination)&#123; ... // 将 C 型飞机飞至指定的目的地&#125; 声明non-virtual函数的目的是为了derived class继承函数的接口及其强制性实现 non-virtual函数为其所属class建立的意义是不变性凌驾其特异性，所以它不该在derived class中被重新定义。 条款35：考虑virtual函数以外的其他选择假设你正在写一个视频游戏软件，你的游戏属于暴力砍杀类型，剧中人物存在被伤害而降低健康状态的情况。因此你决定提供一个成员函数 healthvalue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将healthvalue声明为virtual似乎是再明白不过的做法： 123456class GameCharacter&#123;public: virtual int healthvalue() const; // 返回人物的健康指数, // derived classes 可重新定义它&#125;; 现在考虑一些其它解法： 借助non-virtual interface(NVI)手法实现Template Method模式 保留healthvalue为public成员函数，但让它成为non-virtual，并调用一个private virtual函数进行实际工作： 123456789101112131415161718class GameCharacter&#123;public: int healthvalue() const // derived class 不重新定义它 &#123; ... // 做一些事前工作 int retval = doHealthvalue(); // 做真正的工作 ... // 做一些事后工作 return retval; &#125;// NVI 手法下没必要让 virtual 函数一定是 privateprivate: virtual int doHealthValue() const // derived class 可重新定义它 &#123; ... // 缺省算法, 计算健康指数。 &#125;&#125;; 这一基本设计，“令客户通过public non-virtual成员函数间接调用private virtual函数”，称为non-virtual interface(NVI)手法。它是所谓Template Method设计模式的一个独特表现形式。我把这个non-virtual函数（healthvalue）称为virtual函数的外覆器（wrapper) 。 NVI手法的一个优点隐藏在上述代码注释“做一些事前工作”和“做一些事后工作”之中。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证 class约束条件、验证函数先决条件等。“事后工作”可以包括互斥器解除锁定、验证函数的事后条件、再次验证class约束条件等。如果你让客户直接调用virtual函数，就没有任何好办法可以做这些事。 借助Function Pointer实现Strategy模式 另一个设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个函数指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算： 123456789101112131415161718192021class GameCharacter; // 前向声明// 以下函数是计算健康指数的缺省算法int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: typedef int (*HealthCalcFunc)(const GameCharacter&amp;); explicit GameCharacter (HealthCalcFunc hcf = defaultFealthCalc) : healthFunc(hcf) &#123;&#125; int healthvalue() const &#123; return healthFunc (*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 这种设计策略和前面介绍的方法相比提供了一些有趣的弹性： 同一人物类型的不同实体可以有不同的健康计算函数 123456789101112class EvilBadGuy : public GameCharacter&#123;public: explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc) : GameCharacter(hcf) &#123;...&#125; ...&#125;;int loseHealthQuickly(const GameCharacter&amp;); // 健康指数计算函数 1int loseHealthSlowly(const GameCharacter&amp;); // 健康指数计算函数 2EvilBadGuy ebg1(loseHealthQuickly); // 相同类型的人物搭配EvilBadGuy ebg2(loseHealthSlowly); // 不同的健康计算方式 某已知人物之健康指数计算函数可在运行期变更 例如GameCharacter可提供一个成员函数setHealthcalculator，用来替换当前的健康指数计算函数。 然而这种策略意味着，计算函数并不能访问“被计算健康指数的”那个对象的内部（non-public）成分。如果需要访问non-public成分进行精确计算，这就有问题了。 唯一能够解决的办法就是：弱化class的封装。例如，将健康计算函数声明为friend。或是为其实现的某一部分提供public访问函数。这需要你来权衡利弊进行抉择。 借助std::function实现Strategy模式 123456789101112131415161718192021class GameCharacter;int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: // 不同之处 typedef std::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc; explicit GameCharacter (HealthCalcFunc hcf = defaultFealthCalc) : healthFunc(hcf) &#123;&#125; int healthvalue() const &#123; return healthFunc (*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 那个签名代表的函数是“接受一个reference指向const GameCharacter，并返回int”。这个std::function类型（也就是我们所定义的HealthCalcFunc类型）产生的对象可以持有（保存）任何与此签名式兼容的可调用物。所谓兼容，意思是这个可调用物的参数可被隐式转换为const GameCharacter&amp;，而其返回类型可被隐式转换为int。 这就提供了很大的灵活性： 1234567891011121314151617181920212223242526272829303132333435363738short calcHealth(const GameCharacter&amp;); // 健康计算函数 // 注意其返回类型为 non-intstruct HealthCalculator&#123; // 为计算健康而设计的函数对象 int operator()(const GameCharacter&amp;) const &#123;...&#125;&#125;;class GameLevel&#123;public: float health(const GameCharacter&amp;) const; // 成员函数, 用以计算健康 // 注意其 non-int 返回类型&#125;;// 人物类型 1class EvilBadGuy: public GameCharacter&#123; ... // 同前&#125;;// 人物类型 2class EyeCandyCharacter: public GameCharacter&#123; // 假设其构造函数与 EvilBadGuy 同&#125;;// 人物 1, 使用某个函数计算健康指数EvilBadGuy ebg1(calcHealth);// 人物 2, 使用某个函数对象计算健康指数EyeCandyCharacter ecc1(HealthCalculator());GameLevel currentLevel;...// 人物 3, 使用某个成员函数计算健康指数EvilBadGuy ebg2(std::bind(&amp;GameLevel::health, &amp;currentLevel, _1)); 传统的Strategy模式 123456789101112131415161718192021222324252627282930313233343536373839404142class GameCharacter;class HealthCalcFunc&#123;public: virtual ~HealthCalcFunc() &#123;&#125; virtual int calc(const GameCharacter&amp; gc) const = 0;&#125;;class SlowHealthLoser : HealthCalcFunc&#123;public: virtual int calc(const GameCharacter&amp; gc) const &#123; ... &#125; ...&#125;;class FastHealthLoser : HealthCalcFunc&#123;public: virtual int calc(const GameCharacter&amp; gc) const &#123; ... &#125; ...&#125;;class GameCharacter&#123;public: explicit GameCharacter(HealthCalcFunc* phcf) : pHealthCalc(phcf) &#123;&#125; int healthValue() const &#123; return pHealthCalc-&gt;calc(*this); &#125;private: HealthCalcFunc* pHealthCalc;&#125;; 条款36：绝不重新定义继承而来的non-virtual函数 如题 条款37：绝不重新定义继承而来的缺省参数值本条款的讨论局限于“继承一个带有缺省参数值的virtual函数”：virtual函数是动态绑定（后期绑定，延迟绑定），而缺省参数值却是静态绑定（前期绑定，早绑定）。 123456789101112131415161718192021222324252627// 一个用以描述几何形状的classclass Shape&#123;public: enum ShapeColor&#123;Red, Green, Blue&#125;; // 所有形状都必须提供一个函数, 用来绘出自己 virtual void draw(ShapeColor color = Red) const = 0; ...&#125;;class Rectangle : public Shape &#123;public: // 注意, 赋予不同的缺省参数值, 这真糟糕! virtual void draw(ShapeColor color = Green) const; ...&#125;;class Circle : public shape&#123;public: virtual void draw(ShapeColor color) const; // 请注意，以上这么写则当客户以 对象 调用此函数一定要指定参数值 // 因为静态绑定下这个函数并不从其 base 继承缺省参数值 // 但若以指针或 reference 调用此函数, 可以不指定参数值 // 因为动态绑定下这个函数会从其 base 继承缺省参数值&#125;; 对象的静态类型就是它在程序中所声明的类型，对象的动态类型则是指“目前所指对象的类型” 123shape* ps; // 静态类型为 shape*, 无动态类型Shape* pc = new Circle; // 静态类型为 Shape*, 动态类型是 Circle*Shape* pr = new Rectangle; // 静态类型为 shape*, 动态类型是 Rectangle* 动态类型可在程序执行过程中改变（通常是经由赋值动作）： 12ps = pc; // ps 的动态类型如今是 circle*ps = pr; // ps 的动态类型如今是 Rectangle* virtual函数系动态绑定而来，意思是调用一个virtual函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。 12pr-&gt;draw(); // 调用的是 Rectangle::draw(shape::Red)! // 注意缺省参数是 Red 而不是 Green 此例之中，pr的动态类型是Rectangle*，所以调用的是Rectangle的virtual函数。Rectangle::draw函数的缺省参数值应该是Green，但由于pr的静态类型是shape*，所以此一调用的缺省参数值来自Shape class而非Rectangle class！这不符合预期。 解救方法是利用条款35中介绍的NVI手法替代virtual函数： 123456789101112131415161718192021class Shape&#123;public: enum shapeColor&#123;Red, Green, Blue&#125;; void draw(ShapeColor color = Red) const // 如今它是 non-virtual &#123; doDraw(color); // 调用一个 virtual &#125;private: virtual void doDraw(shapeColor color) const = 0; // 真正的工作在此处完成&#125;;class Rectangle : public Shape&#123;public: ...private: virtual void doDraw (ShapeColor color) const; // 注意, 不须指定缺省参数值 ...&#125;; 这个设计很清楚地使得draw函数的color缺省参数值总是Red。 条款38：通过复合塑模出has-a或is-implemented-in-terms-of当某种类型的对象内含其它对象时便形成了复合关系。 应用域 程序中的对象其实相当于你所塑造出来的世界中的某些事物。比如人，汽车，高楼大厦等。这样的对象属于应用域部分。 实现域 其它对象如缓冲区，互斥器，搜索树等纯粹是实现细节上的工具。这些对象相当于软件中的实现域。 当复合发生于应用域对象之间表现出has-a关系，当它发生于实现域内则表现出is-implemented-in-terms-of（根据某物实现出）的关系。 复合的意义和public继承完全不同 注意区分is-a和is-implemented-in-terms-of这两种对象关系。 条款39：明智而谨慎地使用private继承一个derived类继承base类有public、protected或private三种继承方式。 公有继承（public）（普遍使用） base类的public成员也是derived类的public成员，base类的protected成员也是derived类的protected成员 保护继承（protected）（基本不使用） base类的public和protected成员将成为derived类的protected成员。 私有继承（private）（少的情况使用） base类的public和protected成员将成为derived类的private成员。 无论哪一种继承方式，base类的private成员都不能直接被derived类访问，但是可以通过调用base类的public和protected成员间接来访问（如果base类提供了访问接口的话）。 private继承意味着is-implemented-in-terms-of private继承只限于软件实现层面，这就是为什么private继承后，base class的所有成分（除了private）在你的class内都是private，因为它们都只是实现细节而已。 尽可能使用复合，必要时才使用private继承 当derived类想要访问base class的protected成员时 当derived类为了重新定义base class的virtual函数时 现在考虑一个Widget类，它需要用到另一个计时器Timer类来实现一些业务。 123456 class Timer&#123;public: explicit Timer(int tickFrequecy); virtual void onTick() const; // 定时器每滴答一次, 此函数就调用一次&#125;； 为了让Widget重新定义Timer内的virtual函数，Widget必须继承自Timer。因为Widget不是个Timer，因此public继承不合适。必须以private方式继承： 123456class Widget&#123; ...private: virtual void onTick() const; // &#125;; 通过private继承，Timer的public onTick函数在Widget内变成private，而我们重新声明（定义）时仍然把它留在那儿。如果把onTick放进public内会误导客户以为他们可以调用它，那就违反了条款18。 另一种设计方案是采用复合 + public继承： 123456789101112131415class Widget&#123; ...private: // 在 Widget 内声明一个嵌套式 private class class WidgetTimer : public Timer &#123; public: // 以 public 方式继承并重新定义 virtual 函数 virtual void onTick() const; ... &#125;; WidgetTimer timer; ...&#125;; 采用第二种较为复杂的方式的两点理由： 你或许会想设计Widget使它得以拥有derived class，但同时你可能会想阻止derived class重新定义onTick。如果Widget继承自Timer，上面的想法就不可能实现，即使是private继承也不可能。但如果WidgetTimer是Widget内部的一个private成员并继承自Timer，Widget的derived class将无法取用WidgetTimer，因此无法继承它或重新定义它的virtual函数。 你或许会想要将Widget的编译依存性降至最低（条款31）。如果Widget继承Timer，当Widget被编译时Timer的定义必须可见，所以定义Widget的那个文件恐怕必须#include Timer.h。但如果WidgetTimer移出Widget所在文件之外而Widget内含指针指向一个WidgetTimer，Widget可以只带着一个简单的WidgetTimer前向声明式，不再需要#include任何与Timer有关的东西。很容易就实现了解耦。 EBO（empty base optimization） empty class指的是没有non-static成员变量，没有virtual函数，也没有virtual base class。于是这种class不占用理论上不占用任何内存空间。然而在实现技术上，C++要求独立（非附属）对象都必须有非零大小。 12345678910class Empty &#123; &#125;; // 没有任何需要存储的数据// 理论上 sizeof(HoldAnInt) = 4 字节(就一个 int)// 实际上 sizeof(HoldAnInt) = 8 字节class HoldAnInt&#123;private: int x; // 4 字节 Empty e; // 理论上应该不占据内存&#125;; C++编译器默认为empty class独立对象安插一个char（1字节） 由于内存对齐HoldAnInt的实际大小为4 + 1(内存对齐至 4) = 8 但这个约束不适用于derived class对象的base class成分（非独立）： 123456// 理论和实际上 sizeof(HoldAnInt) = 4 字节(就一个 int)class HoldAnInt : public Empty&#123;private: int x; // 4 字节&#125;; 现实中的empty class并非真是empty。往往内含typedef，enum，static成员变量，或non-virtual函数。STL就有许多技术用途的empty class，其中内含有用的成员（通常是typedef），包括base class unary_function和binary_function，这些是“用户自定义之函数对象”通常会继承的class。由于EBO，这样的继承很少增加derived class的大小。 条款40：明智而谨慎地使用多重继承 多重继承较单一继承复杂，可能导致歧义性 当继承的多个base具有同名成员函数时，derived类调用时会出现歧义。 有时多重继承不得不需要virtual继承，而这会带来额外的体积、运行速度、初始化复杂度等成本 比如这样的钻石继承体系： 这个继承体系中某个base class和某个derived class之间有一条以上的相通路线，假设File class有个成员变量fileName，那么IOFile从每一个base class各继承一份，所以其对象内会有两份fileName成员变量。然而IOFile对象只该有一个文件名称，所以名称fileName不该重复。 解决办法就是采用virtual继承： virtual继承带来的后果是： 使用virtual继承的那些class所产生的对象往往比使用non-virtual继承的class体积大 访问virtual base class的成员变量时，也比访问non-virtual base class的成员变量速度慢 另外，支配“virtual base class初始化”的规则比起non-virtual base class的情况远为复杂且不直观。virtual base class的初始化责任是由继承体系中的最低层（most derived）class负责的，这意味着： class若派生自virtual base而需要初始化，必须知道其virtual base class——不论那些base class距离多远。 当一个新的derived class加入继承体系中，它必须承担其virtual base class的初始化责任。 关于virtual继承的忠告： 非必要不使用virtual base。平常请使用non-virtual继承。 如果必须使用virtual base class，尽可能避免在其中放置数据。这么一来你就不需担心这些class身上的初始化（和赋值）所带来的诡异事情了。 最后看一个多重继承的应用例子——public继承某个Interface class和private继承某个协助实现的class。 （参考书籍P195-P198）","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"数据结构与算法之概论","date":"2020-04-04T05:54:42.000Z","path":"eSK55yN7G7dNea2c/","text":"数据结构相互之间存在一种或多种特定关系的数据元素的集合。研究数据结构，关心的是数据对象的描述以及相关操作函数的实现。 数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如整型、浮点型等数值类型，以及声音、图像等非数值类型。 数据元素是组成数据的、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。 数据项一个数据元素可以由若干个数据项组成。它是数据不可分割的最小单位。 数据对象是性质相同的数据元素（即有相同的数量和类型的数据项）的集合，是数据的子集。 常见的数据结构 线性数据结构：向量vector（顺序存储）、链表list（链式存储）、栈stack和队列queue（优先队列）。 半线性数据结构：二叉树、搜索树（二叉搜索树BST、AVL树、B树、红黑树）、竞赛树等。 非线性数据结构：图。 哈希表hashtable、字典dictionary。 抽象数据类型 数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 抽象数据类型：指一个数学模型及定义在该模型上的一组操作。可以理解为C++中的类class。它体现的是程序设计中问题分解、抽象和信息隐藏的特性。 抽象数据类型的标准格式12345678ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义Operation 操作1 操作2 ...endADT 算法算法是解决指定问题求解步骤的描述。在计算机中是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。 计算或信息处理指借助某种工具，按照一定的规则，以明确而机械的形式进行。 算法中的计算模型就是计算机，即信息处理工具。 算法必须具备的几大要素 输入：待处理的信息或问题。 输出：经处理的信息，即答案。 正确性：的确可以解决指定的问题。 确定性：任何一个算法都可以描述为一个由基本操作组成的序列。 可行性：每一基本操作都可实现，且能在常数时间内完成。 有穷性：对于任何输入，经有限次的基本操作，都可以得到输出。 一个好的算法 正确，即符合语法，能够编译、链接。 能够正确处理简单的、大规模的、一般性的、退化的、任意合法的输入。 健壮，能够辨别不合法的输入并做适当处理，而不致非正常退出。 可读，结构化 + 准确命名 + 注释 + …。 效率，运行速度尽可能快，用到的存储空间尽可能少。 常见的算法 查找 顺序查找、二分查找、插值查找、斐波那契查找、分块查找和哈希查找等。 排序 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序和希尔排序等。 递归、分而治之、动态规划、回溯法和分支定界法等。 要对数据结构和算法设计方法给予评价，就必须能够计算程序性能。 数据结构和算法的关系 数据结构(data structures) + 算法(algorithms) = 程序(programs) (data structures + algorithms) x efficiency = computation 程序性能分析是指分析一个程序对于内存空间和运行时间的需求。 空间复杂度指程序运行时临时占用内存的大小。广义上的概念是包括存储算法本身所占用的空间、算法的输入输出数据所占用的空间以及算法在运行过程中临时占用的存储空间这三个方面。 时间复杂度指运行程序所需要的时间。这里度量的是程序中基本操作执行的次数，它是问题规模n的函数f(n)。记T(n)=O(f(n))，它表示随问题规模n的增大，算法执行时间的增长率和f(n)相同，称作算法的渐进时间复杂度。 复杂度分析这里的复杂度分析通常指的是最坏时间复杂度分析。 常数阶O(1) 取前三个元素x = S[0]、y = S[1]和z = S[2]，这一步只需执行三次（从特定单元读取元素的）基本操作，耗费O(3)时间。接下来，为确定这三个元素的大小次序，最多需要做三次比较，也需O(3)时间。最后，输出居中的非极端元素只需O(1)时间。因此，上面取非极端元素算法的时间复杂度为：T(n) = O(3) + O(3) + O(1) = O(7) = O(1)。 对数阶O(logn) 根据右移运算的性质，每右移一位，n都至少缩减一半。也就是说，至多经过1 + log2n次循环，n必然缩减至0，从而算法终止。因此时间复杂度为：O(1 + log2n) = O(log2n) 。 线性阶O(n) 平方阶O(n) 时间复杂度为：O(2n^2 + n + 1) = O(n^2)。 常见的算法时间复杂度排序Ο(1) ＜ Ο(logn) ＜ Ο(n) ＜ Ο(nlogn) ＜ Ο(n^2) ＜ … ＜ Ο(2^n) ＜ Ο(n!)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Effective C++之实现","date":"2020-04-01T13:35:42.000Z","path":"hNsvEFKo8ZJPUeMf/","text":"第5章：实现条款26：尽可能延后变量定义式的出现时间 应该延长变量的定义，直到非得使用它时 应该延后这份定义，直到能够给它初值实参 对于循环存在的情况： 做法A：定义于循环外 123456Widget w;for(int i = 0; i &lt; n; i++)&#123; w = 取决于 i 的某个值； ...&#125; 做法B：定义于循环内 12345for(int i = 0; i &lt; n; i++)&#123; Widget w(取决于 i 的某个值); ...&#125; 这两种写法的成本如下： 做法A：1个构造函数 + 1个析构函数 + n个赋值操作 做法B：n个构造函数 + n个析构函数 做法A会造成名称w的作用域比做法B更大 除非（1）你知道赋值成本比构造 + 析构成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法B。 条款27：尽量少做转型操作旧式C转型： T(expression) (T)expression 新式C++转型： const_cast&lt;T&gt;(expression) 用来将对象的常量性（const）转除（只有它能办到）。 dynamic_cast&lt;T&gt;(expression) 用来执行安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型。 reinterpret_cast&lt;T&gt;(expression) 用来执行低级转型，如将一个pointer to int 转为一个int。很少使用（在条款50中使用过一次）。 static_cast&lt;T&gt;(expression) 用来强迫隐式转换，例如将non-const对象转为const对象，将int转为double，将void*指针转为typed指针，或将pointer to base转为pointer to derived。 任何一种类型转换（无论显式转换还是隐式转换）往往都会令编译器编译出运行期间执行的码。如将int转为double会产生一些代码，因为int的底层表述不同于double的： 123int x, y;...double z = static_cast&lt;double&gt;(x) / y; 再比如： 1234class Base &#123;...&#125;;class Derived: public Base &#123;...&#125;;Derived d;Base* pb = &amp;d; // 隐喻的将 Derived* 转换为 Base* 这种情况下有时候会有一个偏移量在运行期被施行于Derived*身上，用来取得正确的Base*指针值。这个例子表明单一对象可能有一个以上的地址（以Base*指向它时的地址和以Derived*指向它时的地址）。 假设我们有个base class Window和一个derived class Specialwindow，两者都定义了virtual函数onResize。进一步假设Specialwindow的onResize函数被要求首先调用Window的onResize。下面实际上是错的实现方式： 12345678910111213141516171819202122class Window&#123;public: ... virtual void onResize () &#123;...&#125; // base onResize实现代码 ...&#125;;class Specialwindow: public Window&#123;public: ... // derived onResize 实现代码 virtual void onResize() &#123; static_cast&lt;Window&gt;(*this).onResize(); // 将 *this 转型为 Window, // 然后调用其 onResize; // 这不可行! ... // 这里进行 Specialwindow 专属行为 &#125; ...&#125;; 它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“*this对象之base class成分”的暂时副本身上的onResize！如果Window::onResize修改了对象内容，当前对象其实没被改动，改动的是副本。然而SpecialWindow::onResize内如果也修改对象，当前对象真的会被改动。这使当前对象进入一种“伤残”状态：其base class成分的更改没有落实，而derived class成分的更改倒是落实了。 正确的做法是： 1234567891011class Specialwindow: public Window&#123;public: ... virtual void onResize() &#123; Window::onResize(); // 调用 Window::onResize 作用于 *this 身上 ... &#125; ...&#125;; dynamic_cast的实现版本执行速度相当慢，应该在注重效率的代码中保持对dynamic_cast的警觉 优良的C++代码很少使用转型，我们应该尽可能隔离转型动作，通过将它隐藏在某个函数内，使得客户可以调用该函数而不需要将转型放进他们自己代码内 宁可使用新式转型，也不要使用旧式转型，前者很容易辨识出来 条款28：避免返回handles指向对象内部成分 handles指指针、引用和迭代器 成员变量的封装性最多只等于“返回其reference”的函数的访问级别 如果const成员函数不得不传出去一个reference，则最好将返回类型限定为const 有可能会导致空悬的handles，它的生命期却长于其所指对象 条款29：为“异常安全”而努力是值得的当异常被抛出时，带有异常安全性的函数会： 不泄露任何资源 不允许数据败坏 较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也少。异常安全码必须提供以下三个保证之一： 基本承诺 如果异常被抛出，程序内的任何事物仍然保证在有效状态（只要那是个合法状态）下，没有任何对象或数据结构会因此而败坏，所有对象处于一种内部前后一致的状态。 强烈保证 如果异常被抛出，程序状态不改变。 不抛掷保证 承诺绝不抛出异常，因为它们总能完成原先承诺的功能。 可以实现强烈保证的copy and swap技术：为你打算修改的对象做出copy一份副本，然后在副本身上做一切修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。带所有改变都成功后，再将修改后的副本和原对象swap。 1234567891011121314151617181920212223242526272829// 之所以实现为 struct 是因为其 PrettyMenu 的数据封装性// 已经由 pImpl 是 private 获得了保证class Image &#123;...&#125;;struct PMImpl&#123; std::shared_ptr&lt;Image&gt; bgImage; int imageChanges;&#125;;class PrettyMenu&#123; ...private: Mutex mutex; std::shared_ptr&lt;PMImpl&gt; pImpl; // pimpl idiom 详细描述见条款 31&#125;;void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123; using std::swap; // 见条款25 Lock ml(&amp;mutex); // 获得mutex的副本数据 std::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl)); pNew-&gt;bgImage.reset(new Image(imgSrc)); // 修改副本 ++pNew-&gt;imageChanges; swap(pImpl, pNew); // 置换(swap)数据, 释放 mutex) 注意，并非所有函数都可实现强烈保证或其具备现实意义。 函数提供的”异常安全保证“通常最高只等于其所调用各个函数提供的”异常安全保证“中的最弱者。 条款30：透彻了解inlining的里里外外inline函数是指将对此函数的每一个调用都以函数本体替换之。这将导致两种情况： 目标码增加（显然） 如果inline函数的体积很小，编译器对“函数本体”所产出的码可能比“函数调用”所产出的码小 inline只是对编译器的一个申请，不是强制命令，也就是说编译器可以拒绝将太过复杂（带有递归或循环）的函数进行inline。通过对函数使用inline关键字属于明确提出申请，将函数定义于类内属于隐喻申请。 将大多数inline限制在小型、被频繁调用的函数身上 inline函数通常一定被置于头文件内 因为大多数构建环境在编译过程中进行inlining，而为了将一个函数调用替换为被调用函数的本体，编译器必须知道那个函数长什么样子。 所有对virtual函数的inline申请都会被拒绝（因为对virtual函数的调用在运行期才确定） 条款31：将文件间的编译依存关系降至最低 将接口从实现中分离 12345678910111213class Person&#123;public: Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); string name() const; string birthDate() const; string address() const; ...private: string theName; // 实现细目 Date theBirthDate; // 实现细目 Address theAddress; // 实现细目&#125;; 这里的class无法通过编译，因为编译器没有取得其实现代码所用到的class string，Date，Address的定义式，通常应该在Person定义文件的最上方存在include头文件。 123#include &lt;string&gt;#include \"date.h\"#include \"address.h\" 不幸的是，这么一来便是在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其他头文件有任何改变，那么每一个含入Person class的文件就得重新编译，任何使用person class的文件也必须重新编译。这样的连串编译依存关系（cascading compilation dependencies）会对许多项目造成难以形容的灾难。 Handle classes：pimpl idiom(pointer to implenmentation) + 前向声明 把Person分割成两个class，一个只提供接口，另一个负责实现接口。 1234567891011121314151617181920212223242526272829#include &lt;string&gt; //标准程序库组件不该被前向声明#include &lt;memory&gt;// 使用前向声明而不是包含头文件, 这个很关键class PersonImpl; // Person 实现类// Person 接口用到的 classclass Date; class Address;class Person&#123;public: Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); string name() const; string birthDate() const; string address() const; ...private: shared_ptr&lt;PersonImpl&gt; pImpl; // 指针, 指向实现物 // 如果不这样做的话, 编译器在编译 Person 类的时候，必须知道 Person 类的大小 // 就不得不包含这三个实现细目 /* string theName; // 实现细目 Date theBirthDate; // 实现细目 Address theAddress; // 实现细目 */ // 然而一旦这样写, 前面的前向声明就没用了, 必须包含头文件&#125;; 这样一来，Person类的使用者就完全于Date，Address以及Person的实现细目相分离了。这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：实现上让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。 几个简单的设计策略： 如果使用object reference或object pointer可以完成任务，就不要使用object 你可以只靠一个类型声明式就定义出指向该类型的reference和pointer；但如果定义某类型的object，就需要用到该类型的定义式。 如果能够，尽量以class声明式替换class定义式 注意，当你声明一个函数而它用到某个class时，你并不需要该class的定义。 为声明式和定义式提供不同的头文件 对于前面代码中的前向声明，最好是提供一个声明式头文件，包含全部的前向声明。 下面式Person.cpp文件的部分实现： 12345678910#include &lt;Person.h&gt;#include &lt;PersonImpl.h&gt; // 注意，Person 和PersonImpl的成员函数完全相同, 两者接口完全相同Person::Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr) : pImpl(new PersonImpl(name, birthday,addr)) &#123;&#125;string Person::narne( ) const &#123;return pImpl-&gt;name();&#125;... Interface classes：abstract base class + factory函数 abstract base class通常没有成员变量，也没有构造函数，只有一个virtual析构函数和一组pure virtual函数。但Interface class的客户必须有办法为这种class创建新对象。他们通常调用一个特殊函数，此函数创建实际实现的derived class，这样的函数通常称为factory(工厂）函数（见条款13），它们返回智能指针指向动态分配所得对象，而该对象支持Interface class的接口。这样的函数又往往在Interface class内被声明为static： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 位于 Person.h// 抽象基类, 只有声明// 提供给客户使用的头文件class Person&#123;public: virtual ~Person(); virtual strng name() const = 0; virtual strng birthDate() const = 0; virtual string address() const = 0; // static 的 factory 函数 static shared_ptr&lt;Person&gt; create(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); ...&#125;// 位于 Person.cpp#include \"Person.h\"class RealPerson: public Person&#123;public: RealPerson(const string&amp; name, const Date&amp; birthday, const Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125; virtual ~RealPerson() &#123;&#125; string name() const; string birthDate() const; string address() const;private: string theName; Date theBirthDate; Address theAddress;&#125;;... // 虚函数的实现码shared_ptr&lt;Person&gt; Person::create(const string&amp; name, const Date&amp; birthday, const Address&amp; addr)&#123; return shared_ptr&lt;Person&gt;(new RealPerson(name, birthday, addr));&#125; Handle classes和Interface classes解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之设计与声明","date":"2020-03-21T13:35:42.000Z","path":"S0Qfg61EKNlwLo15/","text":"第4章：设计与声明条款18：让接口容易被正确使用，不容易被误用 如果客户企图使用某个接口却没有获得所预期的行为，这个代码不应该通过编译；如果代码通过了编译，则它的行为就应该是客户想要的 欲达“让接口容易被正确使用，不容易被误用”的目的，必须考虑客户调用接口时可能做出什么样的错误 “促进正确使用”的办法包括接口的一致性，以及与内置类型兼容 “阻止误用”的办法包括建立新类型、限制在类型上的操作，束缚对象值以及消除客户的资源管理责任 条款19：设计class犹如设计type你应该带着“语言设计者当初设计语言内置类型时”一样的谨慎来研讨每一个class的设计。因为，重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结…全都在你手上。 新的type的对象应该如何创建和销毁？ 设计函数为类的构造函数和析构函数以及内存分配函数和释放函数（见条款49-52）。 对象的初始化和对象的赋值该有什么样的差别？ 决定了构造函数和赋值操作符的行为以及差异。 新type的对象被passed by value，意味着什么？ 取决于copy构造函数的实现。 什么新type的合法值？ 你的新type需要配合某个继承图系吗？ 见条款7、34、36。 你的新type需要什么样的转换？ explicit和operator关键字的使用。见条款15。 什么样的操作符和函数对此新type而言时合理的？ 见条款23、24、46。 什么样的标准函数应该驳回？ 见条款6。 谁该取用新type的成员？ 决定了数据成员是public、private还是protected，以及friend关键的使用。 什么是新type的“未声明接口”？ 见条款29。 你的新type有多么一般化？ 决定class template的使用。 你真的需要一个新type吗？ 条款20：宁以pass by reference to const替换pass by value 当把具有继承关系的类作为参数传递时，如果pass by value可能会出现“截断”问题。 条款21：必须返回对象时，别妄想返回其reference 绝不要返回指向一个local stack对象的pointer或reference 绝不要返回指向一个heap allocated对象的reference 除非有单例模式的设计要求，否则绝对不要返回指向一个local static对象的pointer或reference 条款22：将成员变量声明为private 客户访问数据的一致性 public里都是函数。 可以对成员变量有更精确的控制 可以实现成员变量的不可访问，只读、只写、读写访问。 封装性 将成员变量隐藏在函数接口背后，可以为所有可能的实现提供弹性。 从封装的角度看，只有两种权限：private（提供封装）和其它 protected并不比private更具封装性。 条款23：宁以non-member、non-friend替换member函数考虑一个用来表示网页浏览器的class，这个class提供的众多成员函数中，有用来清除下载元素高速缓冲区的，有用来清除访问过的历史记录的，有用来移除系统中所有cookies的。 12345678910111213141516171819202122232425262728class WebBrowser&#123;public: ... void clearCache(); void clearHistory(); void cleatCookies(); ...&#125;;// 客户想一整个执行所有的操作// 以提供一个 member 函数的方式class WebBrowser&#123;public: ... void clearEverthing(); ...&#125;;// 以提供一个 non-member 函数的方式void clearBrowser(WebBrowser&amp; wb)&#123; wb.clearCache(); wb.clearHistory(); wb.cleatCookies();&#125; 后者比较好。因为： 增加封装性 non-member non-friend将提供较大的封装性，因为它并不增加能够访问class内的private成分的函数数量。friend函数对class private成员的访问权力和member函数相同，两者对封装的冲击力度是一样的。 增加扩充机能性 在C++中，正确且自然的做法是： 123456namespace WebBrowserStuff&#123; class WebBrowser &#123;...&#125;; void clearBrowser(WebBrowser&amp; wb); // 为 WebBrowser “提供便利”的函数 ...&#125; namespace和class的不同是，前者可跨越多个源码文件而后者不能。 像WebBrowser这样的类可能有大量的“提供便利”函数，某些与书签有关，与打印有关，与cookie有关… 分离它们最直接的做法就是： 123456789101112131415161718// 头文件 WebBrowser.h 内namespace WebBrowserStuff&#123; class WebBrowser &#123;...&#125;; ... // 核心机能, 例如所有客户都想要的 non-member 函数&#125;// 头文件 WebBrowserBookmarks.h 内namespace WebBrowserStuff&#123; ... // 与书签相关的 non-member 函数&#125;// 头文件 WebBrowserCookies.h 内namespace WebBrowserStuff&#123; ... // 与 cookie 相关的 non-member 函数&#125; 将所有“便利函数”放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组“便利函数”。 条款24：若所有参数皆需类型转换，请为此采用non-member函数 有理数类Rational的实现 重点关注用来将两个有理数相乘的operator*操作符重载函数的实现方式。 条款25：考虑写出一个不抛异常的swap函数标准程序库提供的swap算法的典型实现为： 12345678910namespace std&#123; template&lt;typename T&gt; void swap(T&amp; a, T&amp; b) &#123; T temp(a); a = b; b = temp; &#125;&#125; 只要T类型支持copying函数（copy构造函数和copy assignment操作符）。对于用户自定义类型，效率低下（需要三次复制）。 现在考虑所谓的pimpl(pointer to implementation)实现手法： 1234567891011121314151617181920212223242526// 注意这是个模板类template&lt;typename T&gt;class WidgetImpl&#123;public: ... // 细节不重要private: ... // 有很多数据, 意味着复制时间很长&#125;;// 注意这是个模板类template&lt;typename T&gt;class Widget&#123;public: Widget(const Widget&lt;T&gt;&amp; rhs); // 关于 operator= 的一般性实现参考条款 10, 11, 12 Widget&amp; operator=(const Widget&lt;T&gt;&amp; rhs) &#123; ... *pImpl = *(rhs.pImpl); ... &#125;private: WidgetImpl&lt;T&gt;* pImpl; // 指向实际实现的对象&#125;; 一旦需要置换两个Widget对象值，我们实际唯一需要的是置换两个指针即可。但缺省的swap函数不知道这一点！ 下面是正确的实现步骤： 令Widget实现一个名为swap的public成员函数做真正的置换工作 123456789101112template&lt;typename T&gt;class Widget&#123;public: ... void swap(Widget&lt;T&gt;&amp; other) &#123; using std::swap; // 必须的 swap(pImpl, other.pImpl); // 直接置换指针即可 &#125; ...&#125; 将std::swap特化，令它调用该成员函数（当Widget是类时。这里的例子中，Widget是个模板类则不要这一步） 因为，C++只允许对class template偏特化，不允许对function template进行偏特化 12345678namespace std&#123; template&lt;&gt; void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; a.swap(); &#125;&#125; 声明一个non-member swap，令它调用member swap 123456// 注意, 要将它放在和 Widget&lt;T&gt; 同一个空间内(全局或者自定义的 namespace)template&lt;typename T&gt;void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)&#123; a.swap(b);&#125; 编程时，在调用swap置换对象的语句之前加上using std::swap声明 123456789// 客户代码template&lt;typename T&gt;void doSomething(T&amp; obj1. T&amp; obj2)&#123; using std::swap; // 令 std::swap 在此函数内可用 ... swap(obj1, obj2); // 这样一来, 编译器将为 T 类型对象调用最佳版本 swap ...&#125; 编译器首先在全局作用域或T所在命名空间内寻找T（在这里，T就是例子中的Widget哦）专属的swap（也就是步骤3中实现的）。如果没有实现这些，则调用std内的swap，如果步骤2还实现了特化版本，将会选中特化版本。 劝告，member swap绝不可抛出异常 具体参考条款29。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之资源管理","date":"2020-03-15T13:35:42.000Z","path":"ojSMOM86r5rbvAqL/","text":"第3章：资源管理条款13：以对象管理资源 RAII(Resource Acquisition Is Initialization) 使用new获取资源后于同一条语句内以它初始化某个资源管理对象。利用当管理对象离开作用域被销毁时自动调用其析构函数的机制确保资源被释放。不直接用new和delete，多用智能指针。 智能指针在其析构函数中做delete动作而非delete[]动作 因此，不要在动态分配来的数组身上使用智能指针（虽然它仍然会通过编译）。 条款14：在资源管理类中小心copying行为 当不想RAII类被复制时可以继承Uncopyable类 将智能指针施于heap-based资源身上是个好主意，但并不是所有资源都是heap-based的，比如互斥器mutex，mutex就不可复制。 条款15：在资源管理类中提供对原始资源的访问 显示转换（安全） 例如，shared_ptr类就提供可一个get成员函数来返回智能指针内部的原始指针。 operator隐式转换（调用方便） 123456789101112131415161718class A&#123; ... // operator 可以实现隐式转换函数 operator B() const &#123; return b; &#125; ...private: B b; // B 类型对象成员&#125;;// 接受 B 类型对象的一个函数void func(B b);A a;func(a); // a 会被编译器隐式转换为 B 类型对象 条款16：使用new和delete时要采用相同的形式 编译器在给数组分配内存时，会包括数组大小的记录 这样的好处是，delete[]时知道需要调用多少次析构函数。 不要对数组形式进行typedef动作 条款17：以独立语句将new来的对象置入智能指针考虑这样两个函数： 12int priority(); // 调用这个函数不排除会发生异常void processWidget(shared_ptr&lt;Widget&gt; pw, int priority); 如果这样调用编译不通过，因为shared_ptr接收原始指针的构造函数是explicit的： 1processWidget(new Widget, priority()); 如果这样调用可能会造成内存泄漏： 1processWidget(shared_ptr&lt;Widget&gt;(new Widget), priority()); 因为编译器在编译这条语句时，实际上会创建三个动作： 调用priority() 执行new Widget 调用shared_ptr的构造函数 而C++编译器安排这三个动作的次序是不确定的。 如果执行次序是这样： 执行new Widget 调用priority() 调用shared_ptr的构造函数 一旦中途priority()导致异常，那么new返回的原始指针并未交给智能指针保管，将造成资源泄露。 正确的做法： 12shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority()); 因为，编译器对“跨越语句的各项操作”没有重新排列执行次序的自由。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之构造、析构、赋值运算","date":"2020-03-08T13:35:42.000Z","path":"MeCvwFxjI4asjddf/","text":"第2章：构造、析构、赋值运算条款05：了解C++默默编写并调用哪些函数 编译器会暗自为class创建default构造函数、copy构造函数、copy assignment操作符以及析构函数 对于class内含reference成员或const成员，编译器拒绝为其生成copy构造函数和copy assignment操作符 因为C++不允许reference改指向不同的对象以及更改const成员。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝 为驳回编译器自动提供的函数，可将相应的成员函数声明为private并且不予实现。 掌握Uncopyable类的实现机制 将构造函数和析构函数设置为protected的 将拷贝构造函数和拷贝赋值运算符设置为private的 12345678910class Uncopyable&#123;protected: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable &amp;); const Uncopyable &amp;operator=(const Uncopyable &amp;);&#125;; 条款07：为多态基类声明virtual析构函数 带多态性质的base class应该声明一个virtual析构函数 当class内至少含有一个virtual函数，才为它声明virtual析构函数 class的设计目的如果不是作为base class使用，或不是为了具备多态性，就不该声明virtual析构函数 然而，有时候你希望拥有一个抽象类，但没有任何需要的pure virtual方法，怎么办？ 由于abstract class（不能实例化）总是被期望当作多态基类，多态基类又需要virtual析构函数，而pure virtual函数会导致abstract class，因此可将析构函数声明为pure virtual并且给出默认实现。 12345678// 小技巧:pure virtual 析构函数class AWOV&#123;public: virtual ~AWOV() = 0;&#125;;AWOV::~AWOV() &#123;/* default */&#125; 条款08：别让异常逃离析构函数 析构函数绝对不要吐出异常 假设有一个类负责数据库的连接： 12345678class DBConnection&#123;public: ... static DBConnection create(); void close(); // 关闭联机, 失败则抛出异常&#125;; 为了确保客户不忘记在DBConnection对象上调用close函数，一个合理的想法是创建一个用来管理DBConnection资源的类，并在析构函数中调用close。 123456789101112class DBConn&#123;public: ... ~DBConn() &#123; db.close(); &#125; private: DBConnection db;&#125;; 用户可以写出这样的代码 1234&#123; DBConn dbc(DBConnection::create()); ...&#125; // 区块作用域结束，调用析构函数销毁对象 如果被析构函数调用的函数close可能抛出异常，析构函数应该捕获异常然后吞下它们或者结束程序。 一个好的策略是，开放一个close接口供用户调用，把调用close的责任从DBConn析构函数手上移到用户手上。 1234567891011121314151617181920212223242526272829class DBConn&#123;public: ... void close() &#123; db.close(); closed = true; &#125; ~DBConn() &#123; if(!closed) &#123; try &#123; db.close(); // 关闭连接（如果客户没做的话） &#125; catch(...) &#123; 日志记录下对 close 调用的失败; ... &#125; &#125; &#125; private: DBConnection db; bool closed;&#125;; 因此，如果客户需要对某个操作函数运行期间的异常作出反应，那么class应该提供一个接口执行该操作。如果close的确发生了异常，而客户没有调用close接口进行处理，DBConn只能吞下或结束程序。 条款09：绝不在析构和构造函数中调用virtual函数 派生类对象内的基类成分会在派生类自身成分被构造之前先被构造 基类构造期间，虚函数绝不会下降到派生类层 需要注意的是，有时类有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复时会把相同的初始化代码放到一个init函数中实现，如果这时在init函数中同样调用了虚函数，情况是一样的但比较隐秘。 条款10：令赋值操作符operator=返回一个reference to *this 为了实现连续赋值 条款11：在operator=中处理自我赋值 有些自我赋值并不明显，如通过指针或引用 假设你建立一个class来保存一个指针指向一块动态分配的位图（bitmap）： 1234567class Bitmap &#123;...&#125;;class Widget&#123; ...private: Bitmap* pb; // 指向一个从 heap 分配而得的对象&#125;; 错误的operator=实现为： 1234567// 自我赋值不安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs,pb); return *this;&#125; 可通过一个“证同测试”来检验： 12345678910// 自我赋值安全, 但不具备异常安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; if(this == &amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs,pb); return *this;&#125; 所谓的异常安全指的是，如果new Bitmap发生异常，会导致Widget最终会持有一个指针指向一块被删除的Bitmap。 12345678910// 具备异常安全, 则自动具备自我赋值安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* oldPb = pb; // 记住之前的 pb pb = new Bitmap(*rhs,pb); delete oldPb; return *this;&#125; 使用更好的copy and swap技术： 1234567891011121314151617181920212223class Bitmap &#123;...&#125;;class Widget&#123; ... void swap(Widget&amp; rhs) &#123; ... // 交换 *this 和 rhs 的数据, 见条款 25 &#125; ...&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; // 提升点效率 ? // if(this == &amp;rhs) // return *this; Widget temp(rhs); // copy swap(temp); // swap return *this;&#125; 条款12：复制对象时勿忘每一个成分 每一个成分包括对象内所有成员变量以及所继承的基类成分 在拷贝构造函数中的初始化列表中调用所继承的类的拷贝构造函数 在拷贝赋值操作符函数中调用所继承的类的拷贝赋值操作符函数 不要尝试让拷贝构造函数和拷贝赋值操作符函数互相调用","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之让自己习惯C++","date":"2020-03-01T13:35:42.000Z","path":"l4snoL8SUW9lGasI/","text":"第1章：让自己习惯C++条款01：视C++为一个语言联邦 将C++视为由4个次语言组成的联邦： C：没有模板、没有异常、没有重载… Object-Oriented C++：类、封装、继承、多态、虚函数、动态绑定等等； Template C++：泛型编程部分； STL：是一个Template程序库，容器、迭代器、算法以及函数对象。 从某个此语言切换到另一个时，高效编程守则可能会发生变化。比如，C-like类型（内置类型）pass by value更好；对于Object-Oriented C++而言，pass by reference to-const更好；再切换到STL，由于迭代器和函数对象都是在C指针之上塑造出来的，pass by value守则再次适用。 条款02：尽量以const，enum，inline替换#define 对于单纯常量，最好以const对象或enum hack替换#define 1234567891011121314// 记号名称未进入符号表, 难以调试// 在多处出现目标码, 尤其浮点常量// 无作用域概念, 不提供任何封装性#define ASPECT_RATIO 1.653// 常量会被编译器看到, 进入符号表// 导致较小量的目标码, 因为只有一份// 可放置在类内或 namespace 中限制其作用域const double AspectRatio = 1.653;// 可以放在类或 namespace 中// 令 NumTurns 成为 5 的记号名称, 一般用在类中做常量用// 行为像 #define, 对 const 取地址合法，对 enum 和 #define 取地址就不合法enum &#123;NumTurns = 5&#125;; 对于形似函数的宏，最好用inline（或模板）函数替换 宏中的变量有可能会被运算多次。 条款03：尽可能使用const const作用于迭代器 STL迭代器是以指针为根据塑模出来的，其作用就像个T*指针。声明迭代器为const只是声明一个const指针（作用就像T* const），表明的是迭代器本身不可变，但其所指的值是可以改动的。如果希望迭代器所指的值不可改动，需要的是const_iterator。 123456789std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();*iter = 10; // 正确++iter; // 错误std::vector&lt;int&gt;::const_iterator citer = vec.begin();*citer = 10; // 错误++citer; // 正确 将operator*的返回类型声明为const-by-value const可被施加于任何作用域内的对象、函数参数（常用pass-by-reference-to-const），函数返回类型、类成员函数本体 const施加于成员函数 成员函数上的const限定符意味着不能修改non-mutable，non-static类数据成员。 当const和non-const成员函数有着实质等价的实现时，令non-const成员函数调用const版本可避免代码重复 12345678910111213141516171819202122232425262728293031class TextBook&#123;public: ... const char&amp; operator[](std::size_t position) const &#123; ... // 边界检验 ... // 日记数据访问 ... // 检验数据完整性 return text[position]; &#125; /* char&amp; operator[](std::size_t position) &#123; ... // 边界检验 ... // 日记数据访问 ... // 检验数据完整性 return text[position]; &#125; */ char&amp; operator[](std::size_t position) &#123; // 调用 const_cast 移除对象身上的 const // 调用 static_cast 为 *this 加上 cosnt return const_cast&lt;char &amp;&gt;( static_cast&lt;const TextBook&amp;&gt;(*this)[position] ); &#125;private: std::string text;&#125;; const版本成员函数调用non-const版本不合法 条款04：确定对象被使用前已先被初始化 为内置型对象进行手工初始化，因为C++并不保证初始化它们 构造函数使用成员初始化列表，初始化顺序与在类中声明顺序一致 为避免“跨编译单元内定义的non-local static对象的初始化问题”，以local对象替换non-local static对象 static对象包括global对象、定义与namespace作用域内的对象、在class内、函数内、以及在file作用域内被声明为static的对象 函数内的static被称为local static对象，其它static对象被称为non-local static对象 程序结束时，static对象会被自动销毁，也就是它们的析构函数在main函数结束时被自动调用 编译单元是指产出单一目标文件的源码文件以及所含入的头文件 现在有两个源码文件，每个至少含入一个non-local static对象，其中一个non-local static对象用到了另一个non-local static对象，而被用到的尚未被初始化。 1234567891011121314151617181920212223// 文件 FileSystem.cpp 中class FileSystem&#123;public: ... std::size_t numDisks()const; // 众多成员函数之一 ...&#125;;extern FileSystem tfs; // 预备给客户使用的对象, non-local static 对象// 文件 Directory.cpp 中class Directory&#123;public: Directory(); // 构造函数 ...&#125;;Directory::Directory()&#123; ... std::size_t disks = tfs.numDisks(); // 使用 tfs 对象 ...&#125; 现在客户决定创建一个Directory对象，用来放置临时文件： 1Directory tempDir; // 为临时文件而做出的目录 这个时候就会出现初始化次序带来的问题。由于tfs和tempDir是不同的人在不同的时间于不同的源码文件中创建出来的，因此初始化次序不一定。 解决方法： 12345678910111213141516171819202122232425262728// 文件 FileSystem.cpp 中class FileSystem&#123;public: ... std::size_t numDisks() const; // 众多成员函数之一 ...&#125;;FileSystem&amp; tfs() // 用于创建预备给客户使用的对象的函数&#123; static FileSystem fs; // local static 对象 return fs;&#125;// 文件 Directory.cpp 中class Directory&#123;public: Directory(); // 构造函数 ...&#125;;Directory::Directory()&#123; ... // 这样就保证了被使用对象先被初始化 std::size_t disks = tfs().numDisks(); // 使用 tfs() 创建对象 ...&#125;","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]}]