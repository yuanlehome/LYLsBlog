[{"title":"教你用python实现一个在windows平台的定时更换壁纸的工具","date":"2020-06-14T05:00:42.000Z","path":"20200614/","text":"欢迎分享，转载务必注明来源！ (https://yuanlehome.github.io/20200614/) 有没有感觉到自己的电脑桌面一成不变让人厌倦？虽然有一些诸如360桌面之类的软件可以使用，但弹窗、广告又太多！本文就教你用 python 实现一个简洁清爽的桌面壁纸定时更换工具。 本文使用的方法是用 python 实现一个定时更换壁纸的脚本，壁纸来源与自定义的文件夹内，因此你可以搜集一些你喜欢的壁纸图片放于该文件夹下，这样脚本程序便可以使你的电脑桌面轮流展示这些图片了。 比如我就把我喜欢的壁纸都收集在了 E:/wallpapers/ 文件夹下。 这里推荐几个好的壁纸来源网站 https://wallhaven.cc/ ，https://www.artstation.com/wlop 。 下面直接看代码。 1234567891011121314151617181920212223import win32conimport win32guiimport threadingimport osdef getImages(): # 这里的路径就是你放图片的文件夹路径 images_path = 'E:\\\\wallpapers\\\\' files = os.listdir(images_path) return images_path, filesdef set_wallpaper(it): path, images = getImages() image = path + images[it] it = (it + 1) % len(images) win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, image, 1+2) global timer # 我设置的是每60s更换一次，你可以根据需要自定义设置 timer = threading.Timer(60.0, set_wallpaper, (it,)) timer.start()if __name__ == '__main__': set_wallpaper(0) 为了方便运行，我们可以使用 pyinstaller 工具将该脚本程序转成 .exe 可执行文件。具体的方法可以看这篇文章 Python程序打包成exe可执行文件 。 生成可执行文件之后，运行就可以了。不过，为了每次开机程序都可以自动运行，我们需要进行一些设置。首先按 win+R 键打开运行窗口，输入 shell:startup 回车，这样会打开一个启动文件夹，这个文件夹下的软件在开机时都会自动启动，将你的可执行文件或其快捷方式放在这里就可以了。 这里可以直接下载我已经生成的可执行程序： https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q提取码：v9ng 使用方法就是在E盘下新建一个名为wallpapers的文件夹，然后把自己喜欢的照片放进去就好，即E:/wallpapers/ 。","tags":[{"name":"Windows","slug":"Windows","permalink":"https://yuanlehome.github.io/tags/Windows/"},{"name":"桌面壁纸工具","slug":"桌面壁纸工具","permalink":"https://yuanlehome.github.io/tags/%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"https://yuanlehome.github.io/tags/python/"}]},{"title":"教你实现一个简易的Linux平台下的划词翻译工具","date":"2020-06-12T13:35:42.000Z","path":"20200612/","text":"欢迎分享，转载务必注明来源！ (https://yuanlehome.github.io/20200612/) 这里将要介绍的是一种在 Linux 平台实现的划词翻译工具，当然在考虑自己实现一个如此功能的工具前，本人也是在网上搜索了一些在 Linux 平台实现的类似的开源工具，例如 pdfTranslator，popup-dict，但它们的安装和配置都显得比较麻烦，而且使用起来也并不方便。 本人实现这个工具的初衷本是方便自己看一些英文文献和书籍的，极为方便，考虑到分享出去可以让更多人受惠，因此这里详细介绍一下它的实现步骤。 本文所实现的划词翻译工具主要有以下特性： 支持英文单词和短语到中文的翻译 划词翻译，终端显示 自动过滤选中文本中的换行等特殊字符 只依赖少数几个 Linux 命令工具 下面有动图进行演示。 本人所使用的环境是运行在 VMware 虚拟机下的 Linux 发行版 Ubuntu 18.04.3 LTS ，因此这里介绍的步骤可能与其他 Linux 发行版中的实现略有不同。下面就来一步一步的实现它吧。 一. 安装必要的命令 xclip 1$ sudo apt install xclip xclip 命令建立了终端和剪切板之间通道，可以用命令的方式将终端输出或文件的内容保存到剪切板中，也可以将剪切板的内容输出到终端或文件。详细的用法可以使用 man xclip，见其手册。这里介绍几个常用的用法。 1234$ xclip file_name # 文件内容保存到X window剪切板$ xclip -selection c file_name #文件内容保存到外部剪切板$ xclip -o # X window剪切板内容输出到终端显示$ xclip -selection c -o # 外部剪切板内容输出到终端显示 值得强调的是，这里所说的 X window 剪切板，简单的说就是你用鼠标选择的文本会实时的存放在这个剪切板，使用鼠标中键可以粘贴。而外部剪切板是保存你用 ctrl+c 复制的文本，ctrl+v 可以粘贴。这两个地方是不一样的。 translate-shell 1$ sudo apt install translate-shell 这是命令行版的谷歌翻译工具，之前叫做 Google Translate CLI 是一款借助谷歌翻译（默认）、必应翻译等来翻译的命令行翻译器。它让你可以在终端访问这些翻译引擎。 translate-shell 在大多数 Linux 发行版中都能使用。常用的方法如下： 12$ trans en:zh [word] # 英文到中文的单词翻译$ trans en:zh -b [text] # 简要的输出，进行文本翻译 需要注意的是，使用这个翻译工具需要你能够访问外网，或者通过修改 translate-shell 的默认翻译引擎，具体的方法这里就不阐述了。 二. 编程实现这个工具整体的思路就是 C 程序实时检测鼠标按键的动态，当检测到用户使用鼠标选择一段文本之后，调用 shell 脚本获取 X window 剪切板的内容进行翻译后输出到终端显示。 1. 定位鼠标设备文件 鼠标作为输入设备。其信息可以在文件 /proc/bus/input/devices 中，使用下列命令查看： 1234567891011$ sudo cat /proc/bus/input/devicesI: Bus=0011 Vendor=0002 Product=0013 Version=0006N: Name=\"VirtualPS/2 VMware VMMouse\"P: Phys=isa0060/serio1/input1S: Sysfs=/devices/platform/i8042/serio1/input/input4U: Uniq=H: Handlers=mouse0 event2 B: PROP=0B: EV=bB: KEY=70000 0 0 0 0B: ABS=3 其中的 Handlers 的值 event2 表示可以在 /dev/input/event2 文件下读取鼠标的状态。需要注意的是，对于不同的设备，读取鼠标的状态的文件可能不一样，比如也可能是 /dev/input/event3。我们可以使用下面的命令找到你的鼠标对应的是哪一个 event。 1$ sudo cat /dev/input/event2 | hexdump # 测试时改变数字即可 比如，当我运行上面这条命令之后，我移动鼠标、按鼠标左键/中键/右键，终端都会输出一些值，这就说明 event2 文件就是对应着我的鼠标。如果操作鼠标没有反应，说明这个就不是。你可以通过这种方法找到你的鼠标对应的 event 文件。 2. Linux 下获取按键响应 在 Linux 内核中，input 设备用 input_dev 结构体描述，使用 input 子系统实现输入设备驱动的时候，驱动的核心工作就是向系统报告按键、触摸屏、键盘、鼠标等输入事件（event*，通过 *input_event 结构体描述），不再需要关心文件操作接口，因为 input 子系统已经完成了文件操作接口 Linux/input.h 这个文件定义了 event 事件的结构体，API 和标准按键的编码等。 1234567891011121314151617181920212223242526// 结构体定义见 input.hstruct input_event&#123; struct timeval time; // 按键时间 __u16 type; // 事件类型 __u16 code; // 要模拟成什么按键 __s32 value; // 是按下还是释放&#125;;// 下面宏定义见 input-event-coses.h// type#define EV_KEY 0x01#define EV_REL 0x02#define EV_ABS 0x03// ...// code#define BTN_LEFT 0x110#define BTN_RIGHT 0x111#define BTN_MIDDLE 0x112// ...// value#define MSC_SERIAL 0x00#define MSC_PULSELED 0x01// ... 这里稍微介绍一下 type，指事件类型，常见的事件类型有：EV_KEY，按键事件，如键盘的按键（按下哪个键），鼠标的左键右键（是否击下）等；EV_REL，相对坐标，主要是指鼠标的移动事件（相对位移）；EV_ABS， 绝对坐标，主要指触摸屏的移动事件 。 3. 编写 C 程序 下面就可以编写程序来检测鼠标的动态了。首先在你的用户~目录下建立文件夹 Translator*。在 *Translator 里建立一个 ct.c 源文件，代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/input.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int keys_fd; struct input_event t; // 注意这里打开的文件根据你自己的设备情况作相应的改变 keys_fd = open(\"/dev/input/event2\", O_RDONLY); if (keys_fd &lt;= 0) &#123; printf(\"open /dev/input/event2 error!\\n\"); return -1; &#125; while (1) &#123; read(keys_fd, &amp;t, sizeof(t)); if (t.type == EV_KEY) // 有键按下 if (t.code == BTN_LEFT) // 鼠标左键 if (t.value == MSC_SERIAL) // 松开 // 调用外部shell脚本 system(\"~/Translator/goTranslate.sh\"); &#125; close(keys_fd); return 0;&#125; 然后就是调用 gcc 编译器生成可执行文件 ct： 1$ gcc ct.c -o ct 4. 编写 shell 脚本翻译剪切板内容 在 Translator 里建立 goTranslate.sh 文件，内容如下： 123456789101112131415#!/bin/bashstr_old=$(cat ~/Translator/lastContent)str_new=$(xclip -o 2&gt;/dev/null | xargs)if [[ \"$str_new\" != \"$str_old\" &amp;&amp; $str_new ]]; then echo -e \"\\n\" count=$(echo \"$str_new\" | wc -w) if [ \"$count\" == \"1\" ]; then echo -n -e \"$str_new \" &gt;&gt;~/Translator/words echo \"$str_new\" | trans :zh-CN | tail -1 | cut -c 5- | sed \"s,\\x1b\\[[0-9;]*[a-zA-Z],,g\" | tee -a ~/Translator/words else echo \"$str_new\" | trans :zh-CN -b fi echo \"$str_new\" &gt;~/Translator/lastContentfi 原理非常简单，读者自行了解。这里我们还要在 Translator 里建立一个 lastContent.txt 文件作为缓存，目的是本次调用脚本时能够获取上一次调用时翻译的文本内容，如果和本次调用的翻译文本一样，则本次就不进行翻译。 *5. 设置 *ct 别名 ** 这里已经可以通过下面的命令运行程序了： 1$ sudo ~/Translator/ct 但是由于每次运行都要输出这么长的命令，因此我们在 ~/.bashrc 文件中加入下面一条命令。 1alias ct='sudo ~/Translator/ct' 这样，以后每次看英文文献时就可以在命令行下输入： 1$ ct 三. 结束语这里有一些小技巧。可以更方便的使用这个工具。比如，把终端设为置顶并缩小到合适的尺寸，这样在阅读文献划词翻译时终端屏幕不会遮挡我们的视线。 值得说明的是，由于本人完全是为了方便自己的使用，而且在搞出这么个工具时仅仅接触 Linux 系统才不到两周，所以里面的实现对于有经验的朋友来说略显的有些笨拙了，请理解哈。 个人觉得这个工具使用起来还是很方便的，你觉得呢？ 参考文章： https://blog.csdn.net/liang12360640/article/details/50350648 https://www.cnblogs.com/yangwindsor/articles/3454955.html https://blog.csdn.net/liang12360640/article/details/50s350648","tags":[{"name":"划词翻译","slug":"划词翻译","permalink":"https://yuanlehome.github.io/tags/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/"},{"name":"Linux","slug":"Linux","permalink":"https://yuanlehome.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://yuanlehome.github.io/tags/shell/"}]},{"title":"Effective C++ 第七章","date":"2020-04-18T13:35:42.000Z","path":"20200418/","text":"第7章：模板与泛型编程条款41：了解隐式接口和编译期多态 哪一个重载函数被调用——发生在编译期 哪一个virtual函数被绑定——发生在运行期 class和template都支持接口和多态 对class而言，接口是显式的，以成员函数的签名为中心，多态则通过virtual函数发生在运行期。对template而言，接口是隐式的，以有效表达式为中心，多态则通过template具现化和函数重载解析发生于编译期。 条款42：了解typename的双重意义 当我们声明模板类型参数，class和typename的意义完全相同 12template&lt;typename T&gt;template&lt;class T&gt; typename用来标识嵌套从属类型名称 template内出现的名称如果相依于某个template参数，称这个名称为从属名称，如果丛属名称在class内呈嵌套状，称为嵌套从属名称。如果嵌套从属名称还指涉某种类型名称为嵌套从属类型名称 123456789101112131415161718// std::iterator_traits&lt;IterT&gt;::value_type 就是嵌套从属类型名称template&lt;typename IterT&gt;void workWithIterator(IterT iter)&#123; // 必须使用 typename 关键字标识 typename std::iterator_traits&lt;IterT&gt;::value_type temp(*iter); ...&#125;// 使用 typedef 少打几个字template&lt;typename IterT&gt;void workWithIterator(IterT iter)&#123; // 必须使用 typename 关键字标识 typedef typename std::iterator_traits&lt;IterT&gt;::value_type value_type; value_type temp(*iter); ...&#125; 不允许在base class list或member initialization list内使用typename作为base class的标识符 条款43：学习处理模板化基类内的名称假设我们需要撰写一个MsgSender类，它能够传送信息到若干不同的Company去。信息要不进行加密后的密文，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于template的解法： 1234567891011121314151617181920212223242526272829303132333435363738394041class CompanyA&#123;public: ... void sendCleartext(const string&amp; msg); void sendEncrypted(const string&amp; msg);&#125;;class CompanyB&#123;public: ... void sendCleartext(const string&amp; msg); void sendEncrypted(const string&amp; msg);&#125;;... // 针对其他公司设计的 classclass MsgInfo &#123;...&#125;; // 这个 class 以备将来产生信息template&lt;typename Company&gt;class MsgSender&#123;public: ... //构造函数、析构函数等等 void sendClear(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendCleartext(msg); &#125; void sendSecret(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendEncrypted(msg); &#125;&#125;; 现在假设我们想要在每次送出信息时log某些信息。derived class可轻易提供解决方法： 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log sendClear(info); // 调用 base class 函数, 这段码无法通过编译! ... // 将“传送后”的信息写至 log &#125; ...&#125;; 编译器会抱怨sendClear函数不存在，明明在那里，为什么？ 问题在于，当编译器看见class template LoggingMsgSender定义式时，并不知道它继承什么样的class。当然它继承的是MsgSender&lt;Company&gt;，但其中的Company是个template参数，不当LoggingMsgSender被具现化之前无法确切知道它是什么。而如果不知道Company是什么，就无法知道class MsgSender&lt;Company&gt;看起来像什么——更明确地说是没办法知道它是否有个sendClear函数。 具体点说，假设现在有个CompanyZ坚持只使用加密通讯： 12345678// 不提供 sendCleartext 函数class CompanyZ&#123;public: ... void sendEncrypted(const string&amp; msg); ...&#125;; 一般性的MsgSender template对CompanyZ并不合适，因为那个template提供了一个sendClearMsg函数，而这对CompanyZ对象并不合理。欲矫正这个问题，我们可以针对CompanyZ产生一个MsgSender特化版： 123456789101112131415// 全特化版本只提供 sendSecret 函数template&lt;&gt;class MsgSender&lt;CompanyZ&gt;&#123;public: ... //构造函数、析构函数等等 void sendSecret(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendEncrypted(msg); &#125; ...&#125;; 这就解释了前面编译器拒绝那个调用的原因：它知道base class template有可能被特化，而那个特化版本可能不提供和一般性template相同的接口。因此它往往拒绝在templatized base class（本例的MsgSender&lt;Company&gt;）内寻找继承而来的名称（本例的SendClear)。 当我们从Object Oriented C++跨进Template C++（见条款1) ，继承就不像以前那样畅行无阻了 有三个解决令C++编译器“不进入templatized base class观察”的行为失效的办法： 使用this指针 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log this-&gt;sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 使用using声明 虽然using声明式在在条款33或在这里都可有效运作，但两处解决的问题其实不相同。前者是base class名称被derived class名称遮掩，而后者是编译器不进入base class作用域内查找，于是我们通过using告诉它，请它那么做。 1234567891011121314template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: using MsgSender&lt;Company&gt;::sendClear; ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 使用作用域运算符::明确指定 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log MsgSender&lt;Company&gt;::sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 即使如此，如果稍后这样做： 1234LoggingMsgSender&lt;Companyz&gt;zMsgSender;MsgInfo msgData;...zMsgSender.sendClearMsg(msgData); // 仍然无法通过编译 其中对sendClearMsg的调用动作将无法通过编译，因为在那个点上，编译器知道base class是个template特化版本MsgSender&lt;CompanyZ&gt;，而且它知道那个class不提供sendClear函数，而sendClear却是sendClearMsg尝试调用的函数。 条款44：将与基类无关的代码抽离template当你编写某个函数，其中某些部分的实现码和另一个函数的实现码实质相同，你会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。如果你正在编写某个class，而你明白其中某些部分和另一个class的某些部分相同，你也不会重复这共同的部分。你会把共同部分搬移到新class去，然后使用继承或复合（见条款32，38，39) ，令原先的class取用这共同特性。而原class的互异部分仍然留在原位置不动。 编写template时，也是做相同的分析，以相同的方式避免重复。然而在template代码中，重复是隐晦的：毕竟只存在一份template源码，所以你必须训练自己去感受当template被具现化多次时可能发生的重复。 举个例子，假设你想为固定尺寸的正方矩阵编写一个template。该矩阵的性质之一是支持逆矩阵运算。 123456789101112131415// template 支持 n x n 矩阵, 元素类型为 Ttemplate&lt;typename T, size_t n&gt;class squareMatrix&#123;public: ... void invert( ); // 求逆矩阵&#125;;SquareMatrix&lt;double, 5&gt; sml;...sm1.invert(); // 调用 SquareMatrix&lt;double, 5&gt;::invertsSquareMatrix&lt;double, 10&gt; sm2;...sm2.invert(); // 调用 SquareMatrix&lt;double, 10&gt;::invert 这会具现化两份invert。这些函数并非完完全全相同，因为其中一个操作的是5x5矩阵而另一个操作的是10x10矩阵，但除了常量5和10，两个函数的其他部分完全相同。这是template引出代码膨胀的一个典型例子。 第一次修改： 1234567891011121314151617181920212223242526// 与尺寸无关的 base classtemplate&lt;typename T&gt;class SquareMatrixBase&#123;protected: void invert(size_t matrixSize) // 以给定的尺寸求逆矩阵 &#123; ... &#125;&#125;;template&lt;typename T, size_t n&gt;class SquareMatrix : private SquareMatrixBase&lt;T&gt;&#123;private: // 声明为 private 是为了不让客户看见 using SquareMatrixBase&lt;T&gt;::invert; // 避免遮掩 base 版的 invert, 见条款 33public: ... void invert() &#123; this-&gt;invert(n); // inline 调用 base class 版的 invert // 为什么这儿出现 this-&gt; 见条款 43 // LYL 认为前面已经使用了 using, this-&gt; 应该也不需要了 &#125;&#125;; 这里的base class只是为了帮助derived class实现，不是为了表现SquareMatrix和SquareMatrixBase之间的is-a关系（关于private继承，见条款39)。 目前为止一切都好，但还有一些棘手的题目没有解决。SquareMatrixBase::invert如何知道该操作什么数据？虽然它从参数中知道矩阵尺寸，但它如何知道哪个特定矩阵的数据在哪儿？想必只有derived class知道。derived class如何联络其base class做逆运算动作？一个可能的做法是为SquareMatrixBase::invert添加另一个参数，可以是个指针，指向一块用来放置矩阵数据的内存地址。 第二次修改： 1234567891011121314151617181920212223242526272829303132template&lt;typename T&gt;class SquareMatrixBase&#123;protected: // 存储矩阵大小和一个指针, 指向矩阵数值 squareMatrixBase(size_t n, T* pMem) : size(n), pData(pMem) &#123;&#125; void invert() // 不用指定尺寸了 &#123; ... &#125; ...private: size_t size; // 矩阵的大小 T* pData; // 指针, 指向矩阵内容&#125;;template&lt;typename T, size_t n&gt;class SquareMatrix : private SquareMatrixBase&lt;T&gt;&#123;private: using SquareMatrixBase&lt;T&gt;::invert;public: SquareMatrix() : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125; void invert() &#123; this-&gt;invert(n); &#125; ...private: T data[n * n]; // 这里直接将数据矩阵存储在 SquareMatrix 对象内部 // 也可以使用动态内存分配的方案&#125;; 这个条款只讨论由non-type template parameter（非类型模板参数）带来的膨胀，其实type parameter（类型参数）也会导致膨胀。例如在许多平台上int和 long有相同的二进制表述，所以像vector&lt;int&gt;和vector&lt;long&gt;的成员函数有可能完全相同。某些链接器（linker）会合并完全相同的函数实现码，但有些不会，后者意味某些template被具现化为int和long两个版本，并因此造成代码膨胀。类似情况，所有指针类型都有相同的二进制表述，因此凡template持有指针者（例如list&lt;int*&gt;，list&lt;const int*&gt;，list&lt;SquareMatrix&lt;long, 3&gt;*&gt;等等）往往应该对每一个成员函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它们操作强型指针（strongly typed pointer，即T*），你应该令它们调用另一个操作无类型指针（untyped pointer，即void*）的函数，由后者完成实际工作。某些C++标准程序库实现版本的确为vector，deque和list等template做了这件事。 条款45：成员函数模板接受所有兼容类型内置指针是支持隐式转换的，比如derived class的指针可以隐式转换为base class指针，指向non-const对象的指针可以转换为指向const对象等等。 123456class Top &#123;...&#125;;class Middle : public Top &#123;...&#125;;class Bottom : public Middle &#123;...&#125;;Top* pt1 = new Middle; // 将 Middle* 转换为 Top*Top* pt2 = new Bottom; // 将 Bottom* 转换为 Top*const Top* = pt1; // Top* 转换为 const Top* 但是我们自己实现的智能指针模板类，想做到这样就稍稍有点麻烦了。我们希望下面的代码能够通过编译： 12345678910111213141516temmplate&lt;typename T&gt;class SmartPtr&#123;public: explicit SmartPtr(T* realPtr); // 智能指针通常以内置指针完成初始化 ...&#125;;// 将 SmartPtr&lt;Middle&gt;转 换为 SmartPtr&lt;Top&gt;SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(new Middle);// 将 SmartPtr&lt;Bottom&gt; 转换为 SmartPtr&lt;Top&gt;SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(new Bottom);// 将 SmartPtr&lt;Top&gt; 转换为 SmartPtr&lt;const Top&gt;SmartPtr&lt;const Top&gt; pct2 = ptl; 注意，这些赋值表达式需要调用的都是copy构造函数。这里的代码不能通过编译，因为如果以带有base-derived关系的B，D两类型分别具现化某个template，产生出来的两个具现体并不带有base-derived关系，所以编译器视SmartPtr&lt;Middle&gt;和SmartPtr&lt;Top&gt;为完全不同的class，为了获得我们希望获得的SmartPtr class之间的转换能力，我们必须将它们明确地编写出来。 我们应该为它写一个构造模板。这样的模板是所谓member function template，其作用是为class生成函数： 123456789template&lt;typename T&gt;class SmartPtr&#123;public: // member template, 为了生成 copy 构造函数 template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other); ...&#125;; 我们称之为泛化（generalized）copy构造函数。它并未被声明为explicit，那是因为内置指针类型之间的转换（例如从derived class指针转为base class指针）是隐式转换，所以让智能指针按照这种形式也属合理。 但是，这个为SmartPtr而写的“泛化copy构造函数”提供的东西比我们需要的更多。我们只希望根据一个SmartPtr&lt;Bottom&gt;创建一个SmartPtr&lt;Top&gt;，却不希望根据一个SmartPtr&lt;Top&gt;创建一个SmartPtr&lt;Bottomr&gt;，因为那对public继承而言（见条款32）是矛盾的。我们也不希望根据一个SmartPtr&lt;double&gt;创建一个SmartPtr&lt;int&gt;，我们必须从某方面对这一member template所创建的成员函数群进行挑拣。 假设SmartPtr遵循std::shared_ptr也提供一个get成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望： 12345678910111213template&lt;typename T&gt;class SmartPtr&#123;public: // 以 other 的 heldPtr 初始化 this 的 heldPtr template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other) : heldPtr(other.get()) &#123;...&#125; T* get() const &#123; return heldPtr; &#125; ...private: T* heldPtr; // 这个 SmartPtr 持有的内置指针&#125;; 这个行为只有当“存在某个隐式转换可将一个U*指针转为一个T*指针”时才能通过编译，而这正是我们想要的。 member function template（成员函数模板）的效用不限于构造函数，它常扮演的另一个角色是支持赋值操作。例如std::shared_ptr同时支持所有“来自兼容之内置指针、std::shared_ptr、std::weak_ptr”的构造行为以及赋值操作（std::weak_ptr除外）。赋值操作符和copy构造函数实现类似，故省略。 如果你声明member template用于“泛化copy构造”或“泛化assignment操作”你还是需要声明正常的copy构造函数和copy assignment操作符 条款5说过，编译器可能为我们产生四个成员函数，其中两个是copy构造函数和copy assignment操作符。现在，SmartPtr声明了一个泛化copy构造函数，而显然一旦类型T和U相同，泛化copy构造函数会被具现化为“正常的”copy构造函数。那么究竟编译器会暗自为SmartPtr生成一个copy构造函数呢？或当某个SmartPtr对象根据另一个同型的SmartPtr对象展开构造行为时，编译器会将“泛化copy构造函数模板”具现化呢？ member template并不改变语言规则：“如果程序需要一个copy构造函数，你却没有声明它，编译器会为你暗自生成一个”。在class内声明泛化copy构造函数（是个member template）并不会阻止编译器生成它们自己的copy构造函数（一个non-template），所以如果你想要控制copy构造的方方面面，你必须同时声明泛化copy构造函数和“正常的”copy构造函数。相同规则也适用于赋值操作。 条款46：需要类型转换时请为模板定义非成员函数条款24讨论过为什么惟有non-member函数才有能力“在所有实参身上实施隐式类型转换”，该条款并以Rational class的operator*函数为例。本条款将Rational和operator*模板化： 123456789101112131415161718192021template&lt;typename T&gt;class Rational&#123;public: // 条款 20 告诉你为什么参数以 passed by reference 方式传递 Rational(const T&amp; numerator = 0, const T&amp; denominator = 1); // 条款 28 告诉你为啥返回值以 passed by value 方式传递 // 条款 3 告诉你为啥它们是 const const T numerator() const; const T denominator() const; ...&#125;;template&lt;typename T&gt;const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 就像条款24一样，我们也希望支持混合式算术运算，然而以下代码却不能通过编译： 12Rational&lt;int&gt; oneHalf(1, 2);Rational&lt;int&gt; result &#x3D; oneHalf * 2; &#x2F;&#x2F; 错误!无法通过编译 在这里，编译器不知道我们想要调用哪个函数！它们试图找到什么函数被名为operator*的template具现化出来。它们知道它们应该可以具现化某个“名为operator*并接受两个Rational&lt;T&gt;参数”的函数，但为完成这一具现化行动，必须先算出T是什么。 为了推导T，它们看了看operator*调用动作中的实参类型。分别是Rational&lt;int&gt;（oneHalf的类型）和int（2的类型）。 以oneHalf进行推导，过程并不困难。第二参数的推导则没有这么顺利。operator*的第二参数被声明为Rational&lt;T&gt;，但传递给operator*的类型是int（2）。编译器如何根据这个2推算出T？你或许会期盼编译器使用Rational&lt;int&gt;的non-explicit构造函数将转换为Rational&lt;int&gt;，进而将T推导为int，然而template实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。 template class内的friend声明式可以指涉某个特定函数。这意味class Rational&lt;T&gt;可以声明operator*是它的一个friend函数。class template并不倚赖template实参推导，所以编译器总是能够在class Rational&lt;T&gt;具现化时得知T。因此： 12345678910111213141516template&lt;typename T&gt;class Rational&#123;public: ... friend const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs);&#125;;template&lt;typename T&gt;const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 现在当对象oneHalf被声明为一个Rational&lt;int&gt;，class Rational&lt;int&gt;于是被具现化出来，而作为过程的一部分，friend函数operator*（接受Rational&lt;int&gt;参数）也就被自动声明出来。后者身为一个函数而非function template，因此编译器可在调用它时使用隐式转换函数（例如调用Rational的non-explicit构造函数）。 但是，虽然这段代码通过编译，却无法连接。 因为这个友元函数只被声明于Rational内，并没有被定义出来。我们意图令此class外部的operator* template提供定义式，是行不通的。既然我们没有提供定义式，连接器当然找不到它！ 最简单的方法就是，将函数本体放进class内： 12345678910111213template&lt;typename T&gt;class Rational&#123;public: ... friend template&lt;typename T&gt; const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) &#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); &#125;&#125;; 为了让类型转换可能发生于所有实参身上，我们需要一个non-member函数（条款24）；为了令这个函数被自动具现化，我们需要将它声明在class内部；而在class内部声明non-member函数的唯一办法就是：令它成为一个friend。因此我们就这样做了。 当此friend函数过于复杂时，令其调用类外的辅助函数 12345678910111213141516171819202122template&lt;typename T&gt; class Rational; // 前向声明template&lt;typename T&gt;const Rational&lt;T&gt; doMultiply(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp;rhs);&#123; return Rational&lt;T&gt;(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125;template&lt;typename T&gt;class Rational&#123;public: ... friend const Rational&lt;T&gt;operator* (const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) &#123; return doMultiply(lhs, rhs); &#125; ...&#125;; 作为一个template，doMultiply当然不支持混合式乘法，但它其实也不需要。它只被operator*调用，而operator*支持混合式操作。 条款47：traits classes表现类型信息STL迭代器分类： input迭代器 只能向前移动，一次一步，用户只能读取它所指的东西，而且只能读取一次，读完立即自动向前一步。程序库中的输入流迭代器istream_iterator就属于这一类。 output迭代器 只能向前移动，一次一步，用户只能涂写它所指的东西，而且只能涂写一次，写完立即自动向前一步。程序库中的输出流迭代器ostream_iterator就属于这一类。 forward迭代器 可以做上述两种迭代器做的事情，而且支持多次读写，读写完由用户自行决定是否前进。单向链表slist提供的迭代器就属于这一类。 bidirectional迭代器 除了能做forward迭代器做的事情，还可以向后移动。双向链表list以及set，mutilset，map，mutilmap提供的迭代器属于这一类。 random access迭代器 功能类似于内置指针，可以进行算数操作。vector，deque和string提供的迭代器属于这一类。 迭代器适配器 reverse迭代器 insert迭代器 back inserter front inserter general inserter stream迭代器 move迭代器 12345struct input_iterator_tag &#123;&#125;;struct output_iterator_tag &#123;&#125;;struct forward_iterator_tag : public input_iterator_tag &#123;&#125;;struct bidirectional iterator_tag : public forward_iterator_tag &#123;&#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag &#123;&#125;; 这些struct之间的继承关系是有效的is-a关系：所有forward迭代器都是input迭代器，依此类推。 关于iterator_trait的实现技术（参考书籍P227-P232） 条款48：认识template元编程 如题，以后买本书再专门去学吧！","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++ 第六章","date":"2020-04-10T13:35:42.000Z","path":"20200410/","text":"第6章：继承与面向对象设计条款32：确定你的public继承塑模出is-a关系 “public继承”意味is-a。适用于base class身上的每一件事情一定也适用于derived class身上，因为每一个derived class对象也都是一个base class对象 条款33：避免遮掩继承而来的名称 derived class的作用域被嵌套在base class作用域内 12345678910111213141516171819202122232425class Base&#123;private: int x;public: virtual void mf1() = 0; virtual void mf1(int); void mf2(); void mf2(double);&#125;;class Derived : public Base&#123;public: virtual void mf1(); void mf2();&#125;;Derived d;int x;...d.mf1(); // 没问题, 调用 Derived::mf1d.mf1(x); // 错误! 因为 Derived::mf1 遮掩了 Base::mf1d.mf2(); // 没问题, 调用 Derived::mf2d.mf2(x); // 错误! 因为 Derived::mf2 遮掩了 Base::mf2 这段代码中base class内所有名为mf1和mf2的函数都被derived class内的mf1和mf2函数遮掩掉了。从名称查找观点来看，Base::mf1和Base::mf2不再被Derived继承！ 实际上如果你正在使用public继承而又不继承那些重载函数，就是违反base和derived class之间的is-a关系，而条款32说过is-a是public继承的基石。因此你几乎总会想要推翻C++对“继承而来的名称”的缺省遮掩行为。 使用using声明式 1234567891011121314151617181920212223242526272829class Base&#123;private: int x; public: virtual void mf1() = 0; virtual void mf1(int); void mf2(); void mf2(double); ...&#125;;class Derived : public Base&#123;public: using Base::mf1; // 让 Base class 内名为 mf1 和 mf2 的所有东西 using Base::mf2; // 在 Derived 作用域内都可见, 并且 public virtual void mf1(); void mf2();&#125;;Derived d;int x;...d.mf1(); // 没问题, 调用 Derived::mf1d.mf1(x); // 现在没问题了, 调用 Based::mf1d.mf2(); // 没问题, 调用 Derived::mf2d.mf2(x); // 现在没问题了, 调用 Based::mf2 使用inline转交函数（forwarding function） 然而在private继承之下（见条款39），有时候你并不想继承base class的所有函数。假设Derived以private形式继承Base，而Derived唯一想继承的mf1是那个无参数版本。using声明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名函数在derived class中都可见。 1234567891011121314151617181920212223class Base&#123;public: virtual void mf1() = 0; virtual void mf1(int); ... // 与前同&#125;;class Derived : private Base&#123;public: virtual void mf1() // 转交函数 &#123; Base::mf1(); // 暗自成为 inline (见条款 30) &#125; ...&#125;;Derived d;int x;d.mf1(); // 很好, 调用的是 Derived::mf1d.mf1(x); // 错误! Base::mf1 被遮掩 条款34：区分接口继承和实现继承身为class设计者，有时候你会希望derived class只继承成员函数的接口，也就是声明；有时候你又会希望derived class同时继承函数的接口和实现，但又希望能够覆写（override）它们所继承的实现；又有时候你希望derived class同时继承函数的接口和实现，并且不允许覆写任何东西。 base类强烈影响以public形式继承它的derived class，因为： 成员函数的接口总是会被继承 声明一个pure virtual函数的目的是为了让derived类只继承函数接口 含有pure virtual函数的类属于抽象基类，不能被实例化。继承了它们的类必须重新声明此函数接口并给予实现。抽象基类可以给pure virtual函数提供定义，但调用它的唯一途径是“调用时指定其class的名称”。 声明impure函数的目的是让derived class继承该函数的接口和缺省实现 但是，允许impure virtual函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑XYZ航空公司设计的飞机继承体系。该公司只有A型和B型两种飞机，两者都以相同方式飞行。因此XYZ设计出这样的继承体系： 1234567891011121314class Airport &#123;...&#125;; // 用以表现机场class Airplane&#123;public: virtual void fly(const Airport&amp; destination); ...&#125;;void Airplane::fly(const Airport&amp; destination) &#123; ... // 缺省代码, 将飞机飞至指定的目的地&#125;class ModelA: public Airplane &#123;...&#125;;class ModelB: public Airplane &#123;...&#125;; 为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的fly实现”，Airplane::fly被声明为virtual。然而为了避免在ModelA和ModelB中撰写相同代码，缺省飞行行为由Airplane::fly提供，它同时被ModelA和ModelB继承。 现在，XYZ航空公司决定购买一种新式C型飞机。C型和A型以及B型的飞行方式不同。XYZ公司的程序员在继承体系中针对C型飞机添加了一个class，但由于他们急着让新飞机上线服务，竟忘了重新定义其fly函数： 12345678910class ModelC : public Airplane&#123; // 未声明fly函数&#125;;Airport PDX(... ); // PDX 是我家附近的机场Airplane* pa= new ModelC;...// 这将酿成大灾难pa-&gt;fly(PDX); // 调用 Airplane::fly 一种解救办法为切断“virtual函数接口”和其“缺省实现”之间的连接。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Airplane&#123;public: // 现在是 pure virtual 函数 virtual void fly(const Airport&amp; destination) = 0;protected: void defaultFly (const Airport&amp; destination);&#125;;void Airplane::defaultFly(const Airport&amp; destination)&#123; ... // 缺省行为, 将飞机飞至指定的目的地。&#125;class ModelA : public Airplane &#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly(destination); &#125;&#125;;class ModelB : public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly (destination); &#125;&#125;;// 现在 ModelC class 不可能意外继承不正确的 fly 实现代码了// 因为 Airplane 中的 pure virtual 函数追使 ModelC 必须提供自己的 f1y 版本class ModelC: public Airplane&#123;public: virtual void fly(const Airport&amp; destination);&#125;;void ModelC::fly(const Airport&amp; destination)&#123; ... // 将 C 型飞机飞至指定的目的地&#125; 另一种解救方法是，利用“pure virtual函数必须在derived class中重新声明，但它们也可以拥有自己的实现”这一事实。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Airplane&#123;public: // 现在是 pure virtual 函数 virtual void fly(const Airport&amp; destination) = 0;&#125;;// 给予 pure virtual 函数实现void Airplane::fly(const Airport&amp; destination)&#123; ... // 缺省行为, 将飞机飞至指定的目的地&#125;class ModelA : public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; Airplane::fly(destination); // 通过指定其类名调用它 &#125; ...&#125;;class ModelB : public Airplane&#123;public: virtuai void fly(const Airport&amp; destination) &#123; Airplane::fly(destination); // 通过指定其类名调用它 &#125; ...&#125;;class ModelC : public Airplane&#123;public: virtual void fly(const Airport&amp; destination);&#125;;void ModelC::fly(const Airport&amp; destination)&#123; ... // 将 C 型飞机飞至指定的目的地&#125; 声明non-virtual函数的目的是为了derived class继承函数的接口及其强制性实现 non-virtual函数为其所属class建立的意义是不变性凌驾其特异性，所以它不该在derived class中被重新定义。 条款35：考虑virtual函数以外的其他选择假设你正在写一个视频游戏软件，你的游戏属于暴力砍杀类型，剧中人物存在被伤害而降低健康状态的情况。因此你决定提供一个成员函数 healthvalue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将healthvalue声明为virtual似乎是再明白不过的做法： 123456class GameCharacter&#123;public: virtual int healthvalue() const; // 返回人物的健康指数, // derived classes 可重新定义它&#125;; 现在考虑一些其它解法： 借助non-virtual interface(NVI)手法实现Template Method模式 保留healthvalue为public成员函数，但让它成为non-virtual，并调用一个private virtual函数进行实际工作： 123456789101112131415161718class GameCharacter&#123;public: int healthvalue() const // derived class 不重新定义它 &#123; ... // 做一些事前工作 int retval = doHealthvalue(); // 做真正的工作 ... // 做一些事后工作 return retval; &#125;// NVI 手法下没必要让 virtual 函数一定是 privateprivate: virtual int doHealthValue() const // derived class 可重新定义它 &#123; ... // 缺省算法, 计算健康指数。 &#125;&#125;; 这一基本设计，“令客户通过public non-virtual成员函数间接调用private virtual函数”，称为non-virtual interface(NVI)手法。它是所谓Template Method设计模式的一个独特表现形式。我把这个non-virtual函数（healthvalue）称为virtual函数的外覆器（wrapper) 。 NVI手法的一个优点隐藏在上述代码注释“做一些事前工作”和“做一些事后工作”之中。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证 class约束条件、验证函数先决条件等。“事后工作”可以包括互斥器解除锁定、验证函数的事后条件、再次验证class约束条件等。如果你让客户直接调用virtual函数，就没有任何好办法可以做这些事。 借助Function Pointer实现Strategy模式 另一个设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个函数指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算： 123456789101112131415161718192021class GameCharacter; // 前向声明// 以下函数是计算健康指数的缺省算法int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: typedef int (*HealthCalcFunc)(const GameCharacter&amp;); explicit GameCharacter (HealthCalcFunc hcf = defaultFealthCalc) : healthFunc(hcf) &#123;&#125; int healthvalue() const &#123; return healthFunc (*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 这种设计策略和前面介绍的方法相比提供了一些有趣的弹性： 同一人物类型的不同实体可以有不同的健康计算函数 123456789101112class EvilBadGuy : public GameCharacter&#123;public: explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc) : GameCharacter(hcf) &#123;...&#125; ...&#125;;int loseHealthQuickly(const GameCharacter&amp;); // 健康指数计算函数 1int loseHealthSlowly(const GameCharacter&amp;); // 健康指数计算函数 2EvilBadGuy ebg1(loseHealthQuickly); // 相同类型的人物搭配EvilBadGuy ebg2(loseHealthSlowly); // 不同的健康计算方式 某已知人物之健康指数计算函数可在运行期变更 例如GameCharacter可提供一个成员函数setHealthcalculator，用来替换当前的健康指数计算函数。 然而这种策略意味着，计算函数并不能访问“被计算健康指数的”那个对象的内部（non-public）成分。如果需要访问non-public成分进行精确计算，这就有问题了。 唯一能够解决的办法就是：弱化class的封装。例如，将健康计算函数声明为friend。或是为其实现的某一部分提供public访问函数。这需要你来权衡利弊进行抉择。 借助std::function实现Strategy模式 123456789101112131415161718192021class GameCharacter;int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: // 不同之处 typedef std::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc; explicit GameCharacter (HealthCalcFunc hcf = defaultFealthCalc) : healthFunc(hcf) &#123;&#125; int healthvalue() const &#123; return healthFunc (*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 那个签名代表的函数是“接受一个reference指向const GameCharacter，并返回int”。这个std::function类型（也就是我们所定义的HealthCalcFunc类型）产生的对象可以持有（保存）任何与此签名式兼容的可调用物。所谓兼容，意思是这个可调用物的参数可被隐式转换为const GameCharacter&amp;，而其返回类型可被隐式转换为int。 这就提供了很大的灵活性： 1234567891011121314151617181920212223242526272829303132333435363738short calcHealth(const GameCharacter&amp;); // 健康计算函数 // 注意其返回类型为 non-intstruct HealthCalculator&#123; // 为计算健康而设计的函数对象 int operator()(const GameCharacter&amp;) const &#123;...&#125;&#125;;class GameLevel&#123;public: float health(const GameCharacter&amp;) const; // 成员函数, 用以计算健康 // 注意其 non-int 返回类型&#125;;// 人物类型 1class EvilBadGuy: public GameCharacter&#123; ... // 同前&#125;;// 人物类型 2class EyeCandyCharacter: public GameCharacter&#123; // 假设其构造函数与 EvilBadGuy 同&#125;;// 人物 1, 使用某个函数计算健康指数EvilBadGuy ebg1(calcHealth);// 人物 2, 使用某个函数对象计算健康指数EyeCandyCharacter ecc1(HealthCalculator());GameLevel currentLevel;...// 人物 3, 使用某个成员函数计算健康指数EvilBadGuy ebg2(std::bind(&amp;GameLevel::health, &amp;currentLevel, _1)); 传统的Strategy模式 123456789101112131415161718192021222324252627282930313233343536373839404142class GameCharacter;class HealthCalcFunc&#123;public: virtual ~HealthCalcFunc() &#123;&#125; virtual int calc(const GameCharacter&amp; gc) const = 0;&#125;;class SlowHealthLoser : HealthCalcFunc&#123;public: virtual int calc(const GameCharacter&amp; gc) const &#123; ... &#125; ...&#125;;class FastHealthLoser : HealthCalcFunc&#123;public: virtual int calc(const GameCharacter&amp; gc) const &#123; ... &#125; ...&#125;;class GameCharacter&#123;public: explicit GameCharacter(HealthCalcFunc* phcf) : pHealthCalc(phcf) &#123;&#125; int healthValue() const &#123; return pHealthCalc-&gt;calc(*this); &#125;private: HealthCalcFunc* pHealthCalc;&#125;; 条款36：绝不重新定义继承而来的non-virtual函数 如题 条款37：绝不重新定义继承而来的缺省参数值本条款的讨论局限于“继承一个带有缺省参数值的virtual函数”：virtual函数是动态绑定（后期绑定，延迟绑定），而缺省参数值却是静态绑定（前期绑定，早绑定）。 123456789101112131415161718192021222324252627// 一个用以描述几何形状的classclass Shape&#123;public: enum ShapeColor&#123;Red, Green, Blue&#125;; // 所有形状都必须提供一个函数, 用来绘出自己 virtual void draw(ShapeColor color = Red) const = 0; ...&#125;;class Rectangle : public Shape &#123;public: // 注意, 赋予不同的缺省参数值, 这真糟糕! virtual void draw(ShapeColor color = Green) const; ...&#125;;class Circle : public shape&#123;public: virtual void draw(ShapeColor color) const; // 请注意，以上这么写则当客户以 对象 调用此函数一定要指定参数值 // 因为静态绑定下这个函数并不从其 base 继承缺省参数值 // 但若以指针或 reference 调用此函数, 可以不指定参数值 // 因为动态绑定下这个函数会从其 base 继承缺省参数值&#125;; 对象的静态类型就是它在程序中所声明的类型，对象的动态类型则是指“目前所指对象的类型” 123shape* ps; // 静态类型为 shape*, 无动态类型Shape* pc = new Circle; // 静态类型为 Shape*, 动态类型是 Circle*Shape* pr = new Rectangle; // 静态类型为 shape*, 动态类型是 Rectangle* 动态类型可在程序执行过程中改变（通常是经由赋值动作）： 12ps = pc; // ps 的动态类型如今是 circle*ps = pr; // ps 的动态类型如今是 Rectangle* virtual函数系动态绑定而来，意思是调用一个virtual函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。 12pr-&gt;draw(); // 调用的是 Rectangle::draw(shape::Red)! // 注意缺省参数是 Red 而不是 Green 此例之中，pr的动态类型是Rectangle*，所以调用的是Rectangle的virtual函数。Rectangle::draw函数的缺省参数值应该是Green，但由于pr的静态类型是shape*，所以此一调用的缺省参数值来自Shape class而非Rectangle class！这不符合预期。 解救方法是利用条款35中介绍的NVI手法替代virtual函数： 123456789101112131415161718192021class Shape&#123;public: enum shapeColor&#123;Red, Green, Blue&#125;; void draw(ShapeColor color = Red) const // 如今它是 non-virtual &#123; doDraw(color); // 调用一个 virtual &#125;private: virtual void doDraw(shapeColor color) const = 0; // 真正的工作在此处完成&#125;;class Rectangle : public Shape&#123;public: ...private: virtual void doDraw (ShapeColor color) const; // 注意, 不须指定缺省参数值 ...&#125;; 这个设计很清楚地使得draw函数的color缺省参数值总是Red。 条款38：通过复合塑模出has-a或is-implemented-in-terms-of当某种类型的对象内含其它对象时便形成了复合关系。 应用域 程序中的对象其实相当于你所塑造出来的世界中的某些事物。比如人，汽车，高楼大厦等。这样的对象属于应用域部分。 实现域 其它对象如缓冲区，互斥器，搜索树等纯粹是实现细节上的工具。这些对象相当于软件中的实现域。 当复合发生于应用域对象之间表现出has-a关系，当它发生于实现域内则表现出is-implemented-in-terms-of（根据某物实现出）的关系。 复合的意义和public继承完全不同 注意区分is-a和is-implemented-in-terms-of这两种对象关系。 条款39：明智而谨慎地使用private继承一个derived类继承base类有public、protected或private三种继承方式。 公有继承（public）（普遍使用） base类的public成员也是derived类的public成员，base类的protected成员也是derived类的protected成员 保护继承（protected）（基本不使用） base类的public和protected成员将成为derived类的protected成员。 私有继承（private）（少的情况使用） base类的public和protected成员将成为derived类的private成员。 无论哪一种继承方式，base类的private成员都不能直接被derived类访问，但是可以通过调用base类的public和protected成员间接来访问（如果base类提供了访问接口的话）。 private继承意味着is-implemented-in-terms-of private继承只限于软件实现层面，这就是为什么private继承后，base class的所有成分（除了private）在你的class内都是private，因为它们都只是实现细节而已。 尽可能使用复合，必要时才使用private继承 当derived类想要访问base class的protected成员时 当derived类为了重新定义base class的virtual函数时 现在考虑一个Widget类，它需要用到另一个计时器Timer类来实现一些业务。 123456 class Timer&#123;public: explicit Timer(int tickFrequecy); virtual void onTick() const; // 定时器每滴答一次, 此函数就调用一次&#125;； 为了让Widget重新定义Timer内的virtual函数，Widget必须继承自Timer。因为Widget不是个Timer，因此public继承不合适。必须以private方式继承： 123456class Widget&#123; ...private: virtual void onTick() const; // &#125;; 通过private继承，Timer的public onTick函数在Widget内变成private，而我们重新声明（定义）时仍然把它留在那儿。如果把onTick放进public内会误导客户以为他们可以调用它，那就违反了条款18。 另一种设计方案是采用复合 + public继承： 123456789101112131415class Widget&#123; ...private: // 在 Widget 内声明一个嵌套式 private class class WidgetTimer : public Timer &#123; public: // 以 public 方式继承并重新定义 virtual 函数 virtual void onTick() const; ... &#125;; WidgetTimer timer; ...&#125;; 采用第二种较为复杂的方式的两点理由： 你或许会想设计Widget使它得以拥有derived class，但同时你可能会想阻止derived class重新定义onTick。如果Widget继承自Timer，上面的想法就不可能实现，即使是private继承也不可能。但如果WidgetTimer是Widget内部的一个private成员并继承自Timer，Widget的derived class将无法取用WidgetTimer，因此无法继承它或重新定义它的virtual函数。 你或许会想要将Widget的编译依存性降至最低（条款31）。如果Widget继承Timer，当Widget被编译时Timer的定义必须可见，所以定义Widget的那个文件恐怕必须#include Timer.h。但如果WidgetTimer移出Widget所在文件之外而Widget内含指针指向一个WidgetTimer，Widget可以只带着一个简单的WidgetTimer前向声明式，不再需要#include任何与Timer有关的东西。很容易就实现了解耦。 EBO（empty base optimization） empty class指的是没有non-static成员变量，没有virtual函数，也没有virtual base class。于是这种class不占用理论上不占用任何内存空间。然而在实现技术上，C++要求独立（非附属）对象都必须有非零大小。 12345678910class Empty &#123; &#125;; // 没有任何需要存储的数据// 理论上 sizeof(HoldAnInt) = 4 字节(就一个 int)// 实际上 sizeof(HoldAnInt) = 8 字节class HoldAnInt&#123;private: int x; // 4 字节 Empty e; // 理论上应该不占据内存&#125;; C++编译器默认为empty class独立对象安插一个char（1字节） 由于内存对齐HoldAnInt的实际大小为4 + 1(内存对齐至 4) = 8 但这个约束不适用于derived class对象的base class成分（非独立）： 123456// 理论和实际上 sizeof(HoldAnInt) = 4 字节(就一个 int)class HoldAnInt : public Empty&#123;private: int x; // 4 字节&#125;; 现实中的empty class并非真是empty。往往内含typedef，enum，static成员变量，或non-virtual函数。STL就有许多技术用途的empty class，其中内含有用的成员（通常是typedef），包括base class unary_function和binary_function，这些是“用户自定义之函数对象”通常会继承的class。由于EBO，这样的继承很少增加derived class的大小。 条款40：明智而谨慎地使用多重继承 多重继承较单一继承复杂，可能导致歧义性 当继承的多个base具有同名成员函数时，derived类调用时会出现歧义。 有时多重继承不得不需要virtual继承，而这会带来额外的体积、运行速度、初始化复杂度等成本 比如这样的钻石继承体系： 这个继承体系中某个base class和某个derived class之间有一条以上的相通路线，假设File class有个成员变量fileName，那么IOFile从每一个base class各继承一份，所以其对象内会有两份fileName成员变量。然而IOFile对象只该有一个文件名称，所以名称fileName不该重复。 解决办法就是采用virtual继承： virtual继承带来的后果是： 使用virtual继承的那些class所产生的对象往往比使用non-virtual继承的class体积大 访问virtual base class的成员变量时，也比访问non-virtual base class的成员变量速度慢 另外，支配“virtual base class初始化”的规则比起non-virtual base class的情况远为复杂且不直观。virtual base class的初始化责任是由继承体系中的最低层（most derived）class负责的，这意味着： class若派生自virtual base而需要初始化，必须知道其virtual base class——不论那些base class距离多远。 当一个新的derived class加入继承体系中，它必须承担其virtual base class的初始化责任。 关于virtual继承的忠告： 非必要不使用virtual base。平常请使用non-virtual继承。 如果必须使用virtual base class，尽可能避免在其中放置数据。这么一来你就不需担心这些class身上的初始化（和赋值）所带来的诡异事情了。 最后看一个多重继承的应用例子——public继承某个Interface class和private继承某个协助实现的class。 （参考书籍P195-P198）","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"数据结构与算法之概论","date":"2020-04-04T05:54:42.000Z","path":"20200404/","text":"数据结构 相互之间存在一种或多种特定关系的数据元素的集合。研究数据结构，关心的是数据对象的描述以及相关操作函数的实现。 数据 是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如整型、浮点型等数值类型，以及声音、图像等非数值类型。 数据元素 是组成数据的、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。 数据项 一个数据元素可以由若干个数据项组成。它是数据不可分割的最小单位。 数据对象 是性质相同的数据元素（即有相同的数量和类型的数据项）的集合，是数据的子集。 常见的数据结构 线性数据结构：向量vector（顺序存储）、链表list（链式存储）、栈stack和队列queue（优先队列）。 半线性数据结构：二叉树、搜索树（二叉搜索树BST、AVL树、B树、红黑树）、竞赛树等。 非线性数据结构：图。 哈希表hashing table、字典dictionary。 抽象数据类型 数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 抽象数据类型：指一个数学模型及定义在该模型上的一组操作。可以理解为C++中的类class。它体现的是程序设计中问题分解、抽象和信息隐藏的特性。 抽象数据类型的标准格式12345678ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义Operation 操作1 操作2 ...endADT 算法 算法是解决指定问题求解步骤的描述。在计算机中是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。 计算或信息处理 指借助某种工具，按照一定的规则，以明确而机械的形式进行。 算法中的计算模型就是计算机，即信息处理工具。 算法必须具备的几大要素 输入：待处理的信息或问题。 输出：经处理的信息，即答案。 正确性：的确可以解决指定的问题。 确定性：任何一个算法都可以描述为一个由基本操作组成的序列。 可行性：每一基本操作都可实现，且能在常数时间内完成。 有穷性：对于任何输入，经有限次的基本操作，都可以得到输出。 一个好的算法 正确，即符合语法，能够编译、链接。 能够正确处理简单的、大规模的、一般性的、退化的、任意合法的输入。 健壮，能够辨别不合法的输入并做适当处理，而不致非正常退出。 可读，结构化 + 准确命名 + 注释 + …。 效率，运行速度尽可能快，用到的存储空间尽可能少。 常见的算法 查找 顺序查找、二分查找、插值查找、斐波那契查找、分块查找和哈希查找等。 排序 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序和希尔排序等。 递归、分而治之、动态规划、回溯法和分支定界法等。 要对数据结构和算法设计方法给予评价，就必须能够计算程序性能。 数据结构和算法的关系 数据结构(data structures) + 算法(algorithms) = 程序(programs) (data structures + algorithms) x efficiency = computation 程序性能分析 是指分析一个程序对于内存空间和运行时间的需求。 空间复杂度 指程序运行时临时占用内存的大小。广义上的概念是包括存储算法本身所占用的空间、算法的输入输出数据所占用的空间以及算法在运行过程中临时占用的存储空间这三个方面。 时间复杂度 指运行程序所需要的时间。这里度量的是程序中基本操作执行的次数，它是问题规模n的函数f(n)。记T(n)=O(f(n))，它表示随问题规模n的增大，算法执行时间的增长率和f(n)相同，称作算法的渐进时间复杂度。 复杂度分析这里的复杂度分析通常指的是最坏时间复杂度分析。 常数阶O(1) 取前三个元素x = S[0]、y = S[1]和z = S[2]，这一步只需执行三次（从特定单元读取元素的）基本操作，耗费O(3)时间。接下来，为确定这三个元素的大小次序，最多需要做三次比较，也需O(3)时间。最后，输出居中的非极端元素只需O(1)时间。因此，上面取非极端元素算法的时间复杂度为：T(n) = O(3) + O(3) + O(1) = O(7) = O(1)。 对数阶O(logn) 根据右移运算的性质，每右移一位，n都至少缩减一半。也就是说，至多经过1 + log2n次循环，n必然缩减至0，从而算法终止。因此时间复杂度为：O(1 + log2n) = O(log2n) 。 线性阶O(n) 平方阶O(n) 时间复杂度为：O(2n^2 + n + 1) = O(n^2)。 常见的算法时间复杂度排序 Ο(1) ＜ Ο(logn) ＜ Ο(n) ＜ Ο(nlogn) ＜ Ο(n^2) ＜ … ＜ Ο(2^n) ＜ Ο(n!)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Effective C++ 第五章","date":"2020-04-01T13:35:42.000Z","path":"20200401/","text":"第5章：实现条款26：尽可能延后变量定义式的出现时间 应该延长变量的定义，直到非得使用它时 应该延后这份定义，直到能够给它初值实参 对于循环存在的情况： 做法A：定义于循环外 123456Widget w;for(int i = 0; i &lt; n; i++)&#123; w = 取决于 i 的某个值； ...&#125; 做法B：定义于循环内 12345for(int i = 0; i &lt; n; i++)&#123; Widget w(取决于 i 的某个值); ...&#125; 这两种写法的成本如下： 做法A：1个构造函数 + 1个析构函数 + n个赋值操作 做法B：n个构造函数 + n个析构函数 做法A会造成名称w的作用域比做法B更大 除非（1）你知道赋值成本比构造 + 析构成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法B。 条款27：尽量少做转型操作旧式C转型： T(expression) (T)expression 新式C++转型： const_cast&lt;T&gt;(expression) 用来将对象的常量性（const）转除（只有它能办到）。 dynamic_cast&lt;T&gt;(expression) 用来执行安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型。 reinterpret_cast&lt;T&gt;(expression) 用来执行低级转型，如将一个pointer to int 转为一个int。很少使用（在条款50中使用过一次）。 static_cast&lt;T&gt;(expression) 用来强迫隐式转换，例如将non-const对象转为const对象，将int转为double，将void*指针转为typed指针，或将pointer to base转为pointer to derived。 任何一种类型转换（无论显式转换还是隐式转换）往往都会令编译器编译出运行期间执行的码。如将int转为double会产生一些代码，因为int的底层表述不同于double的： 123int x, y;...double z = static_cast&lt;double&gt;(x) / y; 再比如： 1234class Base &#123;...&#125;;class Derived: public Base &#123;...&#125;;Derived d;Base* pb = &amp;d; // 隐喻的将 Derived* 转换为 Base* 这种情况下有时候会有一个偏移量在运行期被施行于Derived*身上，用来取得正确的Base*指针值。这个例子表明单一对象可能有一个以上的地址（以Base*指向它时的地址和以Derived*指向它时的地址）。 假设我们有个base class Window和一个derived class Specialwindow，两者都定义了virtual函数onResize。进一步假设Specialwindow的onResize函数被要求首先调用Window的onResize。下面实际上是错的实现方式： 12345678910111213141516171819202122class Window&#123;public: ... virtual void onResize () &#123;...&#125; // base onResize实现代码 ...&#125;;class Specialwindow: public Window&#123;public: ... // derived onResize 实现代码 virtual void onResize() &#123; static_cast&lt;Window&gt;(*this).onResize(); // 将 *this 转型为 Window, // 然后调用其 onResize; // 这不可行! ... // 这里进行 Specialwindow 专属行为 &#125; ...&#125;; 它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“*this对象之base class成分”的暂时副本身上的onResize！如果Window::onResize修改了对象内容，当前对象其实没被改动，改动的是副本。然而SpecialWindow::onResize内如果也修改对象，当前对象真的会被改动。这使当前对象进入一种“伤残”状态：其base class成分的更改没有落实，而derived class成分的更改倒是落实了。 正确的做法是： 1234567891011class Specialwindow: public Window&#123;public: ... virtual void onResize() &#123; Window::onResize(); // 调用 Window::onResize 作用于 *this 身上 ... &#125; ...&#125;; dynamic_cast的实现版本执行速度相当慢，应该在注重效率的代码中保持对dynamic_cast的警觉 优良的C++代码很少使用转型，我们应该尽可能隔离转型动作，通过将它隐藏在某个函数内，使得客户可以调用该函数而不需要将转型放进他们自己代码内 宁可使用新式转型，也不要使用旧式转型，前者很容易辨识出来 条款28：避免返回handles指向对象内部成分 handles指指针、引用和迭代器 成员变量的封装性最多只等于“返回其reference”的函数的访问级别 如果const成员函数不得不传出去一个reference，则最好将返回类型限定为const 有可能会导致空悬的handles，它的生命期却长于其所指对象 条款29：为“异常安全”而努力是值得的当异常被抛出时，带有异常安全性的函数会： 不泄露任何资源 不允许数据败坏 较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也少。异常安全码必须提供以下三个保证之一： 基本承诺 如果异常被抛出，程序内的任何事物仍然保证在有效状态（只要那是个合法状态）下，没有任何对象或数据结构会因此而败坏，所有对象处于一种内部前后一致的状态。 强烈保证 如果异常被抛出，程序状态不改变。 不抛掷保证 承诺绝不抛出异常，因为它们总能完成原先承诺的功能。 可以实现强烈保证的copy and swap技术：为你打算修改的对象做出copy一份副本，然后在副本身上做一切修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。带所有改变都成功后，再将修改后的副本和原对象swap。 1234567891011121314151617181920212223242526272829// 之所以实现为 struct 是因为其 PrettyMenu 的数据封装性// 已经由 pImpl 是 private 获得了保证class Image &#123;...&#125;;struct PMImpl&#123; std::shared_ptr&lt;Image&gt; bgImage; int imageChanges;&#125;;class PrettyMenu&#123; ...private: Mutex mutex; std::shared_ptr&lt;PMImpl&gt; pImpl; // pimpl idiom 详细描述见条款 31&#125;;void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123; using std::swap; // 见条款25 Lock ml(&amp;mutex); // 获得mutex的副本数据 std::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl)); pNew-&gt;bgImage.reset(new Image(imgSrc)); // 修改副本 ++pNew-&gt;imageChanges; swap(pImpl, pNew); // 置换(swap)数据, 释放 mutex) 注意，并非所有函数都可实现强烈保证或其具备现实意义。 函数提供的”异常安全保证“通常最高只等于其所调用各个函数提供的”异常安全保证“中的最弱者。 条款30：透彻了解inlining的里里外外inline函数是指将对此函数的每一个调用都以函数本体替换之。这将导致两种情况： 目标码增加（显然） 如果inline函数的体积很小，编译器对“函数本体”所产出的码可能比“函数调用”所产出的码小 inline只是对编译器的一个申请，不是强制命令，也就是说编译器可以拒绝将太过复杂（带有递归或循环）的函数进行inline。通过对函数使用inline关键字属于明确提出申请，将函数定义于类内属于隐喻申请。 将大多数inline限制在小型、被频繁调用的函数身上 inline函数通常一定被置于头文件内 因为大多数构建环境在编译过程中进行inlining，而为了将一个函数调用替换为被调用函数的本体，编译器必须知道那个函数长什么样子。 所有对virtual函数的inline申请都会被拒绝（因为对virtual函数的调用在运行期才确定） 条款31：将文件间的编译依存关系降至最低 将接口从实现中分离 12345678910111213class Person&#123;public: Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); string name() const; string birthDate() const; string address() const; ...private: string theName; // 实现细目 Date theBirthDate; // 实现细目 Address theAddress; // 实现细目&#125;; 这里的class无法通过编译，因为编译器没有取得其实现代码所用到的class string，Date，Address的定义式，通常应该在Person定义文件的最上方存在include头文件。 123#include &lt;string&gt;#include \"date.h\"#include \"address.h\" 不幸的是，这么一来便是在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其他头文件有任何改变，那么每一个含入Person class的文件就得重新编译，任何使用person class的文件也必须重新编译。这样的连串编译依存关系（cascading compilation dependencies）会对许多项目造成难以形容的灾难。 Handle classes：pimpl idiom(pointer to implenmentation) + 前向声明 把Person分割成两个class，一个只提供接口，另一个负责实现接口。 1234567891011121314151617181920212223242526272829#include &lt;string&gt; //标准程序库组件不该被前向声明#include &lt;memory&gt;// 使用前向声明而不是包含头文件, 这个很关键class PersonImpl; // Person 实现类// Person 接口用到的 classclass Date; class Address;class Person&#123;public: Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); string name() const; string birthDate() const; string address() const; ...private: shared_ptr&lt;PersonImpl&gt; pImpl; // 指针, 指向实现物 // 如果不这样做的话, 编译器在编译 Person 类的时候，必须知道 Person 类的大小 // 就不得不包含这三个实现细目 /* string theName; // 实现细目 Date theBirthDate; // 实现细目 Address theAddress; // 实现细目 */ // 然而一旦这样写, 前面的前向声明就没用了, 必须包含头文件&#125;; 这样一来，Person类的使用者就完全于Date，Address以及Person的实现细目相分离了。这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：实现上让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。 几个简单的设计策略： 如果使用object reference或object pointer可以完成任务，就不要使用object 你可以只靠一个类型声明式就定义出指向该类型的reference和pointer；但如果定义某类型的object，就需要用到该类型的定义式。 如果能够，尽量以class声明式替换class定义式 注意，当你声明一个函数而它用到某个class时，你并不需要该class的定义。 为声明式和定义式提供不同的头文件 对于前面代码中的前向声明，最好是提供一个声明式头文件，包含全部的前向声明。 下面式Person.cpp文件的部分实现： 12345678910#include &lt;Person.h&gt;#include &lt;PersonImpl.h&gt; // 注意，Person 和PersonImpl的成员函数完全相同, 两者接口完全相同Person::Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr) : pImpl(new PersonImpl(name, birthday,addr)) &#123;&#125;string Person::narne( ) const &#123;return pImpl-&gt;name();&#125;... Interface classes：abstract base class + factory函数 abstract base class通常没有成员变量，也没有构造函数，只有一个virtual析构函数和一组pure virtual函数。但Interface class的客户必须有办法为这种class创建新对象。他们通常调用一个特殊函数，此函数创建实际实现的derived class，这样的函数通常称为factory(工厂）函数（见条款13），它们返回智能指针指向动态分配所得对象，而该对象支持Interface class的接口。这样的函数又往往在Interface class内被声明为static： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 位于 Person.h// 抽象基类, 只有声明// 提供给客户使用的头文件class Person&#123;public: virtual ~Person(); virtual strng name() const = 0; virtual strng birthDate() const = 0; virtual string address() const = 0; // static 的 factory 函数 static shared_ptr&lt;Person&gt; create(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); ...&#125;// 位于 Person.cpp#include \"Person.h\"class RealPerson: public Person&#123;public: RealPerson(const string&amp; name, const Date&amp; birthday, const Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125; virtual ~RealPerson() &#123;&#125; string name() const; string birthDate() const; string address() const;private: string theName; Date theBirthDate; Address theAddress;&#125;;... // 虚函数的实现码shared_ptr&lt;Person&gt; Person::create(const string&amp; name, const Date&amp; birthday, const Address&amp; addr)&#123; return shared_ptr&lt;Person&gt;(new RealPerson(name, birthday, addr));&#125; Handle classes和Interface classes解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++ 第四章","date":"2020-03-21T13:35:42.000Z","path":"20200321/","text":"第4章：设计与声明条款18：让接口容易被正确使用，不容易被误用 如果客户企图使用某个接口却没有获得所预期的行为，这个代码不应该通过编译；如果代码通过了编译，则它的行为就应该是客户想要的 欲达“让接口容易被正确使用，不容易被误用”的目的，必须考虑客户调用接口时可能做出什么样的错误 “促进正确使用”的办法包括接口的一致性，以及与内置类型兼容 “阻止误用”的办法包括建立新类型、限制在类型上的操作，束缚对象值以及消除客户的资源管理责任 条款19：设计class犹如设计type你应该带着“语言设计者当初设计语言内置类型时”一样的谨慎来研讨每一个class的设计。因为，重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结…全都在你手上。 新的type的对象应该如何创建和销毁？ 设计函数为类的构造函数和析构函数以及内存分配函数和释放函数（见条款49-52）。 对象的初始化和对象的赋值该有什么样的差别？ 决定了构造函数和赋值操作符的行为以及差异。 新type的对象被passed by value，意味着什么？ 取决于copy构造函数的实现。 什么新type的合法值？ 你的新type需要配合某个继承图系吗？ 见条款7、34、36。 你的新type需要什么样的转换？ explicit和operator关键字的使用。见条款15。 什么样的操作符和函数对此新type而言时合理的？ 见条款23、24、46。 什么样的标准函数应该驳回？ 见条款6。 谁该取用新type的成员？ 决定了数据成员是public、private还是protected，以及friend关键的使用。 什么是新type的“未声明接口”？ 见条款29。 你的新type有多么一般化？ 决定class template的使用。 你真的需要一个新type吗？ 条款20：宁以pass by reference to const替换pass by value 当把具有继承关系的类作为参数传递时，如果pass by value可能会出现“截断”问题。 条款21：必须返回对象时，别妄想返回其reference 绝不要返回指向一个local stack对象的pointer或reference 绝不要返回指向一个heap allocated对象的reference 除非有单例模式的设计要求，否则绝对不要返回指向一个local static对象的pointer或reference 条款22：将成员变量声明为private 客户访问数据的一致性 public里都是函数。 可以对成员变量有更精确的控制 可以实现成员变量的不可访问，只读、只写、读写访问。 封装性 将成员变量隐藏在函数接口背后，可以为所有可能的实现提供弹性。 从封装的角度看，只有两种权限：private（提供封装）和其它 protected并不比private更具封装性。 条款23：宁以non-member、non-friend替换member函数考虑一个用来表示网页浏览器的class，这个class提供的众多成员函数中，有用来清除下载元素高速缓冲区的，有用来清除访问过的历史记录的，有用来移除系统中所有cookies的。 12345678910111213141516171819202122232425262728class WebBrowser&#123;public: ... void clearCache(); void clearHistory(); void cleatCookies(); ...&#125;;// 客户想一整个执行所有的操作// 以提供一个 member 函数的方式class WebBrowser&#123;public: ... void clearEverthing(); ...&#125;;// 以提供一个 non-member 函数的方式void clearBrowser(WebBrowser&amp; wb)&#123; wb.clearCache(); wb.clearHistory(); wb.cleatCookies();&#125; 后者比较好。因为： 增加封装性 non-member non-friend将提供较大的封装性，因为它并不增加能够访问class内的private成分的函数数量。friend函数对class private成员的访问权力和member函数相同，两者对封装的冲击力度是一样的。 增加扩充机能性 在C++中，正确且自然的做法是： 123456namespace WebBrowserStuff&#123; class WebBrowser &#123;...&#125;; void clearBrowser(WebBrowser&amp; wb); // 为 WebBrowser “提供便利”的函数 ...&#125; namespace和class的不同是，前者可跨越多个源码文件而后者不能。 像WebBrowser这样的类可能有大量的“提供便利”函数，某些与书签有关，与打印有关，与cookie有关… 分离它们最直接的做法就是： 123456789101112131415161718// 头文件 WebBrowser.h 内namespace WebBrowserStuff&#123; class WebBrowser &#123;...&#125;; ... // 核心机能, 例如所有客户都想要的 non-member 函数&#125;// 头文件 WebBrowserBookmarks.h 内namespace WebBrowserStuff&#123; ... // 与书签相关的 non-member 函数&#125;// 头文件 WebBrowserCookies.h 内namespace WebBrowserStuff&#123; ... // 与 cookie 相关的 non-member 函数&#125; 将所有“便利函数”放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组“便利函数”。 条款24：若所有参数皆需类型转换，请为此采用non-member函数 有理数类Rational的实现 重点关注用来将两个有理数相乘的operator*操作符重载函数的实现方式。 条款25：考虑写出一个不抛异常的swap函数标准程序库提供的swap算法的典型实现为： 12345678910namespace std&#123; template&lt;typename T&gt; void swap(T&amp; a, T&amp; b) &#123; T temp(a); a = b; b = temp; &#125;&#125; 只要T类型支持copying函数（copy构造函数和copy assignment操作符）。对于用户自定义类型，效率低下（需要三次复制）。 现在考虑所谓的pimpl(pointer to implementation)实现手法： 1234567891011121314151617181920212223242526// 注意这是个模板类template&lt;typename T&gt;class WidgetImpl&#123;public: ... // 细节不重要private: ... // 有很多数据, 意味着复制时间很长&#125;;// 注意这是个模板类template&lt;typename T&gt;class Widget&#123;public: Widget(const Widget&lt;T&gt;&amp; rhs); // 关于 operator= 的一般性实现参考条款 10, 11, 12 Widget&amp; operator=(const Widget&lt;T&gt;&amp; rhs) &#123; ... *pImpl = *(rhs.pImpl); ... &#125;private: WidgetImpl&lt;T&gt;* pImpl; // 指向实际实现的对象&#125;; 一旦需要置换两个Widget对象值，我们实际唯一需要的是置换两个指针即可。但缺省的swap函数不知道这一点！ 下面是正确的实现步骤： 令Widget实现一个名为swap的public成员函数做真正的置换工作 123456789101112template&lt;typename T&gt;class Widget&#123;public: ... void swap(Widget&lt;T&gt;&amp; other) &#123; using std::swap; // 必须的 swap(pImpl, other.pImpl); // 直接置换指针即可 &#125; ...&#125; 将std::swap特化，令它调用该成员函数（当Widget是类时。这里的例子中，Widget是个模板类则不要这一步） 因为，C++只允许对class template偏特化，不允许对function template进行偏特化 12345678namespace std&#123; template&lt;&gt; void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; a.swap(); &#125;&#125; 声明一个non-member swap，令它调用member swap 123456// 注意, 要将它放在和 Widget&lt;T&gt; 同一个空间内(全局或者自定义的 namespace)template&lt;typename T&gt;void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)&#123; a.swap(b);&#125; 编程时，在调用swap置换对象的语句之前加上using std::swap声明 123456789// 客户代码template&lt;typename T&gt;void doSomething(T&amp; obj1. T&amp; obj2)&#123; using std::swap; // 令 std::swap 在此函数内可用 ... swap(obj1, obj2); // 这样一来, 编译器将为 T 类型对象调用最佳版本 swap ...&#125; 编译器首先在全局作用域或T所在命名空间内寻找T（在这里，T就是例子中的Widget哦）专属的swap（也就是步骤3中实现的）。如果没有实现这些，则调用std内的swap，如果步骤2还实现了特化版本，将会选中特化版本。 劝告，member swap绝不可抛出异常 具体参考条款29。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++ 第三章","date":"2020-03-15T13:35:42.000Z","path":"20200315/","text":"第3章：资源管理条款13：以对象管理资源 RAII(Resource Acquisition Is Initialization) 使用new获取资源后于同一条语句内以它初始化某个资源管理对象。利用当管理对象离开作用域被销毁时自动调用其析构函数的机制确保资源被释放。不直接用new和delete，多用智能指针。 智能指针在其析构函数中做delete动作而非delete[]动作 因此，不要在动态分配来的数组身上使用智能指针（虽然它仍然会通过编译）。 条款14：在资源管理类中小心copying行为 当不想RAII类被复制时可以继承Uncopyable类 将智能指针施于heap-based资源身上是个好主意，但并不是所有资源都是heap-based的，比如互斥器mutex，mutex就不可复制。 条款15：在资源管理类中提供对原始资源的访问 显示转换（安全） 例如，shared_ptr类就提供可一个get成员函数来返回智能指针内部的原始指针。 operator隐式转换（调用方便） 123456789101112131415161718class A&#123; ... // operator 可以实现隐式转换函数 operator B() const &#123; return b; &#125; ...private: B b; // B 类型对象成员&#125;;// 接受 B 类型对象的一个函数void func(B b);A a;func(a); // a 会被编译器隐式转换为 B 类型对象 条款16：使用new和delete时要采用相同的形式 编译器在给数组分配内存时，会包括数组大小的记录 这样的好处是，delete[]时知道需要调用多少次析构函数。 不要对数组形式进行typedef动作 条款17：以独立语句将new来的对象置入智能指针考虑这样两个函数： 12int priority(); // 调用这个函数不排除会发生异常void processWidget(shared_ptr&lt;Widget&gt; pw, int priority); 如果这样调用编译不通过，因为shared_ptr接收原始指针的构造函数是explicit的： 1processWidget(new Widget, priority()); 如果这样调用可能会造成内存泄漏： 1processWidget(shared_ptr&lt;Widget&gt;(new Widget), priority()); 因为编译器在编译这条语句时，实际上会创建三个动作： 调用priority() 执行new Widget 调用shared_ptr的构造函数 而C++编译器安排这三个动作的次序是不确定的。 如果执行次序是这样： 执行new Widget 调用priority() 调用shared_ptr的构造函数 一旦中途priority()导致异常，那么new返回的原始指针并未交给智能指针保管，将造成资源泄露。 正确的做法： 12shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority()); 因为，编译器对“跨越语句的各项操作”没有重新排列执行次序的自由。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++ 第二章","date":"2020-03-08T13:35:42.000Z","path":"20200308/","text":"第2章：构造、析构、赋值运算条款05：了解C++默默编写并调用哪些函数 编译器会暗自为class创建default构造函数、copy构造函数、copy assignment操作符以及析构函数 对于class内含reference成员或const成员，编译器拒绝为其生成copy构造函数和copy assignment操作符 因为C++不允许reference改指向不同的对象以及更改const成员。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝 为驳回编译器自动提供的函数，可将相应的成员函数声明为private并且不予实现。 掌握Uncopyable类的实现机制 将构造函数和析构函数设置为protected的 将拷贝构造函数和拷贝赋值运算符设置为private的 12345678910class Uncopyable&#123;protected: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable &amp;); const Uncopyable &amp;operator=(const Uncopyable &amp;);&#125;; 条款07：为多态基类声明virtual析构函数 带多态性质的base class应该声明一个virtual析构函数 当class内至少含有一个virtual函数，才为它声明virtual析构函数 class的设计目的如果不是作为base class使用，或不是为了具备多态性，就不该声明virtual析构函数 然而，有时候你希望拥有一个抽象类，但没有任何需要的pure virtual方法，怎么办？ 由于abstract class（不能实例化）总是被期望当作多态基类，多态基类又需要virtual析构函数，而pure virtual函数会导致abstract class，因此可将析构函数声明为pure virtual并且给出默认实现。 12345678// 小技巧:pure virtual 析构函数class AWOV&#123;public: virtual ~AWOV() = 0;&#125;;AWOV::~AWOV() &#123;/* default */&#125; 条款08：别让异常逃离析构函数 析构函数绝对不要吐出异常 假设有一个类负责数据库的连接： 12345678class DBConnection&#123;public: ... static DBConnection create(); void close(); // 关闭联机, 失败则抛出异常&#125;; 为了确保客户不忘记在DBConnection对象上调用close函数，一个合理的想法是创建一个用来管理DBConnection资源的类，并在析构函数中调用close。 123456789101112class DBConn&#123;public: ... ~DBConn() &#123; db.close(); &#125; private: DBConnection db;&#125;; 用户可以写出这样的代码 1234&#123; DBConn dbc(DBConnection::create()); ...&#125; // 区块作用域结束，调用析构函数销毁对象 如果被析构函数调用的函数close可能抛出异常，析构函数应该捕获异常然后吞下它们或者结束程序。 一个好的策略是，开放一个close接口供用户调用，把调用close的责任从DBConn析构函数手上移到用户手上。 1234567891011121314151617181920212223242526272829class DBConn&#123;public: ... void close() &#123; db.close(); closed = true; &#125; ~DBConn() &#123; if(!closed) &#123; try &#123; db.close(); // 关闭连接（如果客户没做的话） &#125; catch(...) &#123; 日志记录下对 close 调用的失败; ... &#125; &#125; &#125; private: DBConnection db; bool closed;&#125;; 因此，如果客户需要对某个操作函数运行期间的异常作出反应，那么class应该提供一个接口执行该操作。如果close的确发生了异常，而客户没有调用close接口进行处理，DBConn只能吞下或结束程序。 条款09：绝不在析构和构造函数中调用virtual函数 派生类对象内的基类成分会在派生类自身成分被构造之前先被构造 基类构造期间，虚函数绝不会下降到派生类层 需要注意的是，有时类有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复时会把相同的初始化代码放到一个init函数中实现，如果这时在init函数中同样调用了虚函数，情况是一样的但比较隐秘。 条款10：令赋值操作符operator=返回一个reference to *this 为了实现连续赋值 条款11：在operator=中处理自我赋值 有些自我赋值并不明显，如通过指针或引用 假设你建立一个class来保存一个指针指向一块动态分配的位图（bitmap）： 1234567class Bitmap &#123;...&#125;;class Widget&#123; ...private: Bitmap* pb; // 指向一个从 heap 分配而得的对象&#125;; 错误的operator=实现为： 1234567// 自我赋值不安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs,pb); return *this;&#125; 可通过一个“证同测试”来检验： 12345678910// 自我赋值安全, 但不具备异常安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; if(this == &amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs,pb); return *this;&#125; 所谓的异常安全指的是，如果new Bitmap发生异常，会导致Widget最终会持有一个指针指向一块被删除的Bitmap。 12345678910// 具备异常安全, 则自动具备自我赋值安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* oldPb = pb; // 记住之前的 pb pb = new Bitmap(*rhs,pb); delete oldPb; return *this;&#125; 使用更好的copy and swap技术： 1234567891011121314151617181920212223class Bitmap &#123;...&#125;;class Widget&#123; ... void swap(Widget&amp; rhs) &#123; ... // 交换 *this 和 rhs 的数据, 见条款 25 &#125; ...&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; // 提升点效率 ? // if(this == &amp;rhs) // return *this; Widget temp(rhs); // copy swap(temp); // swap return *this;&#125; 条款12：复制对象时勿忘每一个成分 每一个成分包括对象内所有成员变量以及所继承的基类成分 在拷贝构造函数中的初始化列表中调用所继承的类的拷贝构造函数 在拷贝赋值操作符函数中调用所继承的类的拷贝赋值操作符函数 不要尝试让拷贝构造函数和拷贝赋值操作符函数互相调用","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++ 第一章","date":"2020-03-01T13:35:42.000Z","path":"20200301/","text":"第1章：让自己习惯C++条款01：视C++为一个语言联邦 将C++视为由4个次语言组成的联邦： C：没有模板、没有异常、没有重载… Object-Oriented C++：类、封装、继承、多态、虚函数、动态绑定等等； Template C++：泛型编程部分； STL：是一个Template程序库，容器、迭代器、算法以及函数对象。 从某个此语言切换到另一个时，高效编程守则可能会发生变化。比如，C-like类型（内置类型）pass by value更好；对于Object-Oriented C++而言，pass by reference to-const更好；再切换到STL，由于迭代器和函数对象都是在C指针之上塑造出来的，pass by value守则再次适用。 条款02：尽量以const，enum，inline替换#define 对于单纯常量，最好以const对象或enum hack替换#define 1234567891011121314// 记号名称未进入符号表, 难以调试// 在多处出现目标码, 尤其浮点常量// 无作用域概念, 不提供任何封装性#define ASPECT_RATIO 1.653// 常量会被编译器看到, 进入符号表// 导致较小量的目标码, 因为只有一份// 可放置在类内或 namespace 中限制其作用域const double AspectRatio = 1.653;// 可以放在类或 namespace 中// 令 NumTurns 成为 5 的记号名称, 一般用在类中做常量用// 行为像 #define, 对 const 取地址合法，对 enum 和 #define 取地址就不合法enum &#123;NumTurns = 5&#125;; 对于形似函数的宏，最好用inline（或模板）函数替换 宏中的变量有可能会被运算多次。 条款03：尽可能使用const const作用于迭代器 STL迭代器是以指针为根据塑模出来的，其作用就像个T*指针。声明迭代器为const只是声明一个const指针（作用就像T* const），表明的是迭代器本身不可变，但其所指的值是可以改动的。如果希望迭代器所指的值不可改动，需要的是const_iterator。 123456789std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();*iter = 10; // 正确++iter; // 错误std::vector&lt;int&gt;::const_iterator citer = vec.begin();*citer = 10; // 错误++citer; // 正确 将operator*的返回类型声明为const-by-value const可被施加于任何作用域内的对象、函数参数（常用pass-by-reference-to-const），函数返回类型、类成员函数本体 const施加于成员函数 成员函数上的const限定符意味着不能修改non-mutable，non-static类数据成员。 当const和non-const成员函数有着实质等价的实现时，令non-const成员函数调用const版本可避免代码重复 12345678910111213141516171819202122232425262728293031class TextBook&#123;public: ... const char&amp; operator[](std::size_t position) const &#123; ... // 边界检验 ... // 日记数据访问 ... // 检验数据完整性 return text[position]; &#125; /* char&amp; operator[](std::size_t position) &#123; ... // 边界检验 ... // 日记数据访问 ... // 检验数据完整性 return text[position]; &#125; */ char&amp; operator[](std::size_t position) &#123; // 调用 const_cast 移除对象身上的 const // 调用 static_cast 为 *this 加上 cosnt return const_cast&lt;char &amp;&gt;( static_cast&lt;const TextBook&amp;&gt;(*this)[position] ); &#125;private: std::string text;&#125;; const版本成员函数调用non-const版本不合法 条款04：确定对象被使用前已先被初始化 为内置型对象进行手工初始化，因为C++并不保证初始化它们 构造函数使用成员初始化列表，初始化顺序与在类中声明顺序一致 为避免“跨编译单元内定义的non-local static对象的初始化问题”，以local对象替换non-local static对象 static对象包括global对象、定义与namespace作用域内的对象、在class内、函数内、以及在file作用域内被声明为static的对象 函数内的static被称为local static对象，其它static对象被称为non-local static对象 程序结束时，static对象会被自动销毁，也就是它们的析构函数在main函数结束时被自动调用 编译单元是指产出单一目标文件的源码文件以及所含入的头文件 现在有两个源码文件，每个至少含入一个non-local static对象，其中一个non-local static对象用到了另一个non-local static对象，而被用到的尚未被初始化。 1234567891011121314151617181920212223// 文件 FileSystem.cpp 中class FileSystem&#123;public: ... std::size_t numDisks()const; // 众多成员函数之一 ...&#125;;extern FileSystem tfs; // 预备给客户使用的对象, non-local static 对象// 文件 Directory.cpp 中class Directory&#123;public: Directory(); // 构造函数 ...&#125;;Directory::Directory()&#123; ... std::size_t disks = tfs.numDisks(); // 使用 tfs 对象 ...&#125; 现在客户决定创建一个Directory对象，用来放置临时文件： 1Directory tempDir; // 为临时文件而做出的目录 这个时候就会出现初始化次序带来的问题。由于tfs和tempDir是不同的人在不同的时间于不同的源码文件中创建出来的，因此初始化次序不一定。 解决方法： 12345678910111213141516171819202122232425262728// 文件 FileSystem.cpp 中class FileSystem&#123;public: ... std::size_t numDisks() const; // 众多成员函数之一 ...&#125;;FileSystem&amp; tfs() // 用于创建预备给客户使用的对象的函数&#123; static FileSystem fs; // local static 对象 return fs;&#125;// 文件 Directory.cpp 中class Directory&#123;public: Directory(); // 构造函数 ...&#125;;Directory::Directory()&#123; ... // 这样就保证了被使用对象先被初始化 std::size_t disks = tfs().numDisks(); // 使用 tfs() 创建对象 ...&#125;","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]}]