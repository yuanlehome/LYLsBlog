<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#7d574c">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#7d574c">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuanlehome.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="寒江孤影-江湖故人-相逢何必曾相识">
<meta property="og:type" content="website">
<meta property="og:title" content="LYL&#39;s Blog">
<meta property="og:url" content="https://yuanlehome.github.io/index.html">
<meta property="og:site_name" content="LYL&#39;s Blog">
<meta property="og:description" content="寒江孤影-江湖故人-相逢何必曾相识">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Liu Y.L.">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yuanlehome.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>LYL's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LYL's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/tfQ2R0ndWz4uaMUM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tfQ2R0ndWz4uaMUM/" class="post-title-link" itemprop="url">设计模式之模板模式（Template）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-08 21:35:42" itemprop="dateCreated datePublished" datetime="2021-10-08T21:35:42+08:00">2021-10-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、动机"><a href="#一、动机" class="headerlink" title="一、动机"></a>一、动机</h5><p>模板方法模式是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。</p>
<p>对于某一项任务，常常有稳定的整体操作结构，但是各个子步骤却有很多改变的需求如何确定稳定操作的前提下，来灵活应对各个子步骤的变化或者晚期实现的需求？ </p>
<h5 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h5><p><code>Template Method</code>是一种非常基础的设计模式，它用最简洁的机制（虚函数的多态性）为很多应用框架提供了灵活的扩展点，是代码复用方法的基本实现结构。</p>
<p>模板方法模式建议将算法分解为一系列步骤，然后将这些步骤改写为方法，最后在 “模板方法” 中依次调用这些方法。步骤可以是抽象的（但一般推荐设置为<code>protected</code>方法，主要是因为这种方法一般不作为接口，而是作为流程中的某一个实现步骤），也可以有一些默认的实现。</p>
<p>为了能够使用算法，客户端需要自行提供子类并实现所有的抽象步骤。如有必要还需重写一些步骤 （但这一步中不包括模板方法自身）。</p>
<h5 id="三、模板模式的结构"><a href="#三、模板模式的结构" class="headerlink" title="三、模板模式的结构"></a>三、模板模式的结构</h5><p><img src="structure_of_Template.png" alt="structure_of_Template"></p>
<ol>
<li><strong>抽象类</strong>（<code>Abstract­Class</code>）会声明作为算法步骤的方法，以及依次调用它们的实际模板方法。算法步骤可以被声明为抽象类型，也可以提供一些默认实现。</li>
<li><strong>具体类</strong>（<code>Concrete­Class</code>）可以重写所有步骤，但不能重写模板方法自身。</li>
</ol>
<h5 id="四、Template代码示例"><a href="#四、Template代码示例" class="headerlink" title="四、Template代码示例"></a>四、<code>Template</code>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类，声明作为算法步骤的方法，以及依次调用它们的实际模板方法。</span></span><br><span class="line"><span class="comment">// 其中，算法步骤可以被声明为抽象类型，也可以给出一些默认的实现。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AbstractClass() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractClass() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BaseOperation1();</span><br><span class="line">        RequiredOperations1();</span><br><span class="line">        BaseOperation2();</span><br><span class="line">        Hook1();</span><br><span class="line">        RequiredOperation2();</span><br><span class="line">        BaseOperation3();</span><br><span class="line">        Hook2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 默认实现部分步骤方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BaseOperation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AbstractClass says: I am doing the bulk of the work\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BaseOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AbstractClass says: But I let subclasses override some operations\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BaseOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"AbstractClass says: But I am doing the bulk of the work anyway\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将需要由具体类实现的步骤声明为虚函数</span></span><br><span class="line">    <span class="comment">// 变化部分</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RequiredOperations1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RequiredOperation2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这些方法不是强制的要求具体类实现，因为他们已经被定义了（虽然并不做任何动作）</span></span><br><span class="line">    <span class="comment">// 它们可以为算法模板提供一些可供具体类修改的扩展点</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Hook1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Hook2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体类需要实现抽象类的所有抽象方法</span></span><br><span class="line"><span class="comment">// 也可以覆盖一些已经默认实现的步骤方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> :</span> <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RequiredOperations1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteClass1 says: Implemented Operation1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RequiredOperation2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteClass1 says: Implemented Operation2\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> :</span> <span class="keyword">public</span> AbstractClass &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RequiredOperations1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteClass2 says: Implemented Operation1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RequiredOperation2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteClass2 says: Implemented Operation2\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Hook1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteClass2 says: Overridden Hook1\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">(AbstractClass *class_)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    class_-&gt;TemplateMethod();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Same client code can work with different subclasses:\n"</span>;</span><br><span class="line">    ConcreteClass1 *concreteClass1 = <span class="keyword">new</span> ConcreteClass1;</span><br><span class="line">    ClientCode(concreteClass1);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Same client code can work with different subclasses:\n"</span>;</span><br><span class="line">    ConcreteClass2 *concreteClass2 = <span class="keyword">new</span> ConcreteClass2;</span><br><span class="line">    ClientCode(concreteClass2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> concreteClass1;</span><br><span class="line">    <span class="keyword">delete</span> concreteClass2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Execution result:</span><br><span class="line">    Same client code can work with different subclasses:</span><br><span class="line">    AbstractClass says: I am doing the bulk of the work</span><br><span class="line">    ConcreteClass1 says: Implemented Operation1</span><br><span class="line">    AbstractClass says: But I let subclasses <span class="keyword">override</span> some operations</span><br><span class="line">    ConcreteClass1 says: Implemented Operation2</span><br><span class="line">    AbstractClass says: But I am doing the bulk of the work anyway</span><br><span class="line"></span><br><span class="line">    Same client code can work with different subclasses:</span><br><span class="line">    AbstractClass says: I am doing the bulk of the work</span><br><span class="line">    ConcreteClass2 says: Implemented Operation1</span><br><span class="line">    AbstractClass says: But I let subclasses <span class="keyword">override</span> some operations</span><br><span class="line">    ConcreteClass2 says: Overridden Hook1</span><br><span class="line">    ConcreteClass2 says: Implemented Operation2</span><br><span class="line">    AbstractClass says: But I am doing the bulk of the work anyway</span><br></pre></td></tr></table></figure>

<h5 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h5><ul>
<li>当你只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时，可使用模板方法模式。</li>
</ul>
<blockquote>
<p>模板方法将整个算法转换为一系列独立的步骤，以便子类能对其进行扩展，同时还可让超类中所定义的结构保持完整。</p>
</blockquote>
<ul>
<li>当多个类的算法除一些细微不同之外几乎完全一样时，你可使用该模式。但其后果就是，只要算法发生变化，你就可能需要修改所有的类。</li>
</ul>
<blockquote>
<p>在将算法转换为模板方法时，你可将相似的实现步骤提取到超类中以去除重复代码。子类间各不同的代码可继续保留在子类中。</p>
</blockquote>
<h5 id="六、优缺点"><a href="#六、优缺点" class="headerlink" title="六、优缺点"></a>六、优缺点</h5><ul>
<li>你可仅允许客户端重写一个大型算法中的特定部分，使得算法其他部分修改对其所造成的影响减小。</li>
<li>你可将重复代码提取到一个超类中。</li>
<li><del>部分客户端可能会受到算法框架的限制。</del></li>
<li><del>通过子类抑制默认步骤实现可能会导致违反里氏替换原则。</del></li>
<li><del>模板方法中的步骤越多，其维护工作就可能会越困难。</del></li>
</ul>
<h5 id="七、与其它模式的关系"><a href="#七、与其它模式的关系" class="headerlink" title="七、与其它模式的关系"></a>七、与其它模式的关系</h5><ul>
<li>工厂方法模式是模板方法模式的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。</li>
<li>模板方法基于继承机制：它允许你通过扩展子类中的部分内容来改变部分算法。策略模式基于组合机制：你可以通过对相应行为提供不同的策略来改变对象的部分行为。模板方法在类层次上运作，因此它是静态的。策略在对象层次上运作，因此允许在运行时切换行为。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/qc1TeyddGlAeNzht/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/qc1TeyddGlAeNzht/" class="post-title-link" itemprop="url">设计模式之策略模式（Strategy）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-01 21:35:42" itemprop="dateCreated datePublished" datetime="2021-10-01T21:35:42+08:00">2021-10-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、动机"><a href="#一、动机" class="headerlink" title="一、动机"></a>一、动机</h5><p>策略模式是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。</p>
<h5 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h5><p>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。</p>
<p>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</p>
<p>策略模式建议找出负责用许多不同方式完成特定任务的类，然后将其中的算法抽取到一组被称为策略的独立类中。</p>
<p>名为<code>Context</code>（上下文）的原始类必须包含一个成员变量来存储对于每种策略的引用。<code>Context</code>并不执行任务，而是将工作委派给已连接的策略对象。</p>
<p><code>Context</code>不负责选择符合任务需要的算法——客户端会将所需策略传递给<code>Context</code>。实际上，<code>Context</code>并不十分了解策略，它会通过同样的通用接口与所有策略进行交互，而该接口只需暴露一个方法来触发所选策略中封装的算法即可。</p>
<p>因此，<code>Context</code>可独立于具体策略。这样你就可在不修改<code>Context</code>代码或其他策略的情况下添加新算法或修改已有算法了。</p>
<h5 id="三、策略模式的结构"><a href="#三、策略模式的结构" class="headerlink" title="三、策略模式的结构"></a>三、策略模式的结构</h5><p><img src="structure_of_Strategy.png" alt="structure_of_Strategy"></p>
<ol>
<li><strong>上下文</strong>（<code>Context</code>）维护指向具体策略的引用，且仅通过策略接口与该对象进行交流。</li>
<li><strong>策略</strong>（<code>Strategy</code>）接口是所有具体策略的通用接口，它声明了一个上下文用于执行策略的方法。</li>
<li><strong>具体策略</strong>（<code>Concrete Strategies</code>）实现了上下文所用算法的各种不同变体。</li>
<li>当上下文需要运行算法时，它会在其已连接的策略对象上调用执行方法。上下文不清楚其所涉及的策略类型与算法的执行方式。</li>
<li><strong>客户端</strong>（<code>Client</code>）会创建一个特定策略对象并将其传递给上下文。上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。</li>
</ol>
<h5 id="四、Strategy代码示例"><a href="#四、Strategy代码示例" class="headerlink" title="四、Strategy代码示例"></a>四、<code>Strategy</code>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象策略，声明了不同策略所具有特定算法的接口</span></span><br><span class="line"><span class="comment">// Context 类会使用该接口来调用不同策略对应的算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Strategy() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Strategy() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 策略接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doAlgorithm</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略1，遵循抽象策略接口所声明的算法规范</span></span><br><span class="line"><span class="comment">// 实现它们在上下文中的互换性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> :</span> <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteStrategy1() &#123;&#125;</span><br><span class="line">    ~ConcreteStrategy1() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doAlgorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteStrategy1's doAlgorithm!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy2</span> :</span> <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteStrategy2() &#123;&#125;</span><br><span class="line">    ~ConcreteStrategy2() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doAlgorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteStrategy2's doAlgorithm!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy3</span> :</span> <span class="keyword">public</span> Strategy &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteStrategy3() &#123;&#125;</span><br><span class="line">    ~ConcreteStrategy3() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doAlgorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteStrategy3's doAlgorithm!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文定义了客户端关注的接口（绑定不同策略）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> &#123;</span></span><br><span class="line">    <span class="comment">// 上下文会维护指向某个策略对象的引用。它不知晓策略的具体类。</span></span><br><span class="line">    <span class="comment">// 上下文必须通过策略接口来与所有策略进行交互。</span></span><br><span class="line">    Strategy *m_strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Context(Strategy *strategy) : m_strategy(strategy) &#123;&#125;</span><br><span class="line">    ~Context() &#123; <span class="keyword">delete</span> m_strategy; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上下文通常会通过构造函数来接收策略对象</span></span><br><span class="line">    <span class="comment">// 同时还提供设置器以便在运行时切换策略</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy *strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_strategy;</span><br><span class="line">        m_strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上下文会将一些工作委派给策略对象，而不是自行实现不同策略的算法。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">executeStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_strategy-&gt;doAlgorithm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码会选择具体策略并将其传递给上下文</span></span><br><span class="line"><span class="comment">// 客户端必须知晓策略之间的差异，才能做出正确的选择。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context *context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategy1);</span><br><span class="line">    context-&gt;executeStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    context-&gt;setStrategy(<span class="keyword">new</span> ConcreteStrategy2);</span><br><span class="line">    context-&gt;executeStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    context-&gt;setStrategy(<span class="keyword">new</span> ConcreteStrategy3);</span><br><span class="line">    context-&gt;executeStrategy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clientCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Execution result:</span><br><span class="line">    ConcreteStrategy1<span class="number">'</span>s doAlgorithm!</span><br><span class="line"></span><br><span class="line">    ConcreteStrategy2<span class="number">'</span>s doAlgorithm!</span><br><span class="line"></span><br><span class="line">    ConcreteStrategy3<span class="number">'</span>s doAlgorithm!</span><br></pre></td></tr></table></figure>

<h5 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h5><ul>
<li>你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。</li>
</ul>
<blockquote>
<p>策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象， 从而以间接方式在运行时更改对象行为。</p>
</blockquote>
<ul>
<li>你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。</li>
</ul>
<blockquote>
<p>模式让你能将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码。</p>
</blockquote>
<ul>
<li>如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。</li>
</ul>
<blockquote>
<p>让你能将各种算法的代码、 内部数据和依赖关系与其他代码隔离开来。 不同客户端可通过一个简单接口执行算法， 并能在运行时进行切换。</p>
</blockquote>
<ul>
<li>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。</li>
</ul>
<blockquote>
<p>策略模式将所有继承自同样接口的算法抽取到独立类中， 因此不再需要条件语句。 原始对象并不实现所有算法的变体， 而是将执行工作委派给其中的一个独立算法对象。</p>
</blockquote>
<h5 id="六、优缺点"><a href="#六、优缺点" class="headerlink" title="六、优缺点"></a>六、优缺点</h5><ul>
<li>你可以在运行时切换对象内的算法。</li>
<li>你可以将算法的实现和使用算法的代码隔离开来。</li>
<li>你可以使用组合来代替继承。</li>
<li>开闭原则。你无需对上下文进行修改就能够引入新的策略。</li>
<li><del>如果你的算法极少发生改变，那么没有任何理由引入新的类和接口。使用该模式只会让程序过于复杂。</del></li>
<li><del>客户端必须知晓策略间的不同——它需要选择合适的策略。</del></li>
<li><del>许多现代编程语言支持函数类型功能，允许你在一组匿名函数中实现不同版本的算法。 这样，你使用这些函数的方式就和使用策略对象时完全相同，无需借助额外的类和接口来保持代码简洁。</del></li>
</ul>
<h5 id="七、与其它模式的关系"><a href="#七、与其它模式的关系" class="headerlink" title="七、与其它模式的关系"></a>七、与其它模式的关系</h5><ul>
<li>桥接模式、状态模式和策略模式（在某种程度上包括适配器模式）模式的接口非常相似。实际上,它们都基于组合模式——即将工作委派给其他对象，不过也各自解决了不同的问题。模式并不只是以特定方式组织代码的配方，你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li>命令模式和策略看上去很像，因为两者都能通过某些行为来参数化对象。但是，它们的意图有非常大的不同。<ul>
<li>你可以使用命令来将任何操作转换为对象。操作的参数将成为对象的成员变量。你可以通过转换来延迟操作的执行、将操作放入队列、保存历史命令或者向远程服务发送命令等。</li>
<li>另一方面，策略通常可用于描述完成某件事的不同方式，让你能够在同一个上下文类中切换算法。</li>
</ul>
</li>
<li>装饰模式可让你更改对象的外表，策略则让你能够改变其本质。</li>
<li>模板方法模式基于继承机制：它允许你通过扩展子类中的部分内容来改变部分算法。策略基于组合机制：你可以通过对相应行为提供不同的策略来改变对象的部分行为。模板方法在类层次上运作，因此它是静态的。策略在对象层次上运作，因此允许在运行时切换行为。</li>
<li>状态可被视为策略的扩展。两者都基于组合机制：它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。策略使得这些对象相互之间完全独立，它们不知道其他对象的存在。但状态模式没有限制具体状态之间的依赖，且允许它们自行改变在不同情景下的状态。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/sCobB6Qf6u1mGzZI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/sCobB6Qf6u1mGzZI/" class="post-title-link" itemprop="url">设计模式之装饰器模式（Decorator）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-27 21:35:42" itemprop="dateCreated datePublished" datetime="2021-09-27T21:35:42+08:00">2021-09-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、动机"><a href="#一、动机" class="headerlink" title="一、动机"></a>一、动机</h5><p>某些情况下我们可能会”过度的使用继承来扩展对象的功能“，由于继承为类型引入的静态特质（编译时装饰），使得这种扩展缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致子类的膨胀。</p>
<p>如何使得”对象功能的扩展“能够根据需求来动态的实现？同时避免”扩展功能的增多“带来的子类膨胀问题？从而使得任何”功能扩展变化“所导致的影响降为最低。</p>
<p>装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，<code>Decorator</code>模式比生成子类（继承）更为灵活（消除重复代码以及减少子类个数）。</p>
<h5 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h5><p>当你需要更改一个对象的行为时，其中一个想法就是扩展它所属的类（使用继承）。 但是， 继承可能引发一个严重的问题。</p>
<ul>
<li>继承是静态的。 你无法在运行时更改已有对象的行为， 只能使用由不同子类创建的对象来替代当前的整个对象。</li>
<li>当子类过多时，将会造成子类代码膨胀。</li>
</ul>
<p>另一个方法是使用组合。两者的工作方式几乎一模一样：一个对象包含指向另一个对象的引用，并将部分工作委派给引用对象；继承中的对象则继承了父类的行为，它们自己能够完成这些工作。</p>
<p><img src="Inheritance_and_Aggregation.png" alt="Inheritance_and_Aggregation"></p>
<p>通过采用组合而非继承的手法，<code>Decorator</code>模式实现了再运行时动态扩展对象功能的能力，而且可以根据需求扩展多个功能。避免了使用继承带来的”灵活性差“和”多子类衍生问题”。</p>
<p><code>Decorator</code>类在接口上表现为<code>is-a Component</code>的继承关系，即<code>Decorator</code>类继承了<code>Component</code>类所具有的接口。但是在实现上又表现为<code>has-a Component</code>的组合关系，即<code>Decorator</code>类有使用另外一个<code>Component</code>类。</p>
<p><code>Decorator</code>模式的目的并非解决”多子类衍生的多继承“问题，其要点在于解决”主体类在多个方向上的扩展功能“——实为”装饰“的含义。</p>
<h5 id="三、装饰器模式的结构"><a href="#三、装饰器模式的结构" class="headerlink" title="三、装饰器模式的结构"></a>三、装饰器模式的结构</h5><p><img src="structure_of_Decorator.png" alt="structure_of_Decorator"></p>
<ol>
<li><strong>部件</strong>（<code>Component</code>）声明封装器和被封装对象的公用接口。</li>
<li><strong>具体部件</strong>（<code>Concrete Component</code>）类是被封装对象所属的类。它定义了基础行为，但装饰类可以改变这些行为。</li>
<li><strong>基础装饰</strong>（<code>Base Decorator</code>）类拥有一个指向被封装对象的引用成员变量。该变量的类型应当被声明为通用部件接口，这样它就可以引用具体的部件和装饰。装饰基类会将所有操作委派给被封装的对象。</li>
<li><strong>具体装饰类</strong>（<code>Concrete Decorators</code>）定义了可动态添加到部件的额外行为。具体装饰类会重写装饰基类的方法，并在调用父类方法之前或之后进行额外的行为。</li>
<li><strong>客户端</strong>（<code>Client</code>）可以使用多层装饰来封装部件，只要它能使用通用接口与所有对象互动即可。</li>
</ol>
<h5 id="四、Decorator代码示例"><a href="#四、Decorator代码示例" class="headerlink" title="四、Decorator代码示例"></a>四、Decorator代码示例</h5><p>穿衣服是使用装饰的一个例子。觉得冷时，你可以穿一件毛衣。如果穿毛衣还觉得冷，你可以再套上一件夹克。如果遇到下雨，你还可以再穿一件雨衣。所有这些衣物都 “扩展” 了你的基本行为，但它们并不是你的一部分，如果你不再需要某件衣物，可以方便地随时脱掉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本组件，是一个抽象类，声明了一个封装器和被封装对象的公用接口。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wear_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wear_base() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Wear_base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">wearing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件类，是被封装对象所属的类。</span></span><br><span class="line"><span class="comment">// 它只定义了基础的行为，但装饰器类可以扩展这一行为。</span></span><br><span class="line"><span class="comment">// 如在本例子中，一个人只穿了内衣。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wear_underwear</span> :</span> <span class="keyword">public</span> Wear_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wear_underwear() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Wear_underwear() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">wearing</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这一行包括下面同一位置处的代码，用于调试时。</span></span><br><span class="line">        <span class="comment">// 用于观察运行过程中此接口函数的调用顺序。</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wear_underwear::wearing()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(underwear)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本装饰类，拥有一个被封装对象的引用成员变量，应被声明为基本组件的引用。</span></span><br><span class="line"><span class="comment">// 这样它就可以利用多态调用具体组件的接口。</span></span><br><span class="line"><span class="comment">// 同时也继承了基本组件类。用于规范具体装饰类的接口函数。</span></span><br><span class="line"><span class="comment">// 装饰基类会将所有操作委派给被封装的对象。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorWear</span> :</span> <span class="keyword">public</span> Wear_base &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Wear_base *m_wear_base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DecoratorWear(Wear_base *wear_base) : m_wear_base(wear_base) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~DecoratorWear() &#123; <span class="keyword">delete</span> m_wear_base; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">wearing</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DecoratorWear::wearing()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> m_wear_base-&gt;wearing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰类，其中定义了可动态添加到具体组件的扩展行为。</span></span><br><span class="line"><span class="comment">// 重写了装饰基类的方法，并且在调用装饰基类方法之前进行行为的扩展。</span></span><br><span class="line"><span class="comment">// 本例为扩展穿裤子行为</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wear_pants</span> :</span> <span class="keyword">public</span> DecoratorWear &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wear_pants(Wear_base *wear_base) : DecoratorWear(wear_base) &#123;&#125;</span><br><span class="line">    ~Wear_pants() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">wearing</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wear_pants::wearing()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(pants"</span> + DecoratorWear::wearing() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本例为扩展穿T-恤衫行为</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wear_sweatshirt</span> :</span> <span class="keyword">public</span> DecoratorWear &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wear_sweatshirt(Wear_base *wear_base) : DecoratorWear(wear_base) &#123;&#125;</span><br><span class="line">    ~Wear_sweatshirt() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">wearing</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wear_sweatshirt::wearing()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(sweatshirt"</span> + DecoratorWear::wearing() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本例为扩展穿外套行为</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wear_jacket</span> :</span> <span class="keyword">public</span> DecoratorWear &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Wear_jacket(Wear_base *wear_base) : DecoratorWear(wear_base) &#123;&#125;</span><br><span class="line">    ~Wear_jacket() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">wearing</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wear_jacket::wearing()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(jacket"</span> + DecoratorWear::wearing() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端，使用通用接口与扩展后的最终对象进行互动。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientCode</span><span class="params">(Wear_base *Wear_base)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Wear_base-&gt;wearing() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最开始是只穿了内衣的具体组件对象</span></span><br><span class="line">    Wear_base *w = <span class="keyword">new</span> Wear_underwear();</span><br><span class="line">    <span class="comment">// 先穿裤子</span></span><br><span class="line">    Wear_base *d1 = <span class="keyword">new</span> Wear_pants(w);</span><br><span class="line">    <span class="comment">// 再穿T-恤衫</span></span><br><span class="line">    Wear_base *d2 = <span class="keyword">new</span> Wear_sweatshirt(d1);</span><br><span class="line">    <span class="comment">// 最后穿上外套</span></span><br><span class="line">    Wear_base *d3 = <span class="keyword">new</span> Wear_jacket(d2);</span><br><span class="line"></span><br><span class="line">    clientCode(d3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DecoratorWear 析构函数里面已经写了释放 delete</span></span><br><span class="line">    <span class="comment">// delete w;</span></span><br><span class="line">    <span class="comment">// delete d1;</span></span><br><span class="line">    <span class="comment">// delete d2;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后形成的对象仍然需要自行 delete</span></span><br><span class="line">    <span class="keyword">delete</span> d3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Execution result:</span><br><span class="line">    Wear_jacket::wearing()</span><br><span class="line">    DecoratorWear::wearing()</span><br><span class="line">    Wear_sweatshirt::wearing()</span><br><span class="line">    DecoratorWear::wearing()</span><br><span class="line">    Wear_pants::wearing()</span><br><span class="line">    DecoratorWear::wearing()</span><br><span class="line">    Wear_underwear::wearing()</span><br><span class="line">    (jacket(sweatshirt(pants(underwear))))</span><br></pre></td></tr></table></figure>

<h5 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h5><ul>
<li>如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式。</li>
</ul>
<blockquote>
<p>装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。</p>
</blockquote>
<ul>
<li>如果用继承来扩展对象行为的方案难以实现或者根本不可行，你可以使用该模式。</li>
</ul>
<blockquote>
<p>许多编程语言使用 <code>final</code>最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式：用封装器对其进行封装。</p>
</blockquote>
<h5 id="六、优缺点"><a href="#六、优缺点" class="headerlink" title="六、优缺点"></a>六、优缺点</h5><ul>
<li><p>你无需创建新子类即可扩展对象的行为。</p>
</li>
<li><p>你可以在运行时添加或删除对象的功能。</p>
</li>
<li><p>你可以用多个装饰封装对象来组合几种行为。</p>
</li>
<li><p>单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</p>
</li>
<li><p><del>在封装器栈中删除特定封装器比较困难。</del></p>
</li>
<li><p><del>实现行为不受装饰栈顺序影响的装饰比较困难。</del></p>
</li>
<li><p><del>各层的初始化配置代码看上去可能会很糟糕。</del></p>
</li>
</ul>
<h5 id="七、与其它模式的关系"><a href="#七、与其它模式的关系" class="headerlink" title="七、与其它模式的关系"></a>七、与其它模式的关系</h5><ul>
<li><p>适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p>
</li>
<li><p>适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</p>
</li>
<li><p>责任链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p>
<p>  责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p>
</li>
<li><p>组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>  装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>  但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li><p>大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
<li><p>装饰可让你更改对象的外表， 策略模式则让你能够改变其本质。</p>
</li>
<li><p>装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/iLIZBP2xmcHRS1WW/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iLIZBP2xmcHRS1WW/" class="post-title-link" itemprop="url">设计模式之观察者模式（Observer）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-24 21:35:42" itemprop="dateCreated datePublished" datetime="2021-09-24T21:35:42+08:00">2021-09-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、动机"><a href="#一、动机" class="headerlink" title="一、动机"></a>一、动机</h5><p>观察者模式是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p>
<p>在软件构建过程中，我们需要为某些对象建立一种”通知依赖关系“——一个对象(目标对象)的状态发生改变（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好的抵御变化。使用面向对象技术，可以将这种依赖关系弱化，并能形成一定的依赖关系，从而实现软件体系结构的松耦合。</p>
<h5 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h5><p>拥有一些值得关注的状态的对象通常被称为<em>目标</em>，由于它要将自身的状态改变通知给其他对象，我们也将其称为<em>发布者</em>（<code>publisher</code>）。所有希望关注发布者状态变化的其他对象被称为<em>订阅者</em>（<code>subscribers</code>）。</p>
<p>观察者模式建议你为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。 不要害怕！这并不像听上去那么复杂。实际上，该机制包括1）一个用于存储订阅者对象引用的列表成员变量；2）几个用于添加或删除该列表中订阅者的公有方法。</p>
<p><img src="observer1.png" alt="observer1"></p>
<p>现在，无论何时发生了重要的发布者事件，它都要遍历订阅者并调用其对象的特定通知方法。</p>
<p>实际应用中可能会有十几个不同的订阅者类跟踪着同一个发布者类的事件，你不会希望发布者与所有这些类相耦合的。此外如果他人会使用发布者类，那么你甚至可能会对其中的一些类一无所知。</p>
<p>因此，所有订阅者都必须实现同样的接口，发布者仅通过该接口与订阅者交互。接口中必须声明通知方法及其参数，这样发布者在发出通知时还能传递一些上下文数据。</p>
<p><img src="observer2.png" alt="observer2"></p>
<p>使用面向对象的抽象，<code>Observer</code>模式使得可独立的改变目标与观察者，从而使得二者之间的依赖关系达致松耦合。目标发送通知的时候，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。观察者自己决定是否需要订阅通知，目标对象对此一无所知。</p>
<h3 id="三、观察者模式的结构"><a href="#三、观察者模式的结构" class="headerlink" title="三、观察者模式的结构"></a>三、观察者模式的结构</h3><p><img src="structure_of_Observer.png" alt="structure_of_Observer"></p>
<ol>
<li><strong>发布者</strong>（<code>Publisher</code>）会向其他对象发送值得关注的事件。事件会在发布者自身状态改变或执行特定行为后发生。发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</li>
<li>当新事件发生时，发送者会遍历订阅列表并调用每个订阅者对象的通知方法。该方法是在订阅者接口中声明的。</li>
<li><strong>订阅者</strong>（<code>Subscriber</code>）接口声明了通知接口。在绝大多数情况下，该接口仅包含一个 <code>update</code>更新方法。该方法可以拥有多个参数，使发布者能在更新时传递事件的详细信息。</li>
<li><strong>具体订阅者</strong>（<code>Concrete Subscribers</code>）可以执行一些操作来回应发布者的通知。所有具体订阅者类都实现了同样的接口，因此发布者不需要与具体类相耦合。</li>
<li>订阅者通常需要一些上下文信息来正确地处理更新。因此，发布者通常会将一些上下文数据作为通知方法的参数进行传递。发布者也可将自身作为参数进行传递，使订阅者直接获取所需的数据。</li>
<li><strong>客户端</strong>（<code>Client</code>）会分别创建发布者和订阅者对象，然后为订阅者注册发布者更新。</li>
</ol>
<h5 id="四、Observer代码示例"><a href="#四、Observer代码示例" class="headerlink" title="四、Observer代码示例"></a>四、<code>Observer</code>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者抽象基类</span></span><br><span class="line"><span class="comment">// 声明了所有具体订阅者同意接受更新信息的接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Subscriber() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Subscriber() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者类</span></span><br><span class="line"><span class="comment">// 包含订阅管理代码和通知方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 拥有一个 map，用来存放订阅者 ID 和实际订阅者之间的映射</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>, Subscriber *&gt; subscribers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Publisher() &#123;&#125;</span><br><span class="line">    ~Publisher() &#123;&#125;</span><br><span class="line">    <span class="comment">// 发布者通过此方法通知所有的订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifySubscribers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Publisher: I'm publisher, updating all subscribers."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s : subscribers) &#123;</span><br><span class="line">            s.second-&gt;update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布者提供一个可供订阅者订阅的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">size_t</span> sid, Subscriber *s)</span> </span>&#123;</span><br><span class="line">        subscribers[sid] = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布者提供一个可供订阅者取消订阅的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="keyword">size_t</span> sid)</span> </span>&#123;</span><br><span class="line">        subscribers.erase(sid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目前共有多少个订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howManyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Publisher: There are "</span> &lt;&lt; subscribers.size() &lt;&lt; <span class="string">" observers."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 具体的订阅者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">concreteSubscriber</span> :</span> <span class="keyword">public</span> Subscriber &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//拥有一个发布者的引用，用来调用发布者的订阅管理代码</span></span><br><span class="line">    Publisher *m_publisher;</span><br><span class="line">    <span class="comment">// 订阅者 ID</span></span><br><span class="line">    <span class="keyword">size_t</span> m_ID;</span><br><span class="line">    <span class="comment">// 此静态成员变量表示已有订阅者中最大的 ID</span></span><br><span class="line">    <span class="comment">// 静态成员，用来更新新注册的订阅者的 ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> maxID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    concreteSubscriber(Publisher *publisher) : m_publisher(publisher), m_ID(concreteSubscriber::maxID + <span class="number">1</span>) &#123;</span><br><span class="line">        concreteSubscriber::maxID++;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Subscriber: Hello, My ID = "</span> &lt;&lt; m_ID &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~concreteSubscriber() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Subscriber: Goodbye, My ID = "</span> &lt;&lt; m_ID &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发布者通过调用此方法来通知每个订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Subscriber: My ID = "</span> &lt;&lt; m_ID &lt;&lt; <span class="string">", I'm updated."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Subscriber: My ID = "</span> &lt;&lt; m_ID &lt;&lt; <span class="string">", I'm subscribed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        m_publisher-&gt;subscribe(m_ID, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Subscriber: My ID = "</span> &lt;&lt; m_ID &lt;&lt; <span class="string">", I'm unsubscribed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        m_publisher-&gt;unsubscribe(m_ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> concreteSubscriber::maxID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端程序可在运行时配置发布者和订阅者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Publisher *publisher = <span class="keyword">new</span> Publisher;</span><br><span class="line"></span><br><span class="line">    concreteSubscriber *subscriber1 = <span class="keyword">new</span> concreteSubscriber(publisher);</span><br><span class="line">    concreteSubscriber *subscriber2 = <span class="keyword">new</span> concreteSubscriber(publisher);</span><br><span class="line">    concreteSubscriber *subscriber3 = <span class="keyword">new</span> concreteSubscriber(publisher);</span><br><span class="line"></span><br><span class="line">    subscriber1-&gt;subscribe();</span><br><span class="line">    subscriber2-&gt;subscribe();</span><br><span class="line">    subscriber3-&gt;subscribe();</span><br><span class="line"></span><br><span class="line">    publisher-&gt;notifySubscribers();</span><br><span class="line"></span><br><span class="line">    subscriber2-&gt;unsubscribe();</span><br><span class="line"></span><br><span class="line">    publisher-&gt;notifySubscribers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> subscriber1;</span><br><span class="line">    <span class="keyword">delete</span> subscriber2;</span><br><span class="line">    <span class="keyword">delete</span> subscriber3;</span><br><span class="line">    <span class="keyword">delete</span> publisher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clientCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Execution result:</span><br><span class="line">    Subscriber: Hello, My ID = <span class="number">1.</span></span><br><span class="line">    Subscriber: Hello, My ID = <span class="number">2.</span></span><br><span class="line">    Subscriber: Hello, My ID = <span class="number">3.</span></span><br><span class="line">    Subscriber: My ID = <span class="number">1</span>, I<span class="number">'</span>m subscribed.</span><br><span class="line">    Subscriber: My ID = <span class="number">2</span>, I<span class="number">'</span>m subscribed.</span><br><span class="line">    Subscriber: My ID = <span class="number">3</span>, I<span class="number">'</span>m subscribed.</span><br><span class="line">    Publisher: There are <span class="number">3</span> observers.</span><br><span class="line">    Publisher: I<span class="number">'</span>m publisher, updating all subscribers.</span><br><span class="line">    Subscriber: My ID = <span class="number">3</span>, I<span class="number">'</span>m updated.</span><br><span class="line">    Subscriber: My ID = <span class="number">1</span>, I<span class="number">'</span>m updated.</span><br><span class="line">    Subscriber: My ID = <span class="number">2</span>, I<span class="number">'</span>m updated.</span><br><span class="line">    Subscriber: My ID = <span class="number">2</span>, I<span class="number">'</span>m unsubscribed.</span><br><span class="line">    Publisher: There are <span class="number">2</span> observers.</span><br><span class="line">    Publisher: I<span class="number">'</span>m publisher, updating all subscribers.</span><br><span class="line">    Subscriber: My ID = <span class="number">3</span>, I<span class="number">'</span>m updated.</span><br><span class="line">    Subscriber: My ID = <span class="number">1</span>, I<span class="number">'</span>m updated.</span><br><span class="line">    Subscriber: Goodbye, My ID = <span class="number">1.</span></span><br><span class="line">    Subscriber: Goodbye, My ID = <span class="number">2.</span></span><br><span class="line">    Subscriber: Goodbye, My ID = <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<h5 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h5><ul>
<li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的时，可使用观察者模式。</li>
</ul>
<blockquote>
<p>当你使用图形用户界面类时通常会遇到一个问题。比如，你创建了自定义按钮类并允许客户端在按钮中注入自定义代码，这样当用户按下按钮时就会触发这些代码。观察者模式允许任何实现了订阅者接口的对象订阅发布者对象的事件通知。你可在按钮中添加订阅机制，允许客户端通过自定义订阅类注入自定义代码。</p>
</blockquote>
<ul>
<li><p>当应用中的一些对象必须观察其他对象时，可使用该模式。但仅能在有限时间内或特定情况下使用。</p>
<blockquote>
<p>订阅列表是动态的， 因此订阅者可随时加入或离开该列表。</p>
</blockquote>
</li>
</ul>
<h5 id="六、优缺点"><a href="#六、优缺点" class="headerlink" title="六、优缺点"></a>六、优缺点</h5><ul>
<li><em>开闭原则</em>。你无需修改发布者代码就能引入新的订阅者类（如果是发布者接口则可轻松引入发布者类）。</li>
<li>你可以在运行时建立对象之间的联系。</li>
<li><del>订阅者的通知顺序是随机的。</del></li>
</ul>
<h5 id="七、与其它模式的关系"><a href="#七、与其它模式的关系" class="headerlink" title="七、与其它模式的关系"></a>七、与其它模式的关系</h5><ul>
<li><p><strong>责任链模式</strong>、<strong>命令模式</strong>、<strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li><strong>责任链</strong>按照顺序将请求动态传递给一系列的潜在接收者，直至其中一名接收者对请求进行处理。</li>
<li><strong>命令</strong>在发送者和请求者之间建立单向连接。</li>
<li><strong>中介者</strong>清除了发送者和请求者之间的直接连接，强制它们通过一个中介对象进行间接沟通。</li>
<li><strong>观察者</strong>允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><p><strong>中介者</strong>和<strong>观察者</strong>之间的区别往往很难记住。在大部分情况下，你可以使用其中一种模式， 而有时可以同时使用。让我们来看看如何做到这一点。</p>
<p>  <strong>中介者</strong>的主要目标是消除一系列系统组件之间的相互依赖。这些组件将依赖于同一个中介者对象。<strong>观察者</strong>的目标是在对象之间建立动态的单向连接，使得部分对象可作为其他对象的附属发挥作用。</p>
<p>  有一种流行的<strong>中介者模式</strong>实现方式依赖于<strong>观察者</strong>。<strong>中介者</strong>对象担当发布者的角色，其他组件则作为订阅者，可以订阅<strong>中介者</strong>的事件或取消订阅。当<strong>中介者</strong>以这种方式实现时，它可能看上去与<strong>观察者</strong>非常相似。</p>
<p>  当你感到疑惑时，记住可以采用其他方式来实现中介者。例如，你可永久性地将所有组件链接到同一个<strong>中介者</strong>对象。这种实现方式和<strong>观察者</strong>并不相同，但这仍是一种<strong>中介者模式</strong>。</p>
<p>  假设有一个程序，其所有的组件都变成了发布者，它们之间可以相互建立动态连接。这样程序中就没有中心化的中介者对象，而只有一些分布式的观察者。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/VVdoIBHqQwF0bZRE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/VVdoIBHqQwF0bZRE/" class="post-title-link" itemprop="url">设计模式之单例模式（Singleton）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-19 21:35:42" itemprop="dateCreated datePublished" datetime="2021-09-19T21:35:42+08:00">2021-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、动机"><a href="#一、动机" class="headerlink" title="一、动机"></a>一、动机</h5><p>在软件系统中，经常有这样一种特殊的类，必须保障它们在系统内中存在一个实例，才能确保它们的逻辑正确性，以及良好的效率。如何绕过常规的构建器，提供一个机制来保证一个类只有一个实例。比如<code>Windows</code>的任务管理器就是很典型的例子，你不能同时打开两个不同的任务管理器。</p>
<h5 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h5><p>单例模式是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。单例模式可以：</p>
<blockquote>
<ul>
<li><p>保证一个类只有一个实例。</p>
</li>
<li><p>为该实例提供一个全局访问节点。</p>
</li>
</ul>
</blockquote>
<p>它的运作方式是这样的：如果你创建了一个对象，同时过一会儿后你决定再创建一个新对象，此时你会获得之前已创建的对象，而不是一个新对象。注意，普通构造函数无法实现上述行为，因为构造函数的设计决定了它必须总是返回一个新对象。<code>Singleton</code>模式中的实例构造器可以设置为<code>protected</code>以允许子类派生。如何实现多线程环境下安全的<code>Singleton</code>？注意对双检查锁的正确实现。</p>
<p>所有单例的实现都包含以下两个相同的步骤：</p>
<blockquote>
<ul>
<li>将默认构造函数设为私有，防止其他对象使用单例类的<code>new</code>运算符。</li>
<li>新建一个静态构建方法作为构造函数。该函数会“偷偷”调用私有构造函数来创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一缓存对象。</li>
</ul>
</blockquote>
<p>如果你的代码能够访问单例类，那它就能调用单例类的静态方法。无论何时调用该方法，它总是会返回相同的对象。</p>
<h5 id="三、模板模式的结构"><a href="#三、模板模式的结构" class="headerlink" title="三、模板模式的结构"></a>三、模板模式的结构</h5><p><img src="structure_of_Singleton.png" alt="structure_of_Singleton"></p>
<p><strong>单例</strong><code>Singleton</code>类声明了一个名为<code>get­Instance</code>获取实例的静态方法来返回其所属类的一个相同实例。单例的构造函数必须对客户端<code>Client</code>代码隐藏。 调用<code>获取实例</code>方法必须是获取单例对象的唯一方式。</p>
<h5 id="四、Singleton代码示例"><a href="#四、Singleton代码示例" class="headerlink" title="四、Singleton代码示例"></a>四、<code>Singleton</code>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全版本单例实现</span></span><br><span class="line"><span class="comment">// 使用 static local 变量既能保证线程安全性，又能保证对象唯一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _value;</span><br><span class="line">    <span class="comment">// 将实际使用的构造函数设置为私有</span></span><br><span class="line">    Singleton(<span class="keyword">int</span> value) : _value(value) &#123;&#125;</span><br><span class="line">    ~Singleton() &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将默认构造函数，拷贝构造函数和拷贝赋值运算符都 delete 掉或者设置为私有</span></span><br><span class="line">    Singleton() = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只提供一个静态的获取实例的方法，用来调用</span></span><br><span class="line">    <span class="comment">// 内部调用 protected 区的唯一一个构造函数来实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Singleton <span class="title">instance</span><span class="params">(value)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Following code emulates slow initialization.</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>));</span><br><span class="line">    Singleton *singleton = Singleton::GetInstance(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; singleton-&gt;value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Following code emulates slow initialization.</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>));</span><br><span class="line">    Singleton *singleton = Singleton::GetInstance(<span class="number">23</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; singleton-&gt;value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"If you see the same value, then singleton was reused (yay!\n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"If you see different values, then 2 singletons were created (booo!!)\n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"RESULT:\n"</span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(ThreadFoo)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(ThreadBar)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Execution result:</span><br><span class="line">    If you see the same value, <span class="function">then singleton was <span class="title">reused</span> <span class="params">(yay!</span></span></span><br><span class="line"><span class="function"><span class="params">    If you see different values, then <span class="number">2</span> singletons were created (booo!!)</span></span></span><br><span class="line"><span class="function"><span class="params">    RESULT:</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">12</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">12</span></span></span></span><br></pre></td></tr></table></figure>

<h5 id="线程安全实现之双检查锁"><a href="#线程安全实现之双检查锁" class="headerlink" title="线程安全实现之双检查锁"></a>线程安全实现之双检查锁</h5><p>因为存在内存读写乱序（编译器问题），实则不安全。</p>
<blockquote>
<p>原因分析：<code>m_instance = new Singleton()</code>这句话可以分成三个步骤来执行：</p>
<ul>
<li>分配了一个<code>Singleton</code>类型对象所需要的内存；</li>
<li>在分配的内存处构造<code>Singleton</code>类型的对象；</li>
<li>把分配的内存的地址赋给指针<code>m_instance</code>。</li>
</ul>
<p>一般会认为这三个步骤是按顺序执行的，但实际上只能确定步骤<code>1</code>是最先执行的，步骤<code>2</code>和<code>3</code>却不一定。问题就出现在这。</p>
<p>假如某个线程<code>A</code>在调用执行<code>m_instance = new Singleton()</code>的时候是按照<code>1,3,2</code>的顺序的，那么刚刚执行完步骤<code>3</code>给<code>Singleton</code>类型分配了内存（此时<code>m_instance</code>就不是<code>nullptr</code>了）就切换到了线程<code>B</code>，由于<code>m_instance</code>已经不是<code>nullptr</code>了，所以线程<code>B</code>会直接执行<code>return m_instance</code>得到一个对象，而这个对象并没有真正的被构造！严重bug就这么发生了。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _value;</span><br><span class="line">    <span class="keyword">static</span> Singleton *_instance;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex _mutex;</span><br><span class="line">    Singleton(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> value) : m_value(value) &#123;&#125;</span><br><span class="line">    ~Singleton() &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singleton() = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双检查锁版本</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> Singleton(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::_instance&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::_mutex&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h5><ul>
<li>如果程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式。</li>
</ul>
<blockquote>
<p>单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。该方法可以创建一个新对象，但如果该对象已经被创建，则返回已有的对象。</p>
</blockquote>
<ul>
<li>如果你需要更加严格地控制全局变量，可以使用单例模式。</li>
</ul>
<blockquote>
<p>单例模式与全局变量不同，它保证类只存在一个实例。除了单例类自己以外，无法通过任何方式替换缓存的实例。</p>
<p>请注意，你可以随时调整限制并设定生成单例实例的数量，只需修改<code>获取实例</code>方法，即 <code>GetInstance</code>中的代码即可实现。</p>
</blockquote>
<h5 id="六、优缺点"><a href="#六、优缺点" class="headerlink" title="六、优缺点"></a>六、优缺点</h5><ul>
<li>你可以保证一个类只有一个实例。</li>
<li>你获得了一个指向该实例的全局访问节点。</li>
<li>仅在首次请求单例对象时对其进行初始化。</li>
<li><del>违反了_单一职责原则_。该模式同时解决了两个问题。</del></li>
<li><del>单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。</del></li>
<li><del>该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。</del></li>
<li><del>单例的客户端代码单元测试可能会比较困难，因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的，而且绝大部分语言无法重写静态方法，所以你需要想出仔细考虑模拟单例的方法。要么干脆不编写测试代码，或者不使用单例模式。</del></li>
</ul>
<h5 id="七、与其它模式的关系"><a href="#七、与其它模式的关系" class="headerlink" title="七、与其它模式的关系"></a>七、与其它模式的关系</h5><ul>
<li><strong>外观模式</strong>类通常可以转换为<strong>单例模</strong>式类，因为在大部分情况下一个外观对象就足够了。</li>
<li>如果你能将对象的所有共享状态简化为一个享元对象，那么<strong>享元模式</strong>就和单例类似了。但这两个模式有两个根本性的不同。<ol>
<li>只会有一个单例实体，但是享元类可以有多个实体，各实体的内在状态也可以不同。</li>
<li>单例对象可以是可变的。享元对象是不可变的。</li>
</ol>
</li>
<li><strong>抽象工厂模式</strong>、<strong>生成器模式</strong>和<strong>原型模式</strong>都可以用单例来实现。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/m7YQnSFO4l7CY8G6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/m7YQnSFO4l7CY8G6/" class="post-title-link" itemprop="url">设计模式之抽象工厂模式（Abstract Factory）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-15 21:35:42" itemprop="dateCreated datePublished" datetime="2021-09-15T21:35:42+08:00">2021-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、动机"><a href="#一、动机" class="headerlink" title="一、动机"></a>一、动机</h5><p>在软件系统中，经常面临”一系列相互依赖的对象“的建构工作，同时，由于需求的变化，往往存在更多系列对象的创建工作。如何应对这种变化? 如何绕过常规的对象创建方法（<code>new</code>），提供一种”封装机制“来避免客户程序和这种”多系列具体对象创建工作“的紧耦合？</p>
<p>抽象工厂模式是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。</p>
<h5 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h5><p>首先，抽象工厂模式建议为系列中的每件产品明确声明接口 。然后，确保所有产品变体都继承这些接口。接下来，我们需要声明<em>抽象工厂</em>——包含系列中所有产品构造方法的接口。</p>
<p>那么该如何处理产品变体呢？对于系列产品的每个变体，我们都将基于<code>抽象工厂</code>接口创建不同的工厂类。每个工厂类都只能返回特定类别的产品。</p>
<p>假设客户端想要工厂创建一把椅子。客户端无需了解工厂类，也不用管工厂类创建出的椅子类型。 无论是现代风格，还是维多利亚风格的椅子，对于客户端来说没有分别，它只需调用抽象<code>椅子</code>接口就可以了。这样一来，客户端只需知道椅子以某种方式实现了<code>sit­</code>坐下方法就足够了。此外，无论工厂返回的是何种椅子变体，它都会和由同一工厂对象创建的沙发风格一致。</p>
<p>如果客户端仅接触抽象接口，那么谁来创建实际的工厂对象呢？ 一般情况下，应用程序会在初始化阶段创建具体工厂对象。而在此之前，应用程序必须根据配置文件或环境设定选择工厂类别。</p>
<p>如果没有应对”多系列对象构建“的需求变化，则没有必要使用<code>Abstract Factory</code>模式，这时候使用简单的工厂模式完全可以。”系列对象“指的是在某一特定系列下的对象之间有相互依赖，或作用的关系。不同系列的对象之间不能互相依赖。<code>Abstract Factory</code>模式主要在于应对”新系列“的需求变动。其缺点在于难以应对“新对象”的需求变动。</p>
<h5 id="三、模板模式的结构"><a href="#三、模板模式的结构" class="headerlink" title="三、模板模式的结构"></a>三、模板模式的结构</h5><p><img src="structure_of_Abstract_Factory.png" alt="structure_of_Abstract_Factory"></p>
<ol>
<li><strong>抽象产品</strong>（<code>Abstract Product</code>）为构成系列产品的一组不同但相关的产品声明接口。</li>
<li><strong>具体产品</strong>（<code>Concrete Product</code>）是抽象产品的多种不同类型实现。所有变体（维多利亚/现代）都必须实现相应的抽象产品（椅子/沙发）。</li>
<li><strong>抽象工厂</strong>（<code>Abstract Factory</code>）接口声明了一组创建各种抽象产品的方法。</li>
<li><strong>具体工厂</strong>（<code>Concrete Factory</code>）实现抽象工厂的构建方法。每个具体工厂都对应特定产品变体，且仅创建此种产品变体。</li>
<li>尽管具体工厂会对具体产品进行初始化，其构建方法签名必须返回相应的<em>抽象</em>产品。这样，使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。<strong>客户端</strong>（<code>Client</code>）只需通过抽象接口调用工厂和产品对象，就能与任何具体工厂/产品变体交互。</li>
</ol>
<h5 id="四、Abstract-Factory代码示例"><a href="#四、Abstract-Factory代码示例" class="headerlink" title="四、Abstract Factory代码示例"></a>四、<code>Abstract Factory</code>代码示例</h5><p>假设你正在开发一款家具商店模拟器。你的代码中包括一些类，用于表示：</p>
<ol>
<li>一系列相关产品，例如<code>椅子Chair</code>、<code>沙发Sofa</code>。</li>
<li>系列产品的不同变体。例如，你可以使用<code>现代Modern</code>、<code>维多利亚Victorian</code>、<code>装饰风艺术Art­Deco</code>等风格生成<code>椅子</code>、<code>沙发</code>。</li>
</ol>
<p><img src="Product_families_and_their_variants.png" alt="Product_families_and_their_variants"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 椅子基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chair</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Chair() &#123;&#125;</span><br><span class="line">    <span class="comment">// 声明 坐下 的抽象方法</span></span><br><span class="line">    <span class="comment">// 椅子系列的每个不同椅子都应具有的基本接口。所有椅子的变体必须实现此接口。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰风艺术风格的椅子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArtDecoChair</span> :</span> <span class="keyword">public</span> Chair &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ArtDecoChair::sit()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代风格的椅子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModernChair</span> :</span> <span class="keyword">public</span> Chair &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ModernChair::sit()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维多利亚风格的椅子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VictorianChair</span> :</span> <span class="keyword">public</span> Chair &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"VictorianChair::sit()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 沙发基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sofa</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Sofa() &#123;&#125;</span><br><span class="line">    <span class="comment">// 声明 躺下 的抽象方法</span></span><br><span class="line">    <span class="comment">// 沙发系列的每个不同椅子都应具有的基本接口。所有沙发的变体必须实现此接口。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">lie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰风艺术风格的沙发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArtDecoSofa</span> :</span> <span class="keyword">public</span> Sofa &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lie</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ArtDecoSofa::lie()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代风格的沙发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModernSofa</span> :</span> <span class="keyword">public</span> Sofa &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lie</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ModernSofa::lie()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维多利亚风格的沙发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VictorianSofa</span> :</span> <span class="keyword">public</span> Sofa &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lie</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"VictorianSofa::lie()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列</span></span><br><span class="line"><span class="comment">// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。</span></span><br><span class="line"><span class="comment">// 系列产品可有多个变体，但不同变体的产品不能搭配使用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractFactory() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Chair *<span class="title">createChair</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Sofa *<span class="title">createSofa</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰风艺术风格产品工厂</span></span><br><span class="line"><span class="comment">// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配</span></span><br><span class="line"><span class="comment">// 使用。具体工厂方法声明会返回一个抽象产品，但在方法内部则会对具体产品进</span></span><br><span class="line"><span class="comment">// 行实例化。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArtDecoFactory</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Chair *<span class="title">createChair</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ArtDecoChair created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArtDecoChair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Sofa *<span class="title">createSofa</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ArtDecoSofa created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArtDecoSofa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代风格产品工厂、</span></span><br><span class="line"><span class="comment">// 每个具体工厂中都会包含一个相应的产品变体。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModernFactory</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Chair *<span class="title">createChair</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ModernChair created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModernChair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Sofa *<span class="title">createSofa</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ModernSofa created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModernSofa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维多利亚风格产品工厂</span></span><br><span class="line"><span class="comment">// 每个具体工厂中都会包含一个相应的产品变体。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VictorianFactory</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Chair *<span class="title">createChair</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"VictorianChair created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VictorianChair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Sofa *<span class="title">createSofa</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"VictorianSofa created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> VictorianSofa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码仅通过抽象类型（AbstractFactory、Chair 和 Sofa）使用工厂</span></span><br><span class="line"><span class="comment">// 和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">(AbstractFactory &amp;factory)</span> </span>&#123;</span><br><span class="line">    Chair *chair = factory.createChair();</span><br><span class="line">    Sofa *sofa = factory.createSofa();</span><br><span class="line">    chair-&gt;sit();</span><br><span class="line">    sofa-&gt;lie();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> chair;</span><br><span class="line">    <span class="keyword">delete</span> sofa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 程序会根据当前配置或环境设定选择工厂类型</span></span><br><span class="line">    <span class="comment">// 并在运行时创建工厂（通常在初始化阶段）。</span></span><br><span class="line">    ModernFactory *mf = <span class="keyword">new</span> ModernFactory;</span><br><span class="line">    ClientCode(*mf);</span><br><span class="line">    <span class="keyword">delete</span> mf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VictorianFactory *vf = new VictorianFactory;</span></span><br><span class="line">    <span class="comment">// ClientCode(*vf);</span></span><br><span class="line">    <span class="comment">// delete vf;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Execution result:</span><br><span class="line">    ModernChair created.</span><br><span class="line">    ModernSofa created.</span><br><span class="line">    ModernChair::sit()</span><br><span class="line">    ModernSofa::lie()</span><br></pre></td></tr></table></figure>

<h5 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h5><ul>
<li>如果代码需要与多个不同系列的相关产品交互，但是由于无法提前获取相关信息，或者出于对未来扩展性的考虑，你不希望代码基于产品的具体类进行构建，在这种情况下，你可以使用抽象工厂。</li>
</ul>
<blockquote>
<p>抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。只要代码通过该接口创建对象，那么你就不会生成与应用程序已生成的产品类型不一致的产品。</p>
</blockquote>
<ul>
<li>如果你有一个基于一组抽象方法的类，且其主要功能因此变得不明确，那么在这种情况下可以考虑使用抽象工厂模式。</li>
</ul>
<blockquote>
<p>在设计良好的程序中，每个类仅负责一件事。如果一个类与多种类型产品交互，就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。</p>
</blockquote>
<h5 id="六、优缺点"><a href="#六、优缺点" class="headerlink" title="六、优缺点"></a>六、优缺点</h5><ul>
<li>你可以确保同一工厂生成的产品相互匹配。</li>
<li>你可以避免客户端和具体产品代码的耦合。</li>
<li><em>单一职责原则</em>。你可以将产品生成代码抽取到同一位置，使得代码易于维护。</li>
<li><em>开闭原则</em>。向应用程序中引入新产品变体时，你无需修改客户端代码。</li>
<li><del>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</del></li>
</ul>
<h5 id="七、与其它模式的关系"><a href="#七、与其它模式的关系" class="headerlink" title="七、与其它模式的关系"></a>七、与其它模式的关系</h5><ul>
<li>在许多设计工作的初期都会使用<strong>工厂方法模式</strong>（较为简单，而且可以更方便地通过子类进行定制），随后演化为使用<strong>抽象工厂模式</strong>、<strong>原型模式</strong>或<strong>生成器模式</strong>（更灵活但更加复杂）。</li>
<li><strong>生成器</strong>重点关注如何分步生成复杂对象。<strong>抽象工厂</strong>专门用于生产一系列相关对象。<strong>抽象工厂</strong>会马上返回产品，<strong>生成器</strong>则允许你在获取产品前执行一些额外构造步骤。</li>
<li><strong>抽象工厂模式</strong>通常基于一组工厂方法，但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</li>
<li>你可以将<strong>抽象工厂</strong>和<strong>桥接模式</strong>搭配使用。如果由桥接定义的抽象只能与特定实现合作，这一模式搭配就非常有用。在这种情况下，<strong>抽象工厂</strong>可以对这些关系进行封装，并且对客户端代码隐藏其复杂性。</li>
<li><strong>抽象工厂</strong>、<strong>生成器</strong>和<strong>原型</strong>都可以用<strong>单例模式</strong>来实现。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/TVfZuYKzcvGyIWWM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/TVfZuYKzcvGyIWWM/" class="post-title-link" itemprop="url">设计模式之工厂模式（Factory）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-07 21:35:42" itemprop="dateCreated datePublished" datetime="2021-09-07T21:35:42+08:00">2021-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、动机"><a href="#一、动机" class="headerlink" title="一、动机"></a>一、动机</h5><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。如何应对这种变化？如何绕过常规的对象创建方法（<code>new</code>），提供一种”封装机制“来避免客户程序和这种”具体对象创建工作“的紧耦合？</p>
<h5 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h5><p>工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系（<code>new</code>）会导致软件的脆弱。</p>
<p><code>FactoryMethod</code>模式通过面向对象的方式，将所要创建的具体对象工作延迟到子类，从而实现一种扩展(而非更改)的策略，较好的解决了这种紧耦合关系。</p>
<h5 id="三、工厂模式的结构"><a href="#三、工厂模式的结构" class="headerlink" title="三、工厂模式的结构"></a>三、工厂模式的结构</h5><p><img src="structure_of_Factory.png" alt="structure of Factory"></p>
<ol>
<li><strong>产品</strong>（<code>Product</code>）将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的。</li>
<li><strong>具体产品</strong>（<code>Concrete Products</code>）是产品接口的不同实现。</li>
<li><strong>创建者</strong>（<code>Creator</code>）类声明返回产品对象的工厂方法。该方法的返回对象类型必须与产品接口相匹配。</li>
</ol>
<blockquote>
<p>你可以将工厂方法声明为抽象方法，强制要求每个子类以不同方式实现该方法。或者，你也可以在基础工厂方法中返回默认产品类型。</p>
<p>注意，尽管它的名字是创建者，但它最主要的职责并不是创建产品。一般来说，创建者类包含一些与产品相关的核心业务逻辑。工厂方法将这些逻辑处理从具体产品类中分离出来。打个比方，大型软件开发公司拥有程序员培训部门。但是，这些公司的主要工作还是编写代码，而非生产程序员。</p>
</blockquote>
<ol start="4">
<li><strong>具体创建者</strong>（<code>Concrete Creators</code>）将会重写基础工厂方法，使其返回不同类型的产品。</li>
</ol>
<blockquote>
<p>注意，并不一定每次调用工厂方法都会创建新的实例。工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</p>
</blockquote>
<h3 id="四、Factory代码示例"><a href="#四、Factory代码示例" class="headerlink" title="四、Factory代码示例"></a>四、<code>Factory</code>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运输基类</span></span><br><span class="line"><span class="comment">// 提供抽象运输接口的声明，具体的运输类都需要给出具体实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transportation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transportation() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Transportation() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象物流类声明的抽象运输接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 陆路卡车运输</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TruckTransportation</span> :</span> <span class="keyword">public</span> Transportation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TruckTransportation() &#123;&#125;</span><br><span class="line">    ~TruckTransportation() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm TruckTransportation."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 陆路火车运输</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainTransportation</span> :</span> <span class="keyword">public</span> Transportation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrainTransportation() &#123;&#125;</span><br><span class="line">    ~TrainTransportation() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm TrainTransportation."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海上轮船运输</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShipTransportation</span> :</span> <span class="keyword">public</span> Transportation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ShipTransportation() &#123;&#125;</span><br><span class="line">    ~ShipTransportation() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm ShipTransportation."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物流工厂基类</span></span><br><span class="line"><span class="comment">// 必须声明一个返回具体运输工具的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticsFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LogisticsFactory() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~LogisticsFactory() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回具体运输工具的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Transportation *<span class="title">createTranportation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里需要注意，工厂的职责除了是创建具体的运输工具</span></span><br><span class="line">    <span class="comment">// 同时还要负责一些其它啊的核心业务</span></span><br><span class="line">    <span class="comment">// 这些业务依赖与抽象方法返回的运输工具对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startTransportation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用抽象方法创建的一个运输工具对象</span></span><br><span class="line">        Transportation *tranportation = createTranportation();</span><br><span class="line">        <span class="comment">// 现在使用该运输工具</span></span><br><span class="line">        tranportation-&gt;deliver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 陆路运输工厂</span></span><br><span class="line"><span class="comment">// 需要重写工厂的抽象方法以创建具体的运输工具</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadFactory</span> :</span> <span class="keyword">public</span> LogisticsFactory &#123;</span><br><span class="line">    <span class="keyword">bool</span> m_trainEnabled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RoadFactory(<span class="keyword">bool</span> trainEnabled) : m_trainEnabled(trainEnabled) &#123;&#125;</span><br><span class="line">    ~RoadFactory() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Transportation *<span class="title">createTranportation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认采用卡车运输</span></span><br><span class="line">        Transportation *ts = <span class="keyword">new</span> TruckTransportation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果火车运输可以用，则改用火车运输</span></span><br><span class="line">        <span class="keyword">if</span>(m_trainEnabled) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ts;</span><br><span class="line">            ts = <span class="keyword">new</span> TrainTransportation;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海上运输工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarineFactory</span> :</span> <span class="keyword">public</span> LogisticsFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MarineFactory() &#123;&#125;</span><br><span class="line">    ~MarineFactory() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Transportation *<span class="title">createTranportation</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShipTransportation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="comment">// 无需了解不同子类返回实际运输对象之间的差别，不关心其具体实现方式。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端程序根据当前配置或环境选择具体的运输类型</span></span><br><span class="line">    LogisticsFactory *<span class="built_in">log</span> = <span class="keyword">new</span> MarineFactory;</span><br><span class="line">    <span class="comment">// log = new RoadFactory(false);</span></span><br><span class="line">    <span class="comment">// log = new RoadFactory(true);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">log</span>-&gt;startTransportation();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">log</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clientCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Execution result:</span><br><span class="line">    I<span class="number">'</span>m ShipTransportation.</span><br></pre></td></tr></table></figure>

<h3 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h3><ul>
<li><p>当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。</p>
<blockquote>
<p>工厂方法将创建产品的代码与实际使用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建部分代码。</p>
<p>例如，如果需要向应用中添加一种新产品，你只需要开发新的创建者子类，然后重写其工厂方法即可。</p>
</blockquote>
</li>
<li><p>如果你希望用户能扩展你软件库或框架的内部组件，可使用工厂方法。</p>
<blockquote>
<p>继承可能是扩展软件库或框架默认行为的最简单方法。但是当你使用子类替代标准组件时，框架如何辨识出该子类？</p>
<p>解决方案是将各框架中构造组件的代码集中到单个工厂方法中，并在继承该组件之外允许任何人对该方法进行重写。</p>
<p>让我们看看具体是如何实现的。假设你使用开源 <code>UI</code> 框架编写自己的应用。你希望在应用中使用圆形按钮，但是原框架仅支持矩形按钮。你可以使用 <code>圆形按钮Round­Button</code>子类来继承标准的 <code>按钮Button</code>类。但是，你需要告诉 <code>UI框架UIFramework</code>类使用新的子类按钮代替默认按钮。</p>
<p>为了实现这个功能，你可以根据基础框架类开发子类 <code>圆形按钮 UI UIWith­Round­Buttons</code> ，并且重写其 <code>create­Button</code>创建按钮方法。基类中的该方法返回 <code>按钮</code>对象，而你开发的子类返回 <code>圆形按钮</code>对象。现在，你就可以使用 <code>圆形按钮 UI</code>类代替 <code>UI框架</code>类。就是这么简单！</p>
</blockquote>
</li>
<li><p>如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象，可使用工厂方法。</p>
<blockquote>
<p>在处理大型资源密集型对象（比如数据库连接、文件系统和网络资源）时，你会经常碰到这种资源需求。</p>
<p>让我们思考复用现有对象的方法：</p>
<ol>
<li><p>首先，你需要创建存储空间来存放所有已经创建的对象。</p>
</li>
<li><p>当他人请求一个对象时，程序将在对象池中搜索可用对象。</p>
</li>
<li><p>…然后将其返回给客户端代码。</p>
</li>
<li><p>如果没有可用对象，程序则创建一个新对象（并将其添加到对象池中）。</p>
</li>
</ol>
<p>这些代码可不少！而且它们必须位于同一处，这样才能确保重复代码不会污染程序。</p>
<p>可能最显而易见，也是最方便的方式，就是将这些代码放置在我们试图重用的对象类的构造函数中。但是从定义上来讲，构造函数始终返回的是新对象，其无法返回现有实例。</p>
<p>因此，你需要有一个既能够创建新对象，又可以重用现有对象的普通方法。这听上去和工厂方法非常相像。</p>
</blockquote>
</li>
</ul>
<h3 id="六、优缺点"><a href="#六、优缺点" class="headerlink" title="六、优缺点"></a>六、优缺点</h3><ul>
<li>你可以避免创建者和具体产品之间的紧密耦合。</li>
<li><em>单一职责原则</em>。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。</li>
<li><em>开闭原则</em>。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。</li>
<li><del>应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。</del></li>
</ul>
<h3 id="七、与其它模式的关系"><a href="#七、与其它模式的关系" class="headerlink" title="七、与其它模式的关系"></a>七、与其它模式的关系</h3><ul>
<li>在许多设计工作的初期都会使用<strong>工厂方法</strong>模式（较为简单，而且可以更方便地通过子类进行定制），随后演化为使用<strong>抽象工厂模式</strong>、<strong>原型模式</strong>或<strong>生成器模式</strong>（更灵活但更加复杂）。</li>
<li><strong>抽象工厂模式</strong>通常基于一组工厂方法，但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</li>
<li>你可以同时使用<strong>工厂方法</strong>和<strong>迭代器模式</strong>来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配。</li>
<li><strong>原型</strong>并不基于继承，因此没有继承的缺点。另一方面，<strong>原型</strong>需要对被复制对象进行复杂的初始化。<strong>工厂方法</strong>基于继承，但是它不需要初始化步骤。</li>
<li><strong>工厂方法</strong>是模板方法模式的一种特殊形式。同时，<strong>工厂方法</strong>可以作为一个大型<strong>模板方法</strong>中的一个步骤。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/MK80vfKBcuYfGiyp/" class="post-title-link" itemprop="url">leetcode刷题系列之小知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-01 21:35:42" itemprop="dateCreated datePublished" datetime="2021-09-01T21:35:42+08:00">2021-09-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章是<code>leetcode</code>刷题系列的番外篇——刷题小知识点。主要是编程题中的一些冷知识、小技巧。</p>
<p><code>leetcode</code>刷题系列其它文章组织如下：</p>
<p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p>
<p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p>
<p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/MK80vfKBcuYfGiyp/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GRrK24ZqnqkWXLK0/" class="post-title-link" itemprop="url">leetcode刷题系列之数据结构设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-10 21:35:42" itemprop="dateCreated datePublished" datetime="2021-07-10T21:35:42+08:00">2021-07-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>36k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章是<code>leetcode</code>刷题系列的第<code>7</code>部分——数据结构设计。</p>
<p><code>leetcode</code>刷题系列其它文章组织如下：</p>
<p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p>
<p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p>
<p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/GRrK24ZqnqkWXLK0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Liu Y.L.">
      <meta itemprop="description" content="寒江孤影-江湖故人-相逢何必曾相识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LYL's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LZqUbK3Z1CXKja4I/" class="post-title-link" itemprop="url">leetcode刷题系列之字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-10 21:35:42" itemprop="dateCreated datePublished" datetime="2021-06-10T21:35:42+08:00">2021-06-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章是<code>leetcode</code>刷题系列的第<code>3</code>部分——字符串。这里把有代表性的题目发出来，共计<code>21</code>道。字符串的问题杂且难，这一块，面试时碰到字符串问题时只能随机应变，没有固定的套路。</p>
<p><code>leetcode</code>刷题系列其它文章组织如下：</p>
<p><code>1</code>. <a href="https://yuanlehome.github.io/qD0F57Dbj7HjnZou/">数组</a></p>
<p><code>2</code>. <a href="https://yuanlehome.github.io/S07PSuYxoZ6CPova/">链表</a></p>
<p><code>3</code>. <a href="https://yuanlehome.github.io/LZqUbK3Z1CXKja4I/">字符串</a></p>
<p><code>4</code>. <a href="https://yuanlehome.github.io/B90hHtDrYEYJD3xv/">二叉树</a></p>
<p><code>5</code>. <a href="https://yuanlehome.github.io/fhQPnKWa9qDDelG3/">队列和栈</a></p>
<p><code>6</code>. <a href="https://yuanlehome.github.io/RT66rbCYdVwFEsD8/">动态规划</a></p>
<p><code>7</code>. <a href="https://yuanlehome.github.io/GRrK24ZqnqkWXLK0/">数据结构设计</a></p>
<p><code>8</code>. <a href="https://yuanlehome.github.io/MK80vfKBcuYfGiyp/">刷题小知识点</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/LZqUbK3Z1CXKja4I/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liu Y.L."
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Liu Y.L.</p>
  <div class="site-description" itemprop="description">寒江孤影-江湖故人-相逢何必曾相识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanlehome" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanlehome" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlehome@163.com" title="E-Mail → mailto:yuanlehome@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/295413378" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;295413378" rel="noopener" target="_blank"><i class=" fa-fw"></i>Bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=804230989&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;804230989&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu Y.L.</span>
</div>

<span>我已在此等候你 <span id="showDays"></span></span>
<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2020,04,04,00,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>