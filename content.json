[{"title":"leetcode刷题系列之队列和栈","date":"2021-03-18T13:35:42.000Z","path":"fhQPnKWa9qDDelG3/","text":"这篇文章是leetcode刷题系列的第5部分——队列和栈。这里把有代表性的题目发出来，共计21道。主要涉及BFS和DFS算法。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少200道！ Queue and Stack1660. Correct a Binary Tree 你有一棵二叉树，这棵二叉树有个小问题，其中有且只有一个无效节点，它的右子节点错误地指向了与其在同一层且在其右侧的一个其他节点。 给定一棵这样的问题二叉树的根节点root，将该无效节点及其所有子节点移除（不移除被错误指向的节点），然后返回新二叉树的根结点。 示例: 123输入: root &#x3D; [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode &#x3D; 7, toNode &#x3D; 4输出: [8,3,1,null,null,9,4,null,null,5,6]解释: 值为 7 的节点是无效的，所以移除这个节点及其子节点 2。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 借助层序遍历的思想// 如果遍历到某一个节点, 发现其右孩子已经访问过了// 就说明当前节点就是无效节点// 但此时需要记录已经访问过的节点// 如果要把此无效节点删除, 还要知道当前节点的父节点// 因此, 使用一个哈希表记录所有访问过的节点以及这些节点的父节点// 哈希表的映射有点特殊, 因为我们想达到这样的效果 mapping[node] == node's parent// 因此, 每次访问一个节点 node 时// 以 node 为值, 分别以其左右孩子(如果存在的话)为键加入哈希表TreeNode* correctBinaryTree(TreeNode* root)&#123; // 队列仅仅用于完成层序遍历 queue&lt;TreeNode*&gt; q; // 当前节点和其父亲的映射的哈希表 unordered_map&lt;TreeNode*, TreeNode*&gt; mapping; if(root) q.push(root); // 标记是否找到了无效节点, 可用于提前结束遍历 bool flag = false; while(!q.empty() &amp;&amp; !flag) &#123; int sz = q.size(); for(int i = 0; i &lt; sz; i++) &#123; TreeNode* node = q.front(); q.pop(); // 以上都是标准的层序遍历迭代实现的固定框架 // 如果当前节点的右孩子已经遍历过了 // 说明找到无效节点 if(mapping.count(node-&gt;right)) &#123; if(mapping[node]-&gt;left == node) // 如果当前节点是其父节点的左孩子 mapping[node]-&gt;left = nullptr; else // 否则是右孩子 mapping[node]-&gt;right = nullptr; flag = true; break; &#125; else &#123; // 否则继续遍历就是了 if(node-&gt;left) &#123; mapping[node-&gt;left] = node; q.push(node-&gt;left); &#125; if(node-&gt;right) &#123; mapping[node-&gt;right] = node; q.push(node-&gt;right); &#125; &#125; &#125; &#125; return root;&#125; 394. Decode String 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的encoded_string正好重复k次。注意k保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数k ，例如不会出现像3a或2[4]的输入。 Constraints: 1 &lt;= s.size() &lt;= 30 s consists of lowercase English letters, digits, and square brackets &#39;[]&#39;. s is guaranteed to be a valid input. All the integers in s are in the range [1, 300]. Example 1: 12Input: s &#x3D; &quot;3[a]2[bc]&quot;Output: &quot;aaabcbc&quot; Example 2: 12Input: s &#x3D; &quot;2[abc]3[cd]ef&quot;Output: &quot;abcabccdcdcdef&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void repeatString(string&amp; str, int count)&#123; string s = str; while(--count) str = s + str;&#125;string decodeString(string str)&#123; unordered_set&lt;string&gt; isdigits&#123;\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"&#125;; stack&lt;string&gt; s; for(char c : str) &#123; if(c == ']') &#123; string substr; while(!s.empty() &amp;&amp; s.top() != \"[\") &#123; substr = s.top() + substr; s.pop(); &#125; s.pop(); // pop 掉相匹配的那个 '[' // 获取 [] 前面的那个数字, 注意可能是多位数 string numstr; while (!s.empty() &amp;&amp; isdigits.count(s.top())) &#123; numstr = s.top() + numstr; s.pop(); &#125; // 将 [] 中的字串重复指定次 repeatString(substr, stoi(numstr)); // 新串再次入栈 s.push(substr); &#125; else s.push(string(1, c)); &#125; // 这时从栈底到栈顶的所有串连在一起其实就是答案了 // 但是要转为 string 返回 string res; while(!s.empty()) &#123; res = s.top() + res; s.pop(); &#125; return res;&#125; 752. Open the Lock 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;。每个拨轮可以自由旋转：例如把&#39;9&#39;变为&#39;0&#39;，&#39;0&#39;变为&#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为&#39;0000&#39; ，一个代表四个拨轮的数字的字符串。 列表deadends包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串target代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回-1。 Example 1: 123456Input: deadends &#x3D; [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target &#x3D; &quot;0202&quot;Output: 6Explanation:A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;. Example 2: 12345Input: deadends &#x3D; [&quot;8888&quot;], target &#x3D; &quot;0009&quot;Output: 1Explanation:We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// 宽度优先遍历 BFS 通常用来解决最小(距离)、最短(路径)、最少(步数)等问题// 先给出 BFS 算法框架// 计算从 [开始状态] 到 [目标状态]的最近距离int BFS(STATE startState, STATE targetState)&#123; queue&lt;STATE&gt; q; // 核心数据结构 unordered_map&lt;STATE&gt; visited; // 避免走回头路 q.push(startState); // 将起点加入队列 visited.insert(startState); int step = 0; // 记录扩散的步数 while(!q.empty()) &#123; int sz = q.size(); /* 将当前队列中的所有状态分别向其所有相邻状态转换 */ for (int i = 0; i &lt; sz; i++) &#123; STATE curState = q.front(); q.pop(); // 下面代码是需要你根据实际问题的逻辑做调整的 /***************************************/ /* 划重点: 这里判断是否到达终点 */ if (curState is targetState) return step; /* 将 cur 的所有相邻状态加入队列 */ for (STATE state : all adjacent states of curState ) &#123; if (state not in visited) &#123; q.push(state); visited.insert(state); &#125; &#125; /***************************************/ &#125; /* 划重点: 更新步数在这里 */ step++; &#125; return step;&#125;// 对于我们这题打开密码锁的问题// 就是穷举所有的密码组合, 直到到达目标密码// 密码锁初始值(开始状态)为 \"0000\", 一共四个位置, 每个位置可以向上或向下拨动, 也就是有 8 个相邻状态int openLock(vector&lt;string&gt;&amp; deadends, string target)&#123; queue&lt;string&gt; q; unordered_set&lt;string&gt; visited; unordered_set&lt;string&gt; deads; // 将死亡密码加入哈希集合 // 其实这里是可以直接用 visited, 就是说直接把死亡密码看作已经被访问过了, 一样的 for(auto elem : deadends) deads.insert(elem); q.push(\"0000\"); visited.insert(\"0000\"); int step = 0; while(!q.empty()) &#123; int qSize = q.size(); for(int i = 0; i &lt; qSize; i++) &#123; // 从队列中取出一个状态访问 string curLock = q.front(); q.pop(); // 如果当前状态在死亡状态里面 // 说明我们不能够到达这个状态 // 因此也就不可能从这个状态向其它相邻状态转换 // 继续取出队列中的下一个状态 if(deads.count(curLock)) continue; // 如果当前状态是目标状态了 if(curLock == target) return step; // 否则, 向相邻的 8 个状态转换 for(int j = 0; j &lt; 4; j++) &#123; // 将第 j 个字符向上拨动 string upRotate = rotate(curLock, j, 1); if(!visited.count(upRotate)) &#123; q.push(upRotate); visited.insert(upRotate); &#125; // 将第 j 个字符向下拨动 string downRotate = rotate(curLock, j, 0); if(!visited.count(downRotate)) &#123; q.push(downRotate); visited.insert(downRotate); &#125; &#125; &#125; step++; &#125; return -1;&#125;// direction 为 1 向上拨动, 为 0 则向下拨动string rotate(string theLock, int position, bool direction)&#123; if(direction) &#123; if(theLock[position] == '9') &#123; theLock[position] = '0'; return theLock; &#125; theLock[position]++; return theLock; &#125; else &#123; if(theLock[position] == '0') &#123; theLock[position] = '9'; return theLock; &#125; theLock[position]--; return theLock; &#125;&#125; 37. Sudoku Solver 编写一个程序，通过填充空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字1-9在每一行只能出现一次。 数字1-9在每一列只能出现一次。 数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。空白格用&#39;.&#39;表示。 一个数独 红色为答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 这是深度优先搜索算法应用的典型题目// void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board)&#123; dfs(board, 0, 0);&#125;bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col)&#123; // 如果当前行填写完了, 就到下一行 if(col == board.size()) return dfs(board, row + 1, 0); // 如果最后一行也填完了, 就说明找到了数独的一个解 if(row == board.size()) return true; // 如果当前格子中已经有数了就跳过这个格子 if(board[row][col] != '.') return dfs(board, row, col + 1); // 针对当前格子 // 从数字 1 到 9 依次尝试 for(char c = '1'; c &lt;= '9'; c++) &#123; // 如果当前格子放置这个数字不符合那 3 条规则就跳过 if(!isValid(board, row, col, c)) continue; // 做选择 board[row][col] = c; // 这里的 if 语句可以在找到一组解的时候立即返回 // 不至于找到所有可能的解 if(dfs(board, row, col + 1)) return true; // 撤销选择 board[row][col] = '.'; &#125; return false;&#125;bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, char c)&#123; for(int i = 0; i &lt; board.size(); i++) &#123; // 当前行不能有数字重复 if(board[row][i] == c) return false; // 当前列不能有数字重复 if(board[i][col] == c) return false; // 当前格子所在的九宫格不能有数字重复 // 这特么还真不好写, 看不懂就背下吧 if(board[(row / 3) * 3 + i / 3][(col / 3) * 3 + i % 3] == c) return false; &#125; return true;&#125; 279. Perfect Squares 给定正整数n，找到若干个完全平方数（比如1, 4, 9, 16, ...）使得它们的和等于n。你需要让组成和的完全平方数的个数最少。 给你一个整数n ，返回和为n的完全平方数的最少数量。 Example 1: 123Input: n &#x3D; 12Output: 3Explanation: 12 &#x3D; 4 + 4 + 4. Example 2: 123Input: n &#x3D; 13Output: 2Explanation: 13 &#x3D; 4 + 9. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// DP 递推式: numSquares(n) = min(numSquares(n - k)) + 1// 有点 找零钱 那题的那味儿int numSquares(int n)&#123; vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] = 0; vector&lt;int&gt; squares; // 先计算出所有符合条件的完全平方数 for(int i = 1; i * i &lt;= n; i++) squares.push_back(i * i); for(int i = 1; i &lt;= n; i++) &#123; for(int square : squares) &#123; if(i - square &lt; 0) break; dp[i] = min(dp[i], dp[i - square]); &#125; dp[i]++; &#125; return dp[n];&#125;// 穷举所有完全平方数相加的组合, 直到一组的和等于目标数// 因为要找用到的 [最少的] 完全平方数, 所以使用 BFS// 第 1 轮: 搜索所有 1 位数字判断是否满足// 将 0 + (1, 2, 4, 9, ...) 的数字依次放进队列中// 第 2 轮: 搜索所有 2 位数字的和并判断是否满足// 将 1 + (1, 2, 4, 9, ...) 的数字依次放进队列中// 将 2 + (1, 2, 4, 0, ...) 的数字依次放进队列中// ...// 第 3 轮: 搜索所有 3 位数字和并判断是否满足// ...// 你会发现我们穷举的时候遇到了大量同样的数字组合, 因此使用一个哈希集合来跳过它们int numSquares(int n)&#123; queue&lt;int&gt; q; unordered_set&lt;int&gt; visited; q.push(0); int step = 0; while(!q.empty()) &#123; int sz = q.size(); for(int i = 0; i &lt; sz; i++) &#123; int cur = q.front(); q.pop(); if(cur == n) return step; // 直到完全平方数大于目标数 // 这里的循环相当于是找当前值的所有可能的邻居 for(int j = 1; j * j &lt;= n; j++) &#123; int temp = cur + j * j; // 如果完全平方数的和还小于目标数 // 或者这个和没有被访问, 才加入队列 if(temp &lt;= n &amp;&amp; !visited.count(temp)) &#123; q.push(temp); visited.insert(temp); &#125; &#125; &#125; step++; &#125; return -1;&#125; 155. Min Stack 设计一个支持push，pop，top操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素x推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 1234567891011121314151617181920212223242526272829303132333435class MinStack&#123;public: /** initialize your data structure here. */ MinStack() : _minVal(INT_MIN) &#123;&#125; void push(int x) &#123; if(x &lt; _minVal || _data.empty()) _minVal = x; _data.push_back(x); &#125; void pop() &#123; if(_data.empty()) return; if(_data.back() == _minVal) _minVal = *min_element(_data.begin(), _data.end() - 1); _data.pop_back(); &#125; int top() &#123; return _data.back(); &#125; int getMin() &#123; return _minVal; &#125;private: vector&lt;int&gt; _data; int _minVal;&#125;; 739. Daily Temperatures 请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用0来代替。 例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是[1, 1, 4, 2, 1, 1, 0, 0]。 123456789101112131415161718192021222324252627// 这题本质上就是找到当前元素的下一个比它大的元素// 然后两者的索引相减即可// 像这样和下一个更大元素有关的问题都需要使用一种单调栈的技巧// 就是说维护一个栈, 使其中的元素保持单调的次序// 下面的代码就是单调栈的模板// 这里维护着从栈底到栈顶递减的次序vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T)&#123; // 存放答案的数组 vector&lt;int&gt; res(T.size()); stack&lt;int&gt; s; // 倒着遍历入栈, 因此也就是正着出栈 for(int i = T.size() - 1; i &gt;= 0; i--) &#123; // 如果当前元素比栈首元素大 // 那么栈的首元素出栈让出位子 // 直到首元素比当前元素大了才把当前元素压入栈 // 注意这里栈内放的是索引 while(!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) s.pop(); // 更新数组中第 i 个元素的下一个更大的元素 // 就在栈首 res[i] = s.empty() ? 0 : (s.top() - i); s.push(i); &#125; return res;&#125; 496. Next Greater Element I 给你两个没有重复元素的数组nums1和nums2，其中nums1是nums2的子集。 请你找出nums1中每个元素在nums2中的下一个比其大的值。 nums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出-1 。 Example: 123456Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2]Output: [-1,3,-1]Explanation:For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.For number 1 in the first array, the next greater number for it in the second array is 3.For number 2 in the first array, there is no next greater number for it in the second array, so output -1. 1234567891011121314151617181920// 直接套用单调栈的模板vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; // 这里用哈希表来存放答案 // 记录着 nums2 数组中的每个元素与其下一个更大的元素之间的映射 unordered_map&lt;int, int&gt; mapping; stack&lt;int&gt; s; for(int i = nums2.size() - 1; i &gt;= 0; i--) &#123; while(!s.empty() &amp;&amp; s.top() &lt;= nums2[i]) s.pop(); mapping[nums2[i]] = s.empty() ? -1 : s.top(); s.push(nums2[i]); &#125; vector&lt;int&gt; res(nums1.size()); // 直接从哈希表中获取 nums1 数组中元素的下一个更大元素即可 for(int i = 0; i &lt; nums1.size(); i++) res[i] = mapping[nums1[i]]; return res;&#125; 503. Next Greater Element II 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字x的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1。 Example: 123&gt;Input: [1,2,1]&gt;Output: [2,-1,2]&gt;Explanation: The first 1&#39;s next greater number is 2; The number 2 can&#39;t find next greater number; The second 1&#39;s next greater number needs to search circularly, which is also 2. 1234567891011121314151617181920212223// 这里和 I 题的区别是, 数组可以循环// 也就是说从当前位置一直向后看去, 直到找到下一个更大元素为止// 如果找到了尾元素则从首元素开始继续找// 可以看作在原始数组后面又接了一段原始数组(见上图)// 你当然可以申请一段两倍的数组空间来这放元素// 但是, 下面来学习一个循环遍历数组的技巧// 先直接套用单调栈的模板// 其中改动的地方就是能够循环遍历数组的技巧vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums)&#123; vector&lt;int&gt; res(nums.size()); stack&lt;int&gt; s; int n = nums.size(); for(int i = 2 * n - 1; i &gt;= 0; i--) &#123; while(!s.empty() &amp;&amp; s.top() &lt;= nums[i % n]) s.pop(); res[i % n] = s.empty() ? -1 : s.top(); s.push(nums[i % n]); &#125; return res;&#125; 556. Next Greater Element III 给你一个正整数n，请你找出符合条件的最小整数，其由重新排列n中存在的每位数字组成，并且其值大于n。如果不存在这样的正整数，则返回-1。 Example 1: 12Input: n &#x3D; 320241Output: 320412 Example 2: 12Input: n &#x3D; 321Output: -1 12345678910111213141516171819202122232425262728293031323334353637// 首先要想到的是先把数字转成字符串, 方便处理// 然后再试想一下, 影响数值前后发生大小变化的决定因素什么// 不知道你脑子里有没有蹦出 [逆序对] 三个字// 注意我这里的 [逆序对] 是指, 原本降序排列的数, 其中相邻的一对数字是升序// 如果你想到了这个, 那问题就很简单了// 对于数字其中的一个逆序对// 如果你把这两个数字交换, 值是不是就变大了？// 但这题要找变大之后的数中最小的数// 那就只需要对最后边的一个逆序对操作嘛// 但是还是不能简单的将逆序对的数字交换// 需要将逆序对的前一个元素和它后面的最后一个比它大的数交换才行// 交换完之后还要将逆序对后面的所有元素进行一次反转// 因为此时后面的那些元素必定是降序排列的, 反转之后值会进一步变小// 说起来太抽象了, 下面直接看代码int nextGreaterElement(int n)&#123; string s(to_string(n)); // 从后往前走 // 定位到第一个逆序对, pivot 指向逆序对的第一个元素 int pivot = s.size() - 2; for(; pivot &gt;= 0; pivot--) if(s[pivot] &lt; s[pivot + 1]) break; // 如果没有逆序对, 说明不可能组合成比原来大的数 if(pivot == -1) return -1; // 从后往前走, 定位到第一个比 pivot 指向元素大的元素 int larger = s.size() - 1; for(; larger &gt; pivot; larger--) if(s[pivot] &lt; s[larger]) break; // 交换二者 swap(s[pivot], s[larger]); // 这时候 pivot 之后的所有元素肯定是降序排列的 // 反转它们, 以求数值最小 reverse(s.begin() + pivot + 1, s.end()); // 如果这个数比 int 类型数值范围, 就不符合题目要求了 if(stol(s) &gt; INT_MAX) return -1; return stoi(s);&#125; 133. Clone Graph 给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。 图中的每个节点都包含它的值val（int）和其邻居的列表list[Node]。 1234567891011// Definition for a Node.struct Node&#123; int val; vector&lt;Node *&gt; neighbors; Node(int _val) &#123; val = _val; neighbors = vector&lt;Node *&gt;(); &#125;&#125;; Example: 1234567Input: adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]Output: [[2,4],[1,3],[2,4],[1,3]]Explanation: There are 4 nodes in the graph.1st node (val &#x3D; 1)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).2nd node (val &#x3D; 2)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).3rd node (val &#x3D; 3)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).4th node (val &#x3D; 4)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3). 1234567891011121314151617181920212223242526272829// 直接深度优先搜索即可// 只是需要使用一个哈希表来记录已经 new 过的节点// 哈希表中记录的是原节点和拷贝节点之间的映射// 下次通过某节点的邻居遍历到相同的节点直接从哈希表中取就可以了Node* cloneGraph(Node* node)&#123; if(!node) return nullptr; unordered_map&lt;Node*, Node*&gt; visited; return dfs(node, visited);&#125;Node* dfs(Node* node, unordered_map&lt;Node*, Node*&gt;&amp; visited)&#123; // 如果这个节点已经 被克隆过了 // 直接从哈希表中返回其映射 if(visited.count(node)) return visited[node]; // 克隆当前节点 Node* res = new Node(node-&gt;val); // 记录映射 visited[node] = res; // 深度遍历其所有邻居 vector&lt;Node*&gt; neighbors = node-&gt;neighbors; for(int i = 0; i &lt; neighbors.size(); i++) // 将其一一添加进拷贝节点的邻居中 res-&gt;neighbors.push_back(dfs(neighbors[i], visited)); return res;&#125; 494. Target Sum 给定一个非负整数数组，a1, a2, ..., an和一个目标数S。现在你有两个符号+和-。对于数组中的任意一个整数，你都可以从+或-中选择一个符号添加在前面。 返回可以使最终数组和为目标数S的所有添加符号的方法数。 Example: 1234567891011Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 &#x3D; 3+1-1+1+1+1 &#x3D; 3+1+1-1+1+1 &#x3D; 3+1+1+1-1+1 &#x3D; 3+1+1+1+1-1 &#x3D; 3There are 5 ways to assign symbols to make the sum of nums be target 3. 123456789101112131415161718192021222324252627282930313233343536// 先上暴力搜索 (dfs)// 注意这里用到的一个技巧是// 等式左边的数相加或相减起来 = S, 等价于 S + 等式左边的那些数相加或相减 = 0// 它们的个数肯定相等嘛int count = 0;int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)&#123; dfs(nums, 0, S); return count;&#125;void dfs(vector&lt;int&gt;&amp; nums, int pos, long S)&#123; if(pos == nums.size()) &#123; if(S == 0) count++; return; &#125; // S += nums[pos]; // 做选择 // dfs(nums, pos + 1, S); // S -= nums[pos]; // 撤销选择 dfs(nums, pos + 1, S + nums[pos]); // 函数进入自动做选择, 返回自动撤销选择 // S -= nums[pos]; // 做选择 // dfs(nums, pos + 1, S); // S += nums[pos]; // 撤销选择 dfs(nums, pos + 1, S - nums[pos]); // 函数进入自动做选择, 返回自动撤销选择&#125;// 再上动态规划// int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)&#123; &#125; 232. Implement Queue using Stacks 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作： 实现MyQueue类： void push(int x)：将元素x推到队列的末尾； int pop()：从队列的开头移除并返回元素； int peek()：返回队列开头的元素； bool empty()：如果队列为空，返回true；否则，返回false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 如上图, 将两个栈这样放class MyQueue&#123;public: /* Initialize your data structure here. */ MyQueue() &#123;&#125; /* Push element x to the back of queue. */ void push(int x) &#123; // 入栈的时候直接放进右边的栈即可 _back.push(x); &#125; /* Removes the element from in front of queue and returns that element. */ int pop() &#123; // 出栈的时候从左边出 // 如果为空, 需要把右边栈的元素搬过来 if(_front.empty()) moveData(); // 搬过来之后直接 pop 左边的栈即可 int res = _front.top(); _front.pop(); return res; &#125; /* Get the front element. */ int peek() &#123; // 取的时候和 pop 的情况一样 if(_front.empty()) moveData(); // 只是不出栈, 只取元素 return _front.top(); &#125; /* Returns whether the queue is empty. */ bool empty() &#123; return _front.empty() &amp;&amp; _back.empty(); &#125; private: stack&lt;int&gt; _front; stack&lt;int&gt; _back; void moveData() &#123; // 搬移数据就是简单的将右边栈出栈 // 左边栈接收元素压入栈 while(!_back.empty()) &#123; _front.push(_back.top()); _back.pop(); &#125; &#125;&#125;; 225. Implement Stack using Queues 请你仅使用两个队列实现一个后入先出的栈，并支持普通队列的全部四种操作。 实现MyStack类： void push(int x)：将元素x压入栈顶； int pop()：移除并返回栈顶元素； int top()：返回栈顶元素； bool empty()：如果栈是空的，返回true；否则，返回false。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 队列实现栈// 入栈操作很简单, 调用队列的 push 即可// 出栈麻烦点, 因为队列只能从对头出列, 对头相当于栈的栈底// 但我们是想 pop 掉队尾元素// 这时很暴力, 直接把队列中除了队尾之外的所有元素依次出队并依次入队即可// 这时对头就是原队尾元素了, 再出队就行// 获取栈顶元素的话, 为了实现 O(1) 复杂度// 使用一个变量实时记录队尾 (栈顶) 元素class MyStack&#123;public: /* Initialize your data structure here. */ MyStack() &#123;&#125; /* Push element x onto stack. */ void push(int x) &#123; // 入队的时候要更新栈顶变量 _top = x; _queue.push(x); &#125; /* Removes the element on top of the stack and returns that element. */ int pop() &#123; int sz = _queue.size(); while(sz-- &gt; 1) &#123; _top = _queue.front(); _queue.pop(); _queue.push(_top); &#125; int res = _queue.front(); _queue.pop(); return res; &#125; /* Get the top element. */ int top() &#123; return _top; &#125; /* Returns whether the stack is empty. */ bool empty() &#123; return _queue.empty(); &#125;private: queue&lt;int&gt; _queue; int _top;&#125;; 200. Number of Islands 给定一个m x n字符栅格网格，该栅格网格表示&#39;1&#39;（土地）和&#39;0&#39;（水）的地图，请返回岛的数量。 一个岛屿被水包围，是通过水平或垂直连接相邻的土地而形成的。 您可以假设网格的所有四个边缘都被水包围。 Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] is &#39;0&#39; or &#39;1&#39; Example 1: 1234567Input: grid &#x3D; [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]Output: 1 Example 2: 1234567Input: grid &#x3D; [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]Output: 3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 思想是// 1. 依次遍历网格中的每一个字符// 2. 如果当前字符是 '1' 说明踏上了一座岛, 进行下一步, 如果为 '0'，回到步骤 1// 3. 然后骚操作来了, 将当前字符赋值为 '0'// 4. 然后遍历当前字符的上下左右四个邻居// 5. 每到一个邻居重复对当前字符的操作// 6. 直到某一个邻居 (可以是邻居的邻居) 的四个邻居都为'0'// 7. 说明这座岛的每一个陆地都走过了, 此时岛数量 +1// 8. 接下来再到下一个字符, 回到步骤 1// 遍历邻居的时候有两种方法, dfs 和 bfs// dfsint numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid)&#123; int count = 0; for(int i = 0; i &lt; grid.size(); i++) &#123; for(int j = 0; j &lt; grid[0].size(); j++) &#123; if(grid[i][j] == '1') &#123; // 踏上了一座岛 count++; // 递归函数的目的把这座岛的所有陆地变成水 (淹没) dfs(grid, i, j); &#125; &#125; &#125; return count;&#125;void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c)&#123; if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size() || grid[r][c] != '1') return; // 淹没陆地 grid[r][c] = '0'; // 判断左邻居 dfs(grid, r - 1, c); // 判断右邻居 dfs(grid, r + 1, c); // 判断上邻居 dfs(grid, r, c - 1); // 判断下邻居 dfs(grid, r, c + 1);&#125;// bfs 借助队列的迭代实现int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid)&#123; if(grid.empty()) return 0; // 队列中保存的是当前陆地的坐标 queue&lt;pair&lt;int, int&gt;&gt; q; int count = 0; for(int i = 0; i &lt; grid.size(); i++) &#123; for(int j = 0; j &lt; grid[0].size(); j++) &#123; if(grid[i][j] == '1') &#123; // 踏上了一座岛 count++; q.push(&#123;i, j&#125;); // while 循环的目的是把这座岛的所有陆地变成水 (淹没) while(!q.empty()) &#123; int r = q.front().first; int c = q.front().second; q.pop(); if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size() || grid[r][c] != '1') continue; // 淹没陆地 grid[r][c] = '0'; // 判断左邻居 q.push(&#123;r - 1, c&#125;); // 判断右邻居 q.push(&#123;r + 1, c&#125;); // 判断上邻居 q.push(&#123;r, c - 1&#125;); // 判断下邻居 q.push(&#123;r, c + 1&#125;); &#125; &#125; &#125; &#125; return count;&#125; 694. Number of Distinct Islands 给定一个非空01二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的1组成，你可以认为网格的四周被海水包围。 请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。 示例 1： 1234511000110000001100011给定上图，返回结果 1 。 示例 2： 1234511011100000000111011给定上图，返回结果 3 。 注意： 11 1 和 1 11 是不同的岛屿，因为我们不考虑旋转、翻转操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344int x = 0, y = 0;int numDistinctIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; set&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; setting; for(int i = 0; i &lt; grid.size(); i++) &#123; for(int j = 0; j &lt; grid[0].size(); j++) &#123; if(grid[i][j] == 1) &#123; // 踏上了一座岛 // isLand 用于记录这座岛的所有陆地坐标 // 实际记录的是相对陆地坐标, 即其他陆地相对于左上角的那块陆地 vector&lt;pair&lt;int, int&gt;&gt; isLand; // 更新当前岛屿的相对坐标 x = i; y = j; // 递归函数的目的把这座岛的所有陆地变成水 (淹没) dfs(grid, isLand, i, j); // set 有自动排序和去重的功能 setting.insert(isLand); &#125; &#125; &#125; return setting.size();&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;pair&lt;int, int&gt;&gt;&amp; isLand, int r, int c)&#123; if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size() || grid[r][c] != 1) return; isLand.push_back(&#123;r - x, c - y&#125;); // 淹没陆地 grid[r][c] = 0; // 判断左邻居 dfs(grid, isLand, r - 1, c); // 判断右邻居 dfs(grid, isLand, r + 1, c); // 判断上邻居 dfs(grid, isLand, r, c - 1); // 判断下邻居 dfs(grid, isLand, r, c + 1);&#125; 1254. Number of Closed Islands 有一个二维矩阵grid，每个位置要么是陆地（记号为0）要么是水域（记号为1）。 我们从一块陆地出发，每次可以往上下左右4个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。 如果一座岛屿完全由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。 请返回封闭岛屿的数目。 Example 1: 1234Input: grid &#x3D; [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]Output: 2Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). Example 2: 12Input: grid &#x3D; [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]Output: 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 注意这题 1 代表水域而 0 代表陆地// 和岛屿数量 I 题的区别在于边界上的岛屿不算岛屿// 所以如果搜索出来的岛屿在边界上就不更新岛屿数bool flag; // 是否是封闭岛的标志int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; int rowLength = grid.size(); int colLength = grid[0].size(); int count = 0; for(int i = 0; i &lt; rowLength; i++) &#123; for(int j = 0; j &lt; colLength; j++) &#123; if(grid[i][j] == 0) &#123; // 踏上了一座岛 // 看它是否是边界岛 flag = true; // 递归函数的目的把这座岛的所有陆地变成水 (淹没) dfs(grid, i, j); if(flag) count++; &#125; &#125; &#125; return count;&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r, int c)&#123; if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size()) &#123; // 能到达边界, 说明不是封闭岛 flag = false; return; &#125; if(grid[r][c] != 0) return; // 淹没陆地 grid[r][c] = 1; // 判断左邻居 dfs(grid, r - 1, c); // 判断右邻居 dfs(grid, r + 1, c); // 判断上邻居 dfs(grid, r, c - 1); // 判断下邻居 dfs(grid, r, c + 1);&#125; 695. Max Area of Island 给定一个包含了一些0和1的非 空二维数组grid。 一个岛屿是由一些相邻的1(代表土地) 构成的组合，这里的「相邻」要求两个1必须在水平或者竖直方向上相邻。你可以假设grid的四个边缘都被0（代表水）包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0 ) Example 1: 12345678910[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]Given the above grid, return &#96;6&#96;. Note the answer is not 11, because the island must be connected 4-directionally. Example 2: 123[[0,0,0,0,0,0,0,0]]Given the above grid, return &#96;0&#96;. 1234567891011121314151617181920212223242526272829303132333435363738// dfsint area; // 用于记录每个岛的面积int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; int res = 0; for(int i = 0; i &lt; grid.size(); i++) &#123; for(int j = 0; j &lt; grid[0].size(); j++) &#123; if(grid[i][j] == 1) &#123; // 踏上了一座岛就把先前岛屿面积清零 area = 0; // 递归函数的目的把这座岛的所有陆地变成水 (淹没) dfs(grid, i, j); res = max(res, area); &#125; &#125; &#125; return res;&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r, int c)&#123; if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size() || grid[r][c] != 1) return; // 淹没陆地 grid[r][c] = 0; area++; // 判断左邻居 dfs(grid, r - 1, c); // 判断右邻居 dfs(grid, r + 1, c); // 判断上邻居 dfs(grid, r, c - 1); // 判断下邻居 dfs(grid, r, c + 1);&#125; 733. Flood Fill 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在0到65535之间。 给你一个坐标(sr, sc)表示图像渲染开始的像素值（行 ，列）和一个新的颜色值newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 Example: 123456789Input: image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connectedto the starting pixel. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 和前面那个岛屿数量 I 的题思路差不多// DFSvector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor)&#123; if(image[sr][sc] != newColor) dfs(image, sr, sc, image[sr][sc], newColor); return image;&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int r, int c, int srcColor, int newColor)&#123; if(r &lt; 0 || c &lt; 0 || r == image.size() || c == image[0].size() || image[r][c] != srcColor) return; image[r][c] = newColor; dfs(image, r + 1, c, srcColor, newColor); dfs(image, r - 1, c, srcColor, newColor); dfs(image, r, c + 1, srcColor, newColor); dfs(image, r, c - 1, srcColor, newColor);&#125;// BFSvector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor)&#123; if(image[sr][sc] == newColor) return image; int srcColor = image[sr][sc]; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;sr, sc&#125;); while(!q.empty()) &#123; int sz = q.size(); for(int i = 0; i &lt; sz; i++) &#123; int r = q.front().first; int c = q.front().second; q.pop(); if(r &lt; 0 || c &lt; 0 || r == image.size() || c == image[0].size() || image[r][c] != srcColor) continue; image[r][c] = newColor; q.push(&#123;r + 1, c&#125;); q.push(&#123;r - 1, c&#125;); q.push(&#123;r, c + 1&#125;); q.push(&#123;r, c - 1&#125;); &#125; &#125; return image;&#125; 542. 01 Matrix 给定一个由0和1组成的矩阵，找出每个元素到最近的0的距离。 两个相邻元素间的距离为1。矩阵中的元素只在四个方向上相邻：上、下、左、右。 Example 1: 123456789&gt;Input:&gt;[[0,0,0],&gt;[0,1,0],&gt;[0,0,0]]&gt;Output:&gt;[[0,0,0],&gt;[0,1,0],&gt;[0,0,0]] Example 2: 123456789&gt;Input:&gt;[[0,0,0],&gt;[0,1,0],&gt;[1,1,1]]&gt;Output:&gt;[[0,0,0],&gt;[0,1,0],&gt;[1,2,1]] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 因为要寻找 [最近] 距离, 所以显然使用 BFSvector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)&#123; int rSize = matrix.size(); int cSize = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; res(rSize, vector&lt;int&gt;(cSize)); queue&lt;pair&lt;int, int&gt;&gt; q; int step = 0; // 因为要对矩阵中的所有元素进行寻找最近的 0 // 所以外面的两层循环实际上是处理这个问题的 // 如果只需要对一个元素进行寻找就不需要这两层循环, 和传统的 BFS 模板一样 for(int i = 0; i &lt; rSize; i++) &#123; for(int j = 0; j &lt; cSize; j++) &#123; step = 0; q.push(&#123;i, j&#125;); while(!q.empty()) &#123; int sz = q.size(); while(sz--) &#123; // 从当前位置出发, 遍历其所有邻居 int r = q.front().first; int c = q.front().second; q.pop(); // 如果 走到了 0, 那么它离 0 的最近距离就是已经走的 step if(matrix[r][c] == 0) &#123; res[i][j] = step; // 更新完 step 之后还要将队列清空方便对下一位置进行搜索时使用 while(!q.empty()) q.pop(); break; &#125; // 将其上下左右四个邻居入栈等待搜索 if(r + 1 &lt; rSize) q.push(&#123;r + 1, c&#125;); if(r - 1 &gt;= 0) q.push(&#123;r - 1, c&#125;); if(c + 1 &lt; cSize) mq.push(&#123;r, c + 1&#125;); if(c - 1 &gt;= 0) q.push(&#123;r, c - 1&#125;); &#125; step++; &#125; &#125; &#125; return res;&#125; 841. Keys and Rooms 有N个房间，开始时你位于0号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间i都有一个钥匙列表rooms[i]，每个钥匙rooms[i][j]由[0,1，...，N-1]中的一个整数表示，其中N = rooms.length。 钥匙rooms[i][j] = v可以打开编号为v的房间。 最初，除0号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回true，否则返回false。 Note: 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 The number of keys in all rooms combined is at most 3000. Example 1: 1234567Input: [[1],[2],[3],[]]Output: trueExplanation: We start in room 0, and pick up key 1.We then go to room 1, and pick up key 2.We then go to room 2, and pick up key 3.We then go to room 3. Since we were able to go to every room, we return true. Example 2: 123Input: [[1,3],[3,0,1],[2],[0]]Output: falseExplanation: We can&#39;t enter the room with number 2. 123456789101112131415161718192021222324252627282930// 因为最多就 1000 个房间// 需要对已经访问过的房间进行标记// 所以这里我们使用一个 bitsetbool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms)&#123; // 所有房间初始化全未被访问 bitset&lt;1000&gt; bits; // 从 0 号房间开始 return dfs(rooms, 0, bits);&#125;// 因为我们是想要搜索到一种可能满足的访问次序就可以// 所以这里的 dfs 函数有 bool 返回值来提前结束搜索bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; rooms, int room, bitset&lt;1000&gt;&amp; bits)&#123; // 访问当前房间, 标记为已访问 bits.set(room); // 如果访问的房间总数等于所有房间数 if(bits.count() == rooms.size()) return true; // 否则, 从当前房间获取其它房间钥匙, 依次进行访问 vector&lt;int&gt; curRoom = rooms[room]; for(int key : curRoom) &#123; // 如果这把钥匙对应的房间已经被访问过, 就不过去了 if(bits.test(key)) continue; // 否则去访问 if(dfs(rooms, key, bits)) return true; &#125; return false;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"操作系统之malloc底层原理","date":"2021-03-15T13:35:42.000Z","path":"wF5qv4uNKgDG1SUa/","text":"malloc、free底层原理先来了解一些背景知识。 进程地址空间的组成： 内核空间：这块区域包含两种数据，一种是对每个进程都一样的数据，如共享的内核代码和全局数据结构。另一种是每个进程都不一样的数据，如页表、内核在进程上下文中执行代码时使用的栈，以及记录该进程虚拟地址空间当前组织状态的各种数据结构。 BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。是可读写的。在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了）。 数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 堆（heap）是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free函数释放内存时，被释放的内存从堆中被释放（堆被缩减） 。 栈（stack）又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数块中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 内存映射区：这块虚拟内存区域被映射到任何需要的对象身上，如共享库文件、磁盘上的普通文件和将要介绍的通过malloc分配的大块内存区域（大于128K）。 注意这些区域实际上存在于进程的虚拟地址空间上，一开始并没有被装载到物理内存上，比如说bss段，理论上是被初始化为零值，但并不是说在物理内存区域的对应段被填入零值，实际上，是将其映射到了零页，等到CPU向这块区域内写数据时，通过引发缺页故障的形式，才被装载到物理内存，分配到初始化为零的页（所谓的写时复制）。 操作系统提供的两个系统调用函数： 1234#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void* sbrk(intptr_t incr);void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset); sbrk函数的作用是移动brk指针扩展heap的上界。函数的参数指示brk指针移动的大小，返回申请之前的brk地址。注意申请的内存地址中的值是随机的，即不要求为零。 mmap函数第一种用法是映射磁盘文件到内存中；而malloc使用的mmap函数的第二种用法，即匿名映射，匿名映射不映射磁盘文件，而是向映射区申请一块全零页内存，相应的虚拟页面是被初始化为零的。 如上面的进程虚拟内存布局图所示，mmap对应Memory Mapping Segment，brk对应Heap。start_brk是堆段的开始位置，brk(program break)则是堆段的结束位置。 下面开始介绍malloc的实现原理。 那么，既然brk/mmap提供了内存分配的功能，直接使用brk/mmap进行内存管理不是更简单吗，为什么需要malloc呢？ 我们知道，系统调用本身会产生软中断，导致程序从用户态陷入内核态，比较消耗资源。试想，如果频繁分配回收小块内存区，那么将有很大的性能耗费在系统调用中。因此，为了减少系统调用带来的性能损耗，malloc采用了内存池的设计，增加了一个代理层，每次内存分配，都优先从内存池中寻找，如果内存池中无法提供，再向操作系统申请。 当申请小于128K内存时，malloc使用sbrk分配内存，当申请大于128K内存时，使用mmap函数申请内存。 下面主要讨论对于小块内存的申请malloc所采用的内存池设计方案。分配器不但要管理已分配的内存块，还需要管理空闲的内存块。malloc利用chunk结构体来管理这些内存块，内存池就是由许多不同大小的chunk链表组成的。 内存池保存在bins这个长128的数组中，每个元素都是一个双向链表。其中： bins[0]目前没有使用。 bins[1]的链表称为unsorted_list，用于维护free释放的chunk。 bins[2, 63)的区间称为small_bins，用于维护＜512字节的内存块，其中每个元素对应的链表中的chunk大小相同，均为index*8。 bins[64,127)称为large_bins，用于维护&gt;512字节的内存块，每个元素对应的链表中的chunk大小不同，index越大，链表中chunk的内存大小相差越大，例如: 下标为64的chunk大小介于[512, 512+64)，下标为95的chunk大小介于[2k+1, 2k+512)。同一条链表上的chunk，按照从小到大的顺序排列。 结构体malloc_chunk来描述这些块： 123456789101112struct malloc_chunk&#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; glibc在内存池中查找合适的chunk时，采用了最佳适应的伙伴算法。举例如下： 如果分配内存&lt; 512字节，则通过内存大小定位到smallbins对应的index上。 如果smallbins[index]为空，进入步骤3 如果smallbins[index]非空，直接返回第一个chunk 如果分配内存&gt; 512字节，则定位到largebins对应的index上。 如果largebins[index]为空，进入步骤3 如果largebins[index]非空，扫描链表，找到第一个大小最合适的chunk，如size=12.5K，则使用chunk B，剩下的0.5k放入unsorted_list中 遍历unsorted_list，查找合适size的chunk，如果找到则返回；否则，将这些chunk都归类放到smallbins和largebins里面。 index++从更大的链表中查找，直到找到合适大小的chunk为止，找到后将chunk拆分，并将剩余的加入到unsorted_list中。 如果还没有找到，那么使用top chunk。 top chunk 如下图示: top chunk是堆顶的chunk，堆顶指针brk位于top chunk的顶部。移动brk指针，即可扩充top chunk的大小。 free释放内存时，有两种情况： chunk和top chunk相邻，则和top chunk合并。 chunk和top chunk不相邻，则直接插入到unsorted_list中。 参考链接： glibc内存管理那些事儿 - 简书 Understanding glibc malloc – sploitF-U-N 自己实现一个简单的malloc可参考 malloc-tutorial/malloc.c at master · danluu/malloc-tutorial [译] 写一个简单的内存分配器（替换glibc中的malloc函数） | yoko blog [译] malloc中的系统调用brk和mmap | yoko blog。 [malloc的底层实现（ptmalloc）_牛客博客","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统之内存管理","date":"2021-03-12T13:35:42.000Z","path":"CB6w5vAiSmICT1OK/","text":"操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做内存管理。 内存管理加载和链接 地址绑定时间 功能 程序设计时 程序员直接在程序中确定所有实际的物理地址 编译或汇编时 程序包含符号地址访问，由编译器在加载程序时把它们转换为实际的绝对地址 加载时 编译器或汇编器产生相对地址，加载器在加载程序时把它们转换为实际的绝对地址 运行时 被加载的程序保持相对地址，处理器硬件在执行时把它们动态的转换为绝对地址 链接时间 功能 程序设计时 不允许外部程序或数据访问。程序员必须把所有引用到的子程序源代码放入程序中 编译或汇编时 汇编器必须取到每个引用的子程序的源代码，并把它们作为一个部件来进行汇编 加载模块产生时 所有目标模块都使用相对地址汇编。这些模块被链接在一起，所有访问都相对于最后加载的模块的地点重新声明 加载时 直到加载模块被加载到内存时才解析外部访问，此时被访问的动态链接模块附加到加载模块后，整个软件包被加载到内存或虚存 运行时 直到处理器执行外部调用时才解析外部访问，此时该进程被中断，需要的模块被链接到调用程序中 加载创建活动进程的第一步是把程序装入内存，并创建一个进程映像。应用程序由许多已编译过或汇编过的模块组成，这些模块以目标代码的形式存在，并被链接起来以解析模块间的任何访问和对库例程的访问。库例程可以合并到程序中，或作为操作系统在运行时提供的共享访问代码。 加载器把加载的模块放置在内存中从x开始的位置。一般而言，可以采用三种方法: 绝对加载 绝对加载器要求给定加载模块总被加载到内存中的同一位置。因此，在提供给加载器的加载模块中，所有的地址访问必须是确定的，或者说是绝对的内存地址。给程序中的内存访问指定具体的地址值既可以由程序员完成，也可以在编译时或汇编时完成， 这种方法存在许多缺点：首先，程序员必须知道在内存中放置模块时预定的分配策略；其次，如果在程序的模块体中进行了任何涉及插入或删除的修改，则所有地址都需要更改。 因此，更可取的方法是允许用符号表示程序中的内存访问，然后在编译或汇编时解析这些符号引用。对指令或数据项的引用最初被表示成一个符号。在准备输入到一个绝对加载器的模块时，汇编器或编译器将把所有这些引用转换为具体地址。 可重定位加载 在加载之前就把内存访问绑定到具体的地址的缺点是，会使得加载模块只能放置到内存中的一个区域。但是，当多个程序共享内存时，不可能事先确定哪块区域用于加载哪个特定的模块，最好是在加载时确定。因此，需要一个可分配到内存中任何地方的加载模块。 为满足这个新需求，汇编器或编译器不产生实际的内存地址（绝对地址），而是使用相对于某些已知点的地址，如相对于程序的起点。加载模块中的所有其他内存访问都用与该模块起点的相对值来表示。 既然所有内存访问都以相对形式表示，那么加载器就可以很容易地把模块放置在期望的位置。如果该模块要加载到从x位置开始的地方，则当加载器把该模块加载到内存中时，只需简单地给每个内存访问都加上x。为完成这一任务，加载模块必须包含一些需要告诉加载器的信息，如地址访问在哪里、如何解释它们（通常相对于程序的起点）。由编译器或汇编器准备这些信息，通常称这些信息为重定位地址库。 动态运行时加载 动态运行时加载可重定位加载器非常普遍，且相对于绝对加载器具有明显的优点。但是，在多道程序设计环境中，即使不依赖于虚存，可重定位的加载方案仍是不够的。由于需要把进程换入或换出内存来增大处理器的利用率，而为最大程度地利用内存，又希望能在不同的时刻把一个进程映像换回到不同的位置，因此，程序被加载后，可能被换出到磁盘，然后又被换回到内存中不同的位置。如果在开始加载时，内存访问就被绑足到绝对地址，那么前面提到的情况是不可能实现的。 一种替代方案是在运行时真正在使用某个绝对地址时再计算它。为达到这一目的，加载模块被加载到内存中时，其所有内存访问都以相对形式表示，一条指令只有在真正被执行时才计算其绝对地址。为确保该功能不会降低性能，这些工作必须由特殊的处理器硬件完成，而不用软件实现。 动态地址计算提供了很大的灵活性。一个程序可以加载到内存中的任何区域，程序的执行可以中断，程序还可换出内存，以后再换回到不同的位置。 链接链接器的功能是把一组目标模块作为输入，产生一个包含完整程序和数据模块的加载模块，并传递给加载器。在每个目标模块中，可能有到其他模块的地址访问，每个这样的访问可以在未链接的目标模块中用符号表示。链接器会创建一个单独的加载模块，它把所有目标模块逐个链接起来。每个模块内的引用必须从符号地址转换为对整个加载模块中的一个位置的引用。 产生可重定位加载模块的链接器通常称为链接编辑程序。地址链接的性质取决于链接发生时要创建的加载模块的类型。通常情况下需要可重定位的加载模块，然后链接按以下方式完成：同时创建每个已编译或汇编的目标模块及相对于该目标模块开始处的引用。所有这些模块，连同相对于该加载模块起点的所有引用，一起放进一个可重定位的加载模块中。该模块可以作为可重定位加载或动态运行时加载的输入。 像加载一样，可以推迟某些链接功能。动态链接是指把某些外部模块的链接推迟到创建加载模块之后。因此，加载模块包含到其他程序的未解析的引用，这些引用可以在加载时或运行时解析。 加载时的动态链接分为如下步骤： 待加载的加载模块（应用模块）读入内存。 应用模块中到一个外部模块（目标模块）的任何引用都将导致加载程序查找目标模块，加载它，并把这些引用修改为相对于应用程序模块开始处的相对地址。 该方法与静态加载相比，有以下优点： 能更容易地并入已改变或已升级的目标模块，如操作系统工具，或某些其他的通用例程。而对于静态链接，这类支持模块的变化需要重新链接全部应用程序模块。 在动态链接文件中的目标代码可以很方便的进行共享。因为操作系统加载并链接了该代码，所以可以识别出有多个应用程序使用相同的目标代码。操作系统可以使用此信息，然后只加载目标代码的一个副本，并把这个被加载的目标副本链接到所有使用该目标代码的应用程序，而不是为每个应用程序都分别加载一个副本。 使用运行时动态链接时，某些链接工作被推迟到执行时。这样一些对目标模块的外部引用保留在被加载的程序中，当调用的模块不存在时，操作系统定位该模块，加载它，并把它链接到调用模块中。这些模块一般是共享的。在 Windows环境下，这些模块称为动态链接库（DLL）。也就是说，如果一个进程已使用动态链接共享模块，该模块就位于内存中，新的进程就可以简单地链接上已加载好的模块。 内存管理的需求操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做内存管理。 术语 解释 页框 内存中固定长度的块 页 固定长度的数据块。一般和页框的长度相等，数据页可临时复制到内存的页框中 段 变长的数据块。整个段可以临时复制到内存中的一个可用区域中，或者将一个段划分为许多页，然后将每页单独复制到内存中（分段和分页相结合） 内存管理的需求如下： 重定位 可用的有限内存空间通常被多个进程共享。程序换出到磁盘后，下次换入内存时并不一定被放回原来的区域。也就是说我们需要把进程重定位到不同的内存区域。同时，我们必须允许程序通过交换技术在内存中移动，所以处理器硬件和操作系统软件必须能够以某种方式将程序代码中写死的内存访问地址转换为实际的物理内存地址。 首次加载一个进程时，重定位将代码中的相对内存访问被绝对内存地址代替，这个绝对地址由进程被加载到的基地址确定。 一个进程在其生命周期中可能占据不同的分区。首次创建一个进程映像时，它被装入内存中的某个分区。以后，该进程可能被换出，当它再次被换入时，可能被指定到与上一次不同的分区中。 进程被换入或在内存中移动时，指令和数据单元的位置会发生改变。为解决这个问题，需要区分几种地址类型。逻辑地址是指与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须把它转换为物理地址。相对地址是逻辑地址的一个特例，它是相对于某些已知点（通常是程序的开始处）的存储单元。物理地址或绝对地址是数据在内存中的实际位置。 进程处于运行态时，有一个特殊处理器寄存器（称为基址寄存器），其内容是程序在内存中的起始地址。还有一个界限寄存器指明程序的终止位置。当程序被装入内存或当该进程的映像被换入时，必须设置这两个寄存器。在进程的执行过程中会遇到相对地址，包括指令寄存器的内容、跳转或调用指令中的指令地址，以及加载和存储指令中的数据地址。每个这样的相对地址都经过处理器的两步操作。首先，基址寄存器中的值加上相对地址产生一个绝对地址；然后，将得到的结果与界限寄存器的值进行比较，如果这个地址在界限范围内，则继续该指令的执行；否则，向操作系统发出一个中断信号，操作系统必须以某种方式对这个错误做出响应。 保护 一个进程的内存空间不能被其它进程未经授权的访问，满足重定位的需求增大了满足保护需求的难度。由于程序在内存中的位置通常会变化，因此，不可能通过在编译时检查绝对地址来保护。必须在运行时检查进程的所有内存访问，以确保它们只访问分配给自己的内存空间。 注意，内存保护必须由硬件（处理器）而非软件（操作系统）来满足。 共享 例如，多个进程在执行同一个程序时，允许每个进程访问该程序的同一个副本，以节省内存空间。这意味着操作系统允许进程对共享内存区域的受控访问。 逻辑组织 计算机系统中的内存总是被组织成线性(或一维）的地址空间，且地址空间由一系列字节或字组成。然而，大多数程序被组织成模块，某些模块是不可修改的（只读、只执行），某些模块包含可以修改的数据。若操作系统和计算机硬件能够有效地处理以某种模块形式组织的用户程序与数据，则会带来很多好处： 可以独立地编写和编译模块，系统在运行时解析从一个模块到其他模块的所有引用。 通过适度的额外开销，可以为不同的模块提供不同的保护级别。 可以引入某种机制，使得模块可被多个进程共享。 最易于满足这些需求的工具是分段。 物理组织 计算机存储器至少要组织成两级，即内存和外存。内存提供快速的访问，成本也相对较高。此外，内存是易失性的，即它不能提供永久性存储。外存比内存慢而且便宜，且通常是非易失性的。因此，大容量的外存可用于长期存储程序和数据，而较小的内存则用于保存当前使用的程序和数据。 在两级存储器间移动信息的任务应由系统负责。这一任务恰好是存储管理的本质。 固定分区和动态分区内存管理的主要操作是处理器把程序装入内存中执行。虚存基于分页和分段两种技术。 内存管理技术 说明 固定分区 在系统生成阶段，内存被划分成许多静态分区。进程可装入大于等于自身大小的分区中 动态分区 分区是动态创建的，因而每个进程可装入与自身大小正好相等的分区中 简单分页 内存被划分成许多大小相等的页框；每个进程被划分成许多大小与页框相等的页；要装入一个进程,需要把进程包含的所有页都装入内存内不一定连续的某些页框中 简单分段 每个进程被划分成许多段；要装入一个进程，需要把进程包含的所有段都装入内存内不一定连续的某些动态分区中 虚存分页 除了不需要装入一个进程的所有页外，与简单分页一样；非驻留页在以后需要时自动调入内存 虚存分段 除了不需要装入一个进程的所有段外，与简单分段一样；非驻留段在以后需要时自动调入内存 固定分区 使用大小相等的分区： 程序可能太大而不能放到一个分区中，此时必须使用覆盖技术。 内存的利用率很低。会产生大量内部碎片。 使用大小不等的分区可缓解这两个问题。 对于大小相等的分区，放置算法将进程放入内存的哪个分区都没有关系。 对于大小不等的分区，放置算法将每个进程分配到能够容纳它的最小分区中。每个分区需要维护一个调度队列，用于保存从这个分区换出的进程。 动态分区 对于动态分区，分区长度和数量是可变的。进程装入内存时，系统会给它分配一块与其所需容量完全相等的内存空间。动态分区方法最初不错，但它最终在内存中形成了许多小空洞。随着时间的推移，内存中形成了越来越多的外部碎片，内存的利用率随之下降。 放置算法把一个进程装入或换入内存时，如果内存中有多个足够大的空闲块，那么操作系统必须确定要为此进程分配哪个空闲块。可供考虑的放置算法有三种：最佳适配、首次适配和下次适配。首次适配算法是最简单，最好和最快的。 置换算法使得操作系统将一个阻塞的进程换出内存，给新进程或处于就绪-挂起态的进程让出空间。因此,操作系统必须选择要替换哪个进程。 伙伴系统 简单分页大小不等的固定分区和大小可变的分区技术在内存的使用上都是低效的，前者会产生内部碎片，后者会产生外部碎片。但是，如果内存被划分成大小固定、相等的块，且块相对比较小，每个进程也被分成同样大小的小块，那么进程中称为页的块可以分配到内存中称为页框的可用块。使用分页技术时，每个进程在内存中浪费的空间，仅是进程最后一页的一小部分形成的内部碎片，没有任何外部碎片。 在某个给定时刻，内存中的某些页框正被使用，某些页框是空闲的，操作系统维护空闲页框的列表。 这时仅有一个简单的基址寄存器是不够的，操作系统需要为每个进程维护一个页表。页表给出了该进程的每页所对应页框的位置。在程序中，每个逻辑地址包括一个页号和在该页中的偏移量。在简单分区的情况下，逻辑地址是一个字相对于程序开始处的位置，处理器把它转换为一个物理地址。在分页中，逻辑地址到物理地址的转换仍然由处理器硬件完成，且处理器必须知道如何访问当前进程的页表。给出逻辑地址（页号，偏移量）后，处理器使用页表产生物理地址（页框号，偏移量）。 进程的每页在页表中都有一项，因此页表很容易按页号对进程的所有页进行索引（从0页开始）。每个页表项包含内存中用于保存相应页的页框的页框号。此外，操作系统为当前内存中未被占用、可供使用的所有页框维护一个空闲页框列表。 总之，采用简单的分页技术，内存可分成许多大小相等且很小的页框，每个进程可划分成同样大小的页；较小的进程需要较少的页，较大的进程需要较多的页；装入一个进程时，其所有页都装入可用页框中，并建立一个页表。 简单分段把程序和与其相关的数据划分到几个段中。并不要求所有程序的所有段的长度都相等。和分页一样，采用分段技术时的逻辑地址也由两部分组成：段号和偏移量。 一般情况下，程序员或编译器会把程序和数据指定到不同的段。为了实现模块化程序设计的目的，程序或数据可能会进一步分成多个段。 采用大小不等的段的另一个结果是，逻辑地址和物理地址间不再是简单的对应关系。类似于分页，在简单的分段方案中，每个进程都有一个段表，系统也会维护一个内存中的空闲块列表。每个段表项必须给出相应段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效地址。当进程进入运行状态时，系统会把其段表的地址装载到一个寄存器中，由内存管理硬件来使用这个寄存器。 总之，采用简单的分段技术，进程可划分为许多段，段的大小无须相等；调入一个进程时，其所有段都装入内存的可用区域，并建立一个段表。 虚拟内存概念 术语 解释 虚拟内存 被定义成一个连续完整的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换 虚拟地址 在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主内的一部分那样 虚拟地址空间 分配给进程的虚拟存储 地址空间 用于某进程的内存地址范围 实地址 内存中存储位置的地址 分页和分段的两个特点： 进程中的所有内存访问都是逻辑地址，这些逻辑地址会在运行时动态的转换为物理地址。这意味着一个进程可被换入和换出内存，进程可在执行过程中占据不同时刻内存中的不同区域。 一个进程可被划分为许多块（页和段），在执行过程中，这些快不需要连续的位于内存中。 假设需要把一个新进程放入内存，此时操作系统仅读取包含程序开始处的一个或几个块。进程执行的任何时候都在内存的部分称为进程的常驻集。进程执行时，只要所有内存访问都是访问常驻集中的单元，执行就可以顺利进行；使用段表或页表，处理器总可以确定是否如此。 处理器需要访问一个不在内存中的逻辑地址时，会产生一个中断，这表明出现了内存访问故障（缺页故障）。操作系统会把被中断的进程置于阻塞态。要继续执行这个进程，操作系统必须把包含引发访问故障的逻辑地址的进程块（所在的页）读入内存。为此，操作系统产生一个磁盘IO读请求。产生I/O请求后，在执行磁盘IO期间，操作系统可以调度另一个进程运行。需要的块读入内存后，产生一个I/O中断，控制权交回给操作系统，而操作系统则把由于缺少该块而被阻塞的进程置为就绪态。 在内存中保留多个进程。 由于对任何特定的进程都仅装入它的某些块，因此有足够的空间来放置更多的进程。这样，在任何时刻这些进程中至少有一个处于就绪态，于是处理器得到了更有效的利用。 进程可以比内存的全部空间还大。 操作系统在需要时会自动地把进程块装入内存。 由于进程只能在内存中执行，因此这个存储器称为实存储器，简称实存。但程序员或用户感觉到的是一个更大的内存，且通常分配在磁盘上，这称为虚拟内存，简称虚存。虚存支持更有效的系统并发度，并能解除用户与内存之间没有必要的紧密约束。 考虑一个由很长的程序和多个数据数组组成的大进程。在任何一段很短的时间内，执行可能会局限在很小的一段程序中（如一个子程序），且可能仅会访问一个或两个数据数组。因此，若在程序被挂起或被换出前仅使用了一部分进程块，则为该进程给内存装入太多的块显然会带来巨大的浪费。仅装入这一小部分块可更好地使用内存。然后，若程序转移到或访问到不在内存中的某个块中的指令或数据，就会引发一个错误，告诉操作系统读取需要的块。 当操作系统读取一块时，它必须把另一块换出。如果一块正好在将要用到之前换出，操作系统就不得不很快地把它取回。这类操作通常被称为系统抖动。 局部性原理表明虚拟内存方案是可行的。要使虚存比较实用并且有效，需要两方面的因素： 首先，必须有对所采用分页或分段方案的硬件支持； 其次，操作系统必须有管理页或段在内存和辅助存储器之间移动的软件。 虚拟分页每个进程都有自己的页表，当它的所有页都装入内存时，将创建页表并装入内存。页表项（Page Table Entry，PTE）包含有与内存中的页框相对应的页框号。由于一个进程可能只有一些页在内存中，因而每个页表项需要有一位P来表示它所对应的页当前是否在内存中。若这一位表示该页在内存中，则这个页表项还包括该页的页框号。 页表项中所需要的另一个控制位是修改位M，它表示相应页的内容从上次装入内存到现在是否已改变。若未改变，则在需要把该页换出时，无须用页框中的内容更新该页。页表项还须提供其他一些控制位，例如，保护位和共享位。 页表结构从内存中读取一个字的基本机制包括使用页表从虚拟地址到物理地址的转换。虚拟地址又称为逻辑地址，它由页号和偏移量组成，而物理地址由页框号和偏移量组成。由于页表的长度可基于进程的长度而变化，因而不能期望在寄存器中保存它，它须在内存中且可以访问。当某个特定的进程正运行时，一个寄存器保存该进程页表的起始地址。虚拟地址的页号用于检索页表、查找相应的页框号，并与虚拟地址的偏移量结合起来形成需要的实地址。一般来说，页号域长于页框号域（n &gt; m）。 每个进程可以占据大量的虚存空间，因而一个进程会有大量的页表项，这会导致保存页表的内存空间太大。大多数虚拟内存方案都在虚存而非实存中保存页表。这意味着页表和其他页一样都服从分页管理。一个进程正在运行时，它的页表至少有一部分须在内存中，这一部分包括正在运行的页的页表项。一些处理器使用两级方案来组织大型页表。在这类方案中有一个页目录，其中的每项指向一个页表。 假设采用字节级的寻址，页尺寸为4KB(2^12^)，则4GB(2^32^)虚拟地址空间由2^20^页组成。若这些页中的每页都由一个4字节的页表项映射，则可创建由2^20^个页表项组成的一个页表，这时需要4MB(2^22^)的内存空间。这个由2^10^页组成的巨大用户页表可以保留在虚存中，并由一个包括2^10^个页表项的根页表映射，根页表占据的内存为4KB(2^12^)。 转换检测缓冲区TLB原则上，每次虚存访问都可能会引起两次物理内存访问：一次取相应的页表项，另一次取需要的数据（进程页）。因此，虚拟内存方案都为页表项使用了一个特殊的高速缓存，通常称为转换检测缓冲区（Translation Lookaside Buffer，TLB）。TLB中包含有最近用过的页号和完整的页表项。给定一个虚拟地址，处理器首先检查TLB，若需要的页表项在其中（TLB命中），则检索页框号并形成实地址。若未找到需要的页表项（TLB未命中）,则处理器用页号检索进程页表，并检查相应的页表项。若“存在位”已置位，则该页在内存中，处理器从页表项中检索页框号以形成实地址。处理器同时更新TLB，使其包含这个新页表项。最后，若“存在位”未置位，则表示需要的页不在内存中，这时会产生一次内存访问故障，称为缺页（page fault）故障。此时离开硬件作用范围，调用操作系统，由操作系统负责装入所需要的页，并更新页表。 页尺寸对缺页中断发生概率的影响使得这些问题变得更为复杂。一般而言，基于局部性原理，如果页尺寸非常小，那么每个进程在内存中就有较多数量的页。一段时间后，内存中的页都包含有最近访问的部分，因此缺页率较低。当页尺寸增加时，每页包含的单元和任何一个最近访问过的单元越来越远。因此局部性原理的影响被削弱，缺页率开始增长。 更为复杂的是，缺页率还取决于分配给一个进程的页框的数量。对固定的页尺寸，当内存中的页数量增加时，缺页率会下降。因此，软件策略（分配给每个进程的内存总量）影响着硬件设计决策（页尺寸)。 虚拟分段和段页式分段允许程序员把内存视为由多个地址空间或段组成，段的大小不等，并且是动态的。内存访问以段号和偏移量的形式组成地址。其优点： 允许程序独立地改变或重新编译，而不要求整个程序集重新链接和重新加载。同样，这也是使用多个段实现的。 有助于进程间的共享。程序员可以在段中放置一个实用工具程序或一个有用的数据表，供其他进程访问。 有助于保护。由于一个段可被构造成包含一个明确定义的程序或数据集，因而程序员或系统管理员可以更方便地指定访问权限。 从内存中读一个字的基本机制，涉及使用段表来将段号和偏移量组成的虚拟地址（或逻辑地址）转换为物理地址。根据进程的大小，段表长度可变，无法在寄存器中保存，因此访问段表时它必须在内存中。当某个特定的进程正在运行时，有一个寄存器为该进程保存段表的起始地址。虚拟地址中的段号用于检索这个表，并查找该段起点的相应内存地址。这个地址加上虚拟地址中的偏移量部分，就形成了需要的实地址。 段页式系统 在段页式系统中，用户的地址空间被程序员划分为许多段。每段依次划分为许多固定大小的页，页的长度等于内存中的页框大小。若某段的长度小于一页，则该段只占据一页。从程序员的角度看，逻辑地址仍然由段号和段偏移量组成：从系统的角度看，段偏移量可视为指定段中的一个页号和页偏移量。 每个进程都使用一个段表和一些页表，且每个进程段使用一个页表。某个特定的进程运行时，使用一个寄存器记录该进程段表的起始地址。对每个虚拟地址，处理器使用段号部分来检索进程段表以寻找该段的页表。然后虚拟地址的页号部分用于检索页表并查找相应的页框号。这种方式结合虚拟地址的偏移部分，就形成了需要的实地址。 分段有助于实现保护与共享机制。实际上，操作系统要求的保护和共享功能通常在段一级处理。由于每个段表项包括一个长度和一个基地址，因而程序不会不经意地访问超出该段的内存单元。为实现共享，一个段可能会在多个进程的段表中引用。 操作系统软件的支持这里主要涉及的是操作系统为虚存方案提供的算法。在段页式虚存系统中，操作系统所面临的内存管理问题大多数都与分页有关。 在各种情况下，最重要的都是与性能相关的问题：由于缺页中断会带来巨大的软件开销，所以希望使缺页中断发生的频率最小。这类开销至少包括决定置换哪个或哪些驻留页，以及交换这些页所需要的IO操作。此外，在这个页IO操作的过程中，操作系统还须调度另一个进程运行，即导致一次进程切换。因此，希望能通过适当的安排，使得在一个进程正在执行时，访问一个未命中的页中的字的概率最小。 读取策略和清除策略读取策略 当一个进程首次启动时，会在一段时间出现大量的缺页故障；取入越来越多的页后，局部性原理表明大多数将来访问的页都是最近读取的页。因此，在一段时间后错误会逐渐减少，缺页率会降到很低。 读取策略决定某页何时取入内存，常用的两种方法是请求分页和预先分页。 对于请求分页，只有当访问到某页中的一个单元时才将该页取入内存。对于预先分页，读取的页并不是缺页中断请求的页。若一个进程的页连续存储在辅存中，则一次读取许多连续的页要比隔一段时间读取一页有效。 进程首先启动时或者发生缺页中断时，都可采用预先分配策略。 某个进程被换出内存并置于挂起态时，它的所有驻留页都会被换出。当该进程被唤醒时，所有以前在内存中的页都会被重新读回内存。 清除策略 与读取策略相反，清除策略用于确定何时将已修改的一页写回辅存。通常有两种选择：请求式清除和预约式清除。 对于请求式清除，只有当一页被选择用于置换时才被写回辅存；而预约式清除策略则将这些已修改的多页在需要使用它们所占据的页框之前成批写回辅存。 一种较好的方法是结合下一节介绍的页缓冲技术，这种技术允许采用下面的策略：只清除可用于置换的页。通过页缓冲，被置换页可放置在两个链表中：修改链表和未修改链表。修改链表中的页可以周期性地成批写出，并移到未修改链表中。未修改链表中的一页要么因为被访问到而被回收，要么在其页框分配给另一页时被淘汰。 放置策略放置策略决定一个进程块驻留在实存中的什么位置。在段页式系统中，此策略无关紧要，因为地址转换硬件和内存访问硬件能以相同的效率为任何页框组合执行相应的功能。 置换策略和页缓冲置换策略决定在必须读取一个新页时，应该置换内存中的哪一页。需要明确三个问题： 给每个活动进程分配多少页框。 计划被置换的页集局限于那些产生缺页故障的进程，还是局限于所有页框都在内存中的进程。 上面两个问题属于驻留集管理。置换策略专指第三个问题。 在计划被置换的页集，选择换出哪一页。 所有置换策略的目标都是移出最近最不可能访问的页。根据局部性原理，最近的访问历史和最近将要访问的模式间有很大的相关性。因此，大多数策略都基于过去的行为来预测将来的行为。 页框锁定 内存中的某些页框可能是被锁定的。被锁定的页框中的页不能被置换。操作系统内核和重要的控制结构就需要保存在被锁定的页框中。锁定是通过给每个页框关联一个“锁定”位实现的，这一位可以包含在页框表和当前页表中。 基本算法 最近最少使用（LRU，Least Recently Used） 该策略选择置换内存中最长时间未被引用的页。根据局部性原理，这也是最近最不可能访问到的页。 这种方法的问题是比较难以实现。一种实现方法是给每页添加一个最后一次访问的时间戳，并在每次访问内存时更新这个时间戳。另一种方法是维护一个关于访问页的栈，但开销同样很大。 先进先出（FIFO，First In First Out） FIFO 策略把分配给进程的页框视为一个循环缓冲区，并按循环方式移动页。它需要的只是一个指针，该指针在进程的页框中循环。 这种方法所隐含的逻辑是置换驻留在内存中时间最长的页：很久以前取入内存的页，现在可能不会再用到。这一推断通常是错误的，因为经常会出现一部分程序或数据在整个程序的生命周期中使用频率都很高的情况，若使用 FIFO算法，则这些页需要被反复地换入和换出。 时钟（Clock） 页缓冲（Page Cache） 页缓冲能够提高分页的性能并允许使用较简单的页面置换策略。 使用页缓冲的置换算法不丢弃置换出的页。若该页未被修改，则将它分配到空闲页链表中；若已被修改，则分配到修改页链表中。注意，该页在内存中并不会物理性移动，移动的只是该页所对应的页表项，移动后的页表项放置在空闲页链表中或修改页链表中。 空闲页链表中包含有可被置换页的一系列页框，需要从磁盘中读取一页到内存中时，都将其放到空闲页链表头节点所指向的页框中，随后将头节点移除。注意，系统记录的被置换的页并不是链表头节点所指向的页。 比如说，头节点当前指向内存中的页a，系统通过置换策略决定出要用磁盘中的页b置换内存中的页c。实际执行的操作是，将页b放置在页a中，如果页c未被修改，就将其加入到空闲页链表尾部，如果页c已被修改，就将其加入到修改页链表中。 这一骚操作的一个重要特点是，被置换的页仍然留在内存中。因此，若进程访问该页，则可迅速返回该进程的驻留集，且代价很小。实际上，空闲页链表和修改页链表充当着页的高速缓存的角色。 修改页链表还有另外―种很有用的功能：已修改的页按簇写回，而不是一次只写一页，因此大大减少了I/O操作的数量，进而减少了磁盘访问时间。 Page Cache和块缓冲（Buffer Cache）的区别 首先要明确一点，cache是位于内存中的，是为了提高磁盘设备的IO性能。程序读磁盘设备中的数据时，首先把需要访问的数据页及其相邻页面统一读到内存（预读取策略），然后从内存中读取数据。程序向磁盘设备中的文件写数据时，先将数据写入内存，然后再将内存中的脏数据页定时统一的刷新到磁盘中。 这个用作磁盘数据缓存的内存就是所谓的Buffer Cache。主要是针对写数据场景的性能优化。也就是说Buffer Cache是作为磁盘数据读写而存在的。 然而，文件系统层为了提高文件读写的性能，也提供了文件系统级别的Page Cache。更多的是针对读数据场景的性能优化。也就是说Page Cache是作为文件读写而存在的。 其实针对的都是磁盘中的数据，有两个缓存显得没有必要了，因此，现有的linux系统版本已经将二者合并了，统称为Page Cache。其是通过radix树（基数树）数据结构实现的。 驻留集管理驻留集是指一个进程被读取到内存中的页集。 分配给一个进程的内存越少，在任何时候驻留在内存中的进程数就越多。这增加了操作系统至少找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间。 若一个进程在内存中的页数较少，尽管有局部性原理，缺页率仍相对较高。 然而，给进程分配的内存空间大到一定程度时，由于局部性原理，缺页率也不会有明显的降低。 固定分配策略为一个进程分配固定数量的页框，以供执行时使用。这个数量由进程创建时确定。对于这种策略，一旦在进程的执行过程中发生缺页中断，该进程的一页就必须被它所需要的页面置换。 可变分配策略允许分配给一个进程的页框在该进程的生命周期中不断地发生变化。其大小可根据当前进程的缺页率大小来实时调整。理论上，若一个进程的缺页率一直比较高，则表明在该进程中局部性原理表现较弱，应给它多分配一些页框以减小缺页率；而若一个进程的缺页率特别低，则表明从局部性的角度看该进程的表现非常好，可在不明显增大缺页率的前提下减少分配给它的页框。 置换范围 局部置换策略在产生这次缺页的进程的驻留页中选择，而全局置换策略则把内存中所有未被锁定的页都作为置换的候选页，而不管它们属于哪个进程。 Linux内存管理 虚存寻址 Linux使用三级页表结构（最新版本已经使用四级页表了），它由下面几种类型的表组成（每个表的大小都是一页）： 顶级页表是页全局目录（PGD），它包含了一个pgd_t类型数组，多数体系结构中pgd_t类型等同于无符号长整型类型。PGD中的表项指向二级页目录中的表项：PMD。每个活动进程的页目录都必须在内存中。 二级页表是中间页目录（PMD），它是个pmd_t类型数组，其中的表项指向PTE中的表项。页中间目录可能跨越多个页。页中间目录中的每项指向页表中的一页。 最后一级的页表简称页表，其中包含了pte_t类型的页表项，该页表项指向物理页面。页表也可跨越多个页。每个页表项指向该进程的一个虚拟页。 页面分配 页面分配为提升向内存中读入和从内存中写出页的效率，Linux定义了一种机制，用于把连续的页映射到连续的页框中。基于这一目的，它使用了伙伴系统。内核维护一系列大小固定的连续页框组，一组可以包含1、2、4、8、16、32个页框。当一页在内存中被分配或被解除分配时，可用的页框组使用伙伴算法来分裂或合并。 Linux引入了一种新的分割LRU算法。 新算法给每个页表项添加了两个有效位：PG_active和PG_referenced。Linux的所有物理内存均基于它们的地址分配到两块“区域”，“激活”和“非激活”两个链表通过内存管理器来进行各区域的页面回收。内核驻留进程kswapd在后台周期性地执行各区域的页面回收，它扫描那些与系统页框对应的页表项。对于所有标记为访问过的页表项，启用PG_referenced有效位。处理器首次访问一个页面时，会启用这个标志位。kswapd每次迭代时，都会检查页表项中的页面访问过标志位是否被启用。kswapd在每次读取页面访问有效位后即将其清除。具体步骤如下： 访问非激活链表中的一页时，PG_referenced有效位启用。 页面下次被访问时，PG_active被置位，并将其移动到激活链表。也就是说，页面经访问两次后被声明为激活。更准确地讲，两次不同扫描的访问才使得一个页面变为激活状态。 若第二次访问并未很快发生，则重置PG_referenced。 同样，激活的页面在两次超时之后也需要移动到非激活链表中。 非激活链表中的页面然后可通过LRU算法被置换。 页（page）内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字，但是，内存管理单元（MMU，管理内存并把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理。正因为如此，MMU以页大小为单位来管理系统中的页表。从虚拟内存的角度来看，页就是最小单位。 内核用struct page结构来表示系统中的每一个物理页，该结构位于&lt;linux/mm_types.h&gt;： 1234567891011struct page&#123; unsigned long flags; atomic_t _count; atomic_t _mapcount; unsigned long private; struct address_space *mapping; pgoff_t index; struct list_head lru; void virtual;&#125; flag域用来存放页的状态。这些状态包括页是不是脏的，是不是被锁定在内存中等。这些标志被定义在&lt;linux/page-flags.h&gt;中。 count域存放页的引用计数——也就是这一页被引用了多少次。当计数值变为-1时，就说明当前内核并没有引用这一页，于是，在新的分配中就可以使用它。内核代码不应当直接检查该域，而是调用page_count()函数进行检查，该函数唯一的参数就是page结构。当页空闲时，尽管该结构内部的_count值是负的，但是对page_count()函数而言，返回0表示页空闲，返回一个正整数表示页在使用。一个页可以由页缓存使用（这时，mapping域指向和这个页关联的addresss_space对象），或者作为私有数据（由private指向），或者作为进程页表中的映射。 virtual域是页的虚拟地址。通常情况下，它就是页在虚拟内存中的地址。 必须要理解的一点是page结构与物理页相关，而并非与虚拟页相关。因此，该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，它们也可能并不再和同一个page结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关的物理页中存放的东西。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。 内核用这一结构来管理系统中所有的页，系统中的每个物理页都要分配一个这样的结构体。因为内核需要知道一个页是否空闲（也就是页有没有被分配）。如果页已经被分配，内核还需要知道谁拥有这个页。拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或页高速缓存（Page Cache）等。 区（zone）有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区。内核使用区对具有相似特性的页进行分组。 Linux主要使用了三种区: ZONE_DMA：这个区包含的页能用来执行DMA操作。 ZONE_NORMAL：这个区包含的都是能正常映射的页。 ZONE_HIGHEM：这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间。 这些区在&lt;linux/mmzone.h&gt;中定义。 区的实际使用和分布是与体系结构相关的。例如，某些体系结构在内存的任何地址上执行DMA都没有问题。在这些体系结构中，ZONE_DMA为空，ZONE_NORMAL就可以直接用于分配。与此相反，在x86体系结构上，ISA设备就不能在整个32位的地址空间中执行DMA，因为ISA设备只能访问物理内存的前16MB。因此，ZONE_DMA在x86上包含的页都在0-16MB的内存范围里。 Linux把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。例如，ZONE_DMA内存池让内核有能力为DMA分配所需的内存。如果需要这样的内存，那么，内核就可以从ZONE_DMA中按照请求的数目取出页。 有些64位的体系结构，如Intel的x86-64体系结构可以映射和处理64位的内存空间，所以x86-64没有ZONE_HIGHMEM区，所有的物理内存都处于ZONE_DMA和ZONE_NORMAL区。 注意，区的划分没有任何物理意义，这只不过是内核为了管理页而采取的一种逻辑上的分组。 每个区都用struct zone表示，在&lt;linux/mmzone.h&gt;中定义。 这个结构体很大，但是，系统中只有三个区，因此，也只有三个这样的结构。 lock域是一个自旋锁，它防止该结构被并发访问。注意，这个域只保护结构，而不保护驻留在这个区中的所有页。没有特定的锁来保护单个页。watermark数组持有该区的最小值、最低和最高水位值。内核使用水位为每个内存区设置合适的内存消耗基准。该水位随空闲内存的多少而变化。name域是一个以NULL结束的字符串表示这个区的名字。内核启动期间初始化这个值，其代码位于mm/page_alloc.c中。分别为“DMA“，“Normal”和“HighMem”。 获得与释放页 内核接口 解释 struct page* alloc_pages(gfp_t gfp_mask, unsigned int order) 该函数分配2^order^ (1 &lt;&lt; order）个连续的物理页，并返回一个指针，该指针指向第一个页的page结构体，如果出错，就返回NULL。 void free_pages(unsigned long addr, unsigned int order) 释放页，释放页时要谨慎，只能释放属于你的页。传递了错误的struct page或地址，用了错误的order值，这些都可能导致系统崩溃。 void kmalloc(size_t size, gfp_t flags) 这个函数返回一个指向以字节为单位内存块的指针。所分配的内存区在物理上是连续的。出错，返回NULL。它确保页在物理地址上是连续的。 void kfree(const void *ptr) 释放由kmalloc()分配出来的内存块。如果释放的内存不是由kmalloc()分配的，或者释放的内存早就被释放了，调用这个函数就会导致严重的后果。调用kfree(NULL)是安全的。 void* vmalloc(unsigned long size) 分配的内存虚拟地址是连续的，而物理地址则无须连续。它通过分配非连续的物理内存块，再“修正”页表，把内存映射到逻辑地址空间的连续区域中。 void vfree(const void* addr) 要释放通过vmalloc()获得的内存。 大多数情况下，只有硬件设备需要得到物理地址连续的内存。在很多体系结构上，硬件设备存在于内存管理单元以外，它根本不理解什么是虚拟地址。因此，硬件设备用到的任何内存区都必须是物理上连续的块，而不仅仅是虚拟地址连续上的块。而仅供软件使用的内存块（例如与进程相关的缓冲区）就可以使用只有虚拟地址连续的内存块。对内核而言，所有内存看起来都是逻辑上连续的。 进程地址空间内核除了管理本身的内存外，还必须管理用户空间中进程的内存。我们称这个内存为进程地址空间，也就是系统中每个用户空间进程所看到的内存。Linux系统中的所有进程之间以虚拟方式共享内存。对一个进程而言，它好像都可以访问整个系统的所有物理内存。即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。 进程地址空间由进程可寻址的虚拟内存组成，内核允许进程使用这种虚拟内存中的地址。每个进程都有一个32位或64位的平坦地址空间。术语“平坦”指的是地址空间范围是一个独立的连续区间。一个进程的地址空间与另一个进程的地址空间即使有相同的内存地址，实际上也彼此互不相干。这样的进程也就是Linux中所谓的线程。 内存地址是一个给定的值，它要在地址空间范围之内，比如4021F000。这个值表示的是进程32位地址空间中的一个特定的字节。尽管一个进程可以寻址4GB的虚拟内存（在32位的地址空间中)，但这并不代表它就有权访问所有的虚拟地址。在地址空间中，我们更为关心的是一些虚拟内存的地址区间，比如08048000 - 0804C000，它们可被进程访问。这些可被访问的合法地址空间称为内存区域。通过内核，进程可以给自己的地址空间动态地添加或减少内存区域。 进程只能访问有效内存区域内的内存地址。每个内存区域也具有相关权限如对相关进程有可读、可写、可执行属性。如果一个进程访问了不在有效范围中的内存区域，或以不正确的方式访向了有效地址，那么内核就会终止该进程，并返回“段错误”信息。 内存描述符Linux内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由mm_struct结构体表示，下面给出内存描述符结构中各个域的描述，请大家结合前面的进程内存段布局图一起看： 12345678910111213141516171819202122232425262728293031323334struct mm_struct&#123; struct vm_area_struct *mmap; /* 内存区域组织成链表 */ struct rb_root mm_rb; /* 内存区域组织成红黑树 */ struct vm_area_struct *mmap_cache; /* 最近使用的内存区域 */ unsigned long free_area_cache; /* 地址空间第一个空洞 */ pgd_t *pgd; /* 页全局目录 */ atomic_t mm_users; /* 使用地址空间的用户数 */ atomic_t mm_count; /* 主使用计数器 */ int map_count; /* 内存区域的个数 */ struct rw_semaphore mmap_sem; /* 内存区域的信号量 */ spinlock_t page_table_lock; /* 页表锁 */ struct list_head mmlist; /* 所有 mm_struct 形成的链表 */ unsigned long rss; /* 所分配的物理页 */ unsigned long total_vm; /* 全部页面数目 */ unsigned long locked_vm; /* 上锁的页面数据 */ unsigned long pinned_vm; /* Refcount permanently increased */ unsigned long shared_vm; /* 共享页面数目 Shared pages (files) */ unsigned long exec_vm; /* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */ unsigned long stack_vm; /* 栈区页面数目 VM_GROWSUP/DOWN */ unsigned long def_flags; /* 代码段、数据段 起始地址和结束地址 */ unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; /* 堆区起始地址和结束地址, 进程栈区的起始地址 */ /* 命令行参数 和 环境变量的 起始地址和结束地址 */ unsigned long arg_start, arg_end, env_start, env_end; /* Architecture-specific MM context */ mm_context_t context; /* 体系结构特殊数据 */ /* Must use atomic bitops to access the bits */ unsigned long flags; /* 状态标志位 */ /* Coredumping and NUMA and HugePage 相关结构体 */ ...&#125;; mm_count代表了对mm_strcut本身的引用，而mm_users代表对mm_struct相关资源的引用，分了两个层次。mm_count类似于以进程为单位。 mm_users类似于以线程为单位。内核线程在运行时会借用其他进程的mm_struct，这样的线程叫anonymous users，因为他们不关心mm_struct指向的用户空间，也不会去访问这个用户空间，他们只是临时借用（比如说当进程执行系统调用陷入到内核中，内核会借用该进程的地址空间）。mm_count记录这样的进程数。mm_users是对mm_struct所指向的用户空间进行共享的所有进程的计数。也就是说，会有多个进程共享同一个用户空间， 这些进程也就是所谓的线程。 mmap和mm_rb这两个不同数据结构体描述的对象是相同的：该地址空间中的全部内存区域。但是前者以链表形式存放而后者以红黑树的形式存放。mmap结构体作为链表，利于简单、高效地遍历所有元素；而mm_rb结构体作为红黑树，更适合搜索定位指定元素。 所有的mm_struct结构体都通过自身的mmlist域连接在一个双向链表中，该链表的首元素是init_mm内存描述符，它代表init进程的地址空间。另外要注意，操作该链表的时候需要使用mmlist_lock锁来防止并发访问，该锁定义在文件kernel/fork.c中。 每个进程都有自己的页表（当然，线程会共享页表）。内存描述符的pgd域指向的就是进程的页全局目录。 内存描述符的分配与撤销在进程的进程描述符（即task_struct结构体）中，mm域存放着该进程使用的内存描述符，所以current-&gt;mm便指向当前进程的内存描述符。fork()函数利用copy_mm()函数复制父进程的内存描述符，也就是current-&gt;mm域给其子进程，而子进程中的mm_struct结构体实际是通过文件kernel/fork.c中的allocate_mm()宏从mm_cachep slab缓存中分配得到的。通常，每个进程都有唯一的mm_struct结构体，即唯一的进程地址空间。 如果父进程希望和其子进程共享地址空间，可以在调用clone()时，设置CLONE_VM标志。我们把这样的进程称作线程。当CLONE_VM被指定后，内核就不再需要调用allocate_mm()函数了，而仅仅需要调用copy_mm()函数中将mm域指向其父进程的内存描述符就可以了： 123456if(clone_flags &amp; CLONE_vM)&#123; // current 是父进程而 tsk 在 fork(）执行期间是子进程 atomic_inc(&amp;current-&gt;mm-&gt;mm_users); tsk-&gt;mm = current-&gt;mm;&#125; 当进程退出时，内核会调用定义在kernel/exit.c中的exit_mm()函数，该函数执行一些常规的撤销工作，同时更新一些统计量。其中，该函数会调用mmput()函数减少内存描述符中的mm_users用户计数，如果用户计数降到零，将调用mmdrop()函数，减少mm_count使用计数。如果mm_count也等于零了，说明该内存描述符不再有任何使用者了，那么调用free_mm()宏通过kmem_cache_free()函数将mm_struct结构体归还到mm_cachep slab缓存中。 内核线程没有进程地址空间，也没有相关的内存描述符。所以内核线程对应的进程描述符中mm域为空。事实上，这也正是内核线程的真实含义——它们没有用户上下文。当一个进程被调度时，该进程的mm域指向的地址空间被装载到内存，进程描述符中的active_mm域会被更新，指向新的地址空间。内核线程没有地址空间，所以mm域为NULL。于是，当一个内核线程被调度时，内核发现它的mm域为NULL，就会保留前一个进程的地址空间，随后内核更新内核线程对应的进程描述符中的active_mm域，使其指向前一个进程的内存描述符。 所以在需要时，内核线程便可以使用前一个进程的页表。因为内核线程不访问用户空间的内存，所以它们仅仅使用地址空间中和内核内存相关的信息，这些信息的含义和普通进程完全相同（要知道用户进程的地址空间是包含分配给内核的那1G的空间的，只不过是不允许访问而已，所以内核线程借用前一个进程的地址空间是用来访问属于内核的那1G空间的）。 虚拟内存区域每个和进程相关的内存区域都对应于一个vm_area_struct结构体。vm_area_struct结构体描述了指定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都拥有一致的属性，比如访问权限等，另外，相应的操作也都一致。按照这样的方式，每一个VMA就可以代表不同类型的内存区域（比如内存映射文件或者进程用户空间栈），下面给出该结构定义和各个域的描述： 1234567891011121314151617181920212223242526272829struct vm_area_struct&#123; struct mm_struct *vm_mm; // 相关的 mm_struct 结构体 unsigned long vm_start; // 区间的首地址 unsigned long vm_end; // 区间的尾地址 struct vm_area_struct *vm_next; // VMA 链表 pgprot_t vm_page_prot; // 访问控制权限 unsigned long vm_flags; //标志 struct rb_node vm_rb; //树上该 VMA 的节点 union &#123; // 或者是关联于 address_space-&gt;i_mmap 字段 // 或者是关联于 address_space-&gt;i_mmap_nonlinear 字段 struct &#123; struct list_head list; void *parent; struct vm_area_truct head; &#125; vm_set; struct prio_tree_node prio_tree_node; &#125; shared; struct list_head anon_vma_node; // anon_vma 项 struct anon_vma *anon_vma; //匿名VMA对象 struct vm_operations_struct vin_ops; // 相关的操作表 unsigned 1ong vm_pgoff; // 文件中的偏移量 struct file *vm_file; // 被映射的文件（如果存在) void *vm_private_data; // 私有数据&#125;; 每个内存描述符都对应于进程地址空间中的唯一区间。vm_start域指向区间的首地址（最低地址），vm_end域指向区间的尾地址（最高地址）之后的第一个字节。注意，在同一个地址空间内的不同内存区间不能重叠。 vm_mm域指向和VMA相关的mm_struct结构体，注意，每个VMA对其相关的mm_struct结构体来说都是唯一的，所以即使两个独立的进程将同一个文件映射到各自的地址空间，它们分别都会有一个vm_area_struct结构体来标志自己的内存区域；反过来，如果两个线程共享一个地址空间，那么它们也同时共享其中的所有vm_area_struct结构体。 上文讨论过，可以通过内存描述符中的mmap和mm_rb域之一访问内存区域。mmap域使用单独链表连接所有的内存区域对象。每一个vm_area_struet结构体通过自身的vm_next域被连入链表，所有的区域按地址增长的方向排序，mmap域指向链表中第一个内存区域，链中最后一个结构体指针指向空。mm_rb域使用红黑树连接所有的内存区域对象。mm_rb域指向红黑树的根节点，地址空间中每一个vm_area_struct结构体通过自身的vm_rb域连接到树中。 创建和删除地址空间内核使用do_mmap()函数创建一个新的线性地址区间。如果创建的地址区间和一个已存在的地址区间相邻，并且它们具有相同的访问权限的话，两个区间将合并为一个。映射时，从vm_area_cachep长字节（slab）缓存中分配一个vm_area_struct结构体，并且使用vma_link()函数将新分配的内存区域添加到地址空间的内存区域链表和红黑树中，随后还要更新内存描述符中的total_vm域，然后才返回新分配的地址区间的初始地址。 do_mmap()函数定义在文件&lt;linux/mm.h&gt;中。 123unsigned long do_mmap(struct file *file, unsigned long addr, unsigned long len, unsigned long prot, unsigned long flag, unsigned long offset); 该函数映射由file指定的文件，具体映射的是文件中从偏移offset处开始，长度为len字节的范围内的数据。如果file参数是NULL并且offset参数也是0，那么就代表这次映射没有和文件相关，该情况称作匿名映射（anonymous mapping）。如果指定了文件名和偏移量，那么该映射称为文件映射（file-backed mapping）。 addr是可选参数，它指定搜索空闲区域的起始位置。prot参数指定内存区域中页面的访问权限。访问权限标志定义在文件&lt;asm/mman.h&gt;中。 在用户空间可以通过mmap()系统调用获取内核函数do_mmap()的功能。mmap()系统调用 1void* mmap2(void* start, size_t length, int prot, int flags, int fd, off_t pgoff); 由于该系统调用是mmap()调用的第二种变种，所以起名为mmap2()。最原始的mmap()调用中最后一个参数是字节偏移量，而目前这个mmap2()使用页面偏移作最后一个参数。使用页面偏移量可以映射更大的文件和更大的偏移位置。原始的mmap()调用由POSIX定义，仍然在C库中作为mmap()方法使用，但是内核中已经没有对应的实现了，而实现的是新方法mmap2()。虽然C库仍然可以使用原始版本的映射方法，但是它其实还是基于函数mmap2进行的，对原始mmap()方法的调用是通过将字节偏移转化为页面偏移，从而转化为对mmap2()函数的调用来实现的。 do_mummap()函数从特定的进程地址空间中删除指定地址区间，该函数定义在文件&lt;linux/mm.h&gt;中： 1int do_mummap(struct mm_struct *mm , unsigned long start, size_t len); 第一个参数指定要删除区域所在的地址空间，删除从地址start开始，长度为len字节的地址区间。如果成功，返回零。否则，返回负的错误码。 系统调用munmap()给用户空间程序提供了一种从自身地址空间中删除指定地址区间的方法，它和系统调用mmap()的作用相反，该系统调用定义在文件mm/mmap.c中，它是对do_mummap()函数的一个简单的封装。 1int munmap(void *start, size_t length); 进程用户栈、线程栈、进程内核栈、中断栈进程用户栈 进程栈是属于用户态栈，和进程虚拟地址空间 (Virtual Address Space) 密切相关。那我们先了解下什么是虚拟地址空间：在32位机器下，虚拟地址空间大小为4G。这些虚拟地址通过页表 (Page Table) 映射到物理内存，页表由操作系统维护，并被处理器的内存管理单元 (MMU) 硬件引用。每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。 Linux内核将这4G字节的空间分为两部分，将最高的1G字节（0xC0000000- 0xFFFFFFFF）供内核使用，称为内核空间。而将较低的3G字节（0x00000000 - 0xBFFFFFFF）供各个进程使用，称为用户空间。每个进程可以通过系统调用陷入内核态，因此内核空间是由所有进程共享的。虽然说内核和用户态进程占用了这么大地址空间，但是并不意味它们使用了这么多物理内存，仅表示它可以支配这么大的地址空间。它们是根据需要，将物理内存映射到虚拟地址空间中使用。 Linux对进程地址空间有个标准布局，地址空间中由各个不同的内存段组成 (Memory Segment)，主要的内存段如下： 程序段 (Text Segment)：可执行文件代码的内存映射。 数据段 (Data Segment)：可执行文件的已初始化全局变量的内存映射。 BSS段 (BSS Segment)：未初始化的全局变量或者静态变量（映射到零页）。 堆区 (Heap) : 存储动态内存分配，匿名的内存映射（malloc分配的内存区域）。 栈区 (Stack) : 进程用户空间栈，由编译器自动分配释放，存放函数的参数值、局部变量的值等。 映射段（Memory Mapping Segment）：任何内存映射文件，如每一个诸如C库或动态连接程序等共享库的代码段、数据段和BSS也会被载入进程的地址空间。 可执行文件的BSS段未存储在磁盘上，内核将零页面映射到BSS范围。 因为在创建新进程时预期BSS段将被初始化为零，并且仅在可执行文件中存储一堆零浪费了空间，所以可执行文件仅指示BSS段应从何处开始以及应该从多大。 当内核从可执行文件构建新进程时，它将为BSS范围创建到零页面的映射，该页面是全零的静态（虚拟）页面。该映射设置有写时复制功能，因此，新进程首次向其中一个BSS页进行写入时，在允许写入完成之前，静态零页的实际副本将分配到另一个内存页中。 这样做有如下几点好处： 节省了可执行文件中的空间。 避免了实际分配可能永远不会被该进程触及的BSS页面，从而节省了内存使用量。 同时仍然提供了确保每个进程中的BSS段看起来都是零初始化的保证。 而上面进程虚拟地址空间中的栈区，正指的是我们所说的进程栈。进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，Linux内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制RLIMIT_STACK（一般为8M），我们可以通过ulimit来查看或更改RLIMIT_STACK的值。 如何确认进程栈的大小 我们要知道栈的大小，那必须得知道栈的起始地址和结束地址。栈起始地址获取很简单，只需要嵌入汇编指令获取栈指针esp寄存器的值即可。栈结束地址的获取有点麻烦，我们需要先利用递归函数把栈搞溢出了，然后再GDB中把栈溢出的时候把栈指针esp寄存器的值打印出来即可。代码如下： 123456789101112131415161718192021222324252627/* file name: stacksize.c */void *orig_stack_pointer;void blow_stack() &#123; blow_stack(); &#125;int main()&#123; __asm__(\"movl %esp, orig_stack_pointer\"); blow_stack(); return 0;&#125;$ g++ -g stacksize.c -o ./stacksize$ gdb ./stacksize(gdb) rStarting program: /home/home/misc-code/setrlimitProgram received signal SIGSEGV, Segmentation fault.blow_stack () at setrlimit.c:44 blow_stack();(gdb) print (void *)$esp$1 = (void *) 0xffffffffff7ff000(gdb) print (void *)orig_stack_pointer$2 = (void *) 0xffffc800(gdb) print 0xffffc800-0xff7ff000$3 = 8378368 // Current Process Stack Size is 8M 进程栈的动态增长实现 进程在运行的过程中，通过不断向栈区压入数据，当超出栈区容量时，就会耗尽栈所对应的内存区域，这将触发一个 缺页异常 (page fault）。通过异常陷入内核态后，异常会被内核的expand_stack()函数处理，进而调用 acct_stack_growth()来检查是否还有合适的地方用于栈的增长。 如果栈的大小低于RLIMIT_STACK（通常为8MB），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情，这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会发生栈溢出（stack overflow），进程将会收到内核发出的段错误（segmentation fault）信号。 动态栈增长是唯一一种访问未映射内存区域而被允许的情形，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。 线程栈 从Linux内核的角度来说，其实它并没有线程的概念。Linux把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了task_struct中。线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和Linux中所谓线程的唯一区别。线程创建的时候，加上了CLONE_VM标记，这样 线程的内存描述符 将直接指向父进程的内存描述符。 虽然线程的地址空间和进程一样，但是对待其地址空间的栈stack还是有些区别的。对于Linux进程或者说主线程，其stack是在fork的时候生成的，实际上就是复制了父亲的stack空间地址，然后写时拷贝 (cow) 以及动态增长。然而对于主线程生成的子线程而言，其stack将不再是这样的了，而是事先固定下来的，使用mmap系统调用，它不带有VM_STACK_FLAGS标记。 这个可以从glibc的nptl/allocatestack.c中的allocate_stack()函数中看到： 1mem = mmap (NULL, size, prot, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0); 由于线程的mm-&gt;start_stack栈地址和所属进程相同，所以线程栈的起始地址并没有存放在task_struct中，应该是使用pthread_attr_t中的stackaddr来初始化task_struct-&gt;thread-&gt;sp（sp指向struct pt_regs对象，该结构体用于保存用户进程或者线程的寄存器现场）。这些都不重要，重要的是，线程栈不能动态增长，一旦用尽就没了，这是和生成进程的fork不同的地方。由于线程栈是从进程的地址空间中map出来的一块内存区域，原则上是线程私有的。 进程内核栈 在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作进程内核栈。进程内核栈在进程创建的时候，通过slab分配器从thread_info_cache缓存池中分配出来，其大小为THREAD_SIZE，一般来说是一个页大小4K： 12345union thread_union&#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE / sizeof(long)];&#125;; thread_union进程内核栈和task_struct进程描述符有着紧密的联系。由于内核经常要访问task_struct，高效获取当前进程的描述符是一件非常重要的事情。因此内核将进程内核栈的头部一段空间，用于存放thread_info结构体，而此结构体中则记录了对应进程的描述符，两者关系如下图： 有了上述关联结构后，内核可以先获取到栈顶指针esp，然后通过esp来获取thread_info。这里有一个小技巧，直接将esp的地址与上~(THREAD_SIZE - 1)后即可直接获得thread_info的地址。由于thread_union结构体是从thread_info_cache的Slab缓存池中申请出来的，而thread_info_cache在kmem_cache_create创建的时候，保证了地址是THREAD_SIZE对齐的。因此只需要对栈指针进行THREAD_SIZE对齐，即可获得thread_union的地址。成功获取到thread_info后，直接取出它的task成员就成功得到了task_struct。其实上面这段描述，也就是current宏的实现方法： 123456789register unsigned long current_stack_pointer asm (\"sp\");static inline struct thread_info *current_thread_info(void)&#123; return (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE - 1));&#125;#define get_current() (current_thread_info()-&gt;task)#define current get_current() 中断栈 进程陷入内核态的时候，需要内核栈来支持内核函数调用。中断也是如此，当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关。 x86上中断栈就是独立于内核栈的；独立的中断栈所在内存空间的分配发生在arch/x86/kernel/irq_32.c的irq_ctx_init()函数中（如果是多处理器系统，那么每个处理器都会有一个独立的中断栈），函数使用__alloc_pages在低端内存区分配2个物理页面，也就是8KB大小的空间。有趣的是，这个函数还会为softirq分配一个同样大小的独立堆栈。如此说来，softirq将不会在hardirq的中断栈上执行，而是在自己的上下文中执行。 为什么需要单独的进程内核栈？ （为什么需要单独的线程栈？进程和线程是否共享一个内核栈？） 所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程A陷入内核态执行的时候，需要等待读取网卡的数据，主动调用schedule()让出CPU；此时调度器唤醒了另一个进程B，碰巧进程B也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程B进入内核态的时候产生的压栈操作，必然会破坏掉进程A已有的内核栈数据；一但进程A的内核栈数据被破坏，很可能导致进程A的内核态无法正确返回到对应的用户态了。 **这三个问题很好理解，只要可被调度执行的对象之间共用一个栈（无论进程栈，内核栈还是线程栈），那必然会有出错的机会，所以不能共用。进程和同一个进程的线程都是可被调度执行的对象！","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统之并发与同步","date":"2021-03-06T13:35:42.000Z","path":"29s2fW7i8PsxWCiK/","text":"并发的概念在单处理器多道程序设计系统中，进程会被交替地执行，因而表现出一种并发执行的外部特征。支持并发进程的基本需求是加强互斥的能力。也就是说，当一个进程被授予互斥能力时，那么在其活动期间，它具有排斥所有其他进程的能力。 并发与同步并发的概念在单处理器多道程序设计系统中，进程会被交替地执行，因而表现出一种并发执行的外部特征。支持并发进程的基本需求是加强互斥的能力。也就是说，当一个进程被授予互斥能力时，那么在其活动期间，它具有排斥所有其他进程的能力。 并发包括很多设计问题，其中有进程间通信、资源共享与竞争（如内存、文件、I/O访问)、多个进程活动的同步以及给进程分配处理器时间等。并发问题源于多道程序设计系统的一个基本特性：进程的相对执行速度不可预测，它取决于其他进程的活动、操作系统处理中断的方式以及操作系统的调度策略。 术语 解释 临界区 一段代码，在这段代码中进程将访问共享资源，当另外一个进程已在这段代码中运行时，这个进程就不能在这段代码中执行 死锁 两个或两个以上的进程因每个进程都在等待其他进程做完某些事情而不能继续执行的情形 互斥 当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源的情形 竞争条件 多个线程或进程在读写一个共享数据时，结果依赖于它们执行的相对时间的情形 饥饿 一个可运行进程尽管能继续执行，但被调度程序无限期地忽视，而不能被调度执行的情形 原子操作 保证指令序列要么作为一个组来执行，要么都不执行 如果需要保护共享的全局变量（以及其他共享的全局资源），唯一的办法是控制访问该变量的代码。 原子性和顺序性 原子性确保指令执行期间不被打断，要么全部执行完，要么根本不执行。另一方面，顺序性确保即使两条或多条指令出现在独立的执行线程中，甚至独立的处理器上，它们本该的执行顺序却依然要保持。顺序性通过屏障（barrier）指令来实施。 进程交互的分类 进程之间互相不知道对方的存在，它们表现出竞争关系 进程间接知道对方的存在，但它们共享某些对象，表现出通过共享合作的关系 进程直接知道对方的存在，可以通过进程ID互相传递消息进行通信，表现出通过通信合作的关系 竞争进程面临三个控制问题： 互斥 假设两个或更多的进程需要访问一个不可共享的资源，如打印机。在执行过程中，每个进程都给该IO设备发命令，接收状态信息，发送数据和接收数据。我们把这类资源称为临界资源，使用临界资源的那部分程序称为程序的临界区。一次只允许有一个程序在临界区中，这一点非常重要。 为了实现互斥则产生了下面两个问题： 死锁 考虑两个进程P1和P2，以及两个资源R1和R2，假设每个进程为执行部分功能都需要访问这两个资源，那么就有可能出现下列情况：操作系统把R1分配给P2，把R2分配给P1，每个进程都在等待另一个资源，且在获得其他资源并完成功能前，谁都不会释放自己已拥有的资源，此时这两个进程就会发生死锁。 饥饿 假设有三个进程（P1、P2和P3），每个进程都周期性地访问资源R。假设操作系统把访问权轮流授予P1和P3，那么即使没有死锁，P2也可能被无限地拒绝访间资源。 合作进程和竞争进程的唯一区别是可以按两种不同的模式（读和写）访问数据项，并且只有写操作必须保证互斥。除了面临上面三个问题外，还有一个新的要求：数据一致性。 若使用临界区来保护数据的一致性，则没有确定的资源或变量可作为参数。此时，可以把参数视为一个在并发进程间共享的标识符，用于标识必须互斥的临界区。 互斥的要求以及实现 必须强制实施互斥：在与相同资源或共享对象的临界区有关的所有进程中，一次只允许一个进程进入临界区。 没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入。 一个进程驻留在临界区中的时间必须是有限的。 硬件支持的实现 禁用中断 为保证互斥，只需保证一个进程不被中断即可，这种能力可通过系统内核为启用和禁用中断定义的原语来提供。但代价非常高。 专用机器指令 在硬件级别上，对存储单元的访问排斥对相同单元的其他访问。因此，处理器的设计者人员提出了一些机器指令，用于保证两个动作的原子性。 软件支持的实现 并发机制 解释 信号量 用于进程间传递信号的一个整数值。在信号量上只可进行三种操作，即初始化、递减和递增，它们都是原子操作。递减操作用于阻塞一个进程，递增操作用于解除一个进程的阻塞 二元信号量 只取0值和1值的信号量 互斥量 类似于二元信号量。关键区别在于为其加锁（设定值为0）的进程和为其解锁（设定值为1）的进程必须为同一个进程，一般被用在构造临界区上 条件变量 一种数据类型，用于阻塞进程或线程，直到特定的条件为真 自旋锁 一种互斥机制，进程在一个无条件循环中执行，等待锁变量的值可用 信号量Linux中的信号量是一种睡眠锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放）后，处于等待队列中的那个任务将被唤醒。 我们可以从信号量的睡眠特性得出一些有意思的结论： 由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况。 相反，锁被短时间持有时，使用信号量就不太适宜了。因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁被占用的全部时间还要长。 面于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下文中是不能进行调度的。 你可以在持有信号量时去睡眠，因为当其他进程试图获得同一信号量时不会因此而死锁（因为该进程也只是去睡眠而已，而你最终会继续执行的）。 为达到预期效果，可把信号量视为一个值为整数的变量，整数值上定义了三个操作： 一个信号量可以初始化成非负数。 semWait操作使信号量减1。若值变成负数，则阻塞执行semWait的进程，否则进程继续执行。 semSignal操作使信号量加1。被semWait操作阻塞的进程之一（可能没有被阻塞的）解除阻塞。 12345678910111213141516171819202122232425262728293031// 使用 比较和交换指令 实现的信号量原语struct semaphore&#123; int count; bool flag; queueType queue;&#125;;void semwait(semaphore s)&#123; while(compare_and_swap(s.flag, 0, 1) == 1); s.count--; if(s.count &lt; 0) &#123; /* 把当前进程插入队列 */; /* 阻塞当前进程 */; &#125; s.flag = 0;&#125;void semSignal(semaphore s)&#123; while(compare_and_swap(s.flag, 0, 1) == 1); s.count++; if(s.count &lt;= O) &#123; /* 把进程 P 从队列中移除 */; /* 把进程卫插入就绪队列 */; &#125; s.flag = 0;&#125; s.count ≥ 0：s.count是可执行semwait(s)而不被阻塞的进程数。这种情形允许信号量支持同步与互斥。 s.count &lt; 0：s.count的大小是阻塞在s.queue队列中的进程数。 二元信号量 二元信号量可以初始化为0或1。 semWaitB操作检查信号的值。若值为0，则进程执行semwaitB就会受阻。若值为1，则将值改为0，并继续执行该进程。 semSignalB操作检查是否有任何进程在该信号上受阻。若有进程受阻，则通过semWaitB操作受阻的进程会被唤醒：若没有进程受阻，则值设置为1。 123456789101112131415161718192021222324252627struct binary_semaphore&#123; enum &#123;zero, one&#125; value; qrueueType queue;&#125;;void semwaitB(binary semaphore s)&#123; if(s.value = one) s.value = zero; else &#123; /* 把当前进程插入队列 */; /* 阻塞当前进程 */; &#125;&#125;void semSignalB(semaphore s)&#123; if(s.queue is empty()) s.value =one; else &#123; /* 把进程 P 从等待队列中移除 */; /* 把进程卫插入就绪队列 */; &#125;&#125; 不论是计数信号量还是二元信号量，都需要使用队列来保存于信号量上等待的进程。这就产生了一个问题，进程按什么顺序从队列中移出？最公平的策略是先进先出，被阻塞时间最久的进程最先从队列释放。采用这一策略定义的信号量称为强信号量，而没有规定进程从队列中移出顺序的信号量称为弱信号量。 强信号量保证不会饥饿，而弱信号量则无法保证。 自旋锁自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个被已经持有（即所谓的争用）的自旋锁，那么该线程就会一直进行忙循环一旋转，等待锁重新可用。要是锁未被争用，请求锁的执行线程便能立刻得到它，继续执行。在任意时间，自旋锁都可以防止多于一个的执行线程同时进入临界区。 自旋锁是不可递归的（不可重入的）。 自旋锁可以使用在中断处理程序中（此处不能使用信号量，因为它们会导致睡眠）。在中断处理程序中使用自旋锁时，一定要在获取锁之前，首先禁止本地中断（在当前处理器上的中断请求），否则，中断处理程序就会打断正持有锁的内核代码，有可能会试图去争用这个已经被持有的自旋锁。这样一来，中断处理程序就会自旋，等待该锁重新可用，但是锁的持有者在这个中断处理程序执行完毕前不可能运行。这正是我们在前面的内容中提到的双重请求死锁。注意，需要关闭的只是当前处理器上的中断。如果中断发生在不同的处理器上，即使中断处理程序在同一锁上自旋，也不会妨碍锁的持有者（在不同处理器上）最终释放锁。 互斥量mutex 任何时刻中只有一个任务可以持有mutex，也就是说，mutex的使用计数永远是1。 给mutex上锁者必须负责给其再解锁——你不能在一个上下文中锁定一个mutex，而在另一个上下文中给它解锁。这个限制使得mutex不适合内核同用户空间复杂的同步场景。最常使用的方式是：在同一上下文中上锁和解锁。 递归地上锁和解锁是不允许的。也就是说，你不能递归地持有同一个锁，同样你也不能再去解锁一个已经被解开的mutex。 当持有一个mutex时，进程不可以退出。 mutex只能通过官方API管理，不可被拷贝、赋值、重复初始化。 除非mutex的某个约束妨碍你使用，否则相比信号量要优先使用mutex。在中断上下文中只能使用自旋锁，而在任务睡眠时只能使用mutex。 死锁原理死锁定义为一组相互竞争系统资源或进行通信的进程间的“永久”阻塞。当一组进程中的每个进程都在等待某个事件（典型情况下是等待释放所请求的资源），而仅有这组进程中被阻塞的其他进程才可触发该事件时，就称这组进程发生了死锁。 资源通常分为两类：可重用资源和可消耗资源。可重用资源是指一次仅供一个进程安全使用且不因使用而耗尽的资源。可重用资源的例子包括处理器、I/O通道、内存和外存、设备，以及诸如文件、数据库和信号量之类的数据结构。可消耗资源是指可被创建（生产）和销毁（消耗）的资源。存在。可消耗资源的例子有中断、信号、消息和I/O缓冲区中的信息。 产生死锁有三个必要条件： 互斥。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。 占有且等待。当一个进程等待其他进程时，继续占有已分配的资源。 不可抢占。不能强行抢占进程已占有的资源。 要产生死锁，还需要第四个条件： 循环等待。存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。 第四个条件实际上是前三个条件的潜在结果，即假设前三个条件存在，那么可能发生的系列事件会导致不可解的循环等待。这个不可解的循环等待实际上就是死锁的定义。循环等待之所以不可解，是因为有前面三个条件的存在。因此，这四个条件一起构成 了死锁的充分必要条件。 死锁预防死锁预防方法分为两类。一类是间接死锁预防方法，即防止前面列出的三个必要条件中的任何一个条件的发生；另一类是直接死锁预防方法，即防止循环等待的发生。 互斥 不可能禁止。如果需要对资源进行互斥访问，那么操作系统就必须支持互斥。 占有且等待 为预防占有且等待的条件，可以要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足。 不可抢占 预防不可抢占的方法有几种。首先，占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放其最初占有的资源，必要时可再次申请这些资源和其他资源。其次，一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不同的条件下，后一种方案才能预防死锁。 此外，只有在资源状态可以很容易地保存和恢复的情况下（如CPU上下文），这种方法才是实用的。 循环等待 循环等待条件可通过定义资源类型的线性顺序来预防。若一个进程已分配了R类型的资源，则其接下来请求的资源只能是那些排在R类型之后的资源。 死锁避免在死锁避免中，是否允许当前的资源分配请求是通过判断该请求是否可能导致死锁来决定的。因此，死锁避免需要知道未来进程资源请求的情况。 进程启动拒绝。若一个进程的请求会导致死锁，则不启动该进程。 资源分配拒绝，又称银行家算法。若一个进程增加的资源请求会导致死锁，则不允许这一资源分配。 死锁避免的优点是，无须死锁预防中的抢占和回滚进程， 死锁检测对于死锁检测来说，只要有可能，就会给进程分配其所请求的资源。操作系统周期性地执行一个算法来检测前面的循环等待条件。算法的策略是查找一个进程，使得可用资源能满足该进程的资源请求，然后假设同意这些资源，让该进程运行直到结束，再释放它的所有资源。然后，算法再寻找另一个可以满足资源请求的进程。 死锁恢复： 取消所有的死锁进程。这是操作系统中最常采用的方法。 连续取消死锁进程直到不再存在死锁。所选取消进程的顺序应基于某种最小代价原则。每次取消后，必须重新调用检测算法，以测试是否仍存在死锁。 连续抢占资源直到不再存在死锁。 对于内存资源来说，基于抢占的死锁预防是最适合的策略。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统之进程与线程管理","date":"2021-03-01T13:35:42.000Z","path":"DRLdCV5y4mc6kSqv/","text":"进程与线程管理任务、线程、进程三者关系 任务是一个抽象的概念，即指软件完成的一个活动；而线程则是完成任务所需的动作；进程则指的是完成此动作所需资源的统称；关于三者的关系，有一个形象的比喻： 任务 = 送货 线程 = 开送货车 系统调度 = 决定合适开哪部送货车 进程 = 道路 + 加油站 + 送货车 + 修车厂 进程进程的概念操作系统为进程提供两种虚拟机制。虚拟处理器让进程觉得自己在独享CPU。虚拟内存让进程在分配和管理内存的时候觉得自己拥有全部内存资源。 进程就是处于执行期的程序和一组相关的系统资源的总称。这些资源包括，打开的文件描述符、挂起的信号、内核内部数据、处理器状态、映射了的内存地址空间、所有执行的线程以及存放全局变量的数据段。它的两个基本元素就是程序代码（可能被执行相同程序的其他进程共享）和与代码相关联的数据集。 进程最少必须包括一个或一组被执行的程序，而与这些程序相关联的是局部变量、全局变量和任何已定义常量的数据单元。因此，一个进程至少应有足够的内存空间来保存其程序和数据；此外，程序的执行通常涉及用于跟踪过程调用和过程间参数传递的栈帧。最后，还有与每个进程相关的许多属性，以便操作系统控制该进程。通常，属性集称为进程描述符。程序、数据、栈帧和属性的集合称为进程映像。下图表示了进程映像在虚存中的结构。 进程描述符从linux内核的观点看，进程又被称为任务，内核将所有进程组织在叫做任务队列的一个双向循环链表中。链表中的每一项是类型为task_struct的结构体（定义在&lt;linux/sched.h&gt;文件中），称为进程描述符或进程控制块，它被用来定义和描述一个完整的进程。 进程描述符包含有一个具体进程的所有信息，主要包括： 进程标识信息 标识符：与进程相关的唯一标识符，用来区分其他进程。每个进程都有唯一的一个进程标识符PID，以及用户标识符UID和组标识符GID。组标识符用于给一组进程指定资源访问特权。 进程状态信息 程序计数器：程序中即将执行的下一条指令的地址。 栈指针：用于指向保存参数和过程调用或系统调用的地址的栈帧的栈顶指针。 上下文数据：进程执行时处理器的寄存器组中的数据。包括控制，状态寄存器等。 进程控制信息 状态：表示进程的执行状态，有执行态、就绪态、停止态、阻塞态和僵死态。 调度信息：Linux调度进程所需要的信息。一个进程可能是普通的或实时的，并具有优先级。实时进程在普通进程前调度，且在每类中使用相关的优先级。一个计数器会记录允许进程执行的时间量。 等待事件信息：进程继续执行前等待的事件标识。 地址空间信息：包括程序代码和进程相关数据的指针，以及与其他进程共享内存块的指针。 时间和计时器：包括进程创建的时刻和进程所消耗的处理器时间总量。一个进程可能还有一个或多个间隔计时器，进程通过系统调用来定义间隔计时器，计时器期满时，会给进程发送一个信号。计时器可以只用一次或周期性地使用。 链接：每个进程都有一个到其父进程的链接及到其兄弟进程（与它有相同的父进程）的链接，以及到其所有子进程的链接。 文件系统：包括指向被该进程打开的任何文件的指针和指向该进程当前目录与根目录的指针。 Linux通过slab分配器动态地给task_struct的结构体分配内存空间，这样能达到对象复用（通过预先分配和重复使用task_struct，可以避免动态分配和释放带来的资源消耗）和缓存着色的目的。除此之外，还需要在内核栈的栈底创建一个类型为thread_info的结构体（定义在&lt;asm/thread_info.h&gt;文件中），结构中的task域存放有指向该任务的task_struct的指针。 对于Linux系统，进程描述符中的state域描述了当前进程的状态，也就是其行为特征，共分为5种： TASK_RUNNING 表示进程是可执行的；要么是在运行队列中等待被调度执行（就绪态），要么是正在执行（运行态）。 TASK_INIERRUPTIBLE 进程正在被阻塞（阻塞态），等待某些条件的满足。一旦条件满足或者接收到信号而提前被唤醒，会从当前状态转为TASK_RUNNING状态（就绪态）。 TASK_UNINIERRUPTIBLE 和TASK_INIERRUPTIBLE状态相同，除了不响应任何信号。也就是执行ps命令后看到进程被标记为D状态的进程，不能通过发送SIGKILL信号杀死处于此状态的进程。比如内核态进程在等待某项资源，这时候是不允许被打断的，否则可能导致系统进入未知状态，或者引发严重的系统异常，所以对于这种操作，定义D状态进行保护。使其在完成本次操作之前，不可以被任何异步状态打断。 _TASK_TRACED 表示此进程正在被其它进程跟踪，例如通过ptrace对调试程序进行跟踪。 _TASK_STOPPED 进程处于终止状态（停止态）。并且只能由来自另一个进程的主动动作恢复，例如，在调试期间收到任何信号都会使进程进入此状态。 僵死态 进程已被终止，但由于某些原因，在进程表中仍然有其task_struct。 可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行（用户态）。当一个程序调执行了系统调用或者触发了某个异常，它就陷入了内核空间（内核态）。此时，我们称内核“代表进程执行”并处于进程上下文中。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复到用户空间继续执行。 系统调用，异常处理程序和中断处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行——对内核的所有访问都必须通过这些接口。 在Linux系统中，所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本并执行其他的相关程序，最终完成系统启动的整个过程。 进程创建进程的创建将一个新进程添加到正被管理的进程集时，操作系统需要建立用于管理该进程的数据结构，并在内存中给它分配地址空间，这些行为构成了一个新进程的创建过程， 操作系统会按照如下步骤操作： 为新进程分配一个唯一的进程描述符。此时，主进程表中会添加一个新表项，每个进程一个表项。 为进程分配空间。包括进程映像中的所有元素。 初始化进程控制块（进程描述符）。 设置正确的链接。即将其放入适当的任务队列中。 创建或扩充其它数据结构。例如，操作系统可因编制账单和/或评估性能，为每个进程维护一个记账文件。 Linux中的进程创建分为两步，首先，fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID、PPID（子进程将其设置为被拷贝进程的PID）和某些资源和统计量（例如，挂起的信号，它没有必要被继承）。然后，在需要时，通过exec()函数族读取可执行文件并将其载入地址空间开始作为一个全新的进程运行。 fork()使用写时拷贝（copy-on-write）页实现。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。 fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。如果进程创建后马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据。 fork()通过clone()系统调用实现。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。fork()和_clone()库函数都根据各自需要的参数标志去调用clone()，然后由clone()去调用do_fork()。 do_fork完成了创建中的大部分工作，它的定义在kernel/fork.c文件中。该函数调用copy_process()函数，然后让进程开始运行。copy _process()函数完成如下工作： 调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同的。 检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制。 子进程着手使自己与父进程区别开来。进程描述符内的许多成员都要被清零或设为初始值。那些不是继承而来的进程描述符成员，主要是统计信息（文件引用计数等）。task_struct中的大多数数据都依然未被修改。 子进程的状态被设置为TASK_UNINTERRUPTIBLE，以保证它不会投入运行。 copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERPRIV标志被清0。表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。 调用alloc_pid()为新进程分配一个有效的PID。 根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。在一般情况下，这些资源会被给定进程的所有线程共享。 最后，copy_process()做扫尾工作并返回一个指向子进程的指针。 再回到do_fork()函数，如果copy_process()函数成功返回，新创建的子进程被唤醒并让其投入运行。内核有意选择子进程首先执行。因为一般子进程都会马上调用exec()函数族，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。 进程终结 原因 说明 正常完成 进程自行执行一个操作系统服务调用，表示它已经结束运行 超出时限 进程运行时间超过规定的时限 无可用内存 系统无法满足进程需要的内存空间 保护错误 进程试图使用不允许使用的资源或文件，如往只读文件中写或试图访问不允许访问的内存单元 I/O失败 在输入或输出期间发生错误，如找不到文件或某些无效操作 父进程终止 当一个父进程终止时，操作系统可能会自动终止该进程的所有子进程 父进程请求 父进程通常具有终止其任何子进程的权力 进程的终结发生在调用exit()系统调用时，exit()又调用了do_exit()（定义在&lt;kernel/exit.c&gt;文件中）： 将tast_struct中的标志成员设置为PF_EXITING。 调用del_timer_sync()删除任一内核定时器。根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。 然后调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（也就是说，这个地址空间没有被共享)，就彻底释放它们。 接下来调用sem__exit()函数。如果进程排队等候IPC信号，它则离开队列。 调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为零，那么就代表没有进程在使用相应的资源，此时可以释放。 接着把存放在task_struct的exit_code成员中的任务退出代码置为由exit()提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。退出代码存放在这里供父进程随时检索。 调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为init进程，并把进程状态（存放在task_struct结构的exit_state中）设成EXIT_ZOMBIE。 如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白地耗费内存。一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。 do_exit()调用schedule()切换到新的进程。因为处于EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程所执行的最后一段代码。do_exit()永不返回。 至此，与进程相关联的所有资源都被释放掉了，还占用的所有内存就是内核栈、thread_info结构和tast_struct结构。此时进程存在的唯一目的就是向它的父进程提供信息。 这意味着，进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得已终结的子进程的信息后，通知内核它并不关注那些信息后，子进程的task_struct结构才被释放。 wait()这一族函数都是通过唯一（但是很复杂）的一个系统调用wait4()来实现的。它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的PID。此外，调用该函数时提供的指针会包含子函数退出时的退出代码。 当最终需要释放进程描述符时，release_task()会被调用，用以完成以下工作： 它调用__exit_signal()，该函数调用_unhash process()，后者又调用detach_pid()从pidhash上删除该进程，同时也要从任务列表中删除该进程。 _exit_signal()释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。 如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么release_task()就要通知僵死的领头进程的父进程。 release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放tast_struct所占的slab高速缓存。 至此，进程描述符和所有进程独享的资源就全部释放掉了。 进程切换进程间切换进程切换可在操作系统从当前正在运行进程中获得控制权的任何时刻（即，当执行进程从用户态转移到内核态之后）发生。 机制 原因 用途 中断 来自当前执行指令的外部 对异步外部事件的反应，如完成一次I/O操作 异常（陷阱） 与当前执行指令有关 处理一个错误或异常事件，如非法的内存或文件访问 系统调用 显示请求 调用系统函数，使用系统调用会将用户进程设为阻塞态 涉及状态变化的完整的进程切换步骤如下： 保存处理器的上下文，包括程序计数器和其他寄存器。 更新当前处于运行态进程的进程控制块，包括把进程的状态改变为另一状态（就绪态、阻塞态、退出态）。还须更新其他相关的字段，包括退出运行态的原因和记账信息。 把该进程的进程控制块移到相应的任务队列（就绪、阻塞） 选择另一个进程执行，详见进程调度。 更新所选进程的进程控制块，包括把进程的状态改为运行态。 更新内存管理数据结构。是否需要更新取决于管理地址转换的方式，详见内存管理。 载入程序计数器和其他寄存器先前的值，将处理器的上下文恢复为所选进程上次退出运行态时的上下文。 与模式切换（指用户态和内核态间切换）的区别在于，模式切换可在不改变当前运行态进程的状态下出现（即不涉及状态变化），此时保存上下文并之后恢复上下文仅需很少的开销。 线程间切换在Linux系统中，当Linux内核执行从一个进程到另一个进程的切换时，会检查当前进程的页目录地址是否与将被调度的进程的相同。若相同，则它们共享同一个地址空间（即同一个进程中的不同线程），所以此时上下文切换仅是从代码的处跳转到代码的另一处。 进程切换分两步： 切换页目录以使用新的地址空间。 切换内核栈和硬件上下文。 对于Linux来说，线程和进程的最大区别就在于地址空间。对于线程切换，第1步是不需要做的，第2步是进程和线程切换都要做的。 所以明显是进程切换代价大。 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理器的页表缓冲（TLB）会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。 线程和线程在Linux中的实现进程是资源分配的最小单元，享有资源所有权，线程是调度执行的具体对象，享有被调度执行权。 线程是在进程中活动的可被内核调度的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。同一个进程中的所有线程可以共享虚拟内存，但拥有独立的虚拟处理器。进程中的所有线程共享该进程的状态和资源，所有线程都驻留在同一块地址空间中，并可访问相同的数据。 Linux实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的task_struct，所以在内核中，它看起来就像是一个普通的进程，只是线程和其他一些进程共享某些资源，如地址空间。 也就是说，组成一个用户级进程的多个用户级线程被映射到共享同一个组ID的多个Linux内核级进程上。因此，这些进程可以共享文件和内存等资源，使得同一个组中的进程调度切换时不需要切换上下文。 线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源： 1clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0); 上面的代码产生的结果和调用fork()差不多，只是父子俩共享地址空间CLONE_VM、文件系统资源CLONE_FS、文件描述符CLONE_FILES和信号处理程序CLONE_SIGHAND。新建的进程和它的父进程就是所谓的线程，但它们都具有各自的用户栈，因为clone()系统调用会为每个进程创建独立的栈空间。 对比一下，一个普通的fork()的实现是： 1clone(SIGCHLD, 0); 这些clone()用到的参数标志以及它们的作用，这些是在&lt;linux/sched.h&gt;中定义的。 内核线程（进程）内核经常需要在后台执行一些操作。这种任务可以通过内核线程（独立运行在内核空间的标准进程，内核线程也只能由其他内核线程创建）完成。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL）。它们只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。 守护线程（进程）Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd等。 守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。 一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。 首先我们要了解一些基本概念： 进程组 ： 每个进程也属于一个进程组 每个进程主都有一个进程组号，该号等于该进程组组长的PID号 . 一个进程只能为它自己或子进程设置进程组ID号 会话：会话（session）是一个或多个进程组的集合。 setsid()函数可以建立一个会话： 如果，调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。 此进程变成该对话期的首进程； 此进程变成一个新进程组的组长进程； 此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误； 为了保证这一点，我们先调用fork()然后父进程exit()，此时只有子进程在运行。 现在我们来给出创建守护进程所需步骤： 编写守护进程的一般步骤步骤： 在父进程中执行fork并让父进程exit退出； 在子进程中调用setsid函数创建新的会话； 在子进程中调用chdir函数，让根目录/成为子进程的工作目录； 在子进程中调用umask函数，设置进程的umask为0； 在子进程中关闭任何不需要的文件描述符。 一些说明： 在后台运行 为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。 脱离控制终端，登录会话和进程组 有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。 控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长，当进程是会话组长时setsid()调用失败。 但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。 禁止进程重新打开控制终端 现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过再次fork()使进程不再成为会话组长来禁止进程重新打开控制终端。 关闭打开的文件描述符 进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。 改变当前工作目录 进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录。 重设文件创建掩码 进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);。 处理SIGCHLD信号 处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN：signal(SIGCHLD, SIG_IGN);。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++重要知识点详细解读之memcpy、memset、strcpy、strcmp、strlen、string的实现","date":"2021-02-21T13:35:42.000Z","path":"fKh6HJGjVNfldP4P/","text":"memcpy memset strcpy strcmp strlen string的实现 memcpy、memset实现memcpy实现 此实现并没有考虑dst和src的内存重叠问题 123456789101112131415// 使用 const 修饰 srcvoid* memcpy(void* dst, const void* src, size_t n)&#123; // 验证 dst 和 src 的合法性 assert(dst != NULL); assert(src != NULL); void* ret = dst; while(n--) &#123; *(char*)dst = *(char*)src; dst = (char*)dst + 1; src = (char*)src + 1; &#125; return ret;&#125; memset实现1234567891011void* memset(void* dst, int ch, size_t n)&#123; assert(dst != NULL); void* ret = dst; while(n--) &#123; *(char*)dst = (char)ch; dst = (char*)dst + 1; &#125; return ret; // 返回原 dst 指针&#125; strcpy、strcmp、strlen实现strcpy实现 此实现并没有考虑dst和src的内存重叠问题 12345678910// 使用 const 修饰 srcchar* strcpy(char* dst, const char* src)&#123; // 验证 dst 和 src 的合法性 assert(dst != NULL); assert(src != NULL); char* ret = dst; while((*dst++ = *src++) != '\\0'); return ret; // 返回原 dst 指针&#125; strcmp实现12345678910111213141516171819202122// 注意将两个指针都用 const 修饰int strcmp(const char* rhs, const char* lhs)&#123; // 判空测试 assert(rhs != NULL); assert(lhs != NULL); // 注意这里必须是 unsigned char // 表示的范围为 0 ~ 255 // 如果是 char 的话, 范围是 -128 ~ 127, 这个范围用来比较字符串是不对的 unsigned char c1, c2; while(1) &#123; c1 = *rhs++; c2 = *lhs++; if(c1 != c2) return c1 &lt; c2 ? -1 : 1; if(c1 == 0) bresk; &#125; return 0;&#125; strlen实现1234567size_t strlen(const char* str)&#123; if(str == NULL) return 0; const char* pc = str; while(*pc++ != '\\0'); return pc - str - 1;&#125; 关于标准库中的实现：通过减少数据从内存存取到寄存器的次数来提高效率，使用的手段是先字节对齐，然后每次读取一个4/8字节的多字节数据，对多字节数据遍历是否存在\\0。 自己动手实现一个string类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;cstring&gt;class String&#123;private: char *_data; size_t _size; void init(const char *c_str) &#123; _data = new char[_size + 1]; strcpy(_data, c_str); &#125;public: String() : _data(nullptr), _size(0) &#123;&#125; String(const char *c_str) : _size(strlen(c_str)) &#123; if (c_str) init(c_str); else _data = nullptr; &#125; String(const String &amp;str) : _size(str._size) &#123; if (str._data) init(str._data); else _data = nullptr; &#125; String(String &amp;&amp;str) noexcept : _data(str._data), _size(str._size) &#123; str._data = nullptr; str._size = 0; &#125; ~String() &#123; if (_data) delete _data; &#125; String &amp;operator=(const char *c_str) &#123; // 使用 copy and swap 技术, 可以处理自我赋值情况 String temp(c_str); swap(temp); return *this; &#125; String &amp;operator=(const String &amp;str) &#123; return *this = str._data; &#125; String &amp;operator=(String &amp;&amp;str) noexcept &#123; // 检测自我赋值情况 if(this == &amp;str) return *this; if (_data) delete _data; _data = nullptr; _size = 0; swap(str); return *this; &#125; size_t size() const &#123; return _size; &#125; char *c_str() &#123; return _data; &#125; const char *c_str() const &#123; return _data; &#125; void swap(String &amp;str) &#123; using std::swap; swap(_data, str._data); swap(_size, str._size); &#125; bool operator==(const char *c_str) &#123; if (strcmp(_data, c_str) == 0) return true; return false; &#125; bool operator==(const String &amp;str) &#123; return *this == str._data; &#125; char &amp;operator[](size_t i) &#123; return _data[i]; &#125; const char &amp;operator[](size_t i) const &#123; return _data[i]; &#125;&#125;;std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const String str)&#123; return os &lt;&lt; str.c_str();&#125;","tags":[{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"C++重要知识点详细解读之const关键字的实现","date":"2021-02-18T13:35:42.000Z","path":"cZUstnNRSXkgncRt/","text":"编译器是如何实现const关键字功能的const用于声明变量const定义的变量只有类型为整数或枚举，且以常量表达式初始化时，在其它地方使用该变量的地方才会被以常量替换。其他情况下它只是一个const限定的变量。但它们都分配了内存地址，把它们统称为常量。 修饰全局变量 123456789101112131415struct Point&#123; int x; int y;&#125;;// 全局const Point p&#123;1, 2&#125;;void func()&#123; Point *pp = (Point *)&amp;p; pp-&gt;x = 3; // error! // Exception has occurred. Segmentation fault&#125; 未被const修饰的全局变量默认为extern，不需要extern显式声明即可以在其它文件中访问！而全局const常量需要显式声明extern，并且需要做初始化，才能在其它文件中访问！因为常量在定义后就不能被修改，所以定义时必须初始化。 虽然可以编译通过（骗过了编译器）。但上述全局const修饰的变量p会被编译器存放在ELF文件的.rodata分区（只读），程序默认不拥有写权限，故运行时不可更改。 接下来，控制变量p的const功能就交给操作系统中内存分页机制了。操作系统会将.rodata所在的内存页的权限标记为只读。每当程序访问内存时，CPU都会检查内存地址对应的权限。如果权限不符，那么CPU就会产生中断并调用操作系统所设置的中断处理例程。在这个例子中，当CPU发现程序想要写一块只读内存时，就会产生中断。而Linux设置的默认动作是终止程序，并打印 “Segmentation fault (core dumped)”。 修饰局部变量 这时只是编译器负责检查你有没有显式的通过p来修改const修饰的变量p的值。但是你可以通过其它技巧骗过编译器来修改。比如： 12345678// 局部void func()&#123; const Point p&#123;1, 2&#125;; p.x = 3; // error! Point *pp = (Point *)&amp;p; pp-&gt;x = 3; // correct!&#125; 编译器的实现为，函数内变量放在函数的栈帧里的，程序拥有对这个存储区自由读写的权限。 修饰类的成员变量 编译器的实现和前面说的修饰函数内局部变量一样。但类中的const成员变量必须通过初始化列表进行初始化。 12345678910111213struct Point&#123; const int x; int y; Point(int x_, int y_) : x(x_), y(y_) &#123;&#125;&#125;;void func()&#123; const Point p(1, 2); // p 对象中 x = 1, y = 2 int *pi = (int *)&amp;p; *pi = 3; // // p 对象中 x = 3, y = 2&#125; 通过指针竟然可以修改类对象内声明为const的对象。细思极恐,，这其实就是指针的被广为诟病的地方了。 修饰函数形参 value with const 12void func(const int val); // 传递过来的参数不可变void func(int *const p); // 指针本身不可变 编译器的实现跟前面讨论的修饰函数内局部变量一样。 reference or pointer with const 12void strcpy(char *dst, const char *src); // 参数指针所指内容为常量不可变void func(const A &amp;a) // 参数为引用, 为了增加效率同时防止修改 修饰函数返回类型 value with const 1const Point func1(); // 无意义, 因为参数返回本身就是赋值给其他的变量！ reference or pointer with const 12const Point* func2(); // 指针指向内容不可变const Point&amp; func2(); // 引用的内容不可变 const用于声明函数 修饰类的成员函数 被const修饰的类对象，只能访问类中const成员函数。 12345678910struct Point&#123; const int x; int y; Point(int x_, int y_) : x(x_), y(y_) &#123;&#125; int getX() const &#123; return x; &#125;&#125;; 编译器会将被const修饰的成员函数getX()转化为： 12345678910111213// 转化为下面这样// 前面的那个 const_ 才是 const 修饰起到的作用, 后面的本身就有int getX(const_ Point* const this)&#123; return this-&gt;x;&#125;// 这样的调用Point p(1, 2);p.getX();// 转化为下面这样getX(&amp;p); 也就是说，const修饰类成员函数时，修饰的只是传进来的this指针而已。 const char* str、char* str、char str[]、const char str[]的区别12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* 注意, 下面的讨论都是把此定义放在 全局 */// 编译器都会将常量 \"hello\" 存放在只读数据段// 而且这和前面是否使用 const 修饰没关系// 程序持有的只是一个指针变量而已// 所以, 通过指针修改这个串 \"hello\", 都会报错的const char* str = \"hello\";// 或char* str = \"hello\";// 但如果这样定义// 此时定义的是数组变量, 有 const 的话会放在只读数据段const char str[] = \"hello\";// 没有 const 的话就会放在可写段char str[] = \"hello\";/////////////////////////////////////////const char *s1 = \"hello\";char *s2 = \"world\";char s3[] = \"dfasd\";const char s4[] = \"asdfasdf\";void func()&#123; *s1 = 'e'; // error char *ps1 = (char *)s1; *ps1 = 'd'; // error *s2 = 'e'; // error *s3 = 'e'; // correct *s4 = 'r'; // error char *ps4 = (char *)s4; *ps4 = 'd'; // error&#125;/* 注意, 下面的讨论都是把此定义放在 局部 */// 和定义在全局相同// 编译器都会将常量 \"hello\" 存放在只读数据段// 而且这和前面是否使用 const 修饰没关系// 程序持有的只是一个指针变量而已// 所以, 通过指针修改这个串 \"hello\", 都会报错的const char* str = \"hello\";// 或char* str = \"hello\";// 但如果这样定义// 此时定义的是数组变量, 有 const 的话 只会放在函数的栈帧上// 编译器会负责检查, 不允许你显示修改 str 数组// 可以通过前面介绍的 trick 骗过编译器来修改const char str[] = \"hello\";// 没有 const 的话, 放在函数的栈帧上, 访问就随意啦char str[] = \"hello\";/////////////////////////////////////////void func()&#123; const char *s1 = \"hello\"; char *s2 = \"world\"; char s3[] = \"dfasd\"; const char s4[] = \"asdfasdf\"; *s1 = 'e'; // error char *ps1 = (char *)s1; *ps1 = 'd'; // error *s2 = 'e'; // error *s3 = 'e'; // correct *s4 = 'r'; // error char *ps4 = (char *)s4; *ps4 = 'd'; // correct&#125; 编译器是如何实现强制类型转换的关于强制类型转换的分类和使用参考《Effective C++》条款27。 进行强制类型转换后，内存空间里面原变量的内容是不会发生改变的，改变的是运算时产生的临时数据对象的类型，是你去读取这个内存空间时的解析方法。 从编译原理的角度去看，C++编译器会维护一份程序中所有变量的名称和其类型之间的一个映射表。通过变量名称去操作内存空间时，会查看这个映射表，获取变量所属的类型之后再决定操作的内存范围。当使用强制类型转换时，会首先改变这个临时数据对象的类型，再去操作内存。","tags":[{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"C++重要知识点详细解读之智能指针","date":"2021-02-15T13:35:42.000Z","path":"DVejmy5owOXx5WKk/","text":"智能指针详解及源码分析关于智能指针的demo，参见C++ primer 12.1。 什么是智能指针智能指针是使用RAII手法对裸指针进行的一个面向对象封装，即在构造函数中初始化资源地址，在析构函数中释放资源。智能指针保证当资源应当被释放的时候一定会释放它，这是利用了栈上的对象出作用域时自动析构这个特点。 为什么引入智能指针用以弥补裸指针的不足： ​ 1）使用裸指针分配内存后，没有对指针释放资源会导致内存泄漏； ​ 2）多个裸指针指向同一资源时，多次释放资源时，对空悬指针进行释放会导致不可预知的错误。 如何知道是否存在内存泄漏在不借助其他检测工具的情况下，可以通过观察，即程序长时间运行后内存占用率一直不断的缓慢的上升，而实际上在你的逻辑中并没有这么多的内存需求。 如何定位到内存泄漏点 review代码，找到new和delete关键字的位置，先看看内存的申请和释放是否是成对的来进行初步的判断； 对于函数中申请的临时空间，认真检查是否存在提前跳出函数的地方而导致没有释放内存。 智能指针有哪些智能指针分为不带引用计数的scoped_ptr和unique_ptr，带引用计数的shared_ptr和weak_ptr。 这些智能指针分别是如何实现的scoped_ptr私有化了拷贝构造函数和赋值操作运算符，资源的所有权无法进行转移，也无法在容器中使用，这种方式杜绝了浅拷贝的发生。 unique_ptr删除了拷贝构造函数和赋值函数，因此不支持普通的拷贝或赋值操作。但引入了移动构造函数和移动赋值运算符。所以它们保证了有唯一的智能指针持有此资源。unique_ptr还提供了reset重置资源，swap交换资源等函数，也经常会使用到。 shared_ptr称为强智能指针，它的资源引用计数器在内存的heap堆上（这保证了，每个智能指针的引用计数变量会动态的变化）。通常用于管理对象的生命周期。只要有一个指向对象的shared_ptr存在，该对象就不会被析构。 weak_ptr被称为弱智能指针，其对资源的引用不会引起资源的引用计数的变化，通常作为观察者，用于判断资源是否存在，并根据不同情况做出相应的操作。比如使用weak_ptr对资源进行弱引用，当调用weak_ptr的lock()方法时，若返回nullptr，则说明资源已经不存在，放弃对资源继续操作。否则，将返回一个shared_ptr对象，可以继续操作资源。另外，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。 当需要多个智能指针指向同一个资源时，使用带引用计数的智能指针。每增加一个智能指针指向同一资源，资源引用计数加1，反之减1。当引用计数为0时，由最后一个指向资源的智能指针将资源进行释放。 如何避免循环引用12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class B; // 前置声明类Bclass A&#123;public: A() &#123; cout &lt;&lt; \"A()\" &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A()\" &lt;&lt; endl; &#125; shared_ptr&lt;B&gt; _ptrb; // 指向B对象的智能指针&#125;;class B&#123;public: B() &#123; cout &lt;&lt; \"B()\" &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; \"~B()\" &lt;&lt; endl; &#125; shared_ptr&lt;A&gt; _ptra; // 指向A对象的智能指针&#125;;int main()&#123; shared_ptr&lt;A&gt; ptra(new A()); // ptra指向A对象，A的引用计数为1 shared_ptr&lt;B&gt; ptrb(new B()); // ptrb指向B对象，B的引用计数为1 ptra-&gt;_ptrb = ptrb; // A对象的成员变量_ptrb也指向B对象，B的引用计数为2 ptrb-&gt;_ptra = ptra; // B对象的成员变量_ptra也指向A对象，A的引用计数为2 cout &lt;&lt; ptra.use_count() &lt;&lt; endl; // 打印A的引用计数结果:2 cout &lt;&lt; ptrb.use_count() &lt;&lt; endl; // 打印B的引用计数结果:2 /* 出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和 B对象的引用计数从2减到1，达不到释放A和B的条件（释放的条件是 A和B的引用计数为0），因此造成两个new出来的A和B对象无法释放， 导致内存泄露，这个问题就是“强智能指针的交叉引用(循环引用)问题” */ return 0;&#125; 解决办法，这也是强弱智能指针的一个重要应用规则：定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class B; // 前置声明类 Bclass A&#123;public: A() &#123; cout &lt;&lt; \"A()\" &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A()\" &lt;&lt; endl; &#125; weak_ptr&lt;B&gt; _ptrb; // 指向 B 对象的弱智能指针。引用对象时，用弱智能指针&#125;;class B&#123;public: B() &#123; cout &lt;&lt; \"B()\" &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; \"~B()\" &lt;&lt; endl; &#125; weak_ptr&lt;A&gt; _ptra; // 指向 A 对象的弱智能指针。引用对象时，用弱智能指针&#125;;int main()&#123; // 定义对象时，用强智能指针 shared_ptr&lt;A&gt; ptra(new A()); // ptra 指向 A 对象，A 的引用计数为 1 shared_ptr&lt;B&gt; ptrb(new B()); // ptrb 指向B 对象，B 的引用计数为 1 // A 对象的成员变量 ptrb 也指向 B 对象，B 的引用计数为 1，因为是弱智能指针，引用计数没有改变 ptra-&gt;_ptrb = ptrb; // B 对象的成员变量 ptra 也指向 A 对象，A 的引用计数为 1，因为是弱智能指针，引用计数没有改变 ptrb-&gt;_ptra = ptra; cout &lt;&lt; ptra.use_count() &lt;&lt; endl; // 打印结果: 1 cout &lt;&lt; ptrb.use_count() &lt;&lt; endl; // 打印结果: 1 /* 出 main 函数作用域，ptra 和 ptrb 两个局部对象析构，分别给 A 对象和 B 对象的引用计数从 1 减到 0，达到释放 A 和 B 的条件，因此 new 出来的 A 和 B 对象 被析构掉，解决了“强智能指针的交叉引用(循环引用)问题” */ return 0;&#125; 什么情况下需要自定义deleter在管理的裸指针不是new出来的裸指针时需要自定义删除器，比如管理的指针为文件指针或由malloc获得的指针等。 enable_shared_from_this机制当class Widget被share_ptr管理，且在Widget的成员函数里需要把当前类对象的智能指针作为参数传给其他函数时，就需要传递一个指向自身的share_ptr。 而当使用shared_ptr管理同一资源，调用shared_ptr的构造函数和拷贝构造函数是不一样的（构造函数新创建一份堆上的引用计数资源，拷贝构造函数修改原来堆上的引用计数资源），它们虽然使得不同shared_ptr指向同一资源，但管理引用计数资源的方式却不一样。这就造成了不能直接传递shared_ptr&lt;Widget&gt;(this)。因为这样会造成2个非共享的share_ptr指向同一个对象，引用计数资源相互独立导致对象被析构2次。 12345678910111213141516171819202122#include &lt;memory&gt;#include &lt;iostream&gt; class Widget&#123;public: std::shared_ptr&lt;Widget&gt; getptr() &#123; return std::shared_ptr&lt;Widget&gt;(this); &#125; ~Widget() &#123; std::cout &lt;&lt; \"Widget::~Widget() called\" &lt;&lt; std::endl; &#125;&#125;; int main()&#123; // 错误的示例, 每个 shared_ptr 都认为自己是对象仅有的所有者 std::shared_ptr&lt;Widget&gt; p1(new Widget; std::shared_ptr&lt;Widget&gt; p2 = p1-&gt;getptr(); // 打印 p1 和 p2 的引用计数 std::cout &lt;&lt; \"p1.use_count() = \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; // 输出为 1 std::cout &lt;&lt; \"p2.use_count() = \" &lt;&lt; p2.use_count() &lt;&lt; std::endl; // 输出为 1&#125; // Widget 对象将会被删除两次 12345678910111213141516171819202122#include &lt;memory&gt;#include &lt;iostream&gt; struct Widget : public std::enable_shared_from_this&lt;Widget&gt; // 注意：继承&#123;public: std::shared_ptr&lt;Widget&gt; getptr() &#123; return shared_from_this(); &#125; ~Widget() &#123; std::cout &lt;&lt; \"Widget::~Widget() called\" &lt;&lt; std::endl; &#125;&#125;; int main()&#123; std::shared_ptr&lt;Widget&gt; p1(new Widget; std::shared_ptr&lt;Widget&gt; p2 = p1-&gt;getptr(); // 打印 p1 和 p2 的引用计数 std::cout &lt;&lt; \"p1.use_count() = \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; // 输出为 2 std::cout &lt;&lt; \"p2.use_count() = \" &lt;&lt; p2.use_count() &lt;&lt; std::endl; // 输出为 2&#125; // // Widget 对象只会被删除一次 实际使用场景：在异步调用中，存在一个保活机制，异步函数执行的时间点我们是无法确定的，然而异步函数可能会使用到异步调用之前就存在的变量。为了保证该变量在异步函数执期间一直有效，我们可以传递一个指向自身的share_ptr给异步函数，这样在异步函数执行期间share_ptr所管理的对象就不会析构，所使用的变量也会一直有效了（保活）。 enable_shared_from_this是如何实现的enable_shared_from_this类中包含一个作为观察者的成员变量，如下： 1234567891011121314151617181920212223template&lt;class T&gt;class enable_shared_from_this&#123;public: ... SetSharedPtr(shared_ptr&lt;T&gt;* sp) &#123; if(weak_this_.expired()) wp = sp; // 标准库中并没有把 sp 直接赋值给 wp，而是使用了 shared_ptr 的别名构造函数 &#125; __shared_ptr&lt;_Tp, _Lp&gt; shared_from_this() &#123; return __shared_ptr&lt;_Tp, _Lp&gt;(this-&gt;_M_weak_this); &#125; __shared_ptr&lt;const _Tp, _Lp&gt; shared_from_this() const &#123; return __shared_ptr&lt;const _Tp, _Lp&gt;(this-&gt;_M_weak_this); &#125;private: mutable weak_ptr&lt;_Tp&gt; _M_weak_this; // 使用 weak_ptr 的目的正是为了避免循环引用!&#125;; 当一个类继承了enable_shared_from_this类，就继承了_M_weak_this这个成员变量。 使用shared_ptr&lt;Widget&gt;(new Widget())第一次构造智能指针对象时，就会初始化一个作为观察者的弱智能指针_M_weak_this指向Widget对象资源。 12345678910111213141516171819class shared_ptr&lt;T&gt;&#123;public: explicit shared_ptr&lt;T&gt;(T* w) &#123; SetSharedPtr(this, w); &#125; void SetSharedPtr(shared_ptr&lt;T&gt;* sp, enable_shared_from_this&lt;T&gt;* w) &#123; w-&gt;SetSharedPtr(sp); &#125; // 此重载函数的作用是为了处理 Widget 并没有继承 enable_shared_from_this 的情况 void SetSharedPtr(...) &#123; // 什么也不做 &#125;&#125;; 通过shared_from_this()方法代替shared_ptr的普通构造函数来返回一个shared_ptr对象，从而避免产生额外的引用计数资源对象。在shared_from_this()函数中，是通过_M_weak_this来构造并返回一个shared_ptr对象的。 智能指针源码分析unique_ptr的声明包含两个模板参数，第一个参数_Tp显然就是原生指针的类型。第二个模板参数_Dp是一个deleter，默认值为default_delete&lt;_Tp&gt;。default_delete是一个针对delete operator的函数对象。 unique_ptr内部用tuple&lt;pointer, _Dp&gt; _M_t;变量保存数据，相当于原生指针和deleter对象组成的一个pair。 定义了构造函数和移动构造函数和移动赋值运算符，但是删除了拷贝构造函数和拷贝赋值运算符。 unqiue_ptr还定义了两个很重要的函数：reset(pointer)和release()。reset(pointer)的功能是用一个新指针替换原来的指针，而release()则是是放弃原生指针的所有权。 到目前为止，unique_ptr还不像个指针，因为还缺少两个方法：operator*和operator-&gt;。 下面是unique_ptr的源码，有删减，但大体上不变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169template &lt;typename _Tp&gt;struct default_delete&#123; /// Default constructor constexpr default_delete() noexcept = default; void operator()(_Tp *__ptr) const &#123; delete __ptr; &#125;&#125;;template &lt;typename _Tp, typename _Dp&gt;class __uniq_ptr_impl&#123; template &lt;typename _Up, typename _Ep, typename = void&gt; struct _Ptr &#123; using type = _Up *; &#125;; template &lt;typename _Up, typename _Ep&gt; struct _Ptr&lt;_Up, _Ep, __void_t&lt;typename remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt; &#123; using type = typename remove_reference&lt;_Ep&gt;::type::pointer; &#125;;public: using pointer = typename _Ptr&lt;_Tp, _Dp&gt;::type; __uniq_ptr_impl() = default; __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125; template &lt;typename _Del&gt; __uniq_ptr_impl(pointer __p, _Del &amp;&amp;__d) : _M_t(__p, std::forward&lt;_Del&gt;(__d)) &#123;&#125; pointer &amp;_M_ptr() &#123; return std::get&lt;0&gt;(_M_t); &#125; pointer _M_ptr() const &#123; return std::get&lt;0&gt;(_M_t); &#125; _Dp &amp;_M_deleter() &#123; return std::get&lt;1&gt;(_M_t); &#125; const _Dp &amp;_M_deleter() const &#123; return std::get&lt;1&gt;(_M_t); &#125;private: tuple&lt;pointer, _Dp&gt; _M_t;&#125;;template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt;class unique_ptr&#123; __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;public: using pointer = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer; using element_type = _Tp; using deleter_type = _Dp; // Constructors. /// Default constructor, creates a unique_ptr that owns nothing. template &lt;typename _Up = _Dp, typename = _DeleterConstraint&lt;_Up&gt;&gt; constexpr unique_ptr() noexcept : _M_t() &#123; &#125; template &lt;typename _Up = _Dp, typename = _DeleterConstraint&lt;_Up&gt;&gt; explicit unique_ptr(pointer __p) noexcept : _M_t(__p) &#123; &#125; unique_ptr(pointer __p, typename remove_reference&lt;deleter_type&gt;::type &amp;&amp;__d) noexcept : _M_t(std::move(__p), std::move(__d)) &#123; &#125; // Move constructors. /// Move constructor. unique_ptr(unique_ptr &amp;&amp;__u) noexcept : _M_t(__u.release(), std::forward&lt;deleter_type&gt;(__u.get_deleter())) &#123;&#125; /// Destructor, invokes the deleter if the stored pointer is not null. ~unique_ptr() noexcept &#123; auto &amp;__ptr = _M_t._M_ptr(); if (__ptr != nullptr) get_deleter()(__ptr); __ptr = pointer(); &#125; // Assignment. unique_ptr &amp;operator=(unique_ptr &amp;&amp;__u) noexcept &#123; reset(__u.release()); get_deleter() = std::forward&lt;deleter_type&gt;(__u.get_deleter()); return *this; &#125; /// Reset the %unique_ptr to empty, invoking the deleter if necessary. unique_ptr &amp;operator=(nullptr_t) noexcept &#123; reset(); return *this; &#125; // Observers. /// Dereference the stored pointer. typename add_lvalue_reference&lt;element_type&gt;::type operator*() const &#123; return *get(); &#125; /// Return the stored pointer. pointer operator-&gt;() const noexcept &#123; return get(); &#125; /// Return the stored pointer. pointer get() const noexcept &#123; return _M_t._M_ptr(); &#125; /// Return a reference to the stored deleter. deleter_type &amp;get_deleter() noexcept &#123; return _M_t._M_deleter(); &#125; /// Return a reference to the stored deleter. const deleter_type &amp;get_deleter() const noexcept &#123; return _M_t._M_deleter(); &#125; /// Return @c true if the stored pointer is not null. explicit operator bool() const noexcept &#123; return get() == pointer() ? false : true; &#125; /// Release ownership of any stored pointer. pointer release() noexcept &#123; pointer __p = get(); _M_t._M_ptr() = pointer(); return __p; &#125; void reset(pointer __p = pointer()) noexcept &#123; using std::swap; swap(_M_t._M_ptr(), __p); if (__p != pointer()) get_deleter()(__p); &#125; /// Exchange the pointer and deleter with another object. void swap(unique_ptr &amp;__u) noexcept &#123; using std::swap; swap(_M_t, __u._M_t); &#125; // Disable copy from lvalue. unique_ptr(const unique_ptr &amp;) = delete; unique_ptr &amp;operator=(const unique_ptr &amp;) = delete;&#125;; 下面是shared_ptr的类图。 如图，shared_ptr类几乎什么都没有做，它是继承了__shared_ptr，__shared_ptr内部有一个类型为__shared_count类型的成员，__shared_count内部有类型为_Sp_counted_base*的成员。 _Sp_counted_base才是整个shared_ptr功能的核心，通过_Sp_counted_base控制引用计数来管理指向的内存，由图可见_Sp_counted_base内部不持有指向内存的指针，这里__shared_count内部的_Sp_counted_base*成员其实指向的是一个继承自_Sp_counted_base的_Sp_counted_ptr类型的派生类对象，_Sp_counted_ptr类型内部持有指向内存的指针M_ptr，这样__shared_count内部就既可以控制引用计数，又可以在最后根据指向对象的指针释放托管内存。 注意的是：为什么_Sp_counted_ptr和__shared_ptr内部都有指向对象的指针。实际上它们可以是不同的类型（只要它们之间存在隐式转换），这是shared_ptr的一大功能： 无需虚析构。假设Bar是Foo的基类，但是Bar和Foo都没有虚析构。 12345678// _Sp_counted_ptr._M_ptr 和 __shared_ptr._M_ptr 的类型都是 Foo*shared_ptr&lt;Foo&gt; sp1(new Foo);// 可以赋值, __shared_ptr._M_ptr 自动向上转型 up-cast// _Sp_counted_ptr._M_ptr 类型不变shared_ptr&lt;Bar&gt; sp2 = sp1;sp1.reset(); // 这时 Foo 对象的引用计数降为 1 此后sp2仍然能安全地管理Foo对象的生命期，并安全完整地释放Foo，因为其_Sp_counted_ptr._M_ptr记住了Foo的实际类型。 shared_ptr&lt;void&gt;可以指向并安全地管理（析构或防止析构）任何对象。 12345678// _Sp_counted_ptr._M_ptr 和 __shared_ptr._M_ptr 的类型都是 Foo*shared_ptr&lt;Foo&gt; sp1(new Foo);// 可以赋值, __shared_ptr._M_ptr 中的 Foo* 类型向 void* 自动转型// _Sp_counted_ptr._M_ptr 类型不变shared_ptr&lt;void&gt; sp2 = sp1;sp1.reset(); // 这时 Foo 对象的引用计数降为 1 此后sp2仍然能安全地管理Foo对象的生命期，并安全完整地释放Foo，不会出现delete void*的情况，因为delete的是_Sp_counted_ptr._M_ptr而不是__shared_ptr._M_ptr。 多继承。假设Bar是Foo的多个基类之一，那么： 1234567shared_ptr&lt;Foo&gt; sp1(new Foo);// 这时 sp1._M_ptr 和 sp2._M_ptr 可能指向不同的地址// 因为 Bar subobject 在 Foo object 中的 offset 可能不为 0shared_ptr&lt;Bar&gt; sp2 = sp1;sp1.reset(); // 此时 Foo 对象的引用计数降为 1 但是sp2仍然能安全地管理Foo对象的生命期，并安全完整地释放Foo，因为delete的不是Bar*，而是原来的 Foo*。换句话说，sp1._M_ptr和sp2._M_ptr可能具有不同的值（当然它们的类型也不同）。 这里称_M_pi为管理对象，它内部的_M_ptr为托管对象，管理同一块托管对象的多个shared_ptr内部共用一个管理对象,，这里的多个shared_ptr可能是通过第一个shared_ptr拷贝或者移动而来，管理对象内部有两个成员变量_M_use_count和_M_weak_count。 _M_use_count表示托管对象的引用计数，控制托管对象什么时候析构和释放，当引用计数为0时调用托管对象的析构函数且释放内存。 _M_weak_count表示管理对象的引用计数，它的初始值比_M_use_count大1，管理对象也是一个内存指针，这块指针是初始化第一个shared_ptr时new出来的，到最后也需要delete，所以使用_M_weak_count来控制管理对象什么时候析构，当weak_ptr析构时时，管理对象的引用计数_M_weak_count就会减1，当_M_weak_count为0时，管理对象_M_pi就会析构且释放内存。 _M_use_count是如何加减的 Muse_count表示托管对象的引用计数，即当shared_ptr拷贝时会增加，当shared_ptr析构时会减少，看精简代码： 12345678910111213141516template &lt;typename _Yp&gt;__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r, element_type* __p) noexcept : _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws&#123;&#125;__shared_count(const __shared_count&amp; __r) noexcept : _M_pi(__r._M_pi)&#123; if (_M_pi != 0) _M_pi-&gt;_M_add_ref_copy();&#125;template &lt;&gt;inline void _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy()&#123; ++_M_use_count;&#125; shared_ptr拷贝时，内部__shared_count类型的_M_refcount会进行拷贝，__shared_count的拷贝构造函数会调用_M_add_ref_copy()方法，_M_add_ref_copy()方法中会将_M_use_count加1。 这里再看下shared_ptr的赋值构造函数： 1234567891011121314151617181920212223242526template &lt;typename _Yp&gt;_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt; operator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept&#123; this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(__r); return *this;&#125;template &lt;typename _Yp&gt;_Assignable&lt;_Yp&gt; operator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept&#123; _M_ptr = __r._M_ptr; _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw return *this;&#125;__shared_count&amp; operator=(const __shared_count&amp; __r) noexcept&#123; _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi; if (__tmp != _M_pi) &#123; if (__tmp != 0) __tmp-&gt;_M_add_ref_copy(); if (_M_pi != 0) _M_pi-&gt;_M_release(); _M_pi = __tmp; &#125; return *this;&#125; 从代码中可见，shared_ptr的operator=会调用__shared_ptr的operator=进而调用__shared_count的operator=，从这里可以看出管理同一块托管对象的shared_ptr共用的同一个管理对象的指针。 _M_use_count是如何减为0的，可以猜想到shared_ptr析构时会调用__shared_count的析构函数，看精简代码： 12345678910111213141516~__shared_count() noexcept&#123; if (_M_pi != nullptr) _M_pi-&gt;_M_release();&#125;template &lt;&gt;inline void _Sp_counted_base&lt;_S_single&gt;::_M_release() noexcept&#123; if (--_M_use_count == 0) &#123; _M_dispose(); if (--_M_weak_count == 0) _M_destroy(); &#125;&#125;virtual void _M_dispose() noexcept &#123; delete _M_ptr; &#125; 在shared_ptr生命周期结束析构时会将引用计数减1，如果引用引用计数为0，会调用_M_dispose()函数进而释放托管对象内存。 _M_weak_count是如何加减的 上面的代码中可以看见_M_weak_count为0时，会调用_M_destroy()函数，这里看看_M_weak_count是如何加减的。管理对象初始化时_M_weak_count的初始值为1 1_Sp_counted_base() noexcept : _M_use_count(1), _M_weak_count(1) &#123;&#125; 注意当shared_ptr拷贝或者移动时_M_weak_count是不会增加的，它表示的是管理对象的计数，只有当__M_use_count为0时_M_weak_count才会减1，除此之外_M_weak_count的数值是由weak_ptr控制的。 由上面类图可以看见weak_ptr内部其实和shared_ptr内部持有的是同一个管理对象指针，即_Sp_counted_base的指针，当weak_ptr拷贝析构时候，_Sp_counted_base内部的_M_weak_count会相应加减。 1234567891011121314151617181920212223__weak_count(const __weak_count&amp; __r) noexcept : _M_pi(__r._M_pi)&#123; if (_M_pi != nullptr) _M_pi-&gt;_M_weak_add_ref();&#125;template &lt;&gt;inline void _Sp_counted_base&lt;_S_single&gt;::_M_weak_add_ref() noexcept&#123; ++_M_weak_count;&#125;~__weak_count() noexcept&#123; if (_M_pi != nullptr) _M_pi-&gt;_M_weak_release();&#125;template &lt;&gt;inline void _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() noexcept&#123; if (--_M_weak_count == 0) _M_destroy();&#125;virtual void _M_destroy() noexcept &#123; delete this; &#125; 从代码中可以看出，weak_ptr拷贝时_M_weak_count加1，析构时_M_weak_count减1，当_M_weak_count为0时，表示不再需要管理对象来控制托管对象，调用_M_destroy()的delete this来释放管理对象内存。 weak_ptr的expired()和lock()做了什么 1234bool expired() const noexcept&#123; return _M_refcount._M_get_use_count() == 0;&#125; weak_ptr的expired()函数只是看了托管对象的引用计数是否为0，为0返回true。 12345678910__shared_ptr&lt;_Tp, _Lp&gt; lock() const noexcept&#123; return __shared_ptr&lt;element_type, _Lp&gt;(*this, std::nothrow);&#125;__shared_ptr(const __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, std::nothrow_t) : _M_refcount(__r._M_refcount, std::nothrow)&#123; _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;&#125; weak_ptr的lock()函数是打算返回一个shared_ptr对象来延长托管对象的生命周期，这里返回后需要判断返回值是否为nullptr。 shared_from_this()是如何实现的 精简代码如下： 1234567891011121314class enable_shared_from_this&#123; __shared_ptr&lt;_Tp, _Lp&gt; shared_from_this() &#123; return __shared_ptr&lt;_Tp, _Lp&gt;(this-&gt;_M_weak_this); &#125; __shared_ptr&lt;const _Tp, _Lp&gt; shared_from_this() const &#123; return __shared_ptr&lt;const _Tp, _Lp&gt;(this-&gt;_M_weak_this); &#125; mutable weak_ptr&lt;_Tp&gt; _M_weak_this;&#125;; 使用shared_from_this()的类需要继承enable_shared_from_this类，enable_shared_from_this类中持有一个类型为weak_ptr的成员_M_weak_this，调用shared_from_this()就是将内部持有的weak_ptr转成了shared_ptr。 为什么建议使用make_shared()函数我们已经看到了，shared_ptr内部维护了两个指针，如果你直接调用构造函数，就想这样： 12class Foo;auto sp = shared_ptr&lt;Widget&gt;(new Foo()); 这里实际分配了两次内存，第一次是调用new Foo()的时候，第二次则是在shared_ptr构造函数的内部构造_Sp_counted_base的时候。分配内存是很昂贵的操作，所以标准库提供了make_shared()函数，让你一次分配全部所需的内存： 12345678template&lt;typename _Tp, _Lock_policy _Lp, typename... _Args&gt;inline __shared_ptr&lt;_Tp, _Lp&gt;__make_shared(_Args&amp;&amp;... __args)&#123; typedef typename std::remove_const&lt;_Tp&gt;::type _Tp_nc; return std::__allocate_shared&lt;_Tp, _Lp&gt; (std::allocator&lt;_Tp_nc&gt;(), std::forward&lt;_Args&gt;(__args)...);&#125; 现在用make_shared()的话，可以一次分配一块足够大的内存，供Foo和_Sp_counted_base对象容身。 智能指针的线程安全性分析 同一个的shared_ptr对象可以被多个线程同时读取（只读） 对同一个对象的并发读，显然是线程安全的。 不同的shared_ptr对象可以被多个线程同时读写 如果这不同的shared_ptr对象管理的是不同的对象资源，显然并发读写是线程安全的。 若它们指向的是同一个对象，这需要它们共同维护一份在堆上的引用计数资源。而shared_ptr对象对于这份引用计数资源的读写使用了原子性操作，因此，也是线程安全的。 容易出现问题的是，从shared_ptr构造weak_ptr或者从weak_ptr构造shared_ptr的情况。 从shared_ptr构造weak_ptr 由于weak_ptr的构造过程中并不涉及引用计数资源的改变（实际上不改变的是shared_ptr对象计数变量_M_use_count_，只是改变了weak_ptr对象计数变量_M_weak_count），和前面的分析一样，使用了原子操作，也是线程安全的。 从weak_ptr构造shared_ptr 而这一过程，会改变引用计数资源（增加shared_ptr对象计数变量_M_use_count），但是实际上也实现了线程安全的修改。可以去参考源码的实现。 同一个shared_ptr对象不可以被多个线程同时读写（有写） shared_ptr&lt;Foo&gt;包含两个成员，一个是指向Foo的指针_M_ptr，另一个是_Sp_counted_base*指针，指向堆上的_Sp_counted_base对象。因为这两个数据成员读写操作不是原子化，所以使用多个线程读写同一个shared_ptr对象需要加锁，也就是说不是线程安全的。 自己动手实现一个基本的shared_ptr123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309#include &lt;iostream&gt;#include &lt;functional&gt;template &lt;class T&gt;class Deleter&#123;public: using DefaultFunc = std::function&lt;void(T *)&gt;; Deleter() : func_(std::bind(&amp;Deleter::defaultFunc, this, std::placeholders::_1)) &#123; std::cout &lt;&lt; \"Deleter::Deleter()\" &lt;&lt; std::endl; &#125; template &lt;class D&gt; Deleter(D func) : func_(func) &#123; std::cout &lt;&lt; \"Deleter::Deleter(D func)\" &lt;&lt; std::endl; &#125; void operator()(T *p) &#123; func_(p); &#125;private: DefaultFunc func_; void defaultFunc(T *p) &#123; std::cout &lt;&lt; \"Deleter::defaultFunc\" &lt;&lt; std::endl; delete p; &#125;&#125;;template &lt;class T&gt;class Ref_count_base&#123;private: T *ptr_; int count_; Deleter&lt;T&gt; deleter_;public: Ref_count_base(T *p) : ptr_(p), count_(1) &#123; std::cout &lt;&lt; \"Ref_count_base::Ref_count_base(T *p)\" &lt;&lt; std::endl; &#125; template &lt;class D&gt; Ref_count_base(T *p, D deleter) : ptr_(p), count_(1), deleter_(deleter) &#123; std::cout &lt;&lt; \"Ref_count_base::Ref_count_base(T *p, D deleter)\" &lt;&lt; std::endl; &#125; ~Ref_count_base() &#123; std::cout &lt;&lt; \"Ref_count_base::~Ref_count_base()\" &lt;&lt; std::endl; deleter_(ptr_); &#125; int increase() &#123; return count_++; &#125; int reduce() &#123; return --count_; &#125; int getCount() &#123; return count_; &#125;&#125;;template &lt;class T&gt;class Shared_ptr&#123;private: T *ptr_; Ref_count_base&lt;T&gt; *ref_count_;public: Shared_ptr() : ptr_(nullptr), ref_count_(nullptr) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr()\" &lt;&lt; std::endl; &#125; explicit Shared_ptr(std::nullptr_t) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr(std::nullptr_t)\" &lt;&lt; std::endl; Shared_ptr&lt;T&gt; temp; swap(temp); &#125; explicit Shared_ptr(T *p) : ptr_(p), ref_count_(new Ref_count_base&lt;T&gt;(p)) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr(T *p)\" &lt;&lt; std::endl; &#125; template &lt;class D&gt; explicit Shared_ptr(T *p, D deleter) : ptr_(p), ref_count_(new Ref_count_base&lt;T&gt;(p, deleter)) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr(T *p, D deleter)\" &lt;&lt; std::endl; &#125; ~Shared_ptr() &#123; std::cout &lt;&lt; \"Shared_ptr::~Shared_ptr()\" &lt;&lt; std::endl; if (ref_count_ &amp;&amp; ref_count_-&gt;reduce() == 0) delete ref_count_; &#125; Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp) : ptr_(sp.ptr_), ref_count_(sp.ref_count_) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp)\" &lt;&lt; std::endl; if (ref_count_) ref_count_-&gt;increase(); &#125; Shared_ptr &amp;operator=(const Shared_ptr&lt;T&gt; &amp;sp) &#123; std::cout &lt;&lt; \"Shared_ptr::operator=(const Shared_ptr&lt;T&gt; &amp;sp)\" &lt;&lt; std::endl; Shared_ptr&lt;T&gt; temp(sp); swap(temp); return *this; &#125; Shared_ptr &amp;operator=(std::nullptr_t) &#123; std::cout &lt;&lt; \"Shared_ptr::operator=(std::nullptr_t)\" &lt;&lt; std::endl; Shared_ptr&lt;T&gt; temp; swap(temp); return *this; &#125; T &amp;operator*() &#123; if (ptr_) return *ptr_; &#125; T *operator-&gt;() &#123; if (ptr_) return ptr_; &#125; T &amp;operator[](ptrdiff_t i) &#123; return ptr_[i]; &#125; bool operator==(Shared_ptr&lt;T&gt; &amp;rhs) const &#123; return ptr_ == rhs.ptr_; &#125; operator bool() const &#123; return ptr_ != nullptr; &#125; T *get() const &#123; return ptr_; &#125; int use_count() const &#123; if (ref_count_) return ref_count_-&gt;getCount(); return 0; &#125; void swap(Shared_ptr&lt;T&gt; &amp;sp) &#123; std::cout &lt;&lt; \"Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)\" &lt;&lt; std::endl; using std::swap; swap(ptr_, sp.ptr_); swap(ref_count_, sp.ref_count_); &#125;&#125;;template &lt;class T&gt;void swap(Shared_ptr&lt;T&gt; &amp;lhs, Shared_ptr&lt;T&gt; &amp;rhs)&#123; lhs.swap(rhs);&#125;/* 以下是测试代码 *//* 以下是测试代码 *//* 以下是测试代码 */class Point&#123;public: explicit Point(int i = 0) : val(i) &#123; std::cout &lt;&lt; \"Point(int i = 0)\" &lt;&lt; std::endl; &#125; ~Point() &#123; std::cout &lt;&lt; \"~Point()\" &lt;&lt; std::endl; &#125; Point &amp;operator=(int i) &#123; std::cout &lt;&lt; \"Point::operator=(int i)\" &lt;&lt; std::endl; val = i; return *this; &#125; int getVal() const &#123; return val; &#125;private: int val;&#125;;class myDeleter1&#123;public: void operator()(Point *p) &#123; delete[] p; &#125;&#125;;void myDeleter2(Point *p)&#123; std::cout &lt;&lt; \"myDeleter2(Point *p)\" &lt;&lt; std::endl; delete[] p;&#125;auto myDeleter3 = [](Point *p) &#123; delete[] p; &#125;;int main()&#123; Shared_ptr&lt;Point&gt; p1(new Point[2], myDeleter3); std::cout &lt;&lt; p1[0].getVal() &lt;&lt; std::endl; p1[0] = 10; std::cout &lt;&lt; p1[0].getVal() &lt;&lt; std::endl; std::cout &lt;&lt; \"p1.use_count: \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; Shared_ptr&lt;Point&gt; p2 = p1; Shared_ptr&lt;Point&gt; p3; p3 = p2; std::cout &lt;&lt; \"p1.use_count: \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"p2.use_count: \" &lt;&lt; p2.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"p3.use_count: \" &lt;&lt; p3.use_count() &lt;&lt; std::endl; if (p1 == p2) std::cout &lt;&lt; \"p1 == p2\" &lt;&lt; std::endl; else std::cout &lt;&lt; \"p1 != p2\" &lt;&lt; std::endl; if (p1) std::cout &lt;&lt; \"p1 为真\" &lt;&lt; std::endl; p1 = nullptr; if (!p1) std::cout &lt;&lt; \"p1 为假\" &lt;&lt; std::endl; std::cout &lt;&lt; \"p1.use_count: \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"p2.use_count: \" &lt;&lt; p2.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"p3.use_count: \" &lt;&lt; p3.use_count() &lt;&lt; std::endl; return 0;&#125;// 运行结果为Point::Point(int i = 0)Point::Point(int i = 0)Deleter::Deleter(D func)Ref_count_base::Ref_count_base(T *p, D deleter)Shared_ptr::Shared_ptr(T *p, D deleter)0Point::operator=(int i)10p1.use_count: 1Shared_ptr::Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::Shared_ptr()Shared_ptr::operator=(const Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::~Shared_ptr()p1.use_count: 3p2.use_count: 3p3.use_count: 3p1 == p2p1 为真Shared_ptr::operator=(std::nullptr_t)Shared_ptr::Shared_ptr()Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::~Shared_ptr()p1 为假p1.use_count: 0p2.use_count: 2p3.use_count: 2Shared_ptr::~Shared_ptr()Shared_ptr::~Shared_ptr()Ref_count_base::~Ref_count_base()Point::~Point()Point::~Point()Shared_ptr::~Shared_ptr() 智能指针使用注意事项 尽量用make_shared/make_unique std::shared_ptr在实现的时候使用的ref count技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行std::shared_ptr&lt;Widget&gt; p2(new Widget)的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而std::make_shared&lt;Widget&gt;()则是只执行一次内存申请，将数据和控制块的申请放到一起。 不要使用相同的内置指针来初始化（或者reset）多个智能指针 不要delete get()返回的指针 不要用get()初始化或reset另一个智能指针 智能指针管理的资源它只会默认删除new分配的内存，如果不是new分配的则要传递给其一个删除器 以下代码试图将malloc产生的动态内存交给shared_ptr管理，显然是有问题的，所以我们需要自定义删除器传递给shared_ptr。 12345678910// 错误的&#123; int* pi = (int*)malloc(4 * sizeof(int)); shared_ptr&lt;int&gt; sp(pi);&#125;// 正确的&#123; int* pi = (int*)malloc(4 * sizeof(int)); shared_ptr&lt;int&gt; sp(pi， [](int* p)&#123; free(p); &#125;);&#125; 不要把一个原生指针给多个shared_ptr或者多个unique_ptr管理 在使用原生指针对智能指针初始化的时候，智能指针对象都视原生指针为自己管理的资源。换句话意思就说：初始化多个智能指针之后，这些智能指针都担负起释放内存的作用。那么就会导致该原生指针会被释放多次！！ 1234// p1, p2 析构的时候都会释放 ptr, 同一内存被释放多次!int* ptr = new int;shared_ptr&lt;int&gt; p1(ptr);shared_ptr&lt;int&gt; p2(ptr);","tags":[{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"C++重要知识点详细解读之排序算法实现及效率分析","date":"2021-02-13T13:35:42.000Z","path":"cuQpjpPOQ0qnpSE2/","text":"快速排序 归并排序 计数排序 堆排序 排序算法实现及效率分析 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 洗牌算法void shuffle(vector&lt;int&gt; &amp;nums)&#123; int n = nums.size(); for (int i = 0 ; i &lt; n; i++) &#123; int j = rand() % ((n - 1) - i + 1) + i; // 返回 [i, n - 1] 内的随机数 swap(nums[i], nums[j]); &#125;&#125;/* 左闭右闭区间, 以首元素作为轴点 */// 版本一, 数据结构视频 9.1.5 节// int partition(std::vector&lt;int&gt; &amp;nums, int lo, int hi)// &#123;// // 随机置乱数组// shuffle(nums.begin(), nums.end(), default_random_engine(time(nullptr)));// int pivot = nums[lo];// while (lo &lt; hi)// &#123;// while (lo &lt; hi &amp;&amp; (pivot &lt;= nums[hi])) hi--;// nums[lo] = nums[hi]; // while (lo &lt; hi &amp;&amp; (nums[lo] &lt;= pivot)) lo++;// nums[hi] = nums[lo];// &#125;// nums[lo] = pivot;// return lo;// &#125;// 版本二, 算法 4 书籍int partition(std::vector&lt;int&gt; &amp;nums, int lo, int hi)&#123; // 随机置乱数组 shuffle(nums.begin(), nums.end(), default_random_engine(time(nullptr))); int i = lo; int j = hi + 1; while (1) &#123; while (nums[++i] &lt; nums[lo]) if (i == hi) break; while (nums[lo] &lt; nums[--j]) if (j == lo) break; if (j &lt;= i) break; std::swap(nums[i], nums[j]); &#125; std::swap(nums[lo], nums[j]); return j;&#125;// 版本三, 数据结构视频 9.3.4 节int partition(std::vector&lt;int&gt; &amp;nums, int lo, int hi)&#123; // 随机置乱数组 shuffle(nums.begin(), nums.end(), default_random_engine(time(nullptr))); int i = lo; int j = lo; while (++j &lt;= hi) if (nums[j] &lt; nums[lo]) std::swap(nums[++i], nums[j]); std::swap(nums[lo], nums[i]); return i;&#125;// 左闭右闭区间void quickSort(std::vector&lt;int&gt; &amp;nums, int lo, int hi)&#123; if (lo &gt;= hi) return; int pivot = partition(nums, lo, hi); quickSort(nums, lo, pivot - 1); quickSort(nums, pivot + 1, hi);&#125;void quickSort(std::vector&lt;int&gt; &amp;nums)&#123; quickSort(nums, 0, nums.size() - 1);&#125; 归并排序（Top-down Approach）12345678910111213141516171819202122232425262728293031323334353637383940414243// 注意以下的 vector 参数传的都是引用// 左闭右闭区间// [lo, mi] 和 [mi + 1, hi] 分别是有序的void merge(vector&lt;int&gt; &amp;nums, int lo, int mi, int hi)&#123; // 辅助空间, 存储 [mi + 1, hi] 元素 vector&lt;int&gt; helper(nums.begin() + mi + 1, nums.begin() + hi + 1); // 对两个数组中的元素, 依次从后向前比较 // 从后向前放置元素, 先放较大者 int i = mi; int j = helper.size() - 1; int k = hi; // 注意 i 的终止条件 while (i &gt;= lo &amp;&amp; j &gt;= 0) // 注意, 这里如果是 &gt;= 就不稳定了 if (nums[i] &gt; helper[j]) nums[k--] = nums[i--]; else nums[k--] = helper[j--]; while (j &gt;= 0) nums[k--] = helper[j--];&#125;// 左闭右闭区间void mergeSort(vector&lt;int&gt; &amp;nums, int lo, int hi)&#123; // 单元素自动有序 if (hi - lo &lt; 1) return; int mi = lo + (hi - lo) / 2; mergeSort(nums, lo, mi); mergeSort(nums, mi + 1, hi); merge(nums, lo, mi, hi);&#125;// 左闭右闭区间void mergeSort(vector&lt;int&gt; &amp;nums)&#123; // 排序 [0, nums.size()) 之间的元素 mergeSort(nums, 0, nums.size() - 1);&#125; 归并排序（Bottom-up Approach）12345678910111213141516171819202122232425262728293031323334353637// 左闭右闭区间// [lo, mi] 和 [mi + 1, hi] 分别是有序的void merge(vector&lt;int&gt; &amp;nums, int lo, int mi, int hi)&#123; // 辅助空间, 存储 [mi + 1, hi] 元素 vector&lt;int&gt; helper(nums.begin() + mi + 1, nums.begin() + hi + 1); // 对两个数组中的元素, 依次从后向前比较 // 从后向前放置元素, 先放较大者 int i = mi; int j = helper.size() - 1; int k = hi; // 注意 i 的终止条件 while (i &gt;= lo &amp;&amp; j &gt;= 0) if (nums[i] &gt; helper[j]) nums[k--] = nums[i--]; else nums[k--] = helper[j--]; while (j &gt;= 0) nums[k--] = helper[j--];&#125;void mergeSort(vector&lt;int&gt;&amp; nums)&#123; int sz = nums.size(); // 中间节点相对于起点的位置是 1 个 step // 终点相对于起点是 2 个 step // step 从 1 开始直到等于数组的长度 sz for(int step = 1; step &lt;= sz; step *= 2) // 注意, 这里 lo 从 0 开始直到等于 sz - 1 for(int lo = 0; lo &lt; sz; lo += 2 * step) // 因为 merge 函数实现的原因, 都是闭区间, 而且 [lo, mi] 和 [mi + 1, hi] 分别是有序的 // 所以这里求出的 mi 和 hi 都需要减 1 merge(nums, lo, min(lo + step - 1, sz - 1), min(lo + 2 * step - 1, sz - 1)); return nums;&#125; 计数排序 计数排序要求待排序的n个元素的大小在[0, k]之间，并且k与n在一个数量级上，即k = O(n)，此时使用计数排序可以把时间复杂度降到O(n)上； 计数排序不是基于比较的排序算法，它基于计数策略； 写计数排序算法时，应该把它写成稳定排序的； 计数排序还是原址排序，但需要借助额外的内存空间； 123456789101112131415161718192021222324252627282930313233// 找出待排序的数组中最大的元素 maxVal 和最小元素 minVal// 统计数组中每个值为 val 的元素出现的次数, 存入数组 count 的第 val - minVal 项// 对所有的计数累加, 从 count 中的第一个元素开始, 每一项和前一项相加// 反向填充目标数组: 将每个元素 val 放在新数组的第 count(val - minVal) 项// 每放一个元素就将 count(val - minVal) 减去 1void CountSort(vector&lt;int&gt; &amp;nums)&#123; int minVal = *min_element(nums.begin(), nums.end()); int maxVal = *max_element(nums.begin(), nums.end()); int valRange = maxVal - minVal; // 注意: 这个数组的大小为 valRange + 1, 用于统计 [0, valRange]范围内的元素 vector&lt;int&gt; count(valRange + 1, 0); // 统计待排序数组中每一个元素的个数 for (auto x : nums) count[x - minVal]++; // 此处计算待排序数组中小于等于第i个元素的个数 for (int i = 1; i &lt;= valRange; ++i) count[i] += count[i - 1]; // 把待排序的数组放到输出数组中, 为了保持排序的稳定性, 从后向前添加元素 vector&lt;int&gt; backup(nums); for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; int index = count[backup[i] - minVal] - 1; nums[index] = backup[i]; // 因为可能有重复的元素, 所以要减 1, 为下一个重复的元素计算正确的下标 count[backup[i] - minVal]--; &#125;&#125; 堆排序秩为i的元素，其父节点若存在，其秩必为(i - 1) / 2；其左孩子若存在，其秩必为2 * i + 1；其右孩子若存在，其秩必为左孩子秩加1。 下滤：将首元素依次和其孩子中较大者交换。上滤：将末元素依次和其父亲交换。时间复杂度均为O(logn)。 批量建堆：可以是所有的内部节点，自右往左依次下滤（复杂度正比于所有下滤节点的高度），或者是末元素依次上滤（复杂度是正比于所有上滤节点的深度），相比之下，前者的时间复杂度为O(n)，后者时间复杂度为O(nlogn)。第一个内部节点其实就是末元素的父亲，之后的内部节点依次递减即可。 堆排序：先执行批量建堆操作，时间复杂度为O(n)，然后进行n次取最大值操作，时间复杂度为O(nlogn)。具体实现可以是建完堆后，反复进行将首元素和未排序的末元素交换，然后对首元素进行下滤的操作。总体时间复杂度为O(n) + O(nlogn) = O(nlogn)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define P(i) ((i - 1) / 2)#define LC(i) ((2 * i) + 1)#define RC(i) (LC(i) + 1)#define INHEAP(i, n) ((i &gt;= 0) &amp;&amp; (i &lt; n))#define HASLC(i, n) INHEAP(LC(i), n)#define HASRC(i, n) INHEAP(RC(i), n)// 找出元素 i 和其左右孩子之间最大值, 返回其索引int maxPC(const vector&lt;int&gt; &amp;nums, int n, int i)&#123; int res = i; if (HASLC(i, n) &amp;&amp; nums[res] &lt; nums[LC(i)]) res = LC(i); if (HASRC(i, n) &amp;&amp; nums[res] &lt; nums[RC(i)]) res = RC(i); return res;&#125;// 参数 n 代表数组的尾元素的下一个位置, 用于验证待下滤元素 i 的左右孩子节点的合法性void downFilter(vector&lt;int&gt; &amp;nums, int n, int i)&#123; int j; // 依次检测元素 i 是否需要下滤 // 如果和其孩子间的最大元素还是它自己, 则不需要下滤 while (i != (j = maxPC(nums, n, i))) &#123; // 否则, 和较大孩子交换位置 std::swap(nums[i], nums[j]); i = j; // 产生新的待下滤元素 &#125;&#125;void heapSort(vector&lt;int&gt; &amp;nums)&#123; int sz = nums.size(); int i = P(sz - 1); // 获取末元素的父亲, 也就是最后一个内部节点 // 建堆操作, 复杂度为 O(n) while (i &gt;= 0) downFilter(nums, sz, i--); // 从最后一个内部节点自后向前 依次下滤 // 此时最大元素是首元素 for (int i = sz - 1; i &gt; 0; i--) &#123; std::swap(nums[0], nums[i]); // 首尾交换, 末元素就位 downFilter(nums, i, 0); // 将新首元素下滤 // 依次缩短未排序数组的长度 &#125;&#125;","tags":[{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"C++重要知识点详细解读之移动语义","date":"2021-02-10T13:35:42.000Z","path":"63ixVU2ANYIUKUrm/","text":"解释右值引用和左值引用的区别 移动构造函数和移动赋值运算符 理解std::move和std::forward 解释右值引用和左值引用的区别所谓右值引用就是必须绑定到右值的引用，通过&amp;&amp;获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。左值引用，不能绑定到要转换的表达式、字面常量或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。 返回左值的表达式包括返回左值引用的函数及赋值、下标、解引用和前置递增/递减运算符，返回右值的表达式包括返回非引用类型的函数及算术、关系、位和后置递增/递减运算符。可以看到，左值的特点是有持久的状态，而右值则是短暂的。 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。 函数参数和其它任何变量一样，都是左值表达式。 移动构造函数和移动赋值运算符参见C++ primer 13.6。 与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcept。 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。 移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。 类似拷贝构造函数和拷贝赋值运算符，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。如果有类成员是const的或是引用，则类的移动赋值运算符被定义为删除的。 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数：移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝（即，通过拷贝构造函数来“移动”）。 拷贝并交换赋值运算符和移动操作HasPtr类定义了一个拷贝并交换赋值运算符，如果为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符： 12345678910111213141516171819class HasPtr&#123;public: // 添加的移动构造函数 HasPtr(HasPtr &amp;&amp;p) noexcept : ps(p.ps), i(p.i) &#123; p.ps = 0; &#125; // 赋值运算符既是移动赋值运算符, 也是拷贝赋值运算符 HasPtr&amp; operator=(HasPtr&amp; rhs) &#123; HasPtr temp(rhs); // copy and swap(*this, temp); // swap return *this; &#125; // 其他成员的定义 ...&#125;; 在这个版本中，我们为类添加了一个移动构造函数，它接管了给定实参的值。构造函数体将给定的HasPtr的指针置为0，从而确保销毁移后源对象是安全的。此函数不会抛出异常，因此我们将其标记为noexcept。现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。假定hp和hp2都是HasPtr对象： 12hp = hp2; // hp2 是一个左值; hp2 通过拷贝构造函数来拷贝hp = std::move(hp2); // 移动构造函数移动 hp2 在第一个赋值中，右侧运算对象是一个左值，因此移动构造函数是不可行的。rhs将使用拷贝构造函数来初始化。拷贝构造函数将分配一个新string，并拷贝hp2指向的string。在第二个赋值中，我们调用std::move将一个右值引用绑定到hp2上。在此情况下，拷贝构造函数和移动构造函数都是可行的。但是，由于实参是一个右值引用，移动构造函数是精确匹配的。移动构造函数从hp2拷贝指针，而不会分配任何内存。不管使用的是拷贝构造函数还是移动构造函数，赋值运算符的函数体都swap两个运算对象的状态。交换HasPtr会交换两个对象的指针成员。在swap之后，rhs中的指针将指向原来左侧运算对象所拥有的string。当rhs离开其作用域时，这个string将被销毁。 理解std::move和std::forward参见C++ primer 16.2.6 &amp; 16.2.7。 调用std::move就意味着承诺：除了对移后源赋值或销毁外，我们将不再使用它。 标准库中std::move的实现123456template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)&#123; // 从一个左值 static_cast 到一个右值引用是允许的 return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);&#125; 其中，remove_reference模板有一个模板类型参数和一个名为type的（public）类型成员。如果我们用一个引用类型实例化remove_reference，则type将表示被引用的类型。例如，如果我们实例化remove_reference&lt;string&amp;&gt;，则type成员将是string。更一般的，给定一个迭代器beg： 1remove_reference&lt;decltype(*beg)&gt;::type 将获得beg引用的元素的类型：decltype(*beg)返回元素类型的引用类型。remove_reference::type脱去引用，剩下元素类型本身。 std::move是如何工作的123string s1(\"hi!\"), s2;s2 = std::move(string(\"bye!\")); // 正确: 从一个右值移动数据s2 = std::move(s1); // 正确: 但在赋值之后, s1的值是不确定的 在第一个赋值中，传递给move的实参是string的构造函数的右值结果——string(&quot;bye!&quot;)。因此，在std::move(string(&quot;bye!&quot;))中： 推断出的T的类型为string； 因此，remove_reference用string进行实例化； remove_reference&lt;string&gt;的type成员是string； move的返回类型是string&amp;&amp;； move的函数参数t的类型为string&amp;&amp;。 因此，这个调用实例化move&lt;string&gt;，即函数 1string&amp;&amp; move(string&amp;&amp; t) 函数体返回static_cast&lt;string&amp;&amp;&gt;(t)。t的类型已经是string&amp;&amp;，于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用。 现在考虑第二个赋值，它调用了std::move。在此调用中，传递给move的实参是一个左值。这样： 推断出的T的类型为string&amp;； 因此，remove_reference用string&amp;进行实例化； remove_reference&lt;string&amp;&gt;的type成员是string； move的返回类型仍是string&amp;&amp;； move的函数参数t实例化为string&amp;&amp; &amp;，会折叠为string&amp;。 因此，这个调用实例化move&lt;string&amp;&gt;，即 1string&amp;&amp; move(string&amp; t) 这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回static_cast&lt;string&amp;&amp;&gt;(t)。在此情况下，t的类型为string&amp;，static_cast将其转换为string&amp;&amp;。 标准库中std::forward的实现1234567891011template &lt;class T&gt;T&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp; t)&#123; return static_cast&lt;T&amp;&amp;&gt;(t);&#125;template &lt;class T&gt;T&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp;&amp; t)&#123; return static_cast&lt;T&amp;&amp;&gt;(t);&#125; std::forward&lt;T&gt;的返回类型是T&amp;&amp;。通常情况下，使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值/右值以及const属性： 12345template&lt;typename T&gt;void func(T&amp;&amp; t)&#123; // 在这里使用 std::forward&lt;T&gt;(t)&#125; 如果实参t是一个右值，则T被推断为一个普通（非引用）类型，std::forward&lt;T&gt;将返回T&amp;&amp;。如果实参是一个左值，则通过引用折叠，T被推断为一个左值引用类型。在此情况下，std::forward&lt;T&gt;返回类型是一个指向左值引用类型的右值引用T&amp;&amp; &amp;，再次引用折叠，将返回一个左值引用类型T&amp;。 注意：不能使用一个左值实例化一个右值引用类型的函数参数。函数参数和其它任何变量一样，在函数体内都是左值表达式。","tags":[{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"leetcode刷题系列之二叉树","date":"2021-02-08T13:35:42.000Z","path":"B90hHtDrYEYJD3xv/","text":"这篇文章是leetcode刷题系列的第4部分——二叉树。这里把有代表性的题目发出来，共计35道。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少200道！ Binary tree114. Binary Tree Preorder Traversal 二叉树的前序遍历。 123456789101112131415161718192021// 迭代实现vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; res; nodes.push(root); while(!nodes.empty()) &#123; TreeNode* node = nodes.top(); nodes.pop(); while(node) &#123; res.push_back(node-&gt;val); if(node-&gt;right) nodes.push(node-&gt;right); node = node-&gt;left; &#125; &#125; return res;&#125; 94. Binary Tree Inorder Traversal 二叉树的中序遍历。 123456789101112131415161718192021222324vector&lt;int&gt; inorderTraversal(TreeNode* root)&#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; res; while(1) &#123; while(root) &#123; nodes.push(root); root = root-&gt;left; &#125; if(nodes.empty()) break; root = nodes.top(); res.push_back(root-&gt;val); nodes.pop(); root = root-&gt;right; &#125; return res;&#125; 145. Binary Tree Postorder Traversal 二叉树的后序遍历。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 此解法借鉴中序遍历的思路vector&lt;int&gt; postorderTraversal(TreeNode* root)&#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; res; TreeNode* preVisited = nullptr; while(1) &#123; while(root) &#123; nodes.push(root); root = root-&gt;left; &#125; if(nodes.empty()) break; root = nodes.top(); if(!root-&gt;right || root-&gt;right == preVisited) &#123; // 如果待访问节点没有右孩子或者右孩子刚才访问过 // 就访问 preVisited = root; res.push_back(root-&gt;val); nodes.pop(); // 这是为了跳过下次的 while(root) 循环 root = nullptr; // 下一个待访问节点一定是刚刚访问节点的父节点 &#125; else &#123; // 如果待访问节点有右孩子并且右孩子上次没有访问过 // 就不访问, 去右孩子 root = root-&gt;right; &#125; &#125; return res;&#125;// 此解法借鉴前序遍历的思路vector&lt;int&gt; postorderTraversal(TreeNode* root)&#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; res; nodes.push(root); while(!nodes.empty()) &#123; TreeNode* node = nodes.top(); nodes.pop(); while(node) &#123; res.push_back(node-&gt;val); // 和前序遍历相反的顺序访问左右子树 if(node-&gt;left) nodes.push(node-&gt;left); node = node-&gt;right; &#125; &#125; // 最后, 逆序输出就和后序遍历一样 reverse(res.begin(), res.end()); return res;&#125; 102. Binary Tree Level Order Traversal 二叉树的层序遍历。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 使用队列迭代实现vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)&#123; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; nodes; if(root) nodes.push(root); while(!nodes.empty()) &#123; vector&lt;int&gt; subVector; int count = nodes.size(); while(count--) &#123; root = nodes.front(); nodes.pop(); if(root-&gt;left) nodes.push(root-&gt;left); if(root-&gt;right) nodes.push(root-&gt;right); subVector.push_back(root-&gt;val); &#125; res.push_back(subVector); &#125; return res;&#125;// 借助前序遍历的思想, 递归实现vector&lt;vector&lt;int&gt;&gt; res;vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)&#123; helper(root, 0); return res;&#125;// 每次递归的时候提供被遍历节点的层级信息void helper(TreeNode* root, int level)&#123; if(!root) return; if (level &gt;= res.size()) res.push_back(vector&lt;int&gt;()); res[level].push_back(root-&gt;val); helper(root-&gt;left, level + 1); helper(root-&gt;right, level + 1);&#125; 104. Maximum Depth of Binary Tree 给定二叉树的根，返回其最大深度。二叉树的最大深度是指沿着从根节点到最远的叶节点的最长路径的节点数。 Example: 12Input: root &#x3D; [3,9,20,null,null,15,7]Output: 3 12345678910111213141516171819202122// 自底向上递归int maxDepth(TreeNode* root)&#123; if(!root) return 0; return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));&#125;// 自上到下递归int res = 0;int maxDepth(TreeNode* root)&#123; helper(root, 1); return res;&#125;// 每次递归时传递被访问节点的深度信息void helper(TreeNode* root, int depth)&#123; if(!root) return; res = max(res, depth); helper(root-&gt;left, 1 + depth); helper(root-&gt;right, 1 + depth);&#125; 111. Minimum Depth of Binary Tree 给定二叉树的根，返回其最小深度。二叉树的最小深度是指沿着从根节点到最近的叶节点的最短路径的节点数。 123456789101112131415161718192021222324252627282930313233// 递归解法int minDepth(TreeNode* root)&#123; if(!root) return 0; int leftMinDepth = minDepth(root-&gt;left); int rightMinDepth = minDepth(root-&gt;right); if(leftMinDepth == 0) return 1 + rightMinDepth; if(rightMinDepth == 0) return 1 + leftMinDepth; return 1 + min(leftMinDepth, rightMinDepth);&#125;// BFS 迭代解法int minDepth(TreeNode* root)&#123; queue&lt;TreeNode*&gt; q; if(root) q.push(root); int step = 0; while(!q.empty()) &#123; int sz = q.size(); while(sz--) &#123; TreeNode* node = q.front(); q.pop(); if(!node-&gt;left &amp;&amp; !node-&gt;right) return step + 1; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; step++; &#125; return step;&#125; 112. Path Sum 给定二叉树的根和一个整数targetSum，如果树具有从根到叶的路径，则沿路径的所有值加起来等于targetSum，则返回true。 Example: 12Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22Output: true 1234567891011121314151617// 自顶向下递归bool hasPathSum(TreeNode* root, int targetSum)&#123; if(!root) return false; return helper(root, targetSum);&#125;bool helper(TreeNode* root, int target)&#123; // is leaf and ... if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == root-&gt;val) return true; if(root-&gt;left &amp;&amp; helper(root-&gt;left, target - root-&gt;val)) return true; if(root-&gt;right &amp;&amp; helper(root-&gt;right, target - root-&gt;val)) return true; return false;&#125; 113. Path Sum II 给定二叉树的根和一个整数targetSum，返回所有从根到叶的路径，其中每个路径的和等于targetSum。 Constraints: The number of nodes in the tree is in the range[0, 5000]. -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 Example: 12Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22Output: [[5,4,11,2],[5,8,4,5]] 12345678910111213141516171819202122232425262728293031323334353637383940414243// dfsvector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum)&#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; target; dfs(res, target, root, targetSum); return res;&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; target, TreeNode* root, int targetSum)&#123; // base case if(!root) return; // 如果是叶子节点 if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; // 如果此叶子节点满足 if(targetSum == root-&gt;val) &#123; target.push_back(root-&gt;val); res.push_back(target); target.pop_back(); &#125; return; &#125; // 做选择 target.push_back(root-&gt;val); // 状态转移 dfs(res, target, root-&gt;left, targetSum - root-&gt;val); // 撤销选择 // target.pop_back(); // 做选择 // target.push_back(root-&gt;val); // 状态转移 dfs(res, target, root-&gt;right, targetSum - root-&gt;val); // 撤销选择 target.pop_back();&#125; 437. Path Sum III 你将获得一棵二叉树，其中每个节点都包含一个整数值。查找路径中节点值总和为给定值的路径数。 该路径无需在根或叶处开始或结束，但必须向下（仅从父节点到子节点移动）。 Example: 123456789101112131415root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8 10 &#x2F; \\ 5 -3 &#x2F; \\ \\ 3 2 11&#x2F; \\ \\3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 12345678910111213141516171819202122232425262728// recursiveint pathSum(TreeNode* root, int sum)&#123; if(!root) return 0; // 等于以从 root 开始的子路径 + ... return rootPathSum(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);&#125;// dfs 求解以从 root 开始的子路径int rootPathSum(TreeNode* root, int targetSum)&#123; int res = 0; dfs(root, targetSum, res); return res;&#125;void dfs(TreeNode* root, int targetSum, int&amp; res)&#123; if(!root) return; // 和上一题 II 不同了 // 不必等到是叶子节点 // 只要中间有满足的, 直接增加计数 if(targetSum == root-&gt;val) res++; // 做选择和撤销选择一起了 // 进入函数自动做选择 // 出函数自动撤销选择 dfs(root-&gt;left, targetSum - root-&gt;val, res); dfs(root-&gt;right, targetSum - root-&gt;val, res);&#125; 666. Path Sum IV 对于一棵深度小于5的树，可以用一组三位十进制整数来表示。 对于每个整数： 百位上的数字表示这个节点的深度D，1 &lt;= D &lt;= 4。十位上的数字表示这个节点在当前层所在的位置P，1 &lt;= P &lt;= 8。位置编号与一棵满二叉树的位置编号相同。个位上的数字表示这个节点的权值V，0 &lt;= V &lt;= 9。给定一个包含三位整数的升序数组，表示一棵深度小于5的二叉树，请你返回从根到所有叶子结点的路径之和。 示例 1： 123456789输入: [113, 215, 221]输出: 12解释: 这棵树形状如下: 3&#x2F; \\5 1路径和 &#x3D; (3 + 5) + (3 + 1) &#x3D; 12. 示例 2： 123456789输入: [113, 221]输出: 4解释: 这棵树形状如下: 3 \\ 1路径和 &#x3D; (3 + 1) &#x3D; 4. 12345678910111213141516171819202122232425262728293031323334// 类似于堆排序中将完全二叉树存储在一个向量的思路// 借助一个哈希表来记录二叉树的每个节点在向量中的索引和其权重的映射// 每个节点的索引可通过其深度和位置计算出来// 公式为 i = 2 ^ (depth - 1) + position - 1// 比如, 根节点 112, depth = 1, position = 1, i = 2 ^ (1 - 1) + 1 - 1 = 1// 某节点 346, depth = 3, position = 4, i = 2 ^ (3 - 1) + 4 - 1 = 7// 这样表示之后, 索引为 i 的节点// 其左孩子索引为 2 * i, 右孩子索引为 2 * i + 1int res = 0;int pathSum(vector&lt;int&gt;&amp; nums)&#123; unordered_map&lt;int, int&gt; mapping; for(int num : nums) &#123; int depth = num / 100; int position = num % 100 / 10; int weight = num % 10; mapping[pow(2, depth - 1) + position - 1] = weight; &#125; dfs(mapping, 1, 0); return res;&#125;void dfs(unordered_map&lt;int, int&gt;&amp; mapping, int i, int sum)&#123; if(!mapping.count(i)) return; // 到达叶子节点 if(!mapping.count(2 * i) &amp;&amp; !mapping.count(2 * i + 1)) res = res + sum + mapping[i]; // 去左子树 dfs(mapping, 2 * i, sum + mapping[i]); // 去右子树 dfs(mapping, 2 * i + 1, sum + mapping[i]);&#125; 129. Sum Root to Leaf Numbers 你将获得只包含0到9的数字的二叉树的根。树中的每条从根到叶的路径都代表一个数字。 例如，从根到叶的路径1 -&gt; 2 -&gt; 3表示数字123。返回所有从根到叶的数字的总和。 Constraints: The number of nodes in the tree is in the range[1, 1000]. 0 &lt;= Node.val &lt;= 9. The depth of the tree will not exceed 10. Example: 1234567Input: root &#x3D; [4,9,0,5,1]Output: 1026Explanation:The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.The root-to-leaf path 4-&gt;0 represents the number 40.Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026. 123456789101112131415161718192021222324252627int sumNumbers(TreeNode* root)&#123; int res = 0; string sequence; dfs(sequence, root, res); return res;&#125;void dfs(string&amp; sequence, TreeNode* root, int&amp; res)&#123; if(!root) return; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; sequence.push_back(root-&gt;val + '0'); res += stoi(sequence); sequence.pop_back(); return; &#125; sequence.push_back(root-&gt;val + '0'); dfs(sequence, root-&gt;left, res); // sequence.pop_back(); // sequence.push_back(to_string(root-&gt;val)); dfs(sequence, root-&gt;right, res); sequence.pop_back();&#125; 124. Binary Tree Maximum Path Sum 二叉树中的路径是节点序列，其中序列中的每对相邻节点都有一条连接它们的边。 一个节点最多只能出现在序列中一次。 请注意，该路径不需要通过根。路径的路径总和是路径中节点值的总和。 给定二叉树的根，返回任何路径的最大路径总和。 Constraints: The number of nodes in the tree is in the range[1, 3 * 104]. -1000 &lt;= Node.val &lt;= 1000. Example: 123Input: root &#x3D; [-10,9,20,null,null,15,7]Output: 42Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 自顶向下递归// int maxPathSum(TreeNode* root)// &#123;// if(!root) return INT_MIN;// return max(rootMaxPathSum(root),// max(maxPathSum(root-&gt;left), maxPathSum(root-&gt;right)));// &#125;// // 该函数的定义是, 返回经过 root 的最大路径和// int rootMaxPathSum(TreeNode* root)// &#123;// int resLeft = 0, resRight = 0;// if(root-&gt;left) dfs(root-&gt;left, resLeft, 0);// if(root-&gt;right) dfs(root-&gt;right, resRight, 0);// return resLeft + resRight + root-&gt;val;// &#125;// // 此递归函数的定义是, 返回 [以 root 为首节点] 的最大路径和// void dfs(TreeNode* root, int&amp; res, int sum)// &#123;// if(!root) return;// res = max(res, sum + root-&gt;val);// dfs(root-&gt;left, res, sum + root-&gt;val);// dfs(root-&gt;right, res, sum + root-&gt;val);// &#125;// 自底向上的递归// 和上一种方法对比// 显然自底向上递归代码简单易懂效率高int maxPathSum(TreeNode* root)&#123; int res = INT_MIN; dfs(root, res); return res;&#125;// 递归函数的定义就是返回 [以 root 为首节点] 的最大路径和int dfs(TreeNode* root, int&amp; res)&#123; if(!root) return 0; // 如果以 left 或 right 为首节点的路径和为负数 // 就不加上它 // 这样就能保证返回的值是以 root 为首节点的最大路径和 // 就是说将 root 单节点看作一条路径 int leftMaxSum = max(0, dfs(root-&gt;left, res)); int rightMaxSum = max(0, dfs(root-&gt;right, res)); // 计算 [经过] root 的最大路径和 // 这样, 通过递归的过程, 保证会, 分别计算经过每一个节点的最大路径和 // 其中最大的就是答案 res = max(res, leftMaxSum + rightMaxSum + root-&gt;val); return root-&gt;val + max(leftMaxSum, rightMaxSum);&#125; 105. Construct Binary Tree from Preorder and Inorder Traversal 给定两个整数数组preorder和inorder，其中preorder是二叉树的前序遍历，而inorder是同一树的中序遍历，构造并返回二叉树。 123456789101112131415161718192021222324252627282930313233343536// 首先要知道前序遍历的首元素就是树的根// 其在中序遍历的位置的左边所有元素构成左子树// 右边所有元素构成右子树TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder)&#123; return build(inorder, preorder, 0, inorder.size() - 1, 0, preorder.size() - 1);&#125;TreeNode* build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; preorder, int inStart, int inEnd, int preStart, int preEnd)&#123; // base case if(inStart &gt; inEnd) return nullptr; int rootVal = preorder[preStart]; TreeNode* root = new TreeNode(rootVal); // 定位 rootVal 在中序遍历中的位置 // 一定存在 // 这里有一个特殊情况 inStart == inEnd // 出现这种情况 index 应该等于 inStart == inEnd // 递归基可以处理 int index = inStart; for(; index &lt;= inEnd; index++) if(inorder[index] == rootVal) break; // 计算左子树节点数量 int leftSize = index - inStart; root-&gt;left = build(inorder, preorder, inStart, index - 1, preStart + 1, preStart + leftSize); root-&gt;right = build(inorder, preorder, index + 1, inEnd, preStart + leftSize + 1, preEnd); return root;&#125; 106. Construct Binary Tree from Inorder and Postorder Traversal 给定两个整数数组postorder和inorder，其中postorder是二叉树的后序遍历，而inorder是同一树的中序遍历，构造并返回二叉树。 12345678910111213141516171819202122232425262728293031323334// 首先要知道后序遍历的尾元素就是树的根// 其在中序遍历的位置的左边所有元素构成左子树// 右边所有元素构成右子树TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder)&#123; return build(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);&#125;TreeNode* build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int inStart, int inEnd, int postStart, int postEnd)&#123; // base case if(inStart &gt; inEnd) return nullptr; // 后序遍历尾元素就是根 int rootVal = postorder[postEnd]; TreeNode* root = new TreeNode(rootVal); // 定位根在中序遍历中的位置 // 一定存在 // 这里有一个特殊情况 inStart == inEnd // 出现这种情况 index 应该等于 inStart == inEnd // 递归基可以处理 int index = inStart; for(; index &lt;= inEnd; index++) if(inorder[index] == rootVal) break; // 计算左子树的节点数 int leftSize = index - inStart; root-&gt;left = build(inorder, postorder, inStart, index - 1, postStart, postStart + leftSize - 1); root-&gt;right = build(inorder, postorder, index + 1, inEnd, postStart + leftSize, postEnd - 1); return root;&#125; 889. Construct Binary Tree from Preorder and Postorder Traversal 返回与给定的前序和后序遍历匹配的任意二叉树。二叉树中的值是不同的正整数。 123456789101112131415161718192021222324252627282930313233343536373839404142// 虽然有些情况不能确定一棵唯一的二叉树// 但我们决定左右子树的规则固定即可// 首先注意到前序遍历的首元素为树的根// 首元素的下一个元素可能为其左子树的根, 也可能为其右子树的根// 但我们始终把它认定为左子树的根// 接下来就是在后序遍历中定位到 前序遍历首元素的下一个元素 的位置// 这个位置左边的就是左子树所有元素 (包括这个位置上的元素, 实际上它是左子树的根)// 右边的就是右子树所有元素 (除了末元素, 因为它是当前树的根啊)TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post)&#123; return construct(pre, post, 0, pre.size() - 1, 0, post.size() - 1);&#125;TreeNode* construct(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post, int preStart, int preEnd, int postStart, int postEnd)&#123; // base case if(preStart &gt; preEnd) return nullptr; int rootVal = pre[preStart]; TreeNode* root = new TreeNode(rootVal); // 这个条件判断非常重要 // 如果 preStart == preEnd // 下面的 index 就会因为找不到而很大 为 postEnd // 导致错误地计算出很大的 leftSize // 递归基处理不了 if(preStart == preEnd) return root; // 定位到左子树的根在后序遍历中的位置 // 此时保证至少会有两个元素, 也就是说 pre[preStart + 1] 在后序遍历中一定存在 int index = postStart; for(; index &lt; postEnd; index++) if(post[index] == pre[preStart + 1]) break; int leftSize = index - postStart + 1; root-&gt;left = construct(pre, post, preStart + 1, preStart + leftSize, postStart, index); root-&gt;right = construct(pre, post, preStart + leftSize + 1, preEnd, index + 1, postEnd - 1); return root;&#125; 1008. Construct Binary Search Tree from Preorder Traversal 给定一个整数已排序数组，该数组表示二叉搜索树的前序遍历结果，请构造该BST树并返回其根。 可以确保始终可以找到满足测试用例要求的BST。 Constraints: 1 &lt;= preorder.length &lt;= 100. 1 &lt;= preorder[i] &lt;= 108. All the values of preorder are unique. Example: 12Input: preorder &#x3D; [8,5,1,7,10,12]Output: [8,5,10,1,7,null,12] 123456789101112131415161718192021222324252627282930// 首先可以确定前序遍历的首元素为树的根// 其左子树的所有元素都小于首元素// 其右子树的所有元素都大于首元素// 所以, 我们接下来只要确定数组中第一个大于首元素的值的位置// 就能够直到左子树和右子树的元素范围TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder)&#123; return build(preorder, 0, preorder.size() - 1);&#125;TreeNode* build(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd)&#123; // base case if(preStart &gt; preEnd) return nullptr; // 根为首元素 int rootVal = preorder[preStart]; TreeNode* root = new TreeNode(rootVal); // 找到第一个大于首元素的位置 int index = prepreStart + 1; for(; index &lt;= preEnd; index++) if(preorder[index] &gt; rootVal) break; // 到这里, 有两种情况 // 1. 左子树为空, 此时 index 应该为 prepreStart + 1 // 2. 右子树为空, 此时 index 应该为 preEnd + 1 // 无论哪一种情况, 递归进去之后, 递归基都可以处理 root-&gt;left = build(preorder, preStart + 1, index - 1); root-&gt;right = build(preorder, index, preEnd); return root;&#125; 117. Populating Next Right Pointers in Each Node II - LeetCode 填充二叉树的每个节点下一个指针以指向其下一个右节点。 如果没有下一个右节点，则下一个指针应设置为NULL。 最初，所有下一个指针都设置为NULL。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// struct Node// &#123;// int val;// Node *left;// Node *right;// Node *next;// &#125;// 使用辅助节点的迭代式解法Node* connect(Node* root)&#123; Node* cur = root; Node* helper = new Node(0, nullptr, nullptr, nullptr); while(cur) &#123; Node* p = helper; while(cur) &#123; if(cur-&gt;left) &#123; p-&gt;next = cur-&gt;left; p = p-&gt;next; &#125; if(cur-&gt;right) &#123; p-&gt;next = cur-&gt;right; p = p-&gt;next; &#125; cur = cur-&gt;next; &#125; cur = helper-&gt;next; helper-&gt;next = nullptr; &#125; delete helper; return root;&#125;// 使用队列的迭代式解法Node* connect(Node* root)&#123; Node* p = root; queue&lt;Node*&gt; nodes; if(root) nodes.push(root); while(!nodes.empty()) &#123; int count = nodes.size(); while(count--) &#123; root = nodes.front(); nodes.pop(); if(count == 0) root-&gt;next = nullptr; else root-&gt;next = nodes.front(); if(root-&gt;left) nodes.push(root-&gt;left); if(root-&gt;right) nodes.push(root-&gt;right); &#125; &#125; return p;&#125; 如果给定的二叉树是棵完美二叉树：116. Populating Next Right Pointers in Each Node 123456789101112131415161718// 针对完美二叉树的递归式解法Node* connect(Node* root)&#123; if(!root) return nullptr; helper(root-&gt;left, root-&gt;right); return root;&#125;void helper(Node* node1, Node* node2)&#123; if(!node1 || !node2) return; node1-&gt;next = node2; helper(node1-&gt;left, node1-&gt;right); helper(node2-&gt;left, node2-&gt;right); helper(node1-&gt;right, node2-&gt;left);&#125; 98. Validate Binary Search Tree 给定二叉树的根，确定它是否是有效的二叉搜索树。 1234567891011121314151617bool isValidBST(TreeNode* root)&#123; return helper(root, nullptr, nullptr);&#125;// 必须将对上层节点的约束传递给下层节点// 限定以 root 为根的子树节点必须满足 min-&gt;val &lt; root.val &lt; max-&gt;valbool helper(TreeNode* root, TreeNode* min, TreeNode* max)&#123; if(!root) return true; if(min &amp;&amp; root-&gt;val &lt;= min-&gt;val) return false; if(max &amp;&amp; root-&gt;val &gt;= max-&gt;val) return false; // 这时 left 节点的最大就是 root, right 节点的最小值就是 root return helper(root-&gt;left, min, root) &amp;&amp; helper(root-&gt;right, root, max);&#125; 1373. Maximum Sum BST in Binary Tree 给定二叉树的根，找出所有是BST的子树，分别计算这些子树的所有节点值的和， 返回其中的最大值。 二叉搜索树的定义如下： 任意节点的左子树中的键值都小于此节点的键值。任意节点的右子树中的键值都大于此节点的键值。任意节点的左子树和右子树都是二叉搜索树。 Example 1: 123Input: root &#x3D; [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]Output: 20Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3. Example 2: 123Input: root &#x3D; [4,3,null,1,2]Output: 2Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2. 123456789101112131415161718192021222324252627282930313233343536373839int maxSumBST(TreeNode* root)&#123; int ans = 0; postOrder(root, ans); return ans;&#125;// tuple 中存的是// 1. 以 root 为根的子树的总和, 如果其不是 BST, 此值为 0// 2. 以 root 为根的树中的最小值// 3. 以 root 为根的树中的最大值tuple&lt;int, int, int&gt; postOrder(TreeNode* root, int&amp; ans)&#123; if(!root) return &#123;0, INT_MAX, INT_MIN&#125;; auto l = postOrder(root-&gt;left, ans); auto r = postOrder(root-&gt;right, ans); // 如果当前节点的左子树中节点的最大值比当前节点还大 // 或者当前节点的右子树中节点的最小值比当前节点还小 // 以当前节点为根的子树就不是 BST // 因此总和为 0 // 最小值为 INT_MIN 以致于右子树中包含此树的树也被认定为非 BST // 最大值为 INT_MAX 以致于左子树中包含此树的树也被认定为非 BST if(get&lt;2&gt;(l) &gt;= root-&gt;val || get&lt;1&gt;(r) &lt;= root-&gt;val) return &#123;0, INT_MIN, INT_MAX&#125;; // 此时, 以当前节点为根的子树是 BST // 计算此树的总和并更新最大值 int num = get&lt;0&gt;(l) + get&lt;0&gt;(r) + root-&gt;val; ans = max(ans, num); // 最后还要返回以当前节点为根的子树的信息 // 其总和就为 num // 1. 当前节点有可能是叶子节点或者只有一颗子树 // 所以最小值为当前节点的值和左子树中最小的值相比取小者 // 最小值为当前节点的值和右子树中最大的值相比取大者 // 因为 if(!root) return &#123;0, INT_MAX, INT_MIN&#125;; 语句 // 保证了左子树中最小的值为 INT_MAX, 右子树中最大的值为 INT_MIN // 所以比较的结果肯定是 root-&gt;val // 2. 当前节点有两颗子树, 那么比较的结果肯定不是 root-&gt;val (这是 BST 的规则!) return &#123;num, min(root-&gt;val, get&lt;1&gt;(l)), max(root-&gt;val, get&lt;2&gt;(r))&#125;;&#125; 297. Serialize and Deserialize Binary Tree 序列化是将数据结构或对象转换为位序列的过程，以便可以将其存储在文件或内存缓冲区中，或者通过网络连接链接进行传输，以便稍后在相同或另一台计算机环境中进行重构。 设计一种用于对二叉树进行序列化和反序列化的算法。 序列化和反序列化算法的工作方式没有任何限制。 你只需要确保可以将二叉树序列化为字符串，并且可以将该字符串反序列化为原始树结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111class Codec&#123;public: // 前序遍历解法 // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string res; serializeHelper(root, res); return res; &#125; void serializeHelper(TreeNode* root, string&amp; res) &#123; if(!root) &#123; res.append(PLACEHOLDER).append(DELIMITER); return; &#125; res.append(to_string(root-&gt;val)).append(DELIMITER); serializeHelper(root-&gt;left, res); serializeHelper(root-&gt;right, res); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; stringstream ss(data); return deserializeHelper(ss); &#125; TreeNode* deserializeHelper(stringstream&amp; ss) &#123; if(!ss) return nullptr; string str; getline(ss, str, ','); if(str == \"#\") return nullptr; TreeNode* root = new TreeNode(stoi(str)); root-&gt;left = deserializeHelper(ss); root-&gt;right = deserializeHelper(ss); return root; &#125;private: const string PLACEHOLDER = \"#\"; const string DELIMITER = \",\";&#125;;class Codec&#123;public: // 后序遍历解法 // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string res; serializeHelper(root, res); return res; &#125; void serializeHelper(TreeNode* root, string&amp; res) &#123; if(!root) &#123; res.append(PLACEHOLDER).append(DELIMITER); return; &#125; serializeHelper(root-&gt;left, res); serializeHelper(root-&gt;right, res); res.append(to_string(root-&gt;val)).append(DELIMITER); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; stringstream ss(data); vector&lt;string&gt; vecString; string str; while(getline(ss, str, ',')) vecString.push_back(str); return deserializeHelper(vecString); &#125; TreeNode* deserializeHelper(vector&lt;string&gt;&amp; vecString) &#123; if(vecString.empty()) return nullptr; string str = vecString.back(); vecString.pop_back(); if(str == \"#\") return nullptr; TreeNode* root = new TreeNode(stoi(str)); // 后序遍历解法需要先构造右孩子, 再构造左孩子 root-&gt;right = deserializeHelper(vecString); root-&gt;left = deserializeHelper(vecString); return root; &#125;private: const string PLACEHOLDER = \"#\"; const string DELIMITER = \",\";&#125;; 653. Two Sum IV - Input is a BST 给定一个二叉搜索树和一个目标数，如果BST中存在两个元素的总和等于给定的目标数，则返回true。 Example: 12Input: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 9Output: true 123456789101112131415// 方法 1 基本思想都是借助 BST 的中序遍历结果是升序排列的, 然后借助双指针搜索即可// 方法 2 如果使用什么遍历 (写成递归和迭代都行), 都借助哈希表在遍历的过程中记录已经出现的值bool findTarget(TreeNode* root, int k)&#123; unordered_set&lt;int&gt; setting; return helper(root, k, setting);&#125;bool helper(TreeNode* root, int k, unordered_set&lt;int&gt;&amp; setting)&#123; if(!root) return false; if(setting.count(k - root-&gt;val)) return true; setting.insert(root-&gt;val); return helper(root-&gt;left, k, setting) || helper(root-&gt;right, k, setting);&#125; 114. Flatten Binary Tree to Linked List 给定二叉树的根，将树展平为“链表”：“链表”应使用相同的TreeNode类，其中右子指针指向列表中的下一个节点，而左子指针始终为null。 “链表”的顺序应与二叉树的前序遍历顺序相同。 12345678910111213141516171819202122232425// 递归思想: 相信递归函数的定义并毫不怀疑的去调用它!// 此例中, void flatten(TreeNode* root) 函数的定义就是将 root 平展// 只需要注意递归基的处理就可以了void flatten(TreeNode* root)&#123; // base case if(!root) return; flatten(root-&gt;left); flatten(root-&gt;right); // 此时左右两棵子树都已经 flatten 完毕了 TreeNode* p = root-&gt;right; // 备份右子树 // 1. 将右孩子指针指向左子树, 随后左孩子指针置空 if(root-&gt;left) &#123; root-&gt;right = root-&gt;left; root-&gt;left = nullptr; &#125; else root-&gt;right = nullptr; // 2. 沿着新右指针一直往前走, 定位到尾节点 while(root &amp;&amp; root-&gt;right) root = root-&gt;right; // 3. 将尾节点指向右子树 root-&gt;right = p;&#125; 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree 给定一个原始树和一个克隆树，克隆树是原始树的副本。并给出对原始树中某目标节点的引用。 返回对克隆树中相同节点的引用。 请注意，不允许您更改两个树或目标节点中的任何一个，并且答案必须是对克隆树中节点的引用。 注意：你的解答要适用于在树上允许有重复的值的情况。 12345678910111213141516// 树上允许有重复的值意味着不能通过比较节点的值来返回目标节点// 题目已经给出保证 original cloned target 都不为 null// 直接对两棵树同步的进行 dfsTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target)&#123; if(!original) return nullptr; if(original == target) return cloned; // 先在左子树中找 TreeNode* found = getTargetCopy(original-&gt;left, cloned-&gt;left, target); // 没找到再去右子树中找 if(!found) found = getTargetCopy(original-&gt;right, cloned-&gt;right, target); return found;&#125; 99. Recover Binary Search Tree 给定一个二叉搜索树的根节点，恰好树中的两个节点错误地交换了。 在不更改其结构的前提下，恢复这棵二叉搜索树。 Example 1 Example 2 Example 1: 123Input: root &#x3D; [1,3,null,null,2]Output: [3,1,null,null,2]Explanation: 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid. Example 2: 123Input: root &#x3D; [3,1,4,null,null,2]Output: [2,1,4,null,null,3]Explanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid. 注意：使用O(n)空间复杂度的解决方案非常简单。 你能设计一个O(1)空间解决方案吗？ 123456789101112131415161718192021222324252627282930313233343536373839404142// 首先要知道, BST 的中序遍历是有序的// 然后注意到, 如果树中有两个节点被交换了// 在中序遍历序列中必然会出现逆序对 (可能一对, 也可能两对)// 一对的情况是被交换的两个节点在中序遍历序列中相邻// 此时我们有两个指针来分别定位这一逆序对的两个节点// 交换它们的值即可// 被交换的两个节点不相邻就会出现两对逆序对的情况// 此时, 有一个指针定位前一个逆序对的第一个节点// 另一个指针定位后一个逆序对的第二个节点// 交换它们的值即可TreeNode* startPoint = nullptr; // 定位逆序对的第一个节点TreeNode* endPoint = nullptr; // 定位逆序对的第二个节点TreeNode* preNode = nullptr; // 始终指向当前访问节点的前一个节点void recoverBinarySearchTree(TreeNode* root)&#123; inorder(root); swap(startPoint-&gt;val, endPoint-&gt;val);&#125;void inorder(TreeNode* root)&#123; if(!root) return; inorder(root-&gt;left); // 从这题要学会如何跟踪遍历过程中当前节点的前一个节点的技术 if(preNode &amp;&amp; preNode-&gt;val &gt; root-&gt;val) &#123; // 如果为空, 说明遇到的是第一个逆序对 // 当前节点是逆序对的第二个节点 // 第一个节点由 preNode 指出, 更新 startPoint // 如果不为空, 说明遇到的是第二个逆序对 // 就不更新 startPoint, 因为我们定位第二个逆序对的第一个节点没有用 if(!startPoint) startPoint = preNode; // 无论是第几个逆序对 // endPoint 都指向逆序对的第二个节点 endPoint = root; &#125; // 持续跟踪前一个节点 preNode = root; inorder(root-&gt;right);&#125; 687. Longest Univalue Path 给定二叉树的根，返回最长路径的长度，其中路径中的每个节点都具有相同的值。 此路径可能会也可能不会通过根。 两个节点之间的路径长度由它们之间的边数表示。 Example 1: 12Input: root &#x3D; [1,4,5,4,4,5]Output: 2 Example 2: 12Input: root &#x3D; [5,4,5,1,1,5]Output: 2 12345678910111213141516171819202122232425262728293031int longestUnivaluePath(TreeNode* root)&#123; int res = 0; dfs(root, res); return res;&#125;// 该递归函数的定义就是返回以 root 为起点的符合条件的路径的最大长度int dfs(TreeNode* root, int&amp; res)&#123; if(!root) return 0; // 利用递归 // 先获取以其左孩子为起点的符合条件的路径长度 int leftPath = dfs(root-&gt;left, res); // 先获取以其右孩子为起点的符合条件的路径长度 int rightPath = dfs(root-&gt;right, res); int rootPathWithLeft = 0, rootPathWithRight = 0; // 如果当前节点的值与其左孩子的值相等 // 那么它就可以和其左孩子的路径连在一块, 路径长度 +1 if(root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val) rootPathWithLeft = leftPath + 1; // 如果当前节点的值与其右孩子的值相等 // 那么它就可以和其右孩子的路径连在一块, 路径长度 +1 if(root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val) rootPathWithRight = rightPath + 1; // 注意这两条路径是不一样的 res = max(res, rootPathWithLeft + rootPathWithRight); // 而以 root 为起点的符合条件的路径的最大长度为这两条路径的较大者 return max(rootPathWithLeft, rootPathWithRight);&#125; 654. Maximum Binary Tree 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 Constraints: All integers in nums are unique. Example: 12Input: nums &#x3D; [3,2,1,6,0,5]Output: [6,3,5,null,2,0,null,null,1] 123456789101112131415161718192021222324252627282930313233343536373839404142TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums)&#123; return construct(nums, 0, nums.size() - 1);&#125;// 构造闭区间 [lo, hi] 内的元素TreeNode* construct(vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; // base case if(lo &gt; hi) return nullptr; // 找到最大值 int maxIndex = findMax(nums, lo, hi); /* 另外, 装逼的话, 获取数组中最大元素的索引可以这样写 int maxIndex = distance(nums.begin(), max_element(nums.begin() + lo, nums.begin() + hi + 1)); */ // 以最大值为根节点 TreeNode* root = new TreeNode(nums[maxIndex]); // 左子树为最大值左边的 root-&gt;left = construct(nums, lo, maxIndex - 1); // 右子树为最大值右边的 root-&gt;right = construct(nums, maxIndex + 1, hi); return root;&#125;int findMax(vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; int maxVal = INT_MIN; int index; for(int i = lo; i &lt;= hi; i++) &#123; if(nums[i] &gt; maxVal) &#123; index = i; maxVal = nums[i]; &#125; &#125; return index;&#125; 998. Maximum Binary Tree II 最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。 给出最大树的根节点root。 就像之前的654. Maximum Binary Tree问题那样，给定的树是从列表A递归地使用下述Construct(A)例程构造的： 如果A为空，返回null否则，令A[i]作为A的最大元素。创建一个值为A[i]的根节点rootroot的左子树将被构建为Construct([A[0], A[1], ..., A[i-1]])root的右子树将被构建为Construct([A[i+1], A[i+2], ..., A[A.length - 1]])返回root请注意，我们这里没有直接给定A，只有一个根节点root = Construct(A). 假设B是A的副本，并在末尾附加值val。题目数据保证B中的值是不同的。返回Construct(B)。 Example 1: 123Input: root &#x3D; [4,1,3,null,null,2], val &#x3D; 5Output: [5,4,null,1,3,null,null,2]Explanation: A &#x3D; [1,4,2,3], B &#x3D; [1,4,2,3,5] Example 2: 123Input: root &#x3D; [5,2,4,null,1], val &#x3D; 3Output: [5,2,4,null,1,null,3]Explanation: A &#x3D; [2,1,5,4], B &#x3D; [2,1,5,4,3] Example 3: 123Input: root &#x3D; [5,2,3,null,1], val &#x3D; 4Output: [5,2,4,null,1,3]Explanation: A &#x3D; [2,1,5,3], B &#x3D; [2,1,5,3,4] 1234567891011121314151617// 先要明确一点, 最大二叉树指的是在构造的时候最大值左边的为左子树, 右边的为右子树// 因为是放在数组右边的, 所以新节点必然在右子树中TreeNode* insertIntoMaxTree(TreeNode* root, int val)&#123; // 如果比人家右子树中的所有节点都小 // 只能作为叶子节点了 if(!root) return new TreeNode(val); // 如果目标值当前节点的值大 // 说明以当前节点为根的子树要成为我的左子树才行 // 因为我是放在最右边的, 你在我左边我还比你大 if(val &gt; root-&gt;val) return new TreeNode(val, root, nullptr); // 否则, 就要向右边搜索位置 // 因为你在原来最大值的右边 root-&gt;right = insertIntoMaxTree(root-&gt;right, val); return root;&#125; 508. Most Frequent Subtree Sum 给定一棵树的根，要求你找到最频繁的子树总和。 节点的子树总和定义为由以该节点为根的子树（包括节点本身）形成的所有节点值的总和。 那么，最频繁的子树总和的值是多少？如果有平局，则以任意顺序返回具有最高频率的所有值。 Examples 1Input: 123 5 &#x2F; \\2 -3 return [2, -3, 4], since all the values happen only once, return all of them in any order. Examples 2Input: 123 5 &#x2F; \\2 -5 return [2], since 2 happens twice, however -5 only occur once. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 思想就是先通过递归获得所有子树的和// 递归的过程中记录下来每一个确定的和出现的次数// 这需要一个哈希表来记录 sum --&gt; preq 的映射// 但是问题来了, 之后我们要获取出现次数最多的, 也就是值(频率)最大的键// 并且频率还有可能相同而出现重复// 第一种方法是 auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);// 注意, cmp 需要定制 auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)// &#123; return a.second &lt; b.second; &#125;;// 这种方法效率有点低, 有多少个重复的 freq, 我们就需要遍历哈希表多少次// 最坏情况下，时间复杂度为 O(n2)// 第二种方法是再使用一个 multimap 来 [逆映射] 原 unordered_map 中的键值对// for(auto elem : mapping)// mappingSwap.insert(&#123;elem.second, elem.first&#125;);// 需要注意的是, 使用有序可重复哈希表, 将原来的键变成值, 值变成键// 然后通过逆迭代器直接获得最大键元素 (在红黑树的最右下边嘛)// 最坏时间复杂度将为 O(n) 啦// 第一种方法// vector&lt;int&gt; findFrequentTreeSum(TreeNode* root)// &#123;// unordered_map&lt;int, int&gt; mapping;// subTreeSum(root, mapping);// auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)// &#123; return a.second &lt; b.second; &#125;;// vector&lt;int&gt; res;// int preFreq = 0;// while(1)// &#123;// if(mapping.empty()) break;// auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);// if(!res.empty() &amp;&amp; maxFreqSum.second != preFreq)// break;// preFreq = maxFreqSum.second;// res.push_back(maxFreqSum.first);// mapping.erase(maxFreqSum.first);// &#125;// return res;// &#125;// 第二种方法vector&lt;int&gt; findFrequentTreeSum(TreeNode* root)&#123; unordered_map&lt;int, int&gt; mapping; multimap&lt;int, int&gt; mappingSwap; subTreeSum(root, mapping); for(auto elem : mapping) mappingSwap.insert(&#123;elem.second, elem.first&#125;); vector&lt;int&gt; res; if(mappingSwap.empty()) return res; int preFreq = mappingSwap.rbegin()-&gt;first; for(auto it = mappingSwap.rbegin(); it != mappingSwap.rend(); it++) &#123; if(it-&gt;first != preFreq) break; res.push_back(it-&gt;second); &#125; return res;&#125;int subTreeSum(TreeNode* root, unordered_map&lt;int, int&gt;&amp; mapping)&#123; if(!root) return 0; int leftSum = subTreeSum(root-&gt;left, mapping); int rightSum = subTreeSum(root-&gt;right, mapping); int rootSum = leftSum + rightSum + root-&gt;val; mapping[rootSum]++; return rootSum;&#125; 236. Lowest Common Ancestor of a Binary Tree 给定一棵二叉树，找到树中两个给定节点的最低公共祖先（LCA）。一个节点的祖先可以是它自己。 Constraints: 所有Node.val互不相同 p != q p 和 q均存在于给定的二叉树中。 123456789101112131415161718192021222324// 接下来的几道题全是最低公共祖先的问题// 这题的限制是给定的两个节点都存在树中// 基本思想就是借助递归, 时刻牢记递归函数的定义, 并且毫不怀疑的使用它// 这题中, lowestCommonAncestor 函数的定义就是, 接受一个根节点和两个在树中的其它节点// 返回它们的 LCA// 所以, 利用后序遍历, 先分别在当前节点的左右子树中找给定两个节点的 LCA// 根据返回值判断寻找情况TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)&#123; // 如果当前节点为空, 肯定找不到 LCA 了 if(!root) return nullptr; // left 为左子树中的寻找情况 TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); // right 为右子树中的寻找情况 TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); // 注意, 如果当前节点属于这两个节点之一 // 意味着 当前节点就是它们的最低公共祖先啦 if(root == p || root == q) return root; // 如果在左子树中和右子树中都找到了一个 LCA // 同样的, 说明当前节点就是它们的 LCA if(left &amp;&amp; right) return root; // 否则, 返回在 以当前节点为根的子树 中给定节点的 LCA return left ? left : right;&#125; 1644. Lowest Common Ancestor of a Binary Tree II 给定一棵二叉树的根节点root，返回给定节点p和q的最近公共祖先（LCA）节点。如果p或q之一不存在于该二叉树中，返回null。 Constraints: 所有Node.val互不相同 p != q 1234567891011121314151617181920212223242526272829303132333435363738// 这题和 I 题不同之处在于// 给定的两个节点可能不在树中// 所以, 这里我们使用两个 flag// 在后序遍历的同时, 标志给定的两个节点是否在树中// 其余的逻辑和 I 题一样bool pIsInTree = false;bool qIsInTree = false;TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)&#123; TreeNode* res = nullptr; // 辅助递归函数返回 LCA res = helper(root, p, q); // 如果有任何一个节点不在树中, 返回 null if(!pIsInTree || !qIsInTree) return nullptr; return res;&#125;TreeNode* helper(TreeNode* root, TreeNode* p, TreeNode* q)&#123; if(!root) return nullptr; TreeNode* left = helper(root-&gt;left, p, q); TreeNode* right = helper(root-&gt;right, p, q); // 将上题中的 if(root == p || root == q) return root; 分开写就行了 if(root == p) &#123; pIsInTree = true; return root; &#125; if(root == q) &#123; qIsInTree = true; return root; &#125; if(left &amp;&amp; right) return root; return left ? left : right;&#125; 1650. Lowest Common Ancestor of a Binary Tree III 给定一棵二叉树中的两个节点p和q，返回它们的最近公共祖先节点（LCA）。 每个节点都包含其父节点的引用（指针）。Node的定义如下： 1234567struct Node&#123; int val; Node* left; Node* right; Node* parent;&#125; Constraints: 所有Node.val互不相同 p != q p 和 q均存在于给定的二叉树中。 123456789101112131415161718192021222324252627// 这题中的树的节点都有指向父亲的指针, 而且还说给定的两个节点还肯定存在// 那就更简单了, 直接分别从给定的两个节点逐层向上找// 借助一个哈希集合, 第一个节点向上找的过程中, 经过的每一个父节点都放进一个集合内// 等第二个节点向上找的时候, 如果遇到已经在哈希集合中的父节点 (首个遇到的)// 那就说明这个节点就是它们的 LCA 啦// 和查找链表的交叉点的思路一样Node* lowestCommonAncestor(Node* p, Node* q)&#123; unordered_set&lt;Node*&gt; setting; // p 先向上, 同样的自己也可以是自己的祖先 while(p) &#123; // 所以自己也得放进集合 setting.insert(p); p = p-&gt;parent; &#125; while(q) &#123; // 已经在集合中了, 就是它! if(setting.count(q)) return q; setting.insert(q); q = q-&gt;parent; &#125; return nullptr;&#125; 1676. Lowest Common Ancestor of a Binary Tree IV 给定一棵二叉树的根节点root和TreeNode类对象的数组（列表）nodes，返回nodes中所有节点的最近公共祖先（LCA）。数组（列表）中所有节点都存在于该二叉树中，且二叉树中所有节点的值都是互不相同的。 Constraints: 所有的Node.val都是互不相同的。 所有的nodes[i]都存在于该树中。 所有的nodes[i]都是互不相同的。 示例 1: 123输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [4,7]输出: 2解释: 节点 4 和 7 的最近公共祖先是 2。 示例 2: 123输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [7,6,2,4]输出: 5解释: 节点 7、6、2 和 4 的最近公共祖先节点是 5。 12345678910111213141516171819202122232425// 这一题, 我笑了// I 题是找两个节点的 LCA// 这题找多个节点的, 思路完全一样TreeNode* lowestCommonAncestor(TreeNode* root, vector&lt;TreeNode*&gt;&amp; nodes)&#123; // 先将 nodes 中的节点们都放进一个哈希集合中 unordered_set&lt;TreeNode*&gt; setting; for(auto node : nodes) setting.insert(node); return dfs(root, setting);&#125;TreeNode* dfs(TreeNode* root, unordered_set&lt;TreeNode*&gt;&amp; setting)&#123; if(!root) return nullptr; TreeNode* left = dfs(root-&gt;left, setting); TreeNode* right = dfs(root-&gt;right, setting); // 将 I 题中的 if(root == p || root == q) return root; 换个写法就行了 if(setting.count(root)) return root; if(left &amp;&amp; right) return root; return left ? left : right;&#125; 101. Symmetric Tree 给定二叉树，请检查其是否是其自身的镜像（即围绕其中心对称）。 Example: 12Input: root &#x3D; [1,2,2,3,4,4,3]Output: true 123456789101112131415161718bool isSymmetric(TreeNode* root)&#123; return helper(root-&gt;left, root-&gt;right);&#125;// 左右子树同步遍历bool helper(TreeNode* p, TreeNode* q)&#123; // 如果都为空, 显然对称 if(!p &amp;&amp; !q) return true; // 此时两者必有不为 null 的 // 就判断是否有为 null 的 if(!p || !q) return false; // 此时两者都不为 null // 就判断它们的值是否相等 if(p-&gt;val != q-&gt;val) return false; return helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left);&#125; 1372. Longest ZigZag Path in a Binary Tree 给你一棵以root为根的二叉树，二叉树中的交错路径定义如下： 选择二叉树中任意节点和一个方向（左或者右）。如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。改变前进方向：左变右或者右变左。重复第二步和第三步，直到你在树中无法继续移动。交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为0）。 请你返回给定树中最长交错路径的长度。 Example 1 Example 2 Example 1: 123Input: root &#x3D; [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]Output: 3Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right). Example 2: 123Input: root &#x3D; [1,1,1,null,1,null,null,1,1,null,1]Output: 4Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 递归形式 1// 0 表示方向向左// 1 表示方向向右int res = 0;int longestZigZag(TreeNode* root)&#123; helper(root-&gt;left, 0, 1); helper(root-&gt;right, 1, 1); return res;&#125;void helper(TreeNode* node, bool dir, int depth)&#123; if(!node) return; res = max(res, depth); if(dir) &#123; // 如果当前节点是从右方向过来的 // 之后就要转去左方向 helper(node-&gt;left, 0, depth + 1); // 同时还可以接着去右方向 // 只不过深度要重新计算 helper(node-&gt;right, 1, 1); &#125; else &#123; // 如果当前节点是从左方向过来的 // 之后就要转去右方向 helper(node-&gt;right, 1, depth + 1); // 同时还可以接着去左方向 // 只不过深度要重新计算 helper(node-&gt;left, 0, 1); &#125;&#125;// 递归形式 2int res = 0;int helper(TreeNode* root, bool dir)&#123; if(!root) return 0; int tmp_L = 1 + helper(root-&gt;left, 0); int tmp_R = 1 + helper(root-&gt;right, 1); res = max(res, tmp_L); res = max(res, tmp_R); return dir ? tmp_L : tmp_R;&#125;int longestZigZag(TreeNode* root)&#123; helper(root, 0); // helper(root, 1); return res - 1;&#125; 173. Binary Search Tree Iterator 实现一个二叉搜索树迭代器类BSTIterator，表示一个按中序遍历二叉搜索树（BST）的迭代器： BSTIterator(TreeNode* root)初始化BSTIterator类的一个对象。BST的根节点root会作为构造函数的一部分给出。指针应初始化为一个不存在于BST中的数字，且该数字小于BST中的任何元素。 bool hasNext()如果向指针右侧遍历存在数字，则返回true；否则返回false。 int next()将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于BST中的数字，所以对next()的首次调用将返回BST中的最小元素。 你可以假设next()调用总是有效的，也就是说，当调用next()时，BST的中序遍历中至少存在一个下一个数字。 12345678910111213141516171819202122232425262728293031323334// 这题考察二叉树的中序遍历的迭代实现// 只不过把循环分摊在每次调用 next 函数里class BSTIterator&#123;public: BSTIterator(TreeNode* root) : _pointer(root) &#123;&#125; // 这段和是中序遍历的迭代式写法 while(1) 循环体里的代码完全一样 int next() &#123; while(_pointer) &#123; _stack.push(_pointer); _pointer = _pointer-&gt;left; &#125; _pointer = _stack.top(); int val = _pointer-&gt;val; _stack.pop(); _pointer = _pointer-&gt;right; return val; &#125; bool hasNext() &#123; // 只有当 _pointer 为空并且 _stack 也为空的情况下 // 才没有下一个节点 return _pointer || !_stack.empty(); &#125;private: TreeNode* _pointer; stack&lt;TreeNode*&gt; _stack;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"leetcode刷题系列之链表","date":"2021-01-08T13:35:42.000Z","path":"S07PSuYxoZ6CPova/","text":"这篇文章是leetcode刷题系列的第2部分——链表，链表的大部分题目难度都不大。leetcode上链表部分的题目也就40道左右，基本上都做了，这里就把有代表性的题目发出来，共计22道。每道题都给出了注释，有的题目还给出了另一种思路和解法。另外，博主是非常注重代码编写风格的，因此代码可读性较好。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少200道！ Linked List206. Reverse Linked List 给定一个单链表的头节点，反转链表，然后返回反转后的链表头节点。 1234567891011121314151617181920212223242526// 迭代解法ListNode* reverseList(ListNode* head)&#123; ListNode* p = nullptr; ListNode* q = p; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p;&#125;// 递归解法ListNode* reverseList(ListNode* head)&#123; if(!head || !head-&gt;next) return head; ListNode* q = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return q;&#125; 92. Reverse Linked List II 给定一个单链表的头以及left和right两个整数，其中left &lt;= right，将链表中从left位置到right位置的节点反转，返回反转后的链表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* 纯递归解法 */// 反转整个链表ListNode* reverseList(ListNode* head)&#123; if(!head || !head-&gt;next) return head; ListNode* q = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return q;&#125;// 反转前 n 个节点ListNode* reverseN(ListNode* head, int n)&#123; ListNode* p = head; while(--n &gt; 0) p = p-&gt;next; ListNode* q = p-&gt;next; p-&gt;next = nullptr; ListNode* r = reverseList(head); head-&gt;next = q; return r;&#125;ListNode* reverseBetween(ListNode* head, int left, int right)&#123; if(left == 1) return reverseN(head, right); head-&gt;next = reverseBetween(head-&gt;next, left - 1, right - 1); return head;&#125;/* 纯迭代解法 */// 反转整个链表ListNode* reverseList(ListNode* head)&#123; ListNode* p = nullptr; ListNode* q = p; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p;&#125;// 反转前 n 个节点ListNode* reverseN(ListNode* head, int n)&#123; ListNode* p = head; while(--n &gt; 0) p = p-&gt;next; ListNode* q = p-&gt;next; p-&gt;next = nullptr; ListNode* r = reverseList(head); head-&gt;next = q; return r;&#125;ListNode* reverseBetween(ListNode* head, int left, int right)&#123; if(left == 1) return reverseN(head, right); // 计算反转的实际节点数 int n = right - left + 1; ListNode* p = head; left--; while(--left &gt; 0) p = p-&gt;next; // p 现在指向第 left 个节点的前一个节点 p-&gt;next = reverseN(p-&gt;next, n); return head;&#125; 25. Reverse Nodes in k-Group 给你一个链表，每k个节点一组进行翻转，请你返回翻转后的链表。k是一个正整数，它的值小于或等于链表的长度。如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺序。 进阶：你可以设计一个只使用常数额外空间的算法来解决此问题吗？不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 Example 1 Example 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 反转整个链表ListNode* reverseList(ListNode* head)&#123; ListNode* p = nullptr; ListNode* q = p; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p;&#125;// 反转前 n 个节点ListNode* reverseN(ListNode* head, int n)&#123; ListNode* p = head; while(--n &gt; 0) p = p-&gt;next; ListNode* q = p-&gt;next; p-&gt;next = nullptr; ListNode* r = reverseList(head); head-&gt;next = q; return r;&#125;ListNode* reverseKGroup(ListNode* head, int k)&#123; ListNode* q = head; int n = k; while(--n &amp;&amp; q) q = q-&gt;next; if(!q) return head; ListNode* p = head; // 这里先反转第一次是为了方便记录头节点 head = reverseN(head, k); while(1) &#123; ListNode* r = p-&gt;next; q = r; n = k; while(--n &amp;&amp; q) q = q-&gt;next; if(!q) break; p-&gt;next = reverseN(p-&gt;next, k); p = r; &#125; return head;&#125; 382. Linked List Random Node 给定一个单链表，从链表随机返回一个节点的值。 每个节点必须具有相同的被选择概率。 如果链表很大并且你不知道其长度怎么办？你能在不使用额外空间的情况下有效解决此问题吗？ 如果随机返回k个节点的值呢？ 水塘抽样算法：遇到第i个元素时，应该有1/i的概率选择该元素，1 - 1/i的概率保持原有的选择。 证明：假设总共有n个元素，我们要的随机性无非就是每个元素被选择的概率都是1/n ，那么对于第i个元素，它被选择的概率就是： 同理，如果要随机选择k个数，只要在第i个元素处以k/i的概率选择该元素，以1 - k/i的概率保持原有选择即可。 证明：略。 12345678910111213141516171819202122232425262728293031323334/* Returns a random node's value. */int getRandom(ListNode* head)&#123; int res = 0, i = 0; while(head) &#123; int j = rand() % ++i; // j 等于 0 的概率就为 1/i if(j == 0) res = head-&gt;val; head = head-&gt;next; &#125; return res;&#125;/* Returns k random node's value. */vector&lt;int&gt; getRandom(ListNode* head, int k)&#123; vector&lt;int&gt; res(k, 0); // 前 k 个值默认先选上 for(int i = 0; i &lt; k &amp;&amp; head; i++, head = head-&gt;next) res[i] = p-&gt;val; int i = k; while(head) &#123; int j = rand() % ++i; // j 小于 k 的概率就为 k/i if(j &lt; k) res[j] = head-&gt;val; head = head-&gt;next; &#125; return res;&#125; 2. Add Two Numbers 给定两个表示两个非负整数的非空链表。 这些数字以相反的顺序存储，即低位数在前，并且它们的每个节点都包含一个数字。 将两个数字相加并返回总和作为链接列表。 12345678910111213141516171819202122232425262728293031323334353637383940ListNode* addTwoNumbers(ListNode* p, ListNode* q)&#123; ListNode head; ListNode* last = &amp;head; int sum = 0; int carry = 0; while(p &amp;&amp; q) &#123; sum = p-&gt;val + q-&gt;val + carry; carry = sum / 10; last-&gt;next = new ListNode(sum % 10); last = last-&gt;next; p = p-&gt;next; q = q-&gt;next; &#125; while(p) &#123; sum = p-&gt;val + carry; carry = sum / 10; last-&gt;next = new ListNode(sum % 10); last = last-&gt;next; p = p-&gt;next; &#125; while(q) &#123; sum = q-&gt;val + carry; carry = sum / 10; last-&gt;next = new ListNode(sum % 10); last = last-&gt;next; q = q-&gt;next; &#125; // 最后别忘了可能还有近位 if(carry &gt; 0) last-&gt;next = new ListNode(carry); return head.next;&#125; 445. Add Two Numbers II 给定两个表示两个非负整数的非空链表。 高位数字在前，并且它们的每个节点都包含一个数字。 将两个数字相加，然后将其作为链表返回。 如果无法修改输入列表怎么办？ 换句话说，不允许反转列表。 Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 借助栈后进先出的特性即可// 只不过插入新节点的时候注意插在头部// 另外将外面的两个 while 循环拿进去, 减少重复代码, 更优美ListNode* addTwoNumbers(ListNode* p, ListNode* q)&#123; stack&lt;ListNode*&gt; pStack, qStack; while(p) &#123; pStack.push(p); p = p-&gt;next; &#125; while(q) &#123; qStack.push(q); q = q-&gt;next; &#125; ListNode* head = nullptr; int sum = 0; int carry = 0; while(!pStack.empty() || !qStack.empty()) &#123; if(!pStack.empty() &amp;&amp; !qStack.empty()) &#123; sum = pStack.top()-&gt;val + qStack.top()-&gt;val + carry; pStack.pop(); qStack.pop(); &#125; else if(!pStack.empty()) &#123; sum = pStack.top()-&gt;val + carry; pStack.pop(); &#125; else &#123; sum = qStack.top()-&gt;val + carry; qStack.pop(); &#125; carry = sum / 10; // 插入时, 插在头部 head = new ListNode(sum % 10, head); &#125; // 最后别忘了可能还有近位 if(carry &gt; 0) head = new ListNode(carry, head); return head;&#125; 1721. Swapping Nodes in a Linked List 给定一个链表的头以及一个整数k。将从头开始第k个节点的值与从结尾开始第k个节点的值交换，返回链表的头。 Input: head = [1, 2, 3, 4, 5], k = 2Output: [1, 4, 3, 2, 5] 123456789101112131415161718192021// 左右双指针的解法ListNode* swapNodes(ListNode* head, int k)&#123; ListNode* left = nullptr; ListNode* p = head; while(--k) p = p-&gt;next; // 此时 left 指向从左边数第 k 个节点 left = p; ListNode* right = head; while(p-&gt;next) &#123; right = right-&gt;next; p = p-&gt;next; &#125; // 此时 right 指向从右边数边第 k 个节点 swap(left-&gt;val, right-&gt;val); return head;&#125; 109. Convert Sorted List to Binary Search Tree 给定一个单链表的头，其中元素按升序排序，请将其转换为高度平衡的BST。结果不唯一。 在此处，高度平衡的二叉树定义为这样一棵二叉树，其中每个节点的两个子树的深度相差不超过1。 123456789101112131415161718192021222324252627282930// 基本思想是将链表的左半部分节点作为 BST 的左子树, 右半部分节点作为 BST 的右子树,// 然后进行递归调用就可以了, 每次只需要处理中间节点即可// 这样可保证 BST 是高度平衡的// 同样的, 如果给的是有序数组, 也可以利用将中间元素构造成根节点的递归思路TreeNode* sortedListToBST(ListNode* head)&#123; // base case if(!head) return nullptr; if(!head-&gt;next) return new TreeNode(head-&gt;val); // 先定位到链表的中间节点 ListNode* slow = head; ListNode* fast = head; ListNode* preSlow = head; while(fast &amp;&amp; fast-&gt;next) &#123; preSlow = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; // 此时 slow 指向中间节点, preSlow 指向其前一节点 // 将左半部分子链表分离 preSlow-&gt;next = nullptr; // 将中间节点构建成 BST 的根节点 TreeNode* root = new TreeNode(slow-&gt;val); root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(slow-&gt;next); return root;&#125; 141. Linked List Cycle 给定链表的头节点，确定链表中是否有环。如果链表中有一个循环，则返回true。 否则，返回false。 123456789101112131415161718// 快慢指针bool hasCycle(ListNode* head)&#123; ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; // 慢指针每次走一步 slow = slow-&gt;next; // 快指针每次走两步 fast = fast-&gt;next-&gt;next; // 如果相遇就有环 if(slow == fast) return true; &#125; return false;&#125; 142. Linked List Cycle II 给定一个链表头节点，返回环开始的节点。 如果没有环，则返回null。 第一次相遇时，假设慢指针slow走了k步，那么快指针fast一定走了2k步： fast一定比slow多走了k步，这多走的k步其实就是fast指针在环里转圈圈，所以k的值就是环长度的「整数倍」。设相遇点距环的起点的距离为m，那么环的起点距头结点head的距离为k - m，也就是说如果从head前进k - m步就能到达环起点。 巧的是，如果从相遇点继续前进k - m步，也恰好到达环起点。你甭管fast在环里到底转了几圈，反正走k步可以到相遇点，那走k - m步一定就是走到环起点了： 1234567891011121314151617181920212223ListNode* detectCycle(ListNode* head)&#123; ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast) break; &#125; // 如果不是因为相遇才出循环的 if(!fast || !fast-&gt;next) return nullptr; slow = head; while(slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow;&#125; 876. Middle of the Linked List 给定一个链表头节点，返回链表的中间节点。 可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。当链表的长度是奇数时，slow恰巧停在中点位置；如果长度是偶数，slow最终的位置是中间偏右。 链表的归并排序：对于链表，合并两个有序链表是很简单的，难点就在于二分。但是现在知道了找到链表的中点的方法，就能实现链表的二分了。 1234567891011121314151617181920212223242526272829// 版本一// 节点个数为偶数时, 返回指向中间两个节点的第二个节点// 为奇数时返回指向中间的节点ListNode* middleNode(ListNode* head)&#123; ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125;// 版本二, 在写链表的归并排序时, 要用这个版本!// 节点个数为偶数时, 返回指向中间两个节点的第一个节点// 为奇数时返回指向中间的节点的前一个节点ListNode* middleNode(ListNode* head)&#123; ListNode* slow = nullptr; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow ? slow-&gt;next : head; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125; 19. Remove Nth Node From End of List 给定一个链表，删除链表的倒数第n个节点，并且返回链表的头结点。 Example: 12&gt;Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2&gt;Output: [1,2,3,5] 1234567891011121314151617ListNode* removeNthFromEnd(ListNode* head, int n)&#123; ListNode* slow = head; ListNode* fast = head; while(n-- &gt; 0) fast = fast-&gt;next; if(!fast) return head-&gt;next; while(fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return head;&#125; 160. Intersection of Two Linked Lists 给定两个单链列表headA和headB的头，返回两个列表相交的节点。 如果两个链接列表完全没有交集，则返回null。 例如，以下两个链接列表开始在节点c1处相交： 123456789101112131415161718192021222324252627282930313233343536// 先制造出一个环来, 再借助前面讲过的返回环起点的思路ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)&#123; if(!headA || !headB) return nullptr; ListNode* p = headA; while(p-&gt;next) p = p-&gt;next; // 将 A 链表的首尾相连成环 p-&gt;next = headA; ListNode* slow = headB; ListNode* fast = headB; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast) break; &#125; // 如果没有相遇, 说明原先不存在交点 if(!fast || !fast-&gt;next) &#123; p-&gt;next = nullptr; return nullptr; &#125; slow = headB; while(slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; // 最后别忘了恢复链表 A p-&gt;next = nullptr; return slow;&#125; 328. Odd Even Linked List 给定一个单链列表的头，将所有具有奇数索引的节点组合在一起，然后再加上具有偶数索引的节点，然后返回重新排序的列表。 第一个节点被认为是奇数，第二个节点被认为是偶数，依此类推。请注意，偶数和奇数组中的相对顺序应保持输入中的原样。 Could you solve it in O(1) space complexity and O(nodes) time complexity? 12345678910111213141516171819202122ListNode* oddEvenList(ListNode* head)&#123; // 0, 1, 2 个节点直接返回即可 if(!head || !head-&gt;next || !head-&gt;next-&gt;next) return head; ListNode* p = head; ListNode* q = head-&gt;next; ListNode* r = q; while(q &amp;&amp; q-&gt;next) &#123; p-&gt;next = q-&gt;next; q-&gt;next = p-&gt;next-&gt;next; p = p-&gt;next; q = q-&gt;next; &#125; p-&gt;next = r; return head;&#125; 234. Palindrome Linked List 给定一个单链表的头节点，如果它是回文链表，则返回true。例如，下面这个就为回文链表： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 链表的后序遍历结合左右指针// 利用系统栈来后进先出节点ListNode* left = nullptr;bool isPalindrome(ListNode* head)&#123; left = head; return traverse(head);&#125;bool traverse(ListNode* right)&#123; if(!right) return true; bool res = traverse(right-&gt;next); res = res &amp;&amp; (left-&gt;val == right-&gt;val); // 左指针前进 left = left-&gt;next; // 结束一个递归实例后, 右指针会自动后退 return res;&#125;// 找到链表的中间节点// 再将后半部分链表反转, 判断ListNode* reverseList(ListNode* head)&#123; if(!head || !head-&gt;next) return head; ListNode* q = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return q;&#125;bool isPalindrome(ListNode* head)&#123; ListNode* slow = head; ListNode* fast = head; // 用于恢复被破坏结构的后半部分链表头节点的前一个节点 ListNode* preSlow = nullptr; while(fast &amp;&amp; fast-&gt;next) &#123; preSlow = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; if(fast) &#123; preSlow = slow; slow = slow-&gt;next; &#125; // 此后 slow 可以用于恢复被破坏结构的原链表 ListNode* slow = reverseList(slow); ListNode* last = slow; while(last) &#123; if(last-&gt;val != head-&gt;val) &#123; preSlow-&gt;next = reverseList(slow); return false; &#125; last = last-&gt;next; head = head-&gt;next; &#125; preSlow-&gt;next = reverseList(slow); return true;&#125; 21. Merge Two Sorted Lists 合并两个有序的链表，并将合并结果作为有序链表返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 迭代解法ListNode* mergeTwoLists(ListNode* p, ListNode* q)&#123; // 辅助节点 ListNode head; ListNode* last = &amp;head; while(p &amp;&amp; q) &#123; if(p-&gt;val &lt;= q-&gt;val) &#123; last-&gt;next = p; p = p-&gt;next; &#125; else &#123; last-&gt;next = q; q = q-&gt;next; &#125; last = last-&gt;next; &#125; if(p) last-&gt;next = p; if(q) last-&gt;next = q; return head.next;&#125;// 递归解法ListNode* mergeTwoLists(ListNode* p, ListNode* q)&#123; if(!p) return q; if(!q) return p; ListNode* head = nullptr; if(p-&gt;val &lt;= q-&gt;val) &#123; head = p; head-&gt;next = mergeTwoLists(p-&gt;next, q); return head; &#125; head = q; head-&gt;next = mergeTwoLists(p, q-&gt;next); return head;&#125; 23. Merge k Sorted Lists 给定一个由k个链表头节点所组成的数组，每个链表以升序排列。将所有链表合并为一个排序的链表，然后将其返回。 Example 1: 12345678910Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]Explanation: The linked-lists are:[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]merging them into one sorted list:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 123456789101112131415161718192021222324252627// 将这 k 个头节点交给优先级队列管理// 优先级队列采用最小堆, 以节点内的值为排序对象// 这样每次 pop 的时候保证总是全局所有节点中最小的节点出队ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)&#123; // C++ 中提供的 priority_queue 默认采用最大堆, 这里需要定制成最小堆 auto cmp = [](ListNode* a, ListNode* b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq(cmp); // 所有头节点移交给 priority_queue 管理 for(int i = 0; i &lt; lists.size(); i++) if(lists[i]) pq.push(lists[i]); // 辅助节点 ListNode heade; ListNode* p = &amp;head; while(!pq.empty()) &#123; // 每次将全局最小节点入链出队 p-&gt;next = pq.top(); pq.pop(); p = p-&gt;next; // 放进去的将是最近入链出队的节点的下一个节点 // 这样才能保证在队列中的是全局最小的 k 个节点 if(p-&gt;next) pq.push(p-&gt;next); &#125; return head.next;&#125; 430. Flatten a Multilevel Doubly Linked List 给定一个双向链表，该链表除了拥有指向下一个节点和上一个节点的指针外，还具有一个孩子指针，该孩子指针可能指向也可能不指向单独的双向链接列表。 这些子链表可能有一个或多个自己的子链表，依此类推，以产生一个多级数据结构，如下面的示例所示： 展平链表，以便所有节点都出现在单级双链表中。 返回链表的头。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Definition for a Node.// class Node// &#123;// public:// int val;// Node* prev;// Node* next;// Node* child;// &#125;;// 将题目中的孩子节点看做左孩子, 下一节点看作右孩子Node* flatten(Node* p)&#123; if(!p) return p; // 初始化辅助节点 Node head; head.prev = nullptr; head.next = nullptr; head.child = nullptr; Node* q = head; stack&lt;Node*&gt; nodes; while(p) &#123; // 接纳新节点 q-&gt;next = p; p-&gt;prev = q; q = q-&gt;next; if(p-&gt;child) &#123; // 有左孩子就将其下一节点压入栈 // 并前进到左孩子 Node* temp = p; if(p-&gt;next) nodes.push(p-&gt;next); p = p-&gt;child; // 将此节点的左孩子指针置空 temp-&gt;child = nullptr; &#125; else p = p-&gt;next; // 没有左孩子就直接前进到下一节点 (右孩子) // 如果既没有左孩子也没有右孩子 // 就从栈中取下一节点 if(!p) &#123; if(nodes.empty()) break; p = nodes.top(); nodes.pop(); &#125; &#125; head.next-&gt;prev = nullptr; return head.next;&#125; 61. Rotate List 给定一个单链表的头节点，将链表向右旋转k个位置。 Example 1: 12Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2Output: [4,5,1,2,3] Example 2: 12Input: head &#x3D; [0,1,2], k &#x3D; 4Output: [2,0,1] Example 1 Example 2 123456789101112131415161718192021222324252627282930313233// 首先要注意到:// 1. 旋转了几次, 就会有末尾的几个节点整体次序不变的被平移到前面// 2. 如果旋转了链表长度的倍数次, 链表将恢复原样ListNode* rotateRight(ListNode* head, int k)&#123; if(!head || k == 0) return head; ListNode* p = head; // 首先获取链表的长度 int count = 1; while(p-&gt;next) &#123; p = p-&gt;next; count++; &#125; // 计算实际旋转的次数 k = k % count; // 如果待旋转次数为链表长度的倍数, 不需要旋转 if(k == 0) return head; // 计算新的头节点为第几个节点 k = count - k; // 将 q 定位到新的头节点的前一个节点 ListNode* q = head; while(--k) q = q-&gt;next; // start 为新的头节点 ListNode* start = q-&gt;next; // 前后接在一块即可 q-&gt;next = nullptr; p-&gt;next = head; return start;&#125; 138. Copy List with Random Pointer 给你一个长度为n的链表，每个节点包含一个额外增加的随机指针random，该指针可以指向链表中的任何节点或空节点。 构造这个链表的深拷贝。 深拷贝应该正好由n个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的next指针和random指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。 例如，如果原链表中有X和Y两个节点，其中X.random --&gt; Y。那么在复制链表中对应的两个节点x和y，同样有x.random --&gt; y。 返回复制链表的头节点。 用一个由n个节点组成的链表来表示输入/输出中的链表。每个节点用一个[val, random_index]表示： val：一个表示Node.val的整数。 random_index：随机指针指向的节点索引（范围从0到n - 1）；如果不指向任何节点，则为null。 你的代码只接受原链表的头节点head作为传入参数。 Example 1: 12Input: head &#x3D; [[3,null],[3,0],[3,null]]Output: [[3,null],[3,0],[3,null]] Example 2: 12Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Definition for a Node.// class Node// &#123;// public:// int val;// Node *next;// Node *random;// Node(int _val)// &#123;// val = _val;// next = NULL;// random = NULL;// &#125;// &#125;;// 直接从头节点通过 next 指针, 向后一个一个遍历就可以了// 先拷贝当前节点, 在判断当前节点的 random 指针是否为空// 如果为空, 直接跳到下一个节点就可以了// 如果不为空, 那就将 random 节点 new 一份// 注意当前节点的 random 节点可能已经遍历过或者啊还没有遍历// 1. 如果已经遍历过, 此时只需要将当前节点的拷贝节点的 random 指向它就可以了// 那么我们怎么获取已经遍历过的节点的拷贝节点的指针呢？// 2. 如果没有被遍历过, 直接 new 出来, 再将当前节点的拷贝节点的 random 指向它就行// 但是, 下次通过 next 指针遍历到它的时候, 不能再 new 了, 因为它已经存在了// 解决这个问题的方法就是借助哈希表在遍历的过程中记录当前节点和其拷贝节点之间的映射// 这样在每次遍历新节点的时候先判断是否已经被 new 出来过了// 下面直接看代码吧, 有详细注释Node* copyRandomList(Node* head)&#123; // 记录节点与其拷贝节点之间的映射 unordered_map&lt;Node*, Node*&gt; mapping; // 辅助节点, 方便插入新节点和最后返回 Node helper(0); // last 之后一直指向新链表的尾节点 Node* last = &amp;helper; while(head) &#123; // 如果当前节点的辅助节点已经被 new 过了 if(mapping.count(head)) // 直接将映射值接在后面就行了 last-&gt;next = mapping[head]; else &#123; // 如果没有, 需要重新 new 一个 last-&gt;next = new Node(head-&gt;val); // 之后添加当前节点和被拷贝节点的映射 mapping[head] = last-&gt;next; &#125; // 如果当前节点指向了一个随机节点 // 就要为它的拷贝节点也要指向一个随机节点 if(head-&gt;random) &#123; // 如果这个随机节点已经 new 过了 if(mapping.count(head-&gt;random)) last-&gt;next-&gt;random = mapping[head-&gt;random]; else &#123; // 否则新 new 一个并添加映射 last-&gt;next-&gt;random = new Node(head-&gt;random-&gt;val); mapping[head-&gt;random] = last-&gt;next-&gt;random; &#125; &#125; // 新旧链表当前节点指针同步前进一步 head = head-&gt;next; last = last-&gt;next; &#125; return helper.next;&#125; 1019. Next Greater Node In Linked List 给出一个以头节点head作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。 每个节点都可能有下一个更大值（next larger value）：对于node_i，如果其next_larger(node_i)是node_j.val，那么就有j &gt; i且node_j.val &gt; node_i.val，而j是可能的选项中最小的那个。如果不存在这样的j，那么下一个更大值为0。 Example 1: 12Input: [2,1,5]Output: [5,5,0] Example 2: 12Input: [2,7,4,3,5]Output: [7,0,5,5,0] 123456789101112131415161718192021222324252627282930313233// 像这种下一个最大元素之类的问题, 一定用的是单调栈的技巧// 有几道数组的题目是找下一个最大元素// 这里给换成了链表了, 换汤不换药// 这里主要学习的技术是链表的后序遍历// 对的, 链表就是一种特殊的二叉树嘛// 链表的后序遍历就是从后向前访问节点// 你当然可以用栈来完成// 这里用递归完成vector&lt;int&gt; nextLargerNodes(ListNode* head)&#123; // 存放答案的向量 vector&lt;int&gt; res; stack&lt;int&gt; s; helper(head, s, res); // 最后需要反转一下 vector // 因为递归函数是从后向前添加的 reverse(res.begin(), res.end()); return res;&#125;void helper(ListNode* head, stack&lt;int&gt;&amp; s, vector&lt;int&gt;&amp; res)&#123; // base case if(!head) return; // 先不访问节点, 递归去下一个节点 helper(head-&gt;next, s, res); // 后序遍历代码 // 下面代码都是是固定的单调栈算法的模板 while(!s.empty() &amp;&amp; s.top() &lt;= head-&gt;val) s.pop(); res.push_back(s.empty() ? 0 : s.top()); s.push(head-&gt;val);&#125; 148. Sort List 链表的排序。这里分别给出归并排序的递归版、迭代版以及快速排序版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206// 归并排序, 递归解法// T: O(nlogn), S: O(logn)ListNode* sortList(ListNode* head)&#123; if(!head || !head-&gt;next) return head; ListNode* mid = getMid(head); ListNode* head1 = mid-&gt;next; mid-&gt;next = nullptr; return merge(sortList(head), sortList(head1));&#125;// // 这里的 bug 是如果链表的长度为 2// // 永远返回的是指向第 2 个元素的指针// // 对这个链表的归并排序将永远循环下去!// // tmd 卡了我半天, 艹!// ListNode* getMid(ListNode* head)// &#123;// ListNode* slow = head;// ListNode* fast = head;// while(fast &amp;&amp; fast-&gt;next)// &#123;// slow = slow-&gt;next;// fast = fast-&gt;next-&gt;next;// &#125;// return slow;// &#125;// 这是修正后的版本ListNode* getMid(ListNode* head)&#123; ListNode* slow = nullptr; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow ? slow-&gt;next : head; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125;ListNode* merge(ListNode* p, ListNode* q)&#123; ListNode helper; ListNode* last = &amp;helper; while(p &amp;&amp; q) &#123; if(p-&gt;val &lt; q-&gt;val) &#123; last-&gt;next = p; p = p-&gt;next; &#125; else &#123; last-&gt;next = q; q = q-&gt;next; &#125; last = last-&gt;next; &#125; last-&gt;next = p ? p : q; return helper.next;&#125;// 归并排序, 迭代解法// T: O(n + nlogn), S: O(1)// nextSublist 始终指向后续待归并的链表的头节点ListNode* nextSublist = nullptr;// tail 始终指向已经归并好的局部子链表的尾节点ListNode* tail = nullptr;ListNode* sortList(ListNode* head)&#123; int size = sizeOfList(head); // 辅助头节点 ListNode helper; helper.next = head; // 从长度为 1 开始, 每次成倍增长地归并子链表 for(int i = 1; i &lt; size; i *= 2) &#123; ListNode* start = &amp;helper; nextSublist = helper.next; while(nextSublist) &#123; // 划出 i 个有序节点组成一个链表 ListNode* list1 = split(nextSublist, i); // 再划出 i 个有序节点组成一个链表 ListNode* list2 = split(nextSublist, i); // 将这划分出来的两个相邻有序链表合并 start-&gt;next = merge(list1, list2); start = tail; &#125; &#125; return helper.next;&#125;// 从 head 链表前面划出 size 长度的子链表出来ListNode* split(ListNode* head, int size)&#123; if(!head) return nullptr; ListNode* p = head; while(--size &gt; 0 &amp;&amp; p) p = p-&gt;next; if(p) &#123; // 这里说明 size 小于 head 链表的长度 // 现在 p 指向被划出来链表的尾节点 nextSublist = p-&gt;next; p-&gt;next = nullptr; &#125; else // 如果 size 大于 head 链表的长度 // 说明已经有序了 nextSublist = nullptr; return head;&#125;// 合并两个有序链表, 和递归版本的没区别// 主要是要更新 tail 指针ListNode* merge(ListNode* p, ListNode* q)&#123; ListNode helper; ListNode* last = &amp;helper; while(p &amp;&amp; q) &#123; if(p-&gt;val &lt; q-&gt;val) &#123; last-&gt;next = p; p = p-&gt;next; &#125; else &#123; last-&gt;next = q; q = q-&gt;next; &#125; last = last-&gt;next; &#125; last-&gt;next = p ? p : q; // 更新 tail 指针, 使其指向这被合并完成的有序链表的尾节点 tail = last; while(last-&gt;next) &#123; tail = last-&gt;next; last = last-&gt;next; &#125; return helper.next;&#125;int sizeOfList(ListNode* head)&#123; int size = 0; for(; head; head = head-&gt;next, ++size); return size;&#125;// 快速排序版本, 最差时间复杂度为 O(n2), 会 Time limit exceeded!ListNode* sortList(ListNode* head)&#123; return quickSort(head, nullptr);&#125;// 接收一个左闭右开区间 [head, end)ListNode* quickSort(ListNode* head, ListNode* end)&#123; // base case if(head == end || head-&gt;next == end) return head; // 取首节点元素为基准值 // 凡小于此值的节点以头插法插入到左边 // 凡大于此值的节点以尾插法插入到右边 ListNode* p = head; ListNode* q = head-&gt;next; ListNode* tail = p; while(q != end) &#123; ListNode* next = q-&gt;next; if(q-&gt;val &lt; p-&gt;val) &#123; // 头插法 q-&gt;next = head; head = q; &#125; else &#123; // 尾插法 tail-&gt;next = q; tail = q; &#125; q = next; &#125; // 这行很重要, tail 一直指向右边链表的尾节点 // 要把开区间的之后的节点们接到它后面 tail-&gt;next = end; // 此时, head 指向新链表的头节点 // p 指向新链表的基准节点, 以基准节点作为右边链表的开区间尾元素进行下一次递归调用 ListNode* newHead = quickSort(head, p); // 跳过已经归位的基准节点 p-&gt;next = quickSort(p-&gt;next, end); return newHead;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"认识C++内存管理的工具 （三）","date":"2020-07-18T13:35:42.000Z","path":"gMOP9F0b8zMZULMj/","text":"13. 重载类本身的operator new/delete1234567891011121314151617181920212223242526272829303132333435363738394041using namespace std;struct A&#123; A() &#123; cout &lt;&lt; \"A() : this:\" &lt;&lt; this &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A(): this: \" &lt;&lt; this &lt;&lt; endl; &#125; // 这个函数写不写 static 都会被编译器做成 static static void* operator new(size_t len) &#123; return malloc(len); &#125; static void operator delete(void* ptr, size_t len) &#123; return free(ptr); &#125;&#125;;int main()&#123; // 调用 A::operator new 版本 A* a = new A(); // 调用全局的 operator new, 如果想调用 A 的版本, 则需显式调用 A::operator new() void* b = operator new(sizeof(A)); A* c = ::new A(); // 调用全局的 operator new void* d = ::new A(); // 调用全局的 operator new delete a; // 先调用 A 的析构函数, 再调用 A 的 operator delete delete b; // 直接调用了全局的 operator delete ::delete c; ::delete d;&#125; 14. 本质就是重载newnew是关键字，编译器看到new，会转换成operator new的调用。 15. 重载new()/delete() 16. 关于多参new对应的delete 上面重载了参数不一的operator new()，那是不是要重载对应的operator delete()呢？ 理论上delete的工作只是为了释放内存，所以只需要一个指针就可以了，但C++在语法上支持多参的delete重载，但delete的调用格式只有delete ptr，所以关于重载的delete版本什么时候被调用，并不是用户手动调用，而是对应版本的Ctor发生异常后，会由crt来调用对应的delete。 17. basic_string使用new(extra)扩充申请量 18. new_handler","tags":[{"name":"C++内存管理","slug":"C-内存管理","permalink":"https://yuanlehome.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"认识C++内存管理的工具 （二）","date":"2020-07-08T13:35:42.000Z","path":"vgFO35JETZ2jRu74/","text":"7. 构造和析构的直接调用方式通过指针不可以直接调用构造函数，但可以直接调用析构函数。可以通过placement new来直接调用构造函数。 123456789101112131415161718192021struct A&#123; int a; int b; A(int _a, int _b) : a(_a), b(_b) &#123;&#125;&#125;;int main()&#123; A* tmp_a = new A(2, 8); // tmp-&gt;A::A(2, 8); // error! cannot call constructor 'A::A' directly tmp_a-&gt;~A(); // 可以的 // 虽然调用了析构函数, 但事实上 tmp_a 的空间并没有释放 // 因为没有 free 掉, 那块内存还在, 值没有被重写 // 所以可以访问 通过 tmp_a 访问原对象的值 // 如果是 delete tmp_a; 就不能访问 // 因为 delete 调用完析构函数之后, 还调用了 free 函数释放那块内存 cout &lt;&lt; tmp_a-&gt;a &lt;&lt; endl; // 所有这里访问的值看似没有变化&#125; 8. array new/deletenew []/delete[]本质调用malloc/free。malloc/free细节： 除了分配给定的内存之外，还会有cookie——用来记录分配数组的长度，查看cookie中的长度，然后调用适当次数的析构函数 所谓内存泄漏 对于一个new []，需要有相应的delete []，本质上cookie记录了free本身需要释放的内存大小，泄露则发生在调用的析构函数次数上：如果对象含有指针的data member，指向堆上的内存，则意味着析构函数是nontrival，需要再析构函数中释放指针指向的内存，反之则是trival的，而析构函数的调用次数，则会影响指针指向的内存部分的泄露。 9. placement new标准不允许直接用指针调用构造函数，但给出了另一种调用语法，可以在现有的对象的内存中调用构造函数，它不会分配新的内存。这也是没有对应的placement delete的原因。 10. C++程序分配内存的途径 从图中可以看出，当出现new Foo(x)后，编译器会检查Foo这个类有没有实现operator new(size_t)的static函数，如果有就会调用Foo这个版本的operator new，如果没有就调用全局的::operator new，delete也是如此。 所以可以为一个类单独实现operator new和operator delete。也可以重载全局的operator new/delete，但很少这么做，因为全局的版本是照顾所有的类。 11. 探究operator new12345678910111213int main()&#123; A* a = new A(); new (a) A(27, 224); void* b = ::operator new(sizeof(A)); cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; a-&gt;a &lt;&lt; endl; cout &lt;&lt; a-&gt;b &lt;&lt; endl;&#125;// 汇编代码如下: 12. 重载::operator new/delete上面说了，重载全局的operator new/delete影响深远，谨慎使用。但可以重载，方法是在非namespace中声明和全局版本相同的函数签名。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using namespace std;struct A&#123; int a; int b; A() &#123; cout &lt;&lt; \"A() : this:\" &lt;&lt; this &lt;&lt; endl; &#125; A(int _a, int _b) : a(_a), b(_b) &#123; cout &lt;&lt; \"A(int,int): this: \" &lt;&lt; this &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A(): this: \" &lt;&lt; this &lt;&lt; endl; &#125;&#125;;// 以下 4 个函数就在当前的文件中声明定义inline void* operator new(size_t len)&#123; return malloc(len); &#125;inline void* operator new[](size_t len)&#123; return malloc(len);&#125;inline void operator delete(void* ptr)&#123; return free(ptr);&#125;inline void operator delete[](void* ptr)&#123; return free(ptr);&#125;int main()&#123; A* a = new A(); // 调用到上面自定义的 operator new void* b = ::operator new(sizeof(A)); // 虽然指定的是 ::operator new, 但还是调用到上面自定义的版本 // 对于 a 是正确的释放, 先调用 A 的析构函数, 再调用上面的 operator delete delete a; // 对于 b, 释放的操作应该显示调用 operator delete // 这里用 delete 后, 并没有调用 A 的析构函数, 而是直接调用了 operator delete // 可见编译器对于 delete void* 的时候, 是直接转换为 opreator delete delete b;&#125;","tags":[{"name":"C++内存管理","slug":"C-内存管理","permalink":"https://yuanlehome.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"认识C++内存管理的工具 （一）","date":"2020-06-28T13:35:42.000Z","path":"kZo0999uFp6r1QI2/","text":"1. 内存管理函数的层次从下图中可以看到，C++程序员处于的位置是最上层的Applications，用的最多的是new，new[]，如果用容器，则内存基本不用管理。其次也可以调用malloc。至于最底层的操作系统级别的API，没有可移植性。它们之间的调用关系如上图的箭头所示。 2. Memory primitives分类 分配 释放 所属 可否重载 malloc free C函数 否 new delete C++表达式 否 ::operator new() ::operator delete() C++函数 可 allocator&lt;T&gt;::allocate() allocator&lt;T&gt;::deallocate() STL分配器 可以自己设计搭配容器 123456789101112131415161718void primitives_sample()&#123; // CRT 运行时函数 void *p1 = malloc( 512 ); free( p1 ); // new complex&lt;int&gt; *p2 = new complex&lt;int&gt;; delete p2; // ::operator new() 全局函数, 可被重载 void *p3 = ::operator new( sizeof( int ) ); // 内部调用 malloc ::operator delete( p3 ); //内部调用delete // allocator 分配器, STL 容器分配内存的方式 void *p4 = allocator&lt;int&gt;().allocate( 7 ); allocator&lt;int&gt;().deallocate( (int *)p4, 7 );&#125; 3. new的初步探究c++的程序员基本都会用new来为对象分配一个堆内存，并且new会调用对应的构造函数，构造函数是用来初始化对象的，所以总结出new的功能是： 在堆中分配一块指定对象大小的内存 将返回的指针转换为指向对象类型的指针 通过指针调用对象相应的构造函数 4. 测试new的调用流程12345678910111213struct A&#123; int a; int b; A() &#123;&#125; A(int _a, int _b): a(_a), b(_b) &#123;&#125;&#125;;int main()&#123; A* tmp_a = new A(2, 8); delete tmp_a;&#125; 上面的4张图是在MSVC中反汇编的运行时代码。从第1张图可以看出，new调用了operator new，从第3张图可以看出，operator new内部调用了malloc。实际上编译器是在new的地方调用了对应的构造函数，并不是在new的内部，new只是编译器识别的一个标识符，并不是函数，编译器看到new后会malloc，然后调用构造函数。 VS2019可以看到operator new的源码： 123456789101112131415161718192021222324_CRT_SECURITYCRITICAL_ATTRIBUTEvoid* __CRTDECL operator new(size_t const size)&#123; for (;;) &#123; if (void* const block = malloc(size)) &#123; return block; &#125; if (_callnewh(size) == 0) &#123; if (size == SIZE_MAX) &#123; __scrt_throw_std_bad_array_new_length(); &#125; else &#123; __scrt_throw_std_bad_alloc(); &#125; &#125; // The new handler was successful; try to allocate again... &#125;&#125; 上面的operator new的作用是调用malloc分配内存。当malloc成功后直接返回。当malloc失败后，并不会再次malloc，而是调用_callnewh() new_handler()，这个函数的作用是向自己定义的函数索取内存，所以new_handler可以理解为释放一些缓存，调用完new_handler后，可能释放了内存，这个时候再尝试调用malloc获取内存。 5. delete的初步探究 6. 测试delete的调用流程12345678910111213141516using namespace std;struct A&#123; int a; int b; A() &#123;&#125; A(int _a, int _b) : a(_a), b(_b) &#123;&#125; ~A() &#123;&#125;&#125;;int main()&#123; A* tmp_a = new A(2, 8); delete tmp_a;&#125;","tags":[{"name":"C++内存管理","slug":"C-内存管理","permalink":"https://yuanlehome.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"深度探索C++对象模型之构造、析构、拷贝语意学","date":"2020-06-18T13:35:42.000Z","path":"plA8MQtWi85PlNcz/","text":"第5章：构造、析构、拷贝语意学 可以定义和调用一个纯虚函数，不过只能被静态的调用（通过类作用域运算符），不能通过虚拟机制调用。 你声明了一个纯虚析构函数，就必须定义它。因为在你提供了声明前提下，每一个derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。因此，只要缺乏任何一个base class destructor的定义，就会导致链接失败。 读到这儿，你可能会有疑问，对于普通的类（没有虚机制参与进来，派生类的析构函数中也会逐一调用基类的析构函数）我们也没有提供它析构函数的，那为什么不会导致链接失败呢？这是因为你没有写析构函数，编译器会默默给你提供一个，以便于在后面的派生类的析构函数中调用它。这里的重点是你没有提供，也就是说你没有声明，如果你声明了，但没有提供定义，同样会导致链接失败。 对于基类该不该将虚函数定义为const的，作者不建议。因为derived class中可能会修改自己的数据成员。 5.1 无继承情况下的对象构造当编译器遇到这样的定义： 1Point global; 在C之中，global被视为一个“临时性的定义”，因为它没有明确的初始化操作。一个“临时性的定义”可以在程序中发生多次。那些实例会被链接器折叠起来，只留下单独一个实体，被放在程序data segment中一个“特别保留给未初始化之global objects使用”的空间。由于历史的缘故，这块空间被称为BSS，是Block Started by Symbol的缩写。 而global在C++中被视为完全定义（它会阻止第二个或更多个定义）。C和C++的一个差异就在于，BSS data segment在C++中相对地不重要。C++的所有全局对象都被当作“初始化过的数据”来对待。 为继承做准备 虚函数的引入不仅仅是每个类对象增加了一个vptr，而且会引发编译器对类产生膨胀作用。我们所定义的构造函数，编译器会附加一些代码，以便vptr初始化。合成一个copy constructor和一个copy assignment operator，它们都不是trival。因为，如果point类对象被初始化或以一个派生类对象赋值，bitwise操作就存在问题了，vptr设置会出错。 C++编译器要求编译器尽量延迟nontrivial members的实际合成操作，直到遇到使用场合为止。如果在你的设计中存在很多以传值的方式返回局部类对象，提供一个拷贝构造函数就比较合理，因为这会触发编译器的NRV优化。 5.2 继承体系下的对象构造constructor可能内带大量的隐藏码，因为编译器会扩充每一个constructor，扩充程度视class T的继承体系而定。一般而言编译器所做的扩充操作大约如下： 记录在member initialization list中的data members初始化操作会被放进constrector的函数本身，并以members的声明顺序为顺序。 如果有数据成员为类对象，并被列于member initialization list中，那么任何明确指定的参数都应该传递过去。 如果有一个member并没有出现在member initialization list之中，但它有一个default constructor，那么该default constructor必须被调用。 在那之前，如果class object有vptr，它（们）必须被设定初值，指向适当的virtual table(s)。 在那之前，所有上一层的base class constructors必须被调用，以base class的声明顺序为序： 如果basc class被列于member initialization list中，那么任何明确指定的参数都应该传递过去。 如果base class没有被列于member initialization list中，而它有default constructor(或default memberwise copy constructor)，那么就调用之。 如果base class是多重继承下的第二或后继的base class，那么this指针必须有所调整。 在那之前，所有virtual base class constructors必须被调用，从左到右，从最深到最浅： 如果class被列于member initialization list中，那么如果有任何明确指定的参数，都应该传递过去。若没有列于list之中，而class有一个default constructor，也应该调用之。 此外，class中的每一个virtual base class subobject的偏移量必须在执行期可被存取。 如果class object是最底层（most-derived）的class，其constructors可能被调用；某些用以支持这个行为的机制必须被放进来。 说明书中接下来的章节对上面这些做了详细的叙述。全是重点，就不做总结了，自行看书。 第6章：执行期语意学很重要，不做总结了，自行看书。","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"实现一个在windows平台的定时更换壁纸的工具","date":"2020-06-14T05:00:42.000Z","path":"JFfWe2Uugfh1u70r/","text":"有没有感觉到自己的电脑桌面一成不变让人厌倦？虽然有一些诸如360桌面之类的软件可以使用，但弹窗、广告又太多！本文就教你用 python 实现一个简洁清爽的桌面壁纸定时更换工具。 本文使用的方法是用 python 实现一个定时更换壁纸的脚本，壁纸来源与自定义的文件夹内，因此你可以搜集一些你喜欢的壁纸图片放于该文件夹下，这样脚本程序便可以使你的电脑桌面轮流展示这些图片了。 比如我就把我喜欢的壁纸都收集在了 E:/wallpapers/ 文件夹下。 这里推荐几个好的壁纸来源网站 https://wallhaven.cc/ ，https://www.artstation.com/wlop 。 下面直接看代码。 1234567891011121314151617181920212223import win32conimport win32guiimport threadingimport osdef getImages(): # 这里的路径就是你放图片的文件夹路径 images_path = 'E:\\\\wallpapers\\\\' files = os.listdir(images_path) return images_path, filesdef set_wallpaper(it): path, images = getImages() image = path + images[it] it = (it + 1) % len(images) win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, image, 1+2) global timer # 我设置的是每60s更换一次，你可以根据需要自定义设置 timer = threading.Timer(60.0, set_wallpaper, (it,)) timer.start()if __name__ == '__main__': set_wallpaper(0) 为了方便运行，我们可以使用 pyinstaller 工具将该脚本程序转成 .exe 可执行文件。具体的方法可以看这篇文章 Python程序打包成exe可执行文件 。 生成可执行文件之后，运行就可以了。不过，为了每次开机程序都可以自动运行，我们需要进行一些设置。首先按 win+R 键打开运行窗口，输入 shell:startup 回车，这样会打开一个启动文件夹，这个文件夹下的软件在开机时都会自动启动，将你的可执行文件或其快捷方式放在这里就可以了。 这里可以直接下载我已经生成的可执行程序： https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q提取码：v9ng 使用方法就是在E盘下新建一个名为wallpapers的文件夹，然后把自己喜欢的照片放进去就好，即E:/wallpapers/ 。","tags":[{"name":"桌面壁纸工具","slug":"桌面壁纸工具","permalink":"https://yuanlehome.github.io/tags/%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"https://yuanlehome.github.io/tags/python/"}]},{"title":"实现一个简易的Linux平台下的划词翻译工具","date":"2020-06-12T13:35:42.000Z","path":"KT2Sz9hHwziaJtFt/","text":"这里将要介绍的是一种在 Linux 平台实现的划词翻译工具，当然在考虑自己实现一个如此功能的工具前，本人也是在网上搜索了一些在 Linux 平台实现的类似的开源工具，例如 pdfTranslator，popup-dict，但它们的安装和配置都显得比较麻烦，而且使用起来也并不方便。 本人实现这个工具的初衷本是方便自己看一些英文文献和书籍的，极为方便，考虑到分享出去可以让更多人受惠，因此这里详细介绍一下它的实现步骤。 本文所实现的划词翻译工具主要有以下特性： 支持英文单词和短语到中文的翻译 划词翻译，终端显示 自动过滤选中文本中的换行等特殊字符 只依赖少数几个 Linux 命令工具 下面有动图进行演示。 本人所使用的环境是运行在 VMware 虚拟机下的 Linux 发行版 Ubuntu 18.04.3 LTS ，因此这里介绍的步骤可能与其他 Linux 发行版中的实现略有不同。下面就来一步一步的实现它吧。 一. 安装必要的命令 xclip 1$ sudo apt install xclip xclip 命令建立了终端和剪切板之间通道，可以用命令的方式将终端输出或文件的内容保存到剪切板中，也可以将剪切板的内容输出到终端或文件。详细的用法可以使用 man xclip，见其手册。这里介绍几个常用的用法。 1234$ xclip file_name # 文件内容保存到X window剪切板$ xclip -selection c file_name #文件内容保存到外部剪切板$ xclip -o # X window剪切板内容输出到终端显示$ xclip -selection c -o # 外部剪切板内容输出到终端显示 值得强调的是，这里所说的 X window 剪切板，简单的说就是你用鼠标选择的文本会实时的存放在这个剪切板，使用鼠标中键可以粘贴。而外部剪切板是保存你用 ctrl+c 复制的文本，ctrl+v 可以粘贴。这两个地方是不一样的。 translate-shell 1$ sudo apt install translate-shell 这是命令行版的谷歌翻译工具，之前叫做 Google Translate CLI 是一款借助谷歌翻译（默认）、必应翻译等来翻译的命令行翻译器。它让你可以在终端访问这些翻译引擎。 translate-shell 在大多数 Linux 发行版中都能使用。常用的方法如下： 12$ trans en:zh [word] # 英文到中文的单词翻译$ trans en:zh -b [text] # 简要的输出，进行文本翻译 需要注意的是，使用这个翻译工具需要你能够访问外网，或者通过修改 translate-shell 的默认翻译引擎，具体的方法这里就不阐述了。 二. 编程实现这个工具整体的思路就是 C 程序实时检测鼠标按键的动态，当检测到用户使用鼠标选择一段文本之后，调用 shell 脚本获取 X window 剪切板的内容进行翻译后输出到终端显示。 1. 定位鼠标设备文件 鼠标作为输入设备。其信息可以在文件 /proc/bus/input/devices 中，使用下列命令查看： 1234567891011$ sudo cat /proc/bus/input/devicesI: Bus=0011 Vendor=0002 Product=0013 Version=0006N: Name=\"VirtualPS/2 VMware VMMouse\"P: Phys=isa0060/serio1/input1S: Sysfs=/devices/platform/i8042/serio1/input/input4U: Uniq=H: Handlers=mouse0 event2 B: PROP=0B: EV=bB: KEY=70000 0 0 0 0B: ABS=3 其中的 Handlers 的值 event2 表示可以在 /dev/input/event2 文件下读取鼠标的状态。需要注意的是，对于不同的设备，读取鼠标的状态的文件可能不一样，比如也可能是 /dev/input/event3。我们可以使用下面的命令找到你的鼠标对应的是哪一个 event。 1$ sudo cat /dev/input/event2 | hexdump # 测试时改变数字即可 比如，当我运行上面这条命令之后，我移动鼠标、按鼠标左键/中键/右键，终端都会输出一些值，这就说明 event2 文件就是对应着我的鼠标。如果操作鼠标没有反应，说明这个就不是。你可以通过这种方法找到你的鼠标对应的 event 文件。 2. Linux 下获取按键响应 在 Linux 内核中，input 设备用 input_dev 结构体描述，使用 input 子系统实现输入设备驱动的时候，驱动的核心工作就是向系统报告按键、触摸屏、键盘、鼠标等输入事件（event*，通过 *input_event 结构体描述），不再需要关心文件操作接口，因为 input 子系统已经完成了文件操作接口 Linux/input.h 这个文件定义了 event 事件的结构体，API 和标准按键的编码等。 1234567891011121314151617181920212223242526// 结构体定义见 input.hstruct input_event&#123; struct timeval time; // 按键时间 __u16 type; // 事件类型 __u16 code; // 要模拟成什么按键 __s32 value; // 是按下还是释放&#125;;// 下面宏定义见 input-event-coses.h// type#define EV_KEY 0x01#define EV_REL 0x02#define EV_ABS 0x03// ...// code#define BTN_LEFT 0x110#define BTN_RIGHT 0x111#define BTN_MIDDLE 0x112// ...// value#define MSC_SERIAL 0x00#define MSC_PULSELED 0x01// ... 这里稍微介绍一下 type，指事件类型，常见的事件类型有：EV_KEY，按键事件，如键盘的按键（按下哪个键），鼠标的左键右键（是否击下）等；EV_REL，相对坐标，主要是指鼠标的移动事件（相对位移）；EV_ABS， 绝对坐标，主要指触摸屏的移动事件 。 3. 编写 C 程序 下面就可以编写程序来检测鼠标的动态了。首先在你的用户~目录下建立文件夹 Translator*。在 *Translator 里建立一个 ct.c 源文件，代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/input.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int keys_fd; struct input_event t; // 注意这里打开的文件根据你自己的设备情况作相应的改变 keys_fd = open(\"/dev/input/event2\", O_RDONLY); if (keys_fd &lt;= 0) &#123; printf(\"open /dev/input/event2 error!\\n\"); return -1; &#125; while (1) &#123; read(keys_fd, &amp;t, sizeof(t)); if (t.type == EV_KEY) // 有键按下 if (t.code == BTN_LEFT) // 鼠标左键 if (t.value == MSC_SERIAL) // 松开 // 调用外部shell脚本 system(\"~/Translator/goTranslate.sh\"); &#125; close(keys_fd); return 0;&#125; 然后就是调用 gcc 编译器生成可执行文件 ct： 1$ gcc ct.c -o ct 4. 编写 shell 脚本翻译剪切板内容 在 Translator 里建立 goTranslate.sh 文件，内容如下： 123456789101112131415#!/bin/bashstr_old=$(cat ~/Translator/lastContent)str_new=$(xclip -o 2&gt;/dev/null | xargs)if [[ \"$str_new\" != \"$str_old\" &amp;&amp; $str_new ]]; then echo -e \"\\n\" count=$(echo \"$str_new\" | wc -w) if [ \"$count\" == \"1\" ]; then echo -n -e \"$str_new \" &gt;&gt;~/Translator/words echo \"$str_new\" | trans :zh-CN | tail -1 | cut -c 5- | sed \"s,\\x1b\\[[0-9;]*[a-zA-Z],,g\" | tee -a ~/Translator/words else echo \"$str_new\" | trans :zh-CN -b fi echo \"$str_new\" &gt;~/Translator/lastContentfi 原理非常简单，读者自行了解。这里我们还要在 Translator 里建立一个 lastContent.txt 文件作为缓存，目的是本次调用脚本时能够获取上一次调用时翻译的文本内容，如果和本次调用的翻译文本一样，则本次就不进行翻译。 *5. 设置 *ct 别名 ** 这里已经可以通过下面的命令运行程序了： 1$ sudo ~/Translator/ct 但是由于每次运行都要输出这么长的命令，因此我们在 ~/.bashrc 文件中加入下面一条命令。 1alias ct='sudo ~/Translator/ct' 这样，以后每次看英文文献时就可以在命令行下输入： 1$ ct 三. 结束语这里有一些小技巧。可以更方便的使用这个工具。比如，把终端设为置顶并缩小到合适的尺寸，这样在阅读文献划词翻译时终端屏幕不会遮挡我们的视线。 值得说明的是，由于本人完全是为了方便自己的使用，而且在搞出这么个工具时仅仅接触 Linux 系统才不到两周，所以里面的实现对于有经验的朋友来说略显的有些笨拙了，请理解哈。 个人觉得这个工具使用起来还是很方便的，你觉得呢？ 参考文章： https://blog.csdn.net/liang12360640/article/details/50350648 https://www.cnblogs.com/yangwindsor/articles/3454955.html https://blog.csdn.net/liang12360640/article/details/50s350648","tags":[{"name":"划词翻译","slug":"划词翻译","permalink":"https://yuanlehome.github.io/tags/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/"},{"name":"Linux","slug":"Linux","permalink":"https://yuanlehome.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://yuanlehome.github.io/tags/shell/"}]},{"title":"深度探索C++对象模型之function语意学","date":"2020-06-08T13:35:42.000Z","path":"rRW3gD4CDal4WhRJ/","text":"第4章：Function语意学4.1 静态成员函数function的调用方式 nonmember function、static member function、nonstatic member function的调用效率完全一样，因为，在内部都被编译器处理成相同的形式。而virtual member function的调用需要通过vptr所指向的virtual table，因此，效率有所降低。 static member function的主要特性就是它没有this指针。以下的次要特性统统根源于其主要特性： 它不能够直接存取其class中的nonstatic members； 它不能够被声明为const、volatile或virtual； 它不需要经由class object才被调用——虽然大部分时候它是这样被调用的。 若取一个static member function的地址不会得到指向其class member function类型的指针（不是return_type (class_type::*)(parameter_types)）。而是一个non-member函数指针（类型为return_type (*)(parameter_types)）。 4.2 虚拟成员函数在C++中，多态表示以一个指向public base class类型的pointer或reference，寻址出一个derived class object的意思。多态机能体现在通过pointer或reference对虚函数的调用身上。因此，识别一个class是否支持多态，唯一适当的方法就是看看它是否有任何virtual function。 为了支持多态，需要在执行期决议出正确的virtual function实例，这需要如下执行期信息的支持： 它所引用的对象的地址，也就是当前它自身的值； 所引用对象的真实类型。这可使我们选择正确的虚函数所在的实体； virtual function实体位置，也就是函数地址，以便我能够调用它。 在实现上，在每一个多态的class object身上增加两个member： 一个字符串或数字，表示class的类型； 一个指针，指向某表格，表格中带有程序的virtual function的执行期地址。 virtual function的地址是固定不变的，执行期不可能新增或替换，而表格的大小和内容在执行期不会改变，因此其建构和存取皆在编译期就可以完成。 为了找到virtual function的地址，需要： 为了找到表格，每一个class object被安插上一个由编译器内部产生的指针，指向该表格； 为了找到函数地址，每一个virtual function被指派一个表格索引值。 这些工作都由编译器完成。执行期要做的，只是在特定的virtual table slot（记录着virtual function的地址）中调用virtual function。这些virtual function可以是： 这个class所定义的函数实体。它override了一个base class virtual function函数实体； 继承自base class的函数实体。这是在derived class中决定不override的virtual function时的情况； 一个pure_virtual_called()函数实体。它既可以扮演pure virtual function的空间保卫者角色，也可以当做执行期异常处理函数（有时候会用到）。 单一继承 例如，对于如下的单一继承体系： virtual destriucior被赋值slot 1，而mult()被赋值slot 2。此例并没有mult()的函数定义，因为它是一个pure virtual function，所以pure _virtual_called()的函数地址会被放在slot 2中。如果该函数意外地被调用，通常的操作是结束掉这个程序。y()被赋值slot 3而z()被赋值slot 4。x()没有slot，因为x()并非virtual function。 此时，一共有三种可能性： 它可以继承base class所声明的virtual function的函数实体。正确地说，是该函数实体的地址会被拷贝到derived class的virtual table相对应的slot之中； 它可以使用自己的函数实体。这表示它自己的函数实体地址必须放在对应的slot之中； 它可以加人一个新的virtual function。这时候virtual table的尺寸会增大一个slot，而新的函数实体地址会被放进该slot之中。 Point2d的virtual table在slot 1中指出destructor，而在slot 2中指出mult()取代pure virtual function。它自己的y()函数实体地址放在slot 3，继承自Point的z()函数实体地址则放在slot 4。 类似的情况： Point3d的virtual table中的slot 1放置Point3d的destructor，slot 2放置Point3d::mult()函数地址。slot 3放置继承自Point2d的y()函数地址，slot 4放置自己的z()函数地址。 这个继承体系中的三个类的virtual table布局如下所示： 现在，如果我们有这样的式子: 1ptr-&gt;z(); 那么，我如何有足够的知识在编译时期设定virtual function的调用呢？ 一般而言，我并不知道ptr所指对象的真正类型。然而我知道，经由ptr可以存取到该对象的virtual table； 虽然我不知道哪一个z()函数实体会被调用，但我知道每一个z()函数地址都被放在slot 4。 这些信息使得编译器可以将该调用转化为： 1(*ptr-&gt;vptr[4])(ptr); 在一个单一继承体系中，virtual function机制的行为十分良好，不但有效率而且很容易塑造出模型。但是在多重继承和虚拟继承之中，就呵呵了。 多重继承和虚拟继承 懒得总结了，看是看懂了，乱七八糟的！ 4.3 指向Member Function的指针取一个nonstatic member function的地址，如果该函数是nonvirtual，则得到的结果是它在内存中真正的地址。然而这个值也是不完全的，它也需要被绑定于某个class object的地址上，才能够通过它调用该函数（以参数this指出）。 回顾一下，一个指向member function的指针，其声明语法如下： 1double (Point::*pmf)(); 然后我们可以这样定义并初始化该指针： 1double (Point::*coord)() = &amp;Point::x; 也可以这样指定其值： 1coord = &amp;Point::y; 想调用它，可以这么做： 123(origin.*coord)();// 或(ptr-&gt;*coord)(); 这些操作会被编译器转化为： 123(coord)(&amp;origin);// 和(coord)(ptr); 获得该函数在内存中的地址。然而面对一个virtual function，其地址在编译时期是未知的，所能知道的仅是virtual function在其相关之virtual table中的索引值，也就是说，对一个virtual member function取其地址，所能获得的只是一个索引值。 那么问题来了，假设我们有以下的Point声明： 1234567class Point&#123;public: // ... virtual ~Point(); virtual float z();&#125;; 取z()函数的地址得到的索引值是2，而不是函数地址。 12float (Point::*pmf)() = &amp;Point::z;Point *ptr = new Point3d; 那么如果通过pmf来间接调用z()函数的话： 12345(ptr-&gt;*pmf)();// 转化为(*ptr-&gt;vptr[(int)pmf]5(ptr); 那么如何知道pmf指向的是virtual function还是nonvirtual function，毕竟pmf如果对nonvirtual function取地址的话得到的是在内存中的地址。也就是说，pmf的内部定义需要允许该函数能够寻址出nonvirtual和virtual两个member function。 同时为了让执行member function的指针也能支持多重继承和虚拟继承，实现方法为使用一个结构体： 1234567891011// 用以支持在多重继承之下指向 member function 的指针struct __mptr&#123; int delta; int index; // virtual 函数 在 virtual table 的索引, 当 index 不指向 virtual table 时值为 -1 union &#123; ptrtofunc faddr; // nonvirtual 函数的地址 int voffset; &#125;;&#125;; 在这样的模型下： 12345(ptr-&gt;*pmf)();// 转化为(pmf.inidex &lt; 0) ? (*pmf.faddr)(ptr) : (*ptr-&gt;vptr[pmf.index](ptr)); 4.4 inline函数","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"深度探索C++对象模型之data语意学","date":"2020-05-28T13:35:42.000Z","path":"ShyaVw4WHERlLCqZ/","text":"第3章：Data语意学The size of class 12345678class X&#123; // char c; // 此时, sizeof(X) == 1, sizeof(Y) == 8, sizeof(Z) == 8, sizeof(A) == 16 char c; // 此时, sizeof(X) == 1, sizeof(Y) == 16, sizeof(Z) == 16, sizeof(A) == 24&#125;;class Y : public virtual X &#123; &#125;;class Z : public virtual X &#123; &#125;;class A : public Y, public Z &#123; &#125;; 一个类的大小主要受三个因素的影响： 语言支持的特性所造成的负担 比如，含虚函数的类会额外多一个vptr指针，含virtual base class会再多一个额外的指针（它或者指向virtual base class subobject，或者指向一个相关表格；表格中存放的若不是virtual base class subobject地址，就是其偏移量）。 编译器对于特殊情况所提供的优化处理 现代编译器的对于空基类的优化处理：一个empty virtual base class被视为derived class object最开头的一部分，也就是说它并没有花费任何的额外空间。因为既然有了members，就不需要原本为了empty class而安插的一个char。 alignment（内存对齐） 就是将数值调整到某数的整数倍。在64位计算机上，通常alignment为8 bytes，以使bus的“运输量”达到最高效率。 nonstatic data members放置的是“个别的class object”感兴趣的数据，static data members则放置的是“整个class”感兴趣的数据。 static data members被放置在程序的一个global data segment中，不会影响个别的class object的大小。在程序之中，不管该class被产生出多少个objects（经由直接产生或间接派生），static data member永远只存在一份实体（即使该class没有任何object实体，其static data members也已存在）。 3.1 data member的绑定类成员函数的argument list中的名称会在它们第一次遭遇时被适当地决议（resolved）完成。因此在extern和nested type name之间的非直觉绑定操作还是会发生。例如在下面的程序片段： 12345678910111213141516typedef std::string length;class Test&#123;public: // 参数列表中的 length 被决议成 std::string!!! // 里面的 val_ 被正确决议成 int void setVal(length val) &#123; val_ = val; &#125;private: typedef int length; length val_;&#125;; 所以这需要使用防御性的程序风格：将nested type name写在class的起始处！ 3.2 数据成员的布局下面这个template function，接受两个data member，然后判断谁先出现在class object之中。如果两个member都是不同的access sections中的第一个被声明者，此函数就可以用来判断哪一个section先出现： 123456template&lt;class class_type, class data_typel, class data_type2&gt;std::string access_order(data_type1 class_type::* mem1, data_type2 class_type::* mem2)&#123; assert(mem1 != mem2); return mem1 &lt; mem2 ? \"member 1 occurs first\" : \"member 2 occurs first\";&#125; 上述函数可以这样被调用： 1access_order(&amp;Point3d::y, &amp;Point3d::z); 3.3 data member的存取static data member 对于类中的静态数据成员，通过一个指针和通过一个对象来存取，效率完全相同，不论这个静态数据成员经过了多么复杂的继承体系。 若取一个static data member的地址不会得到指向其class member的指针（不是value_type class_type::*类型）。而是指向其数据类型的指针（类型为value_type*）。 12345678910111213141516171819class Point&#123;public: static int x; void func1() &#123; &#125; static void func2(int a) &#123; &#125;&#125;;int Point::x = 0;int main()&#123; auto p = &amp;Point::func1; // p 的类型是 void (Point::*p)() auto q = &amp;Point::func2; // q 的类型是 void (*q)(int a) auto p = &amp;Point::x; // r 的类型是 int* r&#125; 构造函数不能是静态成员函数：如果构造函数是静态成员函数，那么将不能访问非静态变量，也没办法完成初始化的工作。 non static data member 对于类中的非静态数据成员，通过一个指针和通过一个对象来存取，当此数据成员属于继承而来的virtual base class时，使用指针效率较低。如果使用对象直接存取，就不会有这些问题，其类型无疑是确定的，而即使它继承自virtual base class，members的offset位置也在编译时期就固定了。 欲对一个nonstatic data member进行存取操作，编译器需要把class object的起始地址加上data member的偏移量。举个例子： 1&amp;origin._y == &amp;origin + (&amp;Point3d::_y - 1); 请注意其中的-1操作。指向data member的指针，其offset值总是被加上1，这样可以使编译系统区分出是用以指出class的第一个member还是没有指出任何member的两种情况。 3.4 C++对象布局 个别struct的数据布局 单一继承而且没有virtual function时的数据布局 C++语言保证——出现在derived class中的base class subobject有其完整原样性 单一继承并含虚拟函数情况下的数据布局 多重继承 虚拟继承，使用pointer strategy和virtual table offset strategy 3.5 指向data member成员的指针取一个nonstatic data member的地址，将会得到它在class中的offset（指针类型为data_type class_type::*），取一个“绑定于真正class object身上的data member”的地址，将会得到该member在内存中的真正地址（指针类型为data_type*）。","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"深度探索C++对象模型之构造函数语意学","date":"2020-05-18T13:35:42.000Z","path":"FXn6nXyz1FEw9e8Y/","text":"第2章：构造函数语意学在这一章中，主要介绍编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”的冲击。 2.1 Default Constructor的构造操作对于未声明构造函数的类，只有在以下四种情况下编译器才会为它们合成默认构造函数： 类有一个类对象（Member Class Object）成员，且该成员含有默认构造函数（Default Constructor） 继承自带有默认构造函数（Default Constructor）的基类（Base class） 带有虚函数（Virtual function）的类 继承自虚基类（Virtual base class）的类 对于以上四种情况，C++标准把合成的默认构造函数叫隐式的有意义默认构造函数(implicit nontrivial default constructors)。被合成的构造函数只能满足编译器（而非程序）的需要，它之所以能够完成任务，是借着调用成员对象或基类的默认构造函数（情况1/2），或是为每一个对象初始化其虚函数机制或虚基类机制（情况3/4）。 至于没有存在上述四种情况，而又没有声明任何构造函数的类，那么它们拥有的是隐式无意义默认构造函数(implicit trivial default constructors)，实际上它们并不会被合成出来。 Default Constructor会在编译器需要的时候被产生出来，被合成出来的Constructor只执行编译器所需要的行为。如果程序有需要，定制Default Constructor的行为是程序员的责任。 “带有Default Constructor”的Member Class Object 如果有多个class member objects都要求constructor初始化操作，将如何呢？C++语言要求以“member objects在class中的声明次序”来调用各个constructors。这一点由编译器完成，它为每一个constructor安插程序代码，以“member声明次序”调用每一个member所关联的default constructors。这些码将被安插在explicit user code之前。举个例子： 123456789101112131415161718192021222324252627282930313233class Dopey&#123;public: Dopey(); ...&#125;;class Sneezy&#123;public: Sneezy(int); Sneezy(); ...&#125;;class Bashful&#123;public: Bashful(); ...&#125;;class Snow_White&#123; ...private: Dopey dopey; Sneezy sneezy; Bashful bashful; int mumble;&#125;; 如果Snow_White没有定义default constructor，就会有一个nontrivial constructor被合成出来，依序调用Dopey、Sneezy、Bashful的default constructors。然而如果Snow_White定义了下面这样的default constructor： 12345// 程序员所写的 default constructorSnow_White::Snow_White() : sneezy(1024)&#123; mumble = 2048;&#125; 它会被扩张为： 1234567891011// 编译器扩张后的 C++ 伪码Snow_White::Snow_White()&#123; // 调用其 constructor dopey.Dopey::Dopey(); Sneezy.Sneezy::Sneezy(1024); bashful.Bashful::Bashful(); // explicit user code mumble = 2048;&#125; “带有Default Constructor”的Base Class 类似的道理，如果一个没有任何constructors的class派生自一个“带有default constructor”的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。它将调用上一层base classes的default constructor（根据它们的声明次序）。对一个后继派生的class而言，这个合成的constructor和一个“被明确提供的default constructor”没有什么差异。 如果设计者提供多个constructors，但其中都没有default constructor呢？编译器会扩张现有的每一个constructors，将“用以调用所有必要之default constructors”的程序代码加进去。它不会合成一个新的default constructor，这是因为其它“由user所提供的constructors”存在的缘故。如果同时亦存在着“带有default constructors”的member class objects，那些default constructor也会被调用。 “带有（声明或继承）一个Virtual Function”的Class 123456789101112131415161718192021class Widget&#123;public: virtual void flip() = 0; ...&#125;;void flip(const Widget&amp; widget)&#123; widget.flip();&#125;// 假设 Bell 和 Whistle 都派生自 Widgetvoid foo()&#123; Bell b; Whistle w; flip(b); flip(w);&#125; 下面两个扩张操作会在编译期间发生： 一个virtual function table会被编译器产生出来，内放class的virtual functions地址。 在每一个class object中，一个额外的pointer member会被编译器合成出来，内含相关的class vtbl的地址。 此外，widget.flip()的虚拟引发操作会被重新改写，以使用widget的vptr和vtbl中的flip()条目： 123// 1 表示 flip() 在 virtual table 的固定索引// &amp;widget 代表要交给\"被调用的某个 flip() 实体\"的 this 指针(*widget.vptr[1])(&amp;widget)); 为了让这个机制发挥功效，编译器必须为每一个Widget（或其派生类之）object的vptr设定初值，放置适当的virtual table地址。对于class所定义的每一个constructor，编译器会安插一些码来做这样的事情。对于那些未声明任何constructors的classes，编译器会为它们合成一个default constructor，以便正确地初始化每一个class object的vptr。 “带有一个Virtual Base Class”的Class 编译器必须使virtual base class在其每一个derived class object中的位置，能够在执行期准备妥当。一种可能的做法是在derived class中安插一个指向每一个virtual base class的指针，所有“经由reference和pointer来存取其中virtual base class中数据的操作”都通过此指针完成。 同样地，这个virtual base class指针是在class object构建期间完成的，编译器的默认行为和3中的vptr的处理方式一样。 2.2 Copy Constructor的构造操作有三种情况会调用copy constructor： 对一个class object做明确的初始化操作 12345class X &#123;...&#125;;X x;X xx(x);X xx = x; 当class object被当作参数交给某个函数时 1234567extern void foo(X x);void bar()&#123; X xx; foo(xx); ...&#125; 当函数返回一个class object 123456X foo_bar()&#123; X xx; ... return xx;&#125; Default Memberwise Initialization 如果class没有提供一个explicit copy constructor又当如何？当class object以“相同class的另一个object”作为初值时，其内部是以所谓的default memberwise initialization完成的，也就是把每一个内建的或派生的data member的值，从某个object拷贝一份到另一个object身上。不过它并不会拷贝其中的member class object，而是以递归的方式施行memberwise initialization。 一个良好的编译器可以为大部分class objects产生bitwise copies，因为它们有bitwise copy semantics。copy constructors在必要的时候才由编译器产生出来。这个句子中的“必要”意指当class不展现bitwise copy semantics时。 Bitwise Copy Semantics C++ Standard把copy constructor区分为trivial和nontrivial两种。只有nontrivial的实体才会被合成于程序之中。决定一个copy constructor是否为trivial的标准在于class是否展现出所谓的“bitwise copy semantics”。 什么时候一个class不展现出Bitwise Copy Semantics呢？ 当class内含一个member object而后者的class声明有一个copy constructor时（不论是被class设计者明确地声明；或是被编译器合成）。 当class继承自一个base class而后者存在有一个copy constructor（再次强调，不论是被明确声明或是被合成而得）。 当class声明了一个或多个virtual functions时。 当class派生自一个继承串链，其中有一个或多个virtual base classes时。 有一点很值得注意：在被合成出来的copy constructor中，如整数、指针、数组等等的nonclass members也都会被复制。 重新设定virtual table的指针vptr 当编译器导入一个vptr到class之中时，该class就不再展现bitwise semantics了。编译器需要合成出一个copy constructor，以求将vptr适当地初始化。 base class object以另一个base class object作为初值，或derived class object以另一个derived class object作为初值，都可以直接靠“bitwise copy semantics”完成。当一个base class object以其derived class的object内容做初始化操作时，其vptr复制操作必须保证安全。此时，合成出来的base copy constructor会明确设定object的vptr指向base class的virtual table，而不是直接从右手边的class object中将其vptr现值拷贝过来。 处理virtual base class subject 和3同理，需要合成copy constructor来明确的设定virtual base class pointer的初值。 2.3 程序转化语意学已知有这样的定义： 1X x0; 下面有三个定义，每一个都明显地以x0来初始化其class object： 123456void foo_bar()&#123; X xl(x0); X x2 = x0; X x3 = X(x0);&#125; 必要的程序转化有两个阶段： 重写每一个定义，其中的初始化操作会被剥除。 class的copy constructor调用操作会被安插进去。 举个例子，在明确的双阶段转化之后，foo_bar()可能看起来像这样： 1234567891011121314// 可能的程序转换// C++ 伪码void foo_bar()&#123; // 注意没有初始化操作 X x1; X x2; X x3; // 编译器安插X copy construction的调用操作 x1.X::X(x0); x2.X::X(x0); x3.X::X(x0);&#125; 参数的初始化 把一个class object当做参数传给一个函数，相当于以下形式的初始化操作： 12// xx 代表形式参数, arg 代表真正的参数值X xx = arg; 返回值的初始化 已知下面这个函数定义： 123456X bar()&#123; X xx; // 处理 xx ... return xx;&#125; 这里有一个双阶段转化： 首先加上一个额外参数，类型是class object的一个reference。这个参数将用来放置被“拷贝建构（copy constructed）”而得的返回值。 在return指令之前安插一个copy constructor调用操作，以便将欲传回之object的内容当做上述新增参数的初值。 根据这样的算法，bar()转换如下： 12345678910void bar(X &amp;_result)&#123; X xx; // 编译器所产生的 default constructor 调用操作 xx.X::X(); // ... 处理 xx // 编译器所产生的 copy constructor result.X::X(xx); return;&#125; 现在编译器必须转换每一个bar()调用操作，以反映其新定义。例如： 1X xx = bar(); 将被转换为下列两个指令句： 123// 注意, 不必施行 default constructorX xx;bar(xx); NRV优化 已知下面这个函数定义： 123456X bar()&#123; X xx; // 处理 xx ... return xx;&#125; 编译器会把它优化为： 123456789void bar(X &amp;_result)&#123; // default constructor 调用操作 _result.X::X(); // ... 直接处理 _result return;&#125; 只有当程序提供了explicit copy constructor，编译器才会实施NRV优化。没有提供的话（编译器自己合成的），是不会实施NRV优化的。 copy constructor要还是不要？ 对于下面的3D坐标点类，这个class的设计者应该提供一个explicit copy constructor吗？ 12345678class Point3d&#123;public: Point3d(float x, float y, float z); // ...private: float _x, _y, _z;&#125;; 除非你预见该class需要大量的memberwise初始化操作，例如函数以传值（by value）的方式传回objects，那么提供一个copy constructor的explicit inline函数实体就非常合理——可以激活编译器提供的NRV优化。否则，不提供explicit copy constructor既快速又安全。 2.4 Member initialization list为了让你的程序能够被顺利编译，必须使用member initialization list的情况： 当初始化一个refercnce member时； 当初始化一个const member时； 当调用一个base class的constructor，而它拥有一组参数时； 当调用一个member class的constructor，而它拥有一组参数时。 在这四种情况之外，不使用member initialization list，程序可以被正确编译并执行，但是效率不彰。例如： 123456789101112class Word&#123;public: Word() &#123; _name = 0; _cnt = 0; &#125;private: String _name; int _cnt;&#125;; 下面是编译器对constructor可能的内部扩张结果： 1234567891011121314151617// C++ 伪码Word::Word(/* this pointer goes here */)&#123; // 调用 String default constructor _name.String::String(); // 产生临时性对象 String temp = String(0); // memberwise 地拷贝 _name _name.String::operator=(temp); // 摧毁暂时性对象 temp.String::~String(); _cnt = 0;&#125; 更有效率的实现方法： 12345// 较佳的方式Word::Word : _name(0)&#123; cnt = 0;&#125; 它会被扩张成这个样子： 1234567// C++ 伪码Word::Word(/* this pointer goes here */)&#123; // 调用 String(int) constructor _name.String::String(0); _cnt = 0;&#125; 编译器会一一操作initialization list，以member声明次序（不是由initialization list中的排列次序决定的）在constructor之内的explicit user code之前安插初始化操作。 调用一个member function以设定一个member的初值是可以的，因为此时this指针已经被构造妥当。 12345678910// X::xfoo() 被调用X::X(int val) : i(xfoo(val)), j(val)&#123; &#125;// 会被扩张为X::X(/* this pointer */, int val)&#123; i = this-&gt;xfoo(val); i = val;&#125; 注意：如果一个derived class member function被调用，其返回值被当做base class constructor的一个参数，这不是一个好主意！！！","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"深度探索C++对象模型之前言","date":"2020-05-08T13:35:42.000Z","path":"jOQUhpad0yAY7aMb/","text":"前言Simplifier是编译器的一部分，处于type checking和code generation之间。它用来转换内部的程序表现。有3种转换是任何对象模型都需要的： 与编译器息息相关的转换（Implementation-dependent transformations） 例如，当parser看到这个表达式： 1fct(); 它并不知道是否（a）这是一个函数调用操作，或者（b）这是overloaded calloperator在class object fct上的一种应用。默认情况下，这个式子所代表的是一个函数调用，但是当（b）的情况出现，Simplifier就要重写并调换call subtree。 语言语意转换（Language semantics transformations） 这包括constructor/destructor的合成和扩展、memberwise初始化、对于memberwise copy的支持、在程序代码中安插conversion operators、临时性对象，以及对constructor/destructor的调用。 程序代码和对象模型的转换（Code and object model transformations） 这包括对virtual functions、virtual base class和inheritance的一般支持、new和delete运算符、class objects所组成的数组、local static class instances、带有非常量表达式（nonconstant cxpression）之global object的静态初始化操作。 什么是C++对象模型？ 语言中直接支持面向对象程序设计的部分 对于各种支持的底层实现机制 第1章：关于对象在C语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。 C++在布局以及存取时间上主要的额外负担是由virtual引起，包括： virtual function机制——用以支持一个有效率的“执行期绑定” virtual base class——用以实现“多次出现在继承体系中的base class，有一个单一而被共享的实体” 此外，还有一些多重继承下的额外负担，发生在“一个derived class和其第二或后继之base class的转换”之间。 1.1 C++对象模型在C++中，有两种class data members：static和nonstatic，以及三种class member functions：static、nonstatic和virtual。 在C++对象模型中，nonstatic data members被配置于每一个class object之内，static data members则被存放在所有的class object之外。static和nonstatic function members也被放在所有的class object之外。virtual functions则以两个步骤支持之： 每一个class产生出一堆指向virtual functions的指针，放在表格之中。这个表格被称为 vtbl。 每一个class object被添加了一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）由每一个class的constructor、destructor和copy assignment运算符自动完成。 在虚拟继承的情况下，base class不管在继承串链中被派生（derived）多少次，永远只会存在一个实体（称为subobject）。 C++最初采用的继承模型并不运用任何间接性: base class subobject的data members被直接放置于derived class object中。这提供了对base class members最紧凑而且最有效率的存取。缺点就是: base class members的任何改变，包括增加﹑移除或改变类型等等，都使得所有用到“此base class或其derived class之objects”者重新编译。 virtual base class的原始模型是在class object中为每一个有关联的virtual base class加上一个指针。 对象模型如何影响程序？ 不同的对象模型，会导致“现有的程序代码必须修改”以及“必须加人新的程序代码”两个结果。例如下面这个函数，其中class X定义了一个copy constructor，一个virtual destructor，和一个virtual function foo： 123456789101112X foobar()&#123; X xx; X* px = new X; // foo 是一个虚函数 xx.foo(); px-&gt;foo(); delete px; return xx; // 这里会用到 copy constructor&#125; 这个函数有可能在内部被转化为： 1234567891011121314151617181920212223242526272829void foobar(X&amp; _result)&#123; // 构造 _result // _result 用来取代 local xx... _result.X::X(); // 扩展 ×* px= new x; px = _new(sizeof(X)); if(px != 0) px-&gt;X::X(); // 扩展 xx.foo() 但不使用 virtual 机制 // 以 _result 取代 xx foo(&amp;_result); // 使用 virtual 机制扩展 px-&gt;foo() (*px-&gt;vtbl[2])(px); // 扩展 delete px; if(px != 0) &#123; (*px-&gt;vtbl[1])(px); // destructor _delete(px); &#125; //不需使用 named return statement //不需要摧毁 local object xx return;&#125; 1.2 关键词所带来的差异 掌握struct和class关键字的差异 struct关键词的使用实现了C的数据萃取概念，而class关键词实现的是C++的ADT（Abstract Data Type）概念。 C程序员的巧计（C++中不可用）。例如把单一元素的数组放在一个struct的尾端，于是每个struct objects可以拥有可变大小的数组： 1234567891011struct mumble&#123; // stuff char pc[1];&#125;;// 从档案或标准输入装置中取得一个字符串 str// 然后为 struct 本身和该字符串配置足够的内存struct mumble *pmumble = (struct mumble*) malloc(sizeof(struct mumble) + strlen(str) + 1);strcpy(&amp;(pmumble-&gt;pc), str); C++中凡处于同一个access section的数据，必定保证以其声明次序出现在内存布局当中。然而被放置在多个access sections中的各笔数据，排列次序就不一定了。组合（composition)，而非继承，才是把C和C++结合在一起的唯一可行方法（conversion运算符提供了一个十分便利的萃取方法）： 12345678struct C_point &#123; ... &#125;;class Point&#123;public: operator C_point() &#123; return c_point_; &#125; // ...private: C_point c_point_; C struct在C++中的一个合理用途，是当你要传递“一个复杂的class object的全部或部分”到某个C函数中去时，struct声明可以将数据封装起来，并保证拥有与C兼容的空间布局。然而这项保证只在组合的情况下才存在。 1.3 对象的差异C++支持3种程序设计模型： 程序模型（面向过程） 抽象数据类型模型（基于对象模型）（封装） 面向对象模型（继承、多态） 在C++，多态只存在于一个个的public class体系中。nonpublic的派生行为以及类型为void*的指针可以说是多态，但它们并没有被语言明白地支持，也就是说它们必须由程序员通过明白的转型操作来管理。C++以下列方法支持多态： 经由一组隐含的转化操作。例如把一个derived class指针转化为一个指向其public base type的指针 1Shape *ps = new Circle(); 经由virtual function机制 经由dynamic_cast和typeid运算符 12if(Circle* pc = dynamic_cast&lt;Circle*&gt;(ps)) ... virtual function机制不只使得“当类型有所增加、修改、或删减时，我们的程序代码不需改变”。而且也使一个新的subtype的供应者不需要重新写出“对继承体系中的所有类型都共通”的行为和操作。 需要多少内存才能够表现一个class object？ nonstatic data members的总和大小 加上任何alignment（内存对齐） 加上为了支持virtual（function，base class）而由内部产生的额外负担 转型（cast）其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。 一个Base指针pb和一个Derived指针pd有什么不同？ 123Derived d;Base* pb = &amp;d;Derived* pd = &amp;d; 它们每个都指向Base object的第一个byte。其间的差别是，pd所涵盖的地址包含整个Derived object，而pb所涵盖的地址只包含Derived object中的Base subobject。 除了Base subobject中出现的members，你不能使用pb来直接处理Derived的任何members。例外是通过virtual机制或转型操作。 当一个base class object被直接初始化为（或是被指定为）一个derived class object时，derived object就会被切割，以塞人较小的base type内存中，derived type将没有留下任何蛛丝马迹。 下面这一组定义，其可能的内存布局为： 12345ZooAnimal za;ZooAnimal *pza;Bear b;Panda* pp = new Panda;pza = &amp;b;","tags":[{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"Effective C++之模板与泛型编程","date":"2020-04-18T13:35:42.000Z","path":"MBICE5WlMJtd4Rku/","text":"第7章：模板与泛型编程条款41：了解隐式接口和编译期多态 哪一个重载函数被调用——发生在编译期 哪一个virtual函数被绑定——发生在运行期 class和template都支持接口和多态 对class而言，接口是显式的，以成员函数的签名为中心，多态则通过virtual函数发生在运行期。对template而言，接口是隐式的，以有效表达式为中心，多态则通过template具现化和函数重载解析发生于编译期。 条款42：了解typename的双重意义 当我们声明模板类型参数，class和typename的意义完全相同 12template&lt;typename T&gt;template&lt;class T&gt; typename用来标识嵌套从属类型名称 template内出现的名称如果相依于某个template参数，称这个名称为从属名称，如果丛属名称在class内呈嵌套状，称为嵌套从属名称。如果嵌套从属名称还指涉某种类型名称为嵌套从属类型名称 123456789101112131415161718// std::iterator_traits&lt;IterT&gt;::value_type 就是嵌套从属类型名称template&lt;typename IterT&gt;void workWithIterator(IterT iter)&#123; // 必须使用 typename 关键字标识 typename std::iterator_traits&lt;IterT&gt;::value_type temp(*iter); ...&#125;// 使用 typedef 少打几个字template&lt;typename IterT&gt;void workWithIterator(IterT iter)&#123; // 必须使用 typename 关键字标识 typedef typename std::iterator_traits&lt;IterT&gt;::value_type value_type; value_type temp(*iter); ...&#125; 不允许在base class list或member initialization list内使用typename作为base class的标识符 条款43：学习处理模板化基类内的名称假设我们需要撰写一个MsgSender类，它能够传送信息到若干不同的Company去。信息要不进行加密后的密文，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于template的解法： 1234567891011121314151617181920212223242526272829303132333435363738394041class CompanyA&#123;public: ... void sendCleartext(const string&amp; msg); void sendEncrypted(const string&amp; msg);&#125;;class CompanyB&#123;public: ... void sendCleartext(const string&amp; msg); void sendEncrypted(const string&amp; msg);&#125;;... // 针对其他公司设计的 classclass MsgInfo &#123;...&#125;; // 这个 class 以备将来产生信息template&lt;typename Company&gt;class MsgSender&#123;public: ... //构造函数、析构函数等等 void sendClear(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendCleartext(msg); &#125; void sendSecret(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendEncrypted(msg); &#125;&#125;; 现在假设我们想要在每次送出信息时log某些信息。derived class可轻易提供解决方法： 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log sendClear(info); // 调用 base class 函数, 这段码无法通过编译! ... // 将“传送后”的信息写至 log &#125; ...&#125;; 编译器会抱怨sendClear函数不存在，明明在那里，为什么？ 问题在于，当编译器看见class template LoggingMsgSender定义式时，并不知道它继承什么样的class。当然它继承的是MsgSender&lt;Company&gt;，但其中的Company是个template参数，不当LoggingMsgSender被具现化之前无法确切知道它是什么。而如果不知道Company是什么，就无法知道class MsgSender&lt;Company&gt;看起来像什么——更明确地说是没办法知道它是否有个sendClear函数。 具体点说，假设现在有个CompanyZ坚持只使用加密通讯： 12345678// 不提供 sendCleartext 函数class CompanyZ&#123;public: ... void sendEncrypted(const string&amp; msg); ...&#125;; 一般性的MsgSender template对CompanyZ并不合适，因为那个template提供了一个sendClearMsg函数，而这对CompanyZ对象并不合理。欲矫正这个问题，我们可以针对CompanyZ产生一个MsgSender特化版： 123456789101112131415// 全特化版本只提供 sendSecret 函数template&lt;&gt;class MsgSender&lt;CompanyZ&gt;&#123;public: ... //构造函数、析构函数等等 void sendSecret(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendEncrypted(msg); &#125; ...&#125;; 这就解释了前面编译器拒绝那个调用的原因：它知道base class template有可能被特化，而那个特化版本可能不提供和一般性template相同的接口。因此它往往拒绝在templatized base class（本例的MsgSender&lt;Company&gt;）内寻找继承而来的名称（本例的SendClear)。 当我们从Object Oriented C++跨进Template C++（见条款1) ，继承就不像以前那样畅行无阻了 有三个解决令C++编译器“不进入templatized base class观察”的行为失效的办法： 使用this指针 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log this-&gt;sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 使用using声明 虽然using声明式在在条款33或在这里都可有效运作，但两处解决的问题其实不相同。前者是base class名称被derived class名称遮掩，而后者是编译器不进入base class作用域内查找，于是我们通过using告诉它，请它那么做。 1234567891011121314template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: using MsgSender&lt;Company&gt;::sendClear; ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 使用作用域运算符::明确指定 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log MsgSender&lt;Company&gt;::sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 即使如此，如果稍后这样做： 1234LoggingMsgSender&lt;Companyz&gt;zMsgSender;MsgInfo msgData;...zMsgSender.sendClearMsg(msgData); // 仍然无法通过编译 其中对sendClearMsg的调用动作将无法通过编译，因为在那个点上，编译器知道base class是个template特化版本MsgSender&lt;CompanyZ&gt;，而且它知道那个class不提供sendClear函数，而sendClear却是sendClearMsg尝试调用的函数。 条款44：将与基类无关的代码抽离template当你编写某个函数，其中某些部分的实现码和另一个函数的实现码实质相同，你会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。如果你正在编写某个class，而你明白其中某些部分和另一个class的某些部分相同，你也不会重复这共同的部分。你会把共同部分搬移到新class去，然后使用继承或复合（见条款32，38，39) ，令原先的class取用这共同特性。而原class的互异部分仍然留在原位置不动。 编写template时，也是做相同的分析，以相同的方式避免重复。然而在template代码中，重复是隐晦的：毕竟只存在一份template源码，所以你必须训练自己去感受当template被具现化多次时可能发生的重复。 举个例子，假设你想为固定尺寸的正方矩阵编写一个template。该矩阵的性质之一是支持逆矩阵运算。 123456789101112131415// template 支持 n x n 矩阵, 元素类型为 Ttemplate&lt;typename T, size_t n&gt;class squareMatrix&#123;public: ... void invert( ); // 求逆矩阵&#125;;SquareMatrix&lt;double, 5&gt; sml;...sm1.invert(); // 调用 SquareMatrix&lt;double, 5&gt;::invertsSquareMatrix&lt;double, 10&gt; sm2;...sm2.invert(); // 调用 SquareMatrix&lt;double, 10&gt;::invert 这会具现化两份invert。这些函数并非完完全全相同，因为其中一个操作的是5x5矩阵而另一个操作的是10x10矩阵，但除了常量5和10，两个函数的其他部分完全相同。这是template引出代码膨胀的一个典型例子。 第一次修改： 1234567891011121314151617181920212223242526// 与尺寸无关的 base classtemplate&lt;typename T&gt;class SquareMatrixBase&#123;protected: void invert(size_t matrixSize) // 以给定的尺寸求逆矩阵 &#123; ... &#125;&#125;;template&lt;typename T, size_t n&gt;class SquareMatrix : private SquareMatrixBase&lt;T&gt;&#123;private: // 声明为 private 是为了不让客户看见 using SquareMatrixBase&lt;T&gt;::invert; // 避免遮掩 base 版的 invert, 见条款 33public: ... void invert() &#123; this-&gt;invert(n); // inline 调用 base class 版的 invert // 为什么这儿出现 this-&gt; 见条款 43 // LYL 认为前面已经使用了 using, this-&gt; 应该也不需要了 &#125;&#125;; 这里的base class只是为了帮助derived class实现，不是为了表现SquareMatrix和SquareMatrixBase之间的is-a关系（关于private继承，见条款39)。 目前为止一切都好，但还有一些棘手的题目没有解决。SquareMatrixBase::invert如何知道该操作什么数据？虽然它从参数中知道矩阵尺寸，但它如何知道哪个特定矩阵的数据在哪儿？想必只有derived class知道。derived class如何联络其base class做逆运算动作？一个可能的做法是为SquareMatrixBase::invert添加另一个参数，可以是个指针，指向一块用来放置矩阵数据的内存地址。 第二次修改： 1234567891011121314151617181920212223242526272829303132template&lt;typename T&gt;class SquareMatrixBase&#123;protected: // 存储矩阵大小和一个指针, 指向矩阵数值 squareMatrixBase(size_t n, T* pMem) : size(n), pData(pMem) &#123;&#125; void invert() // 不用指定尺寸了 &#123; ... &#125; ...private: size_t size; // 矩阵的大小 T* pData; // 指针, 指向矩阵内容&#125;;template&lt;typename T, size_t n&gt;class SquareMatrix : private SquareMatrixBase&lt;T&gt;&#123;private: using SquareMatrixBase&lt;T&gt;::invert;public: SquareMatrix() : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125; void invert() &#123; this-&gt;invert(n); &#125; ...private: T data[n * n]; // 这里直接将数据矩阵存储在 SquareMatrix 对象内部 // 也可以使用动态内存分配的方案&#125;; 这个条款只讨论由non-type template parameter（非类型模板参数）带来的膨胀，其实type parameter（类型参数）也会导致膨胀。例如在许多平台上int和 long有相同的二进制表述，所以像vector&lt;int&gt;和vector&lt;long&gt;的成员函数有可能完全相同。某些链接器（linker）会合并完全相同的函数实现码，但有些不会，后者意味某些template被具现化为int和long两个版本，并因此造成代码膨胀。类似情况，所有指针类型都有相同的二进制表述，因此凡template持有指针者（例如list&lt;int*&gt;，list&lt;const int*&gt;，list&lt;SquareMatrix&lt;long, 3&gt;*&gt;等等）往往应该对每一个成员函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它们操作强型指针（strongly typed pointer，即T*），你应该令它们调用另一个操作无类型指针（untyped pointer，即void*）的函数，由后者完成实际工作。某些C++标准程序库实现版本的确为vector，deque和list等template做了这件事。 条款45：成员函数模板接受所有兼容类型内置指针是支持隐式转换的，比如derived class的指针可以隐式转换为base class指针，指向non-const对象的指针可以转换为指向const对象等等。 123456class Top &#123;...&#125;;class Middle : public Top &#123;...&#125;;class Bottom : public Middle &#123;...&#125;;Top* pt1 = new Middle; // 将 Middle* 转换为 Top*Top* pt2 = new Bottom; // 将 Bottom* 转换为 Top*const Top* = pt1; // Top* 转换为 const Top* 但是我们自己实现的智能指针模板类，想做到这样就稍稍有点麻烦了。我们希望下面的代码能够通过编译： 12345678910111213141516temmplate&lt;typename T&gt;class SmartPtr&#123;public: explicit SmartPtr(T* realPtr); // 智能指针通常以内置指针完成初始化 ...&#125;;// 将 SmartPtr&lt;Middle&gt;转 换为 SmartPtr&lt;Top&gt;SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(new Middle);// 将 SmartPtr&lt;Bottom&gt; 转换为 SmartPtr&lt;Top&gt;SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(new Bottom);// 将 SmartPtr&lt;Top&gt; 转换为 SmartPtr&lt;const Top&gt;SmartPtr&lt;const Top&gt; pct2 = ptl; 注意，这些赋值表达式需要调用的都是copy构造函数。这里的代码不能通过编译，因为如果以带有base-derived关系的B，D两类型分别具现化某个template，产生出来的两个具现体并不带有base-derived关系，所以编译器视SmartPtr&lt;Middle&gt;和SmartPtr&lt;Top&gt;为完全不同的class，为了获得我们希望获得的SmartPtr class之间的转换能力，我们必须将它们明确地编写出来。 我们应该为它写一个构造模板。这样的模板是所谓member function template，其作用是为class生成函数： 123456789template&lt;typename T&gt;class SmartPtr&#123;public: // member template, 为了生成 copy 构造函数 template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other); ...&#125;; 我们称之为泛化（generalized）copy构造函数。它并未被声明为explicit，那是因为内置指针类型之间的转换（例如从derived class指针转为base class指针）是隐式转换，所以让智能指针按照这种形式也属合理。 但是，这个为SmartPtr而写的“泛化copy构造函数”提供的东西比我们需要的更多。我们只希望根据一个SmartPtr&lt;Bottom&gt;创建一个SmartPtr&lt;Top&gt;，却不希望根据一个SmartPtr&lt;Top&gt;创建一个SmartPtr&lt;Bottomr&gt;，因为那对public继承而言（见条款32）是矛盾的。我们也不希望根据一个SmartPtr&lt;double&gt;创建一个SmartPtr&lt;int&gt;，我们必须从某方面对这一member template所创建的成员函数群进行挑拣。 假设SmartPtr遵循std::shared_ptr也提供一个get成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望： 12345678910111213template&lt;typename T&gt;class SmartPtr&#123;public: // 以 other 的 heldPtr 初始化 this 的 heldPtr template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other) : heldPtr(other.get()) &#123;...&#125; T* get() const &#123; return heldPtr; &#125; ...private: T* heldPtr; // 这个 SmartPtr 持有的内置指针&#125;; 这个行为只有当“存在某个隐式转换可将一个U*指针转为一个T*指针”时才能通过编译，而这正是我们想要的。 member function template（成员函数模板）的效用不限于构造函数，它常扮演的另一个角色是支持赋值操作。例如std::shared_ptr同时支持所有“来自兼容之内置指针、std::shared_ptr、std::weak_ptr”的构造行为以及赋值操作（std::weak_ptr除外）。赋值操作符和copy构造函数实现类似，故省略。 如果你声明member template用于“泛化copy构造”或“泛化assignment操作”你还是需要声明正常的copy构造函数和copy assignment操作符 条款5说过，编译器可能为我们产生四个成员函数，其中两个是copy构造函数和copy assignment操作符。现在，SmartPtr声明了一个泛化copy构造函数，而显然一旦类型T和U相同，泛化copy构造函数会被具现化为“正常的”copy构造函数。那么究竟编译器会暗自为SmartPtr生成一个copy构造函数呢？或当某个SmartPtr对象根据另一个同型的SmartPtr对象展开构造行为时，编译器会将“泛化copy构造函数模板”具现化呢？ member template并不改变语言规则：“如果程序需要一个copy构造函数，你却没有声明它，编译器会为你暗自生成一个”。在class内声明泛化copy构造函数（是个member template）并不会阻止编译器生成它们自己的copy构造函数（一个non-template），所以如果你想要控制copy构造的方方面面，你必须同时声明泛化copy构造函数和“正常的”copy构造函数。相同规则也适用于赋值操作。 条款46：需要类型转换时请为模板定义非成员函数条款24讨论过为什么惟有non-member函数才有能力“在所有实参身上实施隐式类型转换”，该条款并以Rational class的operator*函数为例。本条款将Rational和operator*模板化： 123456789101112131415161718192021template&lt;typename T&gt;class Rational&#123;public: // 条款 20 告诉你为什么参数以 passed by reference 方式传递 Rational(const T&amp; numerator = 0, const T&amp; denominator = 1); // 条款 28 告诉你为啥返回值以 passed by value 方式传递 // 条款 3 告诉你为啥它们是 const const T numerator() const; const T denominator() const; ...&#125;;template&lt;typename T&gt;const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 就像条款24一样，我们也希望支持混合式算术运算，然而以下代码却不能通过编译： 12Rational&lt;int&gt; oneHalf(1, 2);Rational&lt;int&gt; result &#x3D; oneHalf * 2; &#x2F;&#x2F; 错误!无法通过编译 在这里，编译器不知道我们想要调用哪个函数！它们试图找到什么函数被名为operator*的template具现化出来。它们知道它们应该可以具现化某个“名为operator*并接受两个Rational&lt;T&gt;参数”的函数，但为完成这一具现化行动，必须先算出T是什么。 为了推导T，它们看了看operator*调用动作中的实参类型。分别是Rational&lt;int&gt;（oneHalf的类型）和int（2的类型）。 以oneHalf进行推导，过程并不困难。第二参数的推导则没有这么顺利。operator*的第二参数被声明为Rational&lt;T&gt;，但传递给operator*的类型是int（2）。编译器如何根据这个2推算出T？你或许会期盼编译器使用Rational&lt;int&gt;的non-explicit构造函数将转换为Rational&lt;int&gt;，进而将T推导为int，然而template实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。 template class内的friend声明式可以指涉某个特定函数。这意味class Rational&lt;T&gt;可以声明operator*是它的一个friend函数。class template并不倚赖template实参推导，所以编译器总是能够在class Rational&lt;T&gt;具现化时得知T。因此： 12345678910111213141516template&lt;typename T&gt;class Rational&#123;public: ... friend const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs);&#125;;template&lt;typename T&gt;const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 现在当对象oneHalf被声明为一个Rational&lt;int&gt;，class Rational&lt;int&gt;于是被具现化出来，而作为过程的一部分，friend函数operator*（接受Rational&lt;int&gt;参数）也就被自动声明出来。后者身为一个函数而非function template，因此编译器可在调用它时使用隐式转换函数（例如调用Rational的non-explicit构造函数）。 但是，虽然这段代码通过编译，却无法连接。 因为这个友元函数只被声明于Rational内，并没有被定义出来。我们意图令此class外部的operator* template提供定义式，是行不通的。既然我们没有提供定义式，连接器当然找不到它！ 最简单的方法就是，将函数本体放进class内： 12345678910111213template&lt;typename T&gt;class Rational&#123;public: ... friend template&lt;typename T&gt; const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) &#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); &#125;&#125;; 为了让类型转换可能发生于所有实参身上，我们需要一个non-member函数（条款24）；为了令这个函数被自动具现化，我们需要将它声明在class内部；而在class内部声明non-member函数的唯一办法就是：令它成为一个friend。因此我们就这样做了。 当此friend函数过于复杂时，令其调用类外的辅助函数 12345678910111213141516171819202122template&lt;typename T&gt; class Rational; // 前向声明template&lt;typename T&gt;const Rational&lt;T&gt; doMultiply(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp;rhs);&#123; return Rational&lt;T&gt;(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125;template&lt;typename T&gt;class Rational&#123;public: ... friend const Rational&lt;T&gt;operator* (const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) &#123; return doMultiply(lhs, rhs); &#125; ...&#125;; 作为一个template，doMultiply当然不支持混合式乘法，但它其实也不需要。它只被operator*调用，而operator*支持混合式操作。 条款47：traits classes表现类型信息STL迭代器分类： input迭代器 只能向前移动，一次一步，用户只能读取它所指的东西，而且只能读取一次，读完立即自动向前一步。程序库中的输入流迭代器istream_iterator就属于这一类。 output迭代器 只能向前移动，一次一步，用户只能涂写它所指的东西，而且只能涂写一次，写完立即自动向前一步。程序库中的输出流迭代器ostream_iterator就属于这一类。 forward迭代器 可以做上述两种迭代器做的事情，而且支持多次读写，读写完由用户自行决定是否前进。单向链表slist提供的迭代器就属于这一类。 bidirectional迭代器 除了能做forward迭代器做的事情，还可以向后移动。双向链表list以及set，mutilset，map，mutilmap提供的迭代器属于这一类。 random access迭代器 功能类似于内置指针，可以进行算数操作。vector，deque和string提供的迭代器属于这一类。 迭代器适配器 reverse迭代器 insert迭代器 back inserter front inserter general inserter stream迭代器 move迭代器 12345struct input_iterator_tag &#123;&#125;;struct output_iterator_tag &#123;&#125;;struct forward_iterator_tag : public input_iterator_tag &#123;&#125;;struct bidirectional iterator_tag : public forward_iterator_tag &#123;&#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag &#123;&#125;; 这些struct之间的继承关系是有效的is-a关系：所有forward迭代器都是input迭代器，依此类推。 关于iterator_trait的实现技术（参考书籍P227-P232） 条款48：认识template元编程 如题，以后买本书再专门去学吧！","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之继承与面向对象设计","date":"2020-04-10T13:35:42.000Z","path":"5pPP61A5gGyfCrjb/","text":"第6章：继承与面向对象设计条款32：确定你的public继承塑模出is-a关系 “public继承”意味is-a。适用于base class身上的每一件事情一定也适用于derived class身上，因为每一个derived class对象也都是一个base class对象 条款33：避免遮掩继承而来的名称 derived class的作用域被嵌套在base class作用域内 12345678910111213141516171819202122232425class Base&#123;private: int x;public: virtual void mf1() = 0; virtual void mf1(int); void mf2(); void mf2(double);&#125;;class Derived : public Base&#123;public: virtual void mf1(); void mf2();&#125;;Derived d;int x;...d.mf1(); // 没问题, 调用 Derived::mf1d.mf1(x); // 错误! 因为 Derived::mf1 遮掩了 Base::mf1d.mf2(); // 没问题, 调用 Derived::mf2d.mf2(x); // 错误! 因为 Derived::mf2 遮掩了 Base::mf2 这段代码中base class内所有名为mf1和mf2的函数都被derived class内的mf1和mf2函数遮掩掉了。从名称查找观点来看，Base::mf1和Base::mf2不再被Derived继承！ 实际上如果你正在使用public继承而又不继承那些重载函数，就是违反base和derived class之间的is-a关系，而条款32说过is-a是public继承的基石。因此你几乎总会想要推翻C++对“继承而来的名称”的缺省遮掩行为。 使用using声明式 1234567891011121314151617181920212223242526272829class Base&#123;private: int x; public: virtual void mf1() = 0; virtual void mf1(int); void mf2(); void mf2(double); ...&#125;;class Derived : public Base&#123;public: using Base::mf1; // 让 Base class 内名为 mf1 和 mf2 的所有东西 using Base::mf2; // 在 Derived 作用域内都可见, 并且 public virtual void mf1(); void mf2();&#125;;Derived d;int x;...d.mf1(); // 没问题, 调用 Derived::mf1d.mf1(x); // 现在没问题了, 调用 Based::mf1d.mf2(); // 没问题, 调用 Derived::mf2d.mf2(x); // 现在没问题了, 调用 Based::mf2 使用inline转交函数（forwarding function） 然而在private继承之下（见条款39），有时候你并不想继承base class的所有函数。假设Derived以private形式继承Base，而Derived唯一想继承的mf1是那个无参数版本。using声明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名函数在derived class中都可见。 1234567891011121314151617181920212223class Base&#123;public: virtual void mf1() = 0; virtual void mf1(int); ... // 与前同&#125;;class Derived : private Base&#123;public: virtual void mf1() // 转交函数 &#123; Base::mf1(); // 暗自成为 inline (见条款 30) &#125; ...&#125;;Derived d;int x;d.mf1(); // 很好, 调用的是 Derived::mf1d.mf1(x); // 错误! Base::mf1 被遮掩 条款34：区分接口继承和实现继承身为class设计者，有时候你会希望derived class只继承成员函数的接口，也就是声明；有时候你又会希望derived class同时继承函数的接口和实现，但又希望能够覆写（override）它们所继承的实现；又有时候你希望derived class同时继承函数的接口和实现，并且不允许覆写任何东西。 base类强烈影响以public形式继承它的derived class，因为： 成员函数的接口总是会被继承 声明一个pure virtual函数的目的是为了让derived类只继承函数接口 含有pure virtual函数的类属于抽象基类，不能被实例化。继承了它们的类必须重新声明此函数接口并给予实现。抽象基类可以给pure virtual函数提供定义，但调用它的唯一途径是“调用时指定其class的名称”。 声明impure函数的目的是让derived class继承该函数的接口和缺省实现 但是，允许impure virtual函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑XYZ航空公司设计的飞机继承体系。该公司只有A型和B型两种飞机，两者都以相同方式飞行。因此XYZ设计出这样的继承体系： 1234567891011121314class Airport &#123;...&#125;; // 用以表现机场class Airplane&#123;public: virtual void fly(const Airport&amp; destination); ...&#125;;void Airplane::fly(const Airport&amp; destination) &#123; ... // 缺省代码, 将飞机飞至指定的目的地&#125;class ModelA: public Airplane &#123;...&#125;;class ModelB: public Airplane &#123;...&#125;; 为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的fly实现”，Airplane::fly被声明为virtual。然而为了避免在ModelA和ModelB中撰写相同代码，缺省飞行行为由Airplane::fly提供，它同时被ModelA和ModelB继承。 现在，XYZ航空公司决定购买一种新式C型飞机。C型和A型以及B型的飞行方式不同。XYZ公司的程序员在继承体系中针对C型飞机添加了一个class，但由于他们急着让新飞机上线服务，竟忘了重新定义其fly函数： 12345678910class ModelC : public Airplane&#123; // 未声明fly函数&#125;;Airport PDX(... ); // PDX 是我家附近的机场Airplane* pa= new ModelC;...// 这将酿成大灾难pa-&gt;fly(PDX); // 调用 Airplane::fly 一种解救办法为切断“virtual函数接口”和其“缺省实现”之间的连接。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Airplane&#123;public: // 现在是 pure virtual 函数 virtual void fly(const Airport&amp; destination) = 0;protected: void defaultFly (const Airport&amp; destination);&#125;;void Airplane::defaultFly(const Airport&amp; destination)&#123; ... // 缺省行为, 将飞机飞至指定的目的地。&#125;class ModelA : public Airplane &#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly(destination); &#125;&#125;;class ModelB : public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly (destination); &#125;&#125;;// 现在 ModelC class 不可能意外继承不正确的 fly 实现代码了// 因为 Airplane 中的 pure virtual 函数追使 ModelC 必须提供自己的 f1y 版本class ModelC: public Airplane&#123;public: virtual void fly(const Airport&amp; destination);&#125;;void ModelC::fly(const Airport&amp; destination)&#123; ... // 将 C 型飞机飞至指定的目的地&#125; 另一种解救方法是，利用“pure virtual函数必须在derived class中重新声明，但它们也可以拥有自己的实现”这一事实。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Airplane&#123;public: // 现在是 pure virtual 函数 virtual void fly(const Airport&amp; destination) = 0;&#125;;// 给予 pure virtual 函数实现void Airplane::fly(const Airport&amp; destination)&#123; ... // 缺省行为, 将飞机飞至指定的目的地&#125;class ModelA : public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; Airplane::fly(destination); // 通过指定其类名调用它 &#125; ...&#125;;class ModelB : public Airplane&#123;public: virtuai void fly(const Airport&amp; destination) &#123; Airplane::fly(destination); // 通过指定其类名调用它 &#125; ...&#125;;class ModelC : public Airplane&#123;public: virtual void fly(const Airport&amp; destination);&#125;;void ModelC::fly(const Airport&amp; destination)&#123; ... // 将 C 型飞机飞至指定的目的地&#125; 声明non-virtual函数的目的是为了derived class继承函数的接口及其强制性实现 non-virtual函数为其所属class建立的意义是不变性凌驾其特异性，所以它不该在derived class中被重新定义。 条款35：考虑virtual函数以外的其他选择假设你正在写一个视频游戏软件，你的游戏属于暴力砍杀类型，剧中人物存在被伤害而降低健康状态的情况。因此你决定提供一个成员函数 healthvalue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将healthvalue声明为virtual似乎是再明白不过的做法： 123456class GameCharacter&#123;public: virtual int healthvalue() const; // 返回人物的健康指数, // derived classes 可重新定义它&#125;; 现在考虑一些其它解法： 借助non-virtual interface(NVI)手法实现Template Method模式 保留healthvalue为public成员函数，但让它成为non-virtual，并调用一个private virtual函数进行实际工作： 123456789101112131415161718class GameCharacter&#123;public: int healthvalue() const // derived class 不重新定义它 &#123; ... // 做一些事前工作 int retval = doHealthvalue(); // 做真正的工作 ... // 做一些事后工作 return retval; &#125;// NVI 手法下没必要让 virtual 函数一定是 privateprivate: virtual int doHealthValue() const // derived class 可重新定义它 &#123; ... // 缺省算法, 计算健康指数。 &#125;&#125;; 这一基本设计，“令客户通过public non-virtual成员函数间接调用private virtual函数”，称为non-virtual interface(NVI)手法。它是所谓Template Method设计模式的一个独特表现形式。我把这个non-virtual函数（healthvalue）称为virtual函数的外覆器（wrapper) 。 NVI手法的一个优点隐藏在上述代码注释“做一些事前工作”和“做一些事后工作”之中。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证 class约束条件、验证函数先决条件等。“事后工作”可以包括互斥器解除锁定、验证函数的事后条件、再次验证class约束条件等。如果你让客户直接调用virtual函数，就没有任何好办法可以做这些事。 借助Function Pointer实现Strategy模式 另一个设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个函数指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算： 123456789101112131415161718192021class GameCharacter; // 前向声明// 以下函数是计算健康指数的缺省算法int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: typedef int (*HealthCalcFunc)(const GameCharacter&amp;); explicit GameCharacter (HealthCalcFunc hcf = defaultFealthCalc) : healthFunc(hcf) &#123;&#125; int healthvalue() const &#123; return healthFunc (*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 这种设计策略和前面介绍的方法相比提供了一些有趣的弹性： 同一人物类型的不同实体可以有不同的健康计算函数 123456789101112class EvilBadGuy : public GameCharacter&#123;public: explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc) : GameCharacter(hcf) &#123;...&#125; ...&#125;;int loseHealthQuickly(const GameCharacter&amp;); // 健康指数计算函数 1int loseHealthSlowly(const GameCharacter&amp;); // 健康指数计算函数 2EvilBadGuy ebg1(loseHealthQuickly); // 相同类型的人物搭配EvilBadGuy ebg2(loseHealthSlowly); // 不同的健康计算方式 某已知人物之健康指数计算函数可在运行期变更 例如GameCharacter可提供一个成员函数setHealthcalculator，用来替换当前的健康指数计算函数。 然而这种策略意味着，计算函数并不能访问“被计算健康指数的”那个对象的内部（non-public）成分。如果需要访问non-public成分进行精确计算，这就有问题了。 唯一能够解决的办法就是：弱化class的封装。例如，将健康计算函数声明为friend。或是为其实现的某一部分提供public访问函数。这需要你来权衡利弊进行抉择。 借助std::function实现Strategy模式 123456789101112131415161718192021class GameCharacter;int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: // 不同之处 typedef std::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc; explicit GameCharacter (HealthCalcFunc hcf = defaultFealthCalc) : healthFunc(hcf) &#123;&#125; int healthvalue() const &#123; return healthFunc (*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 那个签名代表的函数是“接受一个reference指向const GameCharacter，并返回int”。这个std::function类型（也就是我们所定义的HealthCalcFunc类型）产生的对象可以持有（保存）任何与此签名式兼容的可调用物。所谓兼容，意思是这个可调用物的参数可被隐式转换为const GameCharacter&amp;，而其返回类型可被隐式转换为int。 这就提供了很大的灵活性： 1234567891011121314151617181920212223242526272829303132333435363738short calcHealth(const GameCharacter&amp;); // 健康计算函数 // 注意其返回类型为 non-intstruct HealthCalculator&#123; // 为计算健康而设计的函数对象 int operator()(const GameCharacter&amp;) const &#123;...&#125;&#125;;class GameLevel&#123;public: float health(const GameCharacter&amp;) const; // 成员函数, 用以计算健康 // 注意其 non-int 返回类型&#125;;// 人物类型 1class EvilBadGuy: public GameCharacter&#123; ... // 同前&#125;;// 人物类型 2class EyeCandyCharacter: public GameCharacter&#123; // 假设其构造函数与 EvilBadGuy 同&#125;;// 人物 1, 使用某个函数计算健康指数EvilBadGuy ebg1(calcHealth);// 人物 2, 使用某个函数对象计算健康指数EyeCandyCharacter ecc1(HealthCalculator());GameLevel currentLevel;...// 人物 3, 使用某个成员函数计算健康指数EvilBadGuy ebg2(std::bind(&amp;GameLevel::health, &amp;currentLevel, _1)); 传统的Strategy模式 123456789101112131415161718192021222324252627282930313233343536373839404142class GameCharacter;class HealthCalcFunc&#123;public: virtual ~HealthCalcFunc() &#123;&#125; virtual int calc(const GameCharacter&amp; gc) const = 0;&#125;;class SlowHealthLoser : HealthCalcFunc&#123;public: virtual int calc(const GameCharacter&amp; gc) const &#123; ... &#125; ...&#125;;class FastHealthLoser : HealthCalcFunc&#123;public: virtual int calc(const GameCharacter&amp; gc) const &#123; ... &#125; ...&#125;;class GameCharacter&#123;public: explicit GameCharacter(HealthCalcFunc* phcf) : pHealthCalc(phcf) &#123;&#125; int healthValue() const &#123; return pHealthCalc-&gt;calc(*this); &#125;private: HealthCalcFunc* pHealthCalc;&#125;; 条款36：绝不重新定义继承而来的non-virtual函数 如题 条款37：绝不重新定义继承而来的缺省参数值本条款的讨论局限于“继承一个带有缺省参数值的virtual函数”：virtual函数是动态绑定（后期绑定，延迟绑定），而缺省参数值却是静态绑定（前期绑定，早绑定）。 123456789101112131415161718192021222324252627// 一个用以描述几何形状的classclass Shape&#123;public: enum ShapeColor&#123;Red, Green, Blue&#125;; // 所有形状都必须提供一个函数, 用来绘出自己 virtual void draw(ShapeColor color = Red) const = 0; ...&#125;;class Rectangle : public Shape &#123;public: // 注意, 赋予不同的缺省参数值, 这真糟糕! virtual void draw(ShapeColor color = Green) const; ...&#125;;class Circle : public shape&#123;public: virtual void draw(ShapeColor color) const; // 请注意，以上这么写则当客户以 对象 调用此函数一定要指定参数值 // 因为静态绑定下这个函数并不从其 base 继承缺省参数值 // 但若以指针或 reference 调用此函数, 可以不指定参数值 // 因为动态绑定下这个函数会从其 base 继承缺省参数值&#125;; 对象的静态类型就是它在程序中所声明的类型，对象的动态类型则是指“目前所指对象的类型” 123shape* ps; // 静态类型为 shape*, 无动态类型Shape* pc = new Circle; // 静态类型为 Shape*, 动态类型是 Circle*Shape* pr = new Rectangle; // 静态类型为 shape*, 动态类型是 Rectangle* 动态类型可在程序执行过程中改变（通常是经由赋值动作）： 12ps = pc; // ps 的动态类型如今是 circle*ps = pr; // ps 的动态类型如今是 Rectangle* virtual函数系动态绑定而来，意思是调用一个virtual函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。 12pr-&gt;draw(); // 调用的是 Rectangle::draw(shape::Red)! // 注意缺省参数是 Red 而不是 Green 此例之中，pr的动态类型是Rectangle*，所以调用的是Rectangle的virtual函数。Rectangle::draw函数的缺省参数值应该是Green，但由于pr的静态类型是shape*，所以此一调用的缺省参数值来自Shape class而非Rectangle class！这不符合预期。 解救方法是利用条款35中介绍的NVI手法替代virtual函数： 123456789101112131415161718192021class Shape&#123;public: enum shapeColor&#123;Red, Green, Blue&#125;; void draw(ShapeColor color = Red) const // 如今它是 non-virtual &#123; doDraw(color); // 调用一个 virtual &#125;private: virtual void doDraw(shapeColor color) const = 0; // 真正的工作在此处完成&#125;;class Rectangle : public Shape&#123;public: ...private: virtual void doDraw (ShapeColor color) const; // 注意, 不须指定缺省参数值 ...&#125;; 这个设计很清楚地使得draw函数的color缺省参数值总是Red。 条款38：通过复合塑模出has-a或is-implemented-in-terms-of当某种类型的对象内含其它对象时便形成了复合关系。 应用域 程序中的对象其实相当于你所塑造出来的世界中的某些事物。比如人，汽车，高楼大厦等。这样的对象属于应用域部分。 实现域 其它对象如缓冲区，互斥器，搜索树等纯粹是实现细节上的工具。这些对象相当于软件中的实现域。 当复合发生于应用域对象之间表现出has-a关系，当它发生于实现域内则表现出is-implemented-in-terms-of（根据某物实现出）的关系。 复合的意义和public继承完全不同 注意区分is-a和is-implemented-in-terms-of这两种对象关系。 条款39：明智而谨慎地使用private继承一个derived类继承base类有public、protected或private三种继承方式。 公有继承（public）（普遍使用） base类的public成员也是derived类的public成员，base类的protected成员也是derived类的protected成员 保护继承（protected）（基本不使用） base类的public和protected成员将成为derived类的protected成员。 私有继承（private）（少的情况使用） base类的public和protected成员将成为derived类的private成员。 无论哪一种继承方式，base类的private成员都不能直接被derived类访问，但是可以通过调用base类的public和protected成员间接来访问（如果base类提供了访问接口的话）。 private继承意味着is-implemented-in-terms-of private继承只限于软件实现层面，这就是为什么private继承后，base class的所有成分（除了private）在你的class内都是private，因为它们都只是实现细节而已。 尽可能使用复合，必要时才使用private继承 当derived类想要访问base class的protected成员时 当derived类为了重新定义base class的virtual函数时 现在考虑一个Widget类，它需要用到另一个计时器Timer类来实现一些业务。 123456 class Timer&#123;public: explicit Timer(int tickFrequecy); virtual void onTick() const; // 定时器每滴答一次, 此函数就调用一次&#125;； 为了让Widget重新定义Timer内的virtual函数，Widget必须继承自Timer。因为Widget不是个Timer，因此public继承不合适。必须以private方式继承： 123456class Widget&#123; ...private: virtual void onTick() const; // &#125;; 通过private继承，Timer的public onTick函数在Widget内变成private，而我们重新声明（定义）时仍然把它留在那儿。如果把onTick放进public内会误导客户以为他们可以调用它，那就违反了条款18。 另一种设计方案是采用复合 + public继承： 123456789101112131415class Widget&#123; ...private: // 在 Widget 内声明一个嵌套式 private class class WidgetTimer : public Timer &#123; public: // 以 public 方式继承并重新定义 virtual 函数 virtual void onTick() const; ... &#125;; WidgetTimer timer; ...&#125;; 采用第二种较为复杂的方式的两点理由： 你或许会想设计Widget使它得以拥有derived class，但同时你可能会想阻止derived class重新定义onTick。如果Widget继承自Timer，上面的想法就不可能实现，即使是private继承也不可能。但如果WidgetTimer是Widget内部的一个private成员并继承自Timer，Widget的derived class将无法取用WidgetTimer，因此无法继承它或重新定义它的virtual函数。 你或许会想要将Widget的编译依存性降至最低（条款31）。如果Widget继承Timer，当Widget被编译时Timer的定义必须可见，所以定义Widget的那个文件恐怕必须#include Timer.h。但如果WidgetTimer移出Widget所在文件之外而Widget内含指针指向一个WidgetTimer，Widget可以只带着一个简单的WidgetTimer前向声明式，不再需要#include任何与Timer有关的东西。很容易就实现了解耦。 EBO（empty base optimization） empty class指的是没有non-static成员变量，没有virtual函数，也没有virtual base class。于是这种class不占用理论上不占用任何内存空间。然而在实现技术上，C++要求独立（非附属）对象都必须有非零大小。 12345678910class Empty &#123; &#125;; // 没有任何需要存储的数据// 理论上 sizeof(HoldAnInt) = 4 字节(就一个 int)// 实际上 sizeof(HoldAnInt) = 8 字节class HoldAnInt&#123;private: int x; // 4 字节 Empty e; // 理论上应该不占据内存&#125;; C++编译器默认为empty class独立对象安插一个char（1字节） 由于内存对齐HoldAnInt的实际大小为4 + 1(内存对齐至 4) = 8 但这个约束不适用于derived class对象的base class成分（非独立）： 123456// 理论和实际上 sizeof(HoldAnInt) = 4 字节(就一个 int)class HoldAnInt : public Empty&#123;private: int x; // 4 字节&#125;; 现实中的empty class并非真是empty。往往内含typedef，enum，static成员变量，或non-virtual函数。STL就有许多技术用途的empty class，其中内含有用的成员（通常是typedef），包括base class unary_function和binary_function，这些是“用户自定义之函数对象”通常会继承的class。由于EBO，这样的继承很少增加derived class的大小。 条款40：明智而谨慎地使用多重继承 多重继承较单一继承复杂，可能导致歧义性 当继承的多个base具有同名成员函数时，derived类调用时会出现歧义。 有时多重继承不得不需要virtual继承，而这会带来额外的体积、运行速度、初始化复杂度等成本 比如这样的钻石继承体系： 这个继承体系中某个base class和某个derived class之间有一条以上的相通路线，假设File class有个成员变量fileName，那么IOFile从每一个base class各继承一份，所以其对象内会有两份fileName成员变量。然而IOFile对象只该有一个文件名称，所以名称fileName不该重复。 解决办法就是采用virtual继承： virtual继承带来的后果是： 使用virtual继承的那些class所产生的对象往往比使用non-virtual继承的class体积大 访问virtual base class的成员变量时，也比访问non-virtual base class的成员变量速度慢 另外，支配“virtual base class初始化”的规则比起non-virtual base class的情况远为复杂且不直观。virtual base class的初始化责任是由继承体系中的最低层（most derived）class负责的，这意味着： class若派生自virtual base而需要初始化，必须知道其virtual base class——不论那些base class距离多远。 当一个新的derived class加入继承体系中，它必须承担其virtual base class的初始化责任。 关于virtual继承的忠告： 非必要不使用virtual base。平常请使用non-virtual继承。 如果必须使用virtual base class，尽可能避免在其中放置数据。这么一来你就不需担心这些class身上的初始化（和赋值）所带来的诡异事情了。 最后看一个多重继承的应用例子——public继承某个Interface class和private继承某个协助实现的class。 （参考书籍P195-P198）","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"数据结构与算法之概论","date":"2020-04-04T05:54:42.000Z","path":"eSK55yN7G7dNea2c/","text":"数据结构相互之间存在一种或多种特定关系的数据元素的集合。研究数据结构，关心的是数据对象的描述以及相关操作函数的实现。 数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如整型、浮点型等数值类型，以及声音、图像等非数值类型。 数据元素是组成数据的、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。 数据项一个数据元素可以由若干个数据项组成。它是数据不可分割的最小单位。 数据对象是性质相同的数据元素（即有相同的数量和类型的数据项）的集合，是数据的子集。 常见的数据结构 线性数据结构：向量vector（顺序存储）、链表list（链式存储）、栈stack和队列queue（优先队列）。 半线性数据结构：二叉树、搜索树（二叉搜索树BST、AVL树、B树、红黑树）、竞赛树等。 非线性数据结构：图。 哈希表hashtable、字典dictionary。 抽象数据类型 数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 抽象数据类型：指一个数学模型及定义在该模型上的一组操作。可以理解为C++中的类class。它体现的是程序设计中问题分解、抽象和信息隐藏的特性。 抽象数据类型的标准格式12345678ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义Operation 操作1 操作2 ...endADT 算法算法是解决指定问题求解步骤的描述。在计算机中是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。 计算或信息处理指借助某种工具，按照一定的规则，以明确而机械的形式进行。 算法中的计算模型就是计算机，即信息处理工具。 算法必须具备的几大要素 输入：待处理的信息或问题。 输出：经处理的信息，即答案。 正确性：的确可以解决指定的问题。 确定性：任何一个算法都可以描述为一个由基本操作组成的序列。 可行性：每一基本操作都可实现，且能在常数时间内完成。 有穷性：对于任何输入，经有限次的基本操作，都可以得到输出。 一个好的算法 正确，即符合语法，能够编译、链接。 能够正确处理简单的、大规模的、一般性的、退化的、任意合法的输入。 健壮，能够辨别不合法的输入并做适当处理，而不致非正常退出。 可读，结构化 + 准确命名 + 注释 + …。 效率，运行速度尽可能快，用到的存储空间尽可能少。 常见的算法 查找 顺序查找、二分查找、插值查找、斐波那契查找、分块查找和哈希查找等。 排序 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序和希尔排序等。 递归、分而治之、动态规划、回溯法和分支定界法等。 要对数据结构和算法设计方法给予评价，就必须能够计算程序性能。 数据结构和算法的关系 数据结构(data structures) + 算法(algorithms) = 程序(programs) (data structures + algorithms) x efficiency = computation 程序性能分析是指分析一个程序对于内存空间和运行时间的需求。 空间复杂度指程序运行时临时占用内存的大小。广义上的概念是包括存储算法本身所占用的空间、算法的输入输出数据所占用的空间以及算法在运行过程中临时占用的存储空间这三个方面。 时间复杂度指运行程序所需要的时间。这里度量的是程序中基本操作执行的次数，它是问题规模n的函数f(n)。记T(n)=O(f(n))，它表示随问题规模n的增大，算法执行时间的增长率和f(n)相同，称作算法的渐进时间复杂度。 复杂度分析这里的复杂度分析通常指的是最坏时间复杂度分析。 常数阶O(1) 取前三个元素x = S[0]、y = S[1]和z = S[2]，这一步只需执行三次（从特定单元读取元素的）基本操作，耗费O(3)时间。接下来，为确定这三个元素的大小次序，最多需要做三次比较，也需O(3)时间。最后，输出居中的非极端元素只需O(1)时间。因此，上面取非极端元素算法的时间复杂度为：T(n) = O(3) + O(3) + O(1) = O(7) = O(1)。 对数阶O(logn) 根据右移运算的性质，每右移一位，n都至少缩减一半。也就是说，至多经过1 + log2n次循环，n必然缩减至0，从而算法终止。因此时间复杂度为：O(1 + log2n) = O(log2n) 。 线性阶O(n) 平方阶O(n) 时间复杂度为：O(2n^2 + n + 1) = O(n^2)。 常见的算法时间复杂度排序Ο(1) ＜ Ο(logn) ＜ Ο(n) ＜ Ο(nlogn) ＜ Ο(n^2) ＜ … ＜ Ο(2^n) ＜ Ο(n!)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Effective C++之实现","date":"2020-04-01T13:35:42.000Z","path":"hNsvEFKo8ZJPUeMf/","text":"第5章：实现条款26：尽可能延后变量定义式的出现时间 应该延长变量的定义，直到非得使用它时 应该延后这份定义，直到能够给它初值实参 对于循环存在的情况： 做法A：定义于循环外 123456Widget w;for(int i = 0; i &lt; n; i++)&#123; w = 取决于 i 的某个值； ...&#125; 做法B：定义于循环内 12345for(int i = 0; i &lt; n; i++)&#123; Widget w(取决于 i 的某个值); ...&#125; 这两种写法的成本如下： 做法A：1个构造函数 + 1个析构函数 + n个赋值操作 做法B：n个构造函数 + n个析构函数 做法A会造成名称w的作用域比做法B更大 除非（1）你知道赋值成本比构造 + 析构成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法B。 条款27：尽量少做转型操作旧式C转型： T(expression) (T)expression 新式C++转型： const_cast&lt;T&gt;(expression) 用来将对象的常量性（const）转除（只有它能办到）。 dynamic_cast&lt;T&gt;(expression) 用来执行安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型。 reinterpret_cast&lt;T&gt;(expression) 用来执行低级转型，如将一个pointer to int 转为一个int。很少使用（在条款50中使用过一次）。 static_cast&lt;T&gt;(expression) 用来强迫隐式转换，例如将non-const对象转为const对象，将int转为double，将void*指针转为typed指针，或将pointer to base转为pointer to derived。 任何一种类型转换（无论显式转换还是隐式转换）往往都会令编译器编译出运行期间执行的码。如将int转为double会产生一些代码，因为int的底层表述不同于double的： 123int x, y;...double z = static_cast&lt;double&gt;(x) / y; 再比如： 1234class Base &#123;...&#125;;class Derived: public Base &#123;...&#125;;Derived d;Base* pb = &amp;d; // 隐喻的将 Derived* 转换为 Base* 这种情况下有时候会有一个偏移量在运行期被施行于Derived*身上，用来取得正确的Base*指针值。这个例子表明单一对象可能有一个以上的地址（以Base*指向它时的地址和以Derived*指向它时的地址）。 假设我们有个base class Window和一个derived class Specialwindow，两者都定义了virtual函数onResize。进一步假设Specialwindow的onResize函数被要求首先调用Window的onResize。下面实际上是错的实现方式： 12345678910111213141516171819202122class Window&#123;public: ... virtual void onResize () &#123;...&#125; // base onResize实现代码 ...&#125;;class Specialwindow: public Window&#123;public: ... // derived onResize 实现代码 virtual void onResize() &#123; static_cast&lt;Window&gt;(*this).onResize(); // 将 *this 转型为 Window, // 然后调用其 onResize; // 这不可行! ... // 这里进行 Specialwindow 专属行为 &#125; ...&#125;; 它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“*this对象之base class成分”的暂时副本身上的onResize！如果Window::onResize修改了对象内容，当前对象其实没被改动，改动的是副本。然而SpecialWindow::onResize内如果也修改对象，当前对象真的会被改动。这使当前对象进入一种“伤残”状态：其base class成分的更改没有落实，而derived class成分的更改倒是落实了。 正确的做法是： 1234567891011class Specialwindow: public Window&#123;public: ... virtual void onResize() &#123; Window::onResize(); // 调用 Window::onResize 作用于 *this 身上 ... &#125; ...&#125;; dynamic_cast的实现版本执行速度相当慢，应该在注重效率的代码中保持对dynamic_cast的警觉 优良的C++代码很少使用转型，我们应该尽可能隔离转型动作，通过将它隐藏在某个函数内，使得客户可以调用该函数而不需要将转型放进他们自己代码内 宁可使用新式转型，也不要使用旧式转型，前者很容易辨识出来 条款28：避免返回handles指向对象内部成分 handles指指针、引用和迭代器 成员变量的封装性最多只等于“返回其reference”的函数的访问级别 如果const成员函数不得不传出去一个reference，则最好将返回类型限定为const 有可能会导致空悬的handles，它的生命期却长于其所指对象 条款29：为“异常安全”而努力是值得的当异常被抛出时，带有异常安全性的函数会： 不泄露任何资源 不允许数据败坏 较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也少。异常安全码必须提供以下三个保证之一： 基本承诺 如果异常被抛出，程序内的任何事物仍然保证在有效状态（只要那是个合法状态）下，没有任何对象或数据结构会因此而败坏，所有对象处于一种内部前后一致的状态。 强烈保证 如果异常被抛出，程序状态不改变。 不抛掷保证 承诺绝不抛出异常，因为它们总能完成原先承诺的功能。 可以实现强烈保证的copy and swap技术：为你打算修改的对象做出copy一份副本，然后在副本身上做一切修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。带所有改变都成功后，再将修改后的副本和原对象swap。 1234567891011121314151617181920212223242526272829// 之所以实现为 struct 是因为其 PrettyMenu 的数据封装性// 已经由 pImpl 是 private 获得了保证class Image &#123;...&#125;;struct PMImpl&#123; std::shared_ptr&lt;Image&gt; bgImage; int imageChanges;&#125;;class PrettyMenu&#123; ...private: Mutex mutex; std::shared_ptr&lt;PMImpl&gt; pImpl; // pimpl idiom 详细描述见条款 31&#125;;void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123; using std::swap; // 见条款25 Lock ml(&amp;mutex); // 获得mutex的副本数据 std::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl)); pNew-&gt;bgImage.reset(new Image(imgSrc)); // 修改副本 ++pNew-&gt;imageChanges; swap(pImpl, pNew); // 置换(swap)数据, 释放 mutex) 注意，并非所有函数都可实现强烈保证或其具备现实意义。 函数提供的”异常安全保证“通常最高只等于其所调用各个函数提供的”异常安全保证“中的最弱者。 条款30：透彻了解inlining的里里外外inline函数是指将对此函数的每一个调用都以函数本体替换之。这将导致两种情况： 目标码增加（显然） 如果inline函数的体积很小，编译器对“函数本体”所产出的码可能比“函数调用”所产出的码小 inline只是对编译器的一个申请，不是强制命令，也就是说编译器可以拒绝将太过复杂（带有递归或循环）的函数进行inline。通过对函数使用inline关键字属于明确提出申请，将函数定义于类内属于隐喻申请。 将大多数inline限制在小型、被频繁调用的函数身上 inline函数通常一定被置于头文件内 因为大多数构建环境在编译过程中进行inlining，而为了将一个函数调用替换为被调用函数的本体，编译器必须知道那个函数长什么样子。 所有对virtual函数的inline申请都会被拒绝（因为对virtual函数的调用在运行期才确定） 条款31：将文件间的编译依存关系降至最低 将接口从实现中分离 12345678910111213class Person&#123;public: Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); string name() const; string birthDate() const; string address() const; ...private: string theName; // 实现细目 Date theBirthDate; // 实现细目 Address theAddress; // 实现细目&#125;; 这里的class无法通过编译，因为编译器没有取得其实现代码所用到的class string，Date，Address的定义式，通常应该在Person定义文件的最上方存在include头文件。 123#include &lt;string&gt;#include \"date.h\"#include \"address.h\" 不幸的是，这么一来便是在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其他头文件有任何改变，那么每一个含入Person class的文件就得重新编译，任何使用person class的文件也必须重新编译。这样的连串编译依存关系（cascading compilation dependencies）会对许多项目造成难以形容的灾难。 Handle classes：pimpl idiom(pointer to implenmentation) + 前向声明 把Person分割成两个class，一个只提供接口，另一个负责实现接口。 1234567891011121314151617181920212223242526272829#include &lt;string&gt; //标准程序库组件不该被前向声明#include &lt;memory&gt;// 使用前向声明而不是包含头文件, 这个很关键class PersonImpl; // Person 实现类// Person 接口用到的 classclass Date; class Address;class Person&#123;public: Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); string name() const; string birthDate() const; string address() const; ...private: shared_ptr&lt;PersonImpl&gt; pImpl; // 指针, 指向实现物 // 如果不这样做的话, 编译器在编译 Person 类的时候，必须知道 Person 类的大小 // 就不得不包含这三个实现细目 /* string theName; // 实现细目 Date theBirthDate; // 实现细目 Address theAddress; // 实现细目 */ // 然而一旦这样写, 前面的前向声明就没用了, 必须包含头文件&#125;; 这样一来，Person类的使用者就完全于Date，Address以及Person的实现细目相分离了。这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：实现上让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。 几个简单的设计策略： 如果使用object reference或object pointer可以完成任务，就不要使用object 你可以只靠一个类型声明式就定义出指向该类型的reference和pointer；但如果定义某类型的object，就需要用到该类型的定义式。 如果能够，尽量以class声明式替换class定义式 注意，当你声明一个函数而它用到某个class时，你并不需要该class的定义。 为声明式和定义式提供不同的头文件 对于前面代码中的前向声明，最好是提供一个声明式头文件，包含全部的前向声明。 下面式Person.cpp文件的部分实现： 12345678910#include &lt;Person.h&gt;#include &lt;PersonImpl.h&gt; // 注意，Person 和PersonImpl的成员函数完全相同, 两者接口完全相同Person::Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr) : pImpl(new PersonImpl(name, birthday,addr)) &#123;&#125;string Person::narne( ) const &#123;return pImpl-&gt;name();&#125;... Interface classes：abstract base class + factory函数 abstract base class通常没有成员变量，也没有构造函数，只有一个virtual析构函数和一组pure virtual函数。但Interface class的客户必须有办法为这种class创建新对象。他们通常调用一个特殊函数，此函数创建实际实现的derived class，这样的函数通常称为factory(工厂）函数（见条款13），它们返回智能指针指向动态分配所得对象，而该对象支持Interface class的接口。这样的函数又往往在Interface class内被声明为static： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 位于 Person.h// 抽象基类, 只有声明// 提供给客户使用的头文件class Person&#123;public: virtual ~Person(); virtual strng name() const = 0; virtual strng birthDate() const = 0; virtual string address() const = 0; // static 的 factory 函数 static shared_ptr&lt;Person&gt; create(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); ...&#125;// 位于 Person.cpp#include \"Person.h\"class RealPerson: public Person&#123;public: RealPerson(const string&amp; name, const Date&amp; birthday, const Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125; virtual ~RealPerson() &#123;&#125; string name() const; string birthDate() const; string address() const;private: string theName; Date theBirthDate; Address theAddress;&#125;;... // 虚函数的实现码shared_ptr&lt;Person&gt; Person::create(const string&amp; name, const Date&amp; birthday, const Address&amp; addr)&#123; return shared_ptr&lt;Person&gt;(new RealPerson(name, birthday, addr));&#125; Handle classes和Interface classes解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之设计与声明","date":"2020-03-21T13:35:42.000Z","path":"S0Qfg61EKNlwLo15/","text":"第4章：设计与声明条款18：让接口容易被正确使用，不容易被误用 如果客户企图使用某个接口却没有获得所预期的行为，这个代码不应该通过编译；如果代码通过了编译，则它的行为就应该是客户想要的 欲达“让接口容易被正确使用，不容易被误用”的目的，必须考虑客户调用接口时可能做出什么样的错误 “促进正确使用”的办法包括接口的一致性，以及与内置类型兼容 “阻止误用”的办法包括建立新类型、限制在类型上的操作，束缚对象值以及消除客户的资源管理责任 条款19：设计class犹如设计type你应该带着“语言设计者当初设计语言内置类型时”一样的谨慎来研讨每一个class的设计。因为，重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结…全都在你手上。 新的type的对象应该如何创建和销毁？ 设计函数为类的构造函数和析构函数以及内存分配函数和释放函数（见条款49-52）。 对象的初始化和对象的赋值该有什么样的差别？ 决定了构造函数和赋值操作符的行为以及差异。 新type的对象被passed by value，意味着什么？ 取决于copy构造函数的实现。 什么新type的合法值？ 你的新type需要配合某个继承图系吗？ 见条款7、34、36。 你的新type需要什么样的转换？ explicit和operator关键字的使用。见条款15。 什么样的操作符和函数对此新type而言时合理的？ 见条款23、24、46。 什么样的标准函数应该驳回？ 见条款6。 谁该取用新type的成员？ 决定了数据成员是public、private还是protected，以及friend关键的使用。 什么是新type的“未声明接口”？ 见条款29。 你的新type有多么一般化？ 决定class template的使用。 你真的需要一个新type吗？ 条款20：宁以pass by reference to const替换pass by value 当把具有继承关系的类作为参数传递时，如果pass by value可能会出现“截断”问题。 条款21：必须返回对象时，别妄想返回其reference 绝不要返回指向一个local stack对象的pointer或reference 绝不要返回指向一个heap allocated对象的reference 除非有单例模式的设计要求，否则绝对不要返回指向一个local static对象的pointer或reference 条款22：将成员变量声明为private 客户访问数据的一致性 public里都是函数。 可以对成员变量有更精确的控制 可以实现成员变量的不可访问，只读、只写、读写访问。 封装性 将成员变量隐藏在函数接口背后，可以为所有可能的实现提供弹性。 从封装的角度看，只有两种权限：private（提供封装）和其它 protected并不比private更具封装性。 条款23：宁以non-member、non-friend替换member函数考虑一个用来表示网页浏览器的class，这个class提供的众多成员函数中，有用来清除下载元素高速缓冲区的，有用来清除访问过的历史记录的，有用来移除系统中所有cookies的。 12345678910111213141516171819202122232425262728class WebBrowser&#123;public: ... void clearCache(); void clearHistory(); void cleatCookies(); ...&#125;;// 客户想一整个执行所有的操作// 以提供一个 member 函数的方式class WebBrowser&#123;public: ... void clearEverthing(); ...&#125;;// 以提供一个 non-member 函数的方式void clearBrowser(WebBrowser&amp; wb)&#123; wb.clearCache(); wb.clearHistory(); wb.cleatCookies();&#125; 后者比较好。因为： 增加封装性 non-member non-friend将提供较大的封装性，因为它并不增加能够访问class内的private成分的函数数量。friend函数对class private成员的访问权力和member函数相同，两者对封装的冲击力度是一样的。 增加扩充机能性 在C++中，正确且自然的做法是： 123456namespace WebBrowserStuff&#123; class WebBrowser &#123;...&#125;; void clearBrowser(WebBrowser&amp; wb); // 为 WebBrowser “提供便利”的函数 ...&#125; namespace和class的不同是，前者可跨越多个源码文件而后者不能。 像WebBrowser这样的类可能有大量的“提供便利”函数，某些与书签有关，与打印有关，与cookie有关… 分离它们最直接的做法就是： 123456789101112131415161718// 头文件 WebBrowser.h 内namespace WebBrowserStuff&#123; class WebBrowser &#123;...&#125;; ... // 核心机能, 例如所有客户都想要的 non-member 函数&#125;// 头文件 WebBrowserBookmarks.h 内namespace WebBrowserStuff&#123; ... // 与书签相关的 non-member 函数&#125;// 头文件 WebBrowserCookies.h 内namespace WebBrowserStuff&#123; ... // 与 cookie 相关的 non-member 函数&#125; 将所有“便利函数”放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组“便利函数”。 条款24：若所有参数皆需类型转换，请为此采用non-member函数 有理数类Rational的实现 重点关注用来将两个有理数相乘的operator*操作符重载函数的实现方式。 条款25：考虑写出一个不抛异常的swap函数标准程序库提供的swap算法的典型实现为： 12345678910namespace std&#123; template&lt;typename T&gt; void swap(T&amp; a, T&amp; b) &#123; T temp(a); a = b; b = temp; &#125;&#125; 只要T类型支持copying函数（copy构造函数和copy assignment操作符）。对于用户自定义类型，效率低下（需要三次复制）。 现在考虑所谓的pimpl(pointer to implementation)实现手法： 1234567891011121314151617181920212223242526// 注意这是个模板类template&lt;typename T&gt;class WidgetImpl&#123;public: ... // 细节不重要private: ... // 有很多数据, 意味着复制时间很长&#125;;// 注意这是个模板类template&lt;typename T&gt;class Widget&#123;public: Widget(const Widget&lt;T&gt;&amp; rhs); // 关于 operator= 的一般性实现参考条款 10, 11, 12 Widget&amp; operator=(const Widget&lt;T&gt;&amp; rhs) &#123; ... *pImpl = *(rhs.pImpl); ... &#125;private: WidgetImpl&lt;T&gt;* pImpl; // 指向实际实现的对象&#125;; 一旦需要置换两个Widget对象值，我们实际唯一需要的是置换两个指针即可。但缺省的swap函数不知道这一点！ 下面是正确的实现步骤： 令Widget实现一个名为swap的public成员函数做真正的置换工作 123456789101112template&lt;typename T&gt;class Widget&#123;public: ... void swap(Widget&lt;T&gt;&amp; other) &#123; using std::swap; // 必须的 swap(pImpl, other.pImpl); // 直接置换指针即可 &#125; ...&#125; 将std::swap特化，令它调用该成员函数（当Widget是类时。这里的例子中，Widget是个模板类则不要这一步） 因为，C++只允许对class template偏特化，不允许对function template进行偏特化 12345678namespace std&#123; template&lt;&gt; void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; a.swap(); &#125;&#125; 声明一个non-member swap，令它调用member swap 123456// 注意, 要将它放在和 Widget&lt;T&gt; 同一个空间内(全局或者自定义的 namespace)template&lt;typename T&gt;void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)&#123; a.swap(b);&#125; 编程时，在调用swap置换对象的语句之前加上using std::swap声明 123456789// 客户代码template&lt;typename T&gt;void doSomething(T&amp; obj1. T&amp; obj2)&#123; using std::swap; // 令 std::swap 在此函数内可用 ... swap(obj1, obj2); // 这样一来, 编译器将为 T 类型对象调用最佳版本 swap ...&#125; 编译器首先在全局作用域或T所在命名空间内寻找T（在这里，T就是例子中的Widget哦）专属的swap（也就是步骤3中实现的）。如果没有实现这些，则调用std内的swap，如果步骤2还实现了特化版本，将会选中特化版本。 劝告，member swap绝不可抛出异常 具体参考条款29。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之资源管理","date":"2020-03-15T13:35:42.000Z","path":"ojSMOM86r5rbvAqL/","text":"第3章：资源管理条款13：以对象管理资源 RAII(Resource Acquisition Is Initialization) 使用new获取资源后于同一条语句内以它初始化某个资源管理对象。利用当管理对象离开作用域被销毁时自动调用其析构函数的机制确保资源被释放。不直接用new和delete，多用智能指针。 智能指针在其析构函数中做delete动作而非delete[]动作 因此，不要在动态分配来的数组身上使用智能指针（虽然它仍然会通过编译）。 条款14：在资源管理类中小心copying行为 当不想RAII类被复制时可以继承Uncopyable类 将智能指针施于heap-based资源身上是个好主意，但并不是所有资源都是heap-based的，比如互斥器mutex，mutex就不可复制。 条款15：在资源管理类中提供对原始资源的访问 显示转换（安全） 例如，shared_ptr类就提供可一个get成员函数来返回智能指针内部的原始指针。 operator隐式转换（调用方便） 123456789101112131415161718class A&#123; ... // operator 可以实现隐式转换函数 operator B() const &#123; return b; &#125; ...private: B b; // B 类型对象成员&#125;;// 接受 B 类型对象的一个函数void func(B b);A a;func(a); // a 会被编译器隐式转换为 B 类型对象 条款16：使用new和delete时要采用相同的形式 编译器在给数组分配内存时，会包括数组大小的记录 这样的好处是，delete[]时知道需要调用多少次析构函数。 不要对数组形式进行typedef动作 条款17：以独立语句将new来的对象置入智能指针考虑这样两个函数： 12int priority(); // 调用这个函数不排除会发生异常void processWidget(shared_ptr&lt;Widget&gt; pw, int priority); 如果这样调用编译不通过，因为shared_ptr接收原始指针的构造函数是explicit的： 1processWidget(new Widget, priority()); 如果这样调用可能会造成内存泄漏： 1processWidget(shared_ptr&lt;Widget&gt;(new Widget), priority()); 因为编译器在编译这条语句时，实际上会创建三个动作： 调用priority() 执行new Widget 调用shared_ptr的构造函数 而C++编译器安排这三个动作的次序是不确定的。 如果执行次序是这样： 执行new Widget 调用priority() 调用shared_ptr的构造函数 一旦中途priority()导致异常，那么new返回的原始指针并未交给智能指针保管，将造成资源泄露。 正确的做法： 12shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority()); 因为，编译器对“跨越语句的各项操作”没有重新排列执行次序的自由。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之构造、析构、赋值运算","date":"2020-03-08T13:35:42.000Z","path":"MeCvwFxjI4asjddf/","text":"第2章：构造、析构、赋值运算条款05：了解C++默默编写并调用哪些函数 编译器会暗自为class创建default构造函数、copy构造函数、copy assignment操作符以及析构函数 对于class内含reference成员或const成员，编译器拒绝为其生成copy构造函数和copy assignment操作符 因为C++不允许reference改指向不同的对象以及更改const成员。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝 为驳回编译器自动提供的函数，可将相应的成员函数声明为private并且不予实现。 掌握Uncopyable类的实现机制 将构造函数和析构函数设置为protected的 将拷贝构造函数和拷贝赋值运算符设置为private的 12345678910class Uncopyable&#123;protected: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable &amp;); const Uncopyable &amp;operator=(const Uncopyable &amp;);&#125;; 条款07：为多态基类声明virtual析构函数 带多态性质的base class应该声明一个virtual析构函数 当class内至少含有一个virtual函数，才为它声明virtual析构函数 class的设计目的如果不是作为base class使用，或不是为了具备多态性，就不该声明virtual析构函数 然而，有时候你希望拥有一个抽象类，但没有任何需要的pure virtual方法，怎么办？ 由于abstract class（不能实例化）总是被期望当作多态基类，多态基类又需要virtual析构函数，而pure virtual函数会导致abstract class，因此可将析构函数声明为pure virtual并且给出默认实现。 12345678// 小技巧:pure virtual 析构函数class AWOV&#123;public: virtual ~AWOV() = 0;&#125;;AWOV::~AWOV() &#123;/* default */&#125; 条款08：别让异常逃离析构函数 析构函数绝对不要吐出异常 假设有一个类负责数据库的连接： 12345678class DBConnection&#123;public: ... static DBConnection create(); void close(); // 关闭联机, 失败则抛出异常&#125;; 为了确保客户不忘记在DBConnection对象上调用close函数，一个合理的想法是创建一个用来管理DBConnection资源的类，并在析构函数中调用close。 123456789101112class DBConn&#123;public: ... ~DBConn() &#123; db.close(); &#125; private: DBConnection db;&#125;; 用户可以写出这样的代码 1234&#123; DBConn dbc(DBConnection::create()); ...&#125; // 区块作用域结束，调用析构函数销毁对象 如果被析构函数调用的函数close可能抛出异常，析构函数应该捕获异常然后吞下它们或者结束程序。 一个好的策略是，开放一个close接口供用户调用，把调用close的责任从DBConn析构函数手上移到用户手上。 1234567891011121314151617181920212223242526272829class DBConn&#123;public: ... void close() &#123; db.close(); closed = true; &#125; ~DBConn() &#123; if(!closed) &#123; try &#123; db.close(); // 关闭连接（如果客户没做的话） &#125; catch(...) &#123; 日志记录下对 close 调用的失败; ... &#125; &#125; &#125; private: DBConnection db; bool closed;&#125;; 因此，如果客户需要对某个操作函数运行期间的异常作出反应，那么class应该提供一个接口执行该操作。如果close的确发生了异常，而客户没有调用close接口进行处理，DBConn只能吞下或结束程序。 条款09：绝不在析构和构造函数中调用virtual函数 派生类对象内的基类成分会在派生类自身成分被构造之前先被构造 基类构造期间，虚函数绝不会下降到派生类层 需要注意的是，有时类有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复时会把相同的初始化代码放到一个init函数中实现，如果这时在init函数中同样调用了虚函数，情况是一样的但比较隐秘。 条款10：令赋值操作符operator=返回一个reference to *this 为了实现连续赋值 条款11：在operator=中处理自我赋值 有些自我赋值并不明显，如通过指针或引用 假设你建立一个class来保存一个指针指向一块动态分配的位图（bitmap）： 1234567class Bitmap &#123;...&#125;;class Widget&#123; ...private: Bitmap* pb; // 指向一个从 heap 分配而得的对象&#125;; 错误的operator=实现为： 1234567// 自我赋值不安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs,pb); return *this;&#125; 可通过一个“证同测试”来检验： 12345678910// 自我赋值安全, 但不具备异常安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; if(this == &amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs,pb); return *this;&#125; 所谓的异常安全指的是，如果new Bitmap发生异常，会导致Widget最终会持有一个指针指向一块被删除的Bitmap。 12345678910// 具备异常安全, 则自动具备自我赋值安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* oldPb = pb; // 记住之前的 pb pb = new Bitmap(*rhs,pb); delete oldPb; return *this;&#125; 使用更好的copy and swap技术： 1234567891011121314151617181920212223class Bitmap &#123;...&#125;;class Widget&#123; ... void swap(Widget&amp; rhs) &#123; ... // 交换 *this 和 rhs 的数据, 见条款 25 &#125; ...&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; // 提升点效率 ? // if(this == &amp;rhs) // return *this; Widget temp(rhs); // copy swap(temp); // swap return *this;&#125; 条款12：复制对象时勿忘每一个成分 每一个成分包括对象内所有成员变量以及所继承的基类成分 在拷贝构造函数中的初始化列表中调用所继承的类的拷贝构造函数 在拷贝赋值操作符函数中调用所继承的类的拷贝赋值操作符函数 不要尝试让拷贝构造函数和拷贝赋值操作符函数互相调用","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]},{"title":"Effective C++之让自己习惯C++","date":"2020-03-01T13:35:42.000Z","path":"l4snoL8SUW9lGasI/","text":"第1章：让自己习惯C++条款01：视C++为一个语言联邦 将C++视为由4个次语言组成的联邦： C：没有模板、没有异常、没有重载… Object-Oriented C++：类、封装、继承、多态、虚函数、动态绑定等等； Template C++：泛型编程部分； STL：是一个Template程序库，容器、迭代器、算法以及函数对象。 从某个此语言切换到另一个时，高效编程守则可能会发生变化。比如，C-like类型（内置类型）pass by value更好；对于Object-Oriented C++而言，pass by reference to-const更好；再切换到STL，由于迭代器和函数对象都是在C指针之上塑造出来的，pass by value守则再次适用。 条款02：尽量以const，enum，inline替换#define 对于单纯常量，最好以const对象或enum hack替换#define 1234567891011121314// 记号名称未进入符号表, 难以调试// 在多处出现目标码, 尤其浮点常量// 无作用域概念, 不提供任何封装性#define ASPECT_RATIO 1.653// 常量会被编译器看到, 进入符号表// 导致较小量的目标码, 因为只有一份// 可放置在类内或 namespace 中限制其作用域const double AspectRatio = 1.653;// 可以放在类或 namespace 中// 令 NumTurns 成为 5 的记号名称, 一般用在类中做常量用// 行为像 #define, 对 const 取地址合法，对 enum 和 #define 取地址就不合法enum &#123;NumTurns = 5&#125;; 对于形似函数的宏，最好用inline（或模板）函数替换 宏中的变量有可能会被运算多次。 条款03：尽可能使用const const作用于迭代器 STL迭代器是以指针为根据塑模出来的，其作用就像个T*指针。声明迭代器为const只是声明一个const指针（作用就像T* const），表明的是迭代器本身不可变，但其所指的值是可以改动的。如果希望迭代器所指的值不可改动，需要的是const_iterator。 123456789std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();*iter = 10; // 正确++iter; // 错误std::vector&lt;int&gt;::const_iterator citer = vec.begin();*citer = 10; // 错误++citer; // 正确 将operator*的返回类型声明为const-by-value const可被施加于任何作用域内的对象、函数参数（常用pass-by-reference-to-const），函数返回类型、类成员函数本体 const施加于成员函数 成员函数上的const限定符意味着不能修改non-mutable，non-static类数据成员。 当const和non-const成员函数有着实质等价的实现时，令non-const成员函数调用const版本可避免代码重复 12345678910111213141516171819202122232425262728293031class TextBook&#123;public: ... const char&amp; operator[](std::size_t position) const &#123; ... // 边界检验 ... // 日记数据访问 ... // 检验数据完整性 return text[position]; &#125; /* char&amp; operator[](std::size_t position) &#123; ... // 边界检验 ... // 日记数据访问 ... // 检验数据完整性 return text[position]; &#125; */ char&amp; operator[](std::size_t position) &#123; // 调用 const_cast 移除对象身上的 const // 调用 static_cast 为 *this 加上 cosnt return const_cast&lt;char &amp;&gt;( static_cast&lt;const TextBook&amp;&gt;(*this)[position] ); &#125;private: std::string text;&#125;; const版本成员函数调用non-const版本不合法 条款04：确定对象被使用前已先被初始化 为内置型对象进行手工初始化，因为C++并不保证初始化它们 构造函数使用成员初始化列表，初始化顺序与在类中声明顺序一致 为避免“跨编译单元内定义的non-local static对象的初始化问题”，以local对象替换non-local static对象 static对象包括global对象、定义与namespace作用域内的对象、在class内、函数内、以及在file作用域内被声明为static的对象 函数内的static被称为local static对象，其它static对象被称为non-local static对象 程序结束时，static对象会被自动销毁，也就是它们的析构函数在main函数结束时被自动调用 编译单元是指产出单一目标文件的源码文件以及所含入的头文件 现在有两个源码文件，每个至少含入一个non-local static对象，其中一个non-local static对象用到了另一个non-local static对象，而被用到的尚未被初始化。 1234567891011121314151617181920212223// 文件 FileSystem.cpp 中class FileSystem&#123;public: ... std::size_t numDisks()const; // 众多成员函数之一 ...&#125;;extern FileSystem tfs; // 预备给客户使用的对象, non-local static 对象// 文件 Directory.cpp 中class Directory&#123;public: Directory(); // 构造函数 ...&#125;;Directory::Directory()&#123; ... std::size_t disks = tfs.numDisks(); // 使用 tfs 对象 ...&#125; 现在客户决定创建一个Directory对象，用来放置临时文件： 1Directory tempDir; // 为临时文件而做出的目录 这个时候就会出现初始化次序带来的问题。由于tfs和tempDir是不同的人在不同的时间于不同的源码文件中创建出来的，因此初始化次序不一定。 解决方法： 12345678910111213141516171819202122232425262728// 文件 FileSystem.cpp 中class FileSystem&#123;public: ... std::size_t numDisks() const; // 众多成员函数之一 ...&#125;;FileSystem&amp; tfs() // 用于创建预备给客户使用的对象的函数&#123; static FileSystem fs; // local static 对象 return fs;&#125;// 文件 Directory.cpp 中class Directory&#123;public: Directory(); // 构造函数 ...&#125;;Directory::Directory()&#123; ... // 这样就保证了被使用对象先被初始化 std::size_t disks = tfs().numDisks(); // 使用 tfs() 创建对象 ...&#125;","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"}]}]