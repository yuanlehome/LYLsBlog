[{"title":"leetcode刷题系列之数据结构设计","date":"2021-07-10T13:35:42.000Z","path":"GRrK24ZqnqkWXLK0/","text":"这篇文章是leetcode刷题系列的第3部分——字符串。这里把有代表性的题目发出来，共计21道。字符串的问题杂且难，这一块，面试时碰到字符串问题时只能随机应变，没有固定的套路。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！ 622. Design Circular Queue 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： 1234567891011121314MyCircularQueue(k)构造器, 设置队列长度为 kFront从队首获取元素, 如果队列为空，返回 -1Rear获取队尾元素, 如果队列为空，返回 -1enQueue(value)向循环队列插入一个元素, 如果成功插入则返回真deQueue()从循环队列中删除一个元素, 如果成功删除则返回真isEmpty()检查循环队列是否为空isFull()检查循环队列是否已满 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 为了简单起见, 使用头尾两个索引变量和一个大小变量// _head 永远指向头元素的前一个位置// _tail 永远指向尾元素// _size 指示队列中的元素数// 队列方向为 _head &lt;----------- _tail// _head 和 _tail 只加不减, 循环class MyCircularQueue &#123;private: int _head; int _tail; int _size; vector&lt;int&gt; _data; public: // 初始化时, 头尾索引为 -1 表示无效, 大小为 0 MyCircularQueue(int k) : _head(-1), _tail(-1), _size(0) &#123; // 将 vector 容量扩充到指定大小, 默认以 0 填充 _data.resize(k); &#125; bool enQueue(int value) &#123; // 入队时, 判断是否已满 if(isFull()) &#123; return false; &#125; // 尾指针当前指向尾元素, 添加元素时需要 ++ // 如果超过 vector 索引范围, 直接回到 0 if(++_tail == _data.size()) &#123; _tail = 0; &#125; _data[_tail] = value; _size++; return true; &#125; bool deQueue() &#123; // 出队时先判断是否为空 if(isEmpty()) &#123; return false; &#125; // 因为 _head 当前指向首元素前一个位置 // 需要先 ++ 再赋值 _head++; // 如果超过 vector 索引范围, 直接回到 0 if(_head == _data.size()) &#123; _head = 0; &#125; _size--; return true; &#125; int Front() const &#123; if(isEmpty()) &#123; return -1; &#125; return _head + 1 == _data.size() ? _data[0] : _data[_head + 1]; &#125; int Rear() const &#123; return isEmpty() ? -1 : _data[_tail]; &#125; int size() const &#123; return _size; &#125; bool isEmpty() const &#123; return _size == 0; &#125; bool isFull() const &#123; return _size == _data.size(); &#125;&#125;; 146. LRU Cache 运用你所掌握的数据结构，设计和实现一个LRU(最近最少使用) 缓存机制 。 参考链接： 从 LRU Cache 带你看面试的本质 缓存淘汰算法的实现与应用介绍（LRU、LFU） 我竟然跪在了LRU，好亏奥！ 实现LRUCache类： 123456LRUCache(int capacity)以正整数作为容量 capacity 初始化 LRU 缓存int get(int key)如果关键字 key 存在于缓存中，则返回关键字的值, 否则返回 -1void put(int key, int value)如果关键字已经存在, 则变更其数据值: 如果关键字不存在, 则插入该组「关键字-值」, 当缓存容量达到上限时, 它应该在写入新数据之前删除最久未使用的数据值, 从而为新的数据值留出空间 1234567891011121314151617181920212223242526272829303132333435363738template &lt;typename T&gt;class LRUCache &#123;private: typedef T value_type; typedef int key_type; typedef typename list&lt;pair&lt;key_type, value_type&gt;&gt;::iterator iterator_to_node; unordered_map&lt;key_type, iterator_to_node&gt; _key2item; list&lt;pair&lt;key_type, value_type&gt;&gt; _items; size_t _capacity; public: LRUCache(size_t capacity) : _capacity(capacity) &#123;&#125;; ~LRUCache() = default; value_type get(key_type key) &#123; value_type value; if(_key2item.count(key)) &#123; value = _key2item[key]-&gt;second; _items.splice(_items.begin(), _items, _key2item[key]); &#125; return value; &#125; void put(key_type key, value_type value) &#123; if(_key2item.count(key)) &#123; _key2item[key]-&gt;second = value; _items.splice(_items.begin(), _items, _key2item[key]); &#125; else &#123; if(_capacity &lt;= _items.size()) &#123; _key2item.erase(_items.back().first); _items.pop_back(); &#125; _items.emplace_front(key, value); _key2item[key] = _items.begin(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041// hashmap + listtemplate &lt;typename T&gt;class LRUCache &#123;private: typedef T value_type; typedef int key_type; typedef typename list&lt;pair&lt;key_type, value_type&gt;&gt;::iterator iterator_to_node; size_t _capacity; unordered_map&lt;key_type, iterator_to_node&gt; _keyToItem; list&lt;pair&lt;key_type, value_type&gt;&gt; _itemList; public: LRUCache(size_t capacity) : _capacity(capacity) &#123;&#125; ~LRUCache() &#123;&#125; value_type get(key_type key) &#123; value_type value; if(_keyToItem.count(key)) &#123; value = _keyToItem[key]-&gt;second; // 如果 key 存在, 则在 LRUcache 中重新添加这个 key put(key, value); &#125; // 返回 key 对应的值 return value; &#125; void put(key_type key, value_type val) &#123; // 如果 key 已经存在, 则直接删掉链表中对应的条目 if(_keyToItem.count(key)) &#123; _itemList.erase(_keyToItem[key]); &#125; else if(_capacity &lt;= _itemList.size()) &#123; // 如果容量已经满, 则删除链表尾部的条目以及 hashmap 中对应的 key _keyToItem.erase(_itemList.back().first); _itemList.pop_back(); &#125; // 将新 key 加入链表首部并在 hashmap 中更新/添加 key _itemList.emplace_front(key, val); _keyToItem[key] = _itemList.begin(); &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 自己实现双向链表template &lt;typename T&gt;struct Node &#123; T _value; Node* _prev; Node* _next; Node(const T&amp; value) : _value(value), _prev(nullptr), _next(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;class DoubleLinkedList &#123;public: typedef T value_type; typedef Node&lt;value_type&gt;* link_type; private: link_type _node; size_t _size; public: DoubleLinkedList() : _node(nullptr), _size(0) &#123; _node = new Node&lt;value_type&gt;(value_type()); _node-&gt;_next = _node; _node-&gt;_prev = _node; &#125; ~DoubleLinkedList() &#123; while(_size &gt; 0) &#123; pop_front(); &#125; delete _node; &#125; link_type begin() const &#123; return _node-&gt;_next; &#125; link_type end() const &#123; return _node; &#125; value_type&amp; front() const &#123; return _node-&gt;_next-&gt;_value; &#125; value_type&amp; back() const &#123; return _node-&gt;_prev-&gt;_value; &#125; size_t size() const &#123; return _size; &#125; void erase(link_type node) &#123; _size--; node-&gt;_prev-&gt;_next = node-&gt;_next; node-&gt;_next-&gt;_prev = node-&gt;_prev; delete node; &#125; void pop_front() &#123; erase(_node-&gt;_next); &#125; void pop_back() &#123; erase(_node-&gt;_prev); &#125; void insert(link_type pos, value_type value) &#123; _size++; link_type node = new Node&lt;value_type&gt;(value); pos-&gt;_prev-&gt;_next = node; node-&gt;_prev = pos-&gt;_prev; pos-&gt;_prev = node; node-&gt;_next = pos; &#125; void push_front(value_type value) &#123; insert(_node-&gt;_next, value); &#125; void push_back(value_type value) &#123; insert(_node, value); &#125;&#125;;template &lt;typename T&gt;class LRUCache &#123;private: typedef T value_type; typedef typename DoubleLinkedList&lt;pair&lt;int, value_type&gt;&gt;::link_type iterator_to_node; size_t _capacity; unordered_map&lt;int, iterator_to_node&gt; _keyToItem; DoubleLinkedList&lt;pair&lt;int, value_type&gt;&gt; _itemList; public: LRUCache(int capacity) : _capacity(capacity) &#123;&#125; ~LRUCache() &#123;&#125; value_type get(int key) &#123; if(_keyToItem.count(key) == 0) &#123; return -1; &#125; value_type res = _keyToItem[key]-&gt;_value.second; // 如果 key 存在, 则在 LRUcache 中重新添加这个 key put(key, res); // 返回 key 对应的值 return res; &#125; void put(int key, value_type val) &#123; // 如果 key 已经存在, 则直接删掉链表中对应的条目 if(_keyToItem.count(key)) &#123; _itemList.erase(_keyToItem[key]); &#125; else if(_capacity &lt;= _itemList.size()) &#123; // 如果容量已经满, 则删除链表尾部的条目以及 hashmap 中对应的 key _keyToItem.erase(_itemList.back().first); _itemList.pop_back(); &#125; // 将新 key 加入链表首部并在 hashmap 中更新/添加 key _itemList.push_front(make_pair(key, val)); _keyToItem[key] = _itemList.begin(); &#125;&#125;; 460. LFU Cache 请你为最不经常使用（LFU）缓存算法设计并实现数据结构。 实现LFUCache类： 123456LFUCache(int capacity)用数据结构的容量 capacity 初始化对象int get(int key)如果键存在于缓存中, 则获取键的值, 否则返回 -1void put(int key, int value)如果键已存在, 则变更其值; 如果键不存在, 请插入键值对, 当缓存达到其容量时, 则应该在插入新项之前, 使最不经常使用的项无效, 在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键 注意「项的使用次数」就是自插入该项以来对其调用get和put函数的次数之和。使用次数会在对应项被移除后置为0。 为了确定最不常使用的键，可以为缓存中的每个键维护一个使用计数器 。使用计数最小的键是最久未使用的键。当一个键首次插入到缓存中时，它的使用计数器被设置为1 (由于put操作)。对缓存中的键执行get或put操作，使用计数器的值将会递增。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 双 hashmap + list 方法, 实现的 get 和 put 的操作时间复杂度都为 O(1)template &lt;typename T&gt;struct Node &#123; typedef T value_type; int _key; value_type _value; size_t _freq; Node(int key, value_type value, size_t freq) : _key(key), _value(value), _freq(freq) &#123;&#125;&#125;;template &lt;typename T&gt;class LFUCache &#123;private: typedef T value_type; typedef typename list&lt;Node&lt;value_type&gt;&gt;::iterator iterator_to_node; size_t _capacity; size_t _minFreq; unordered_map&lt;int, iterator_to_node&gt; _keyToItem; unordered_map&lt;size_t, list&lt;Node&lt;value_type&gt;&gt;&gt; _freqToKeys; public: LFUCache(size_t capacity) : _capacity(capacity), _minFreq(0) &#123;&#125; ~LFUCache() &#123;&#125; value_type get(int key) &#123; if(_keyToItem.count(key) == 0) &#123; return value_type(); &#125; // 将 key 对应的 _freq + 1 increaseFreq(key); return _keyToItem[key]-&gt;_value; &#125; void put(int key, value_type value) &#123; // 如果 key 已经存在，则更新对应的 _value, 然后将 key 对应的 _freq + 1 if(_keyToItem.count(key)) &#123; _keyToItem[key]-&gt;_value = value; increaseFreq(key); return; &#125; // 如果容量已满, 则删除 _minFreq 对应的最久未使用的条目 if(_capacity &lt;= _keyToItem.size()) &#123; auto lfu_key = _freqToKeys[_minFreq].back()._key; _freqToKeys[_minFreq].pop_back(); _keyToItem.erase(lfu_key); // 如果 _minFreq 对应的 _key 链表已空, 则删除这个 _minFreq 对应的映射 if(_freqToKeys[_minFreq].empty()) &#123; _freqToKeys.erase(_minFreq); &#125; // 此处不需要更新 _minFreq 的值, 因为接下来添加新条目后会将 _minFreq 设为 1 &#125; // 腾出空间后, 添加 _freq 为 1 的键值对 _freqToKeys[1].push_front(Node&lt;value_type&gt;(key, value, 1)); _keyToItem[key] = _freqToKeys[1].begin(); // 更新目前最小 freq, 因为新添加了一个条目, 所以就是 1 _minFreq = 1; &#125; private: // 将 key 对应的 freq + 1 void increaseFreq(int key) &#123; // 首先缓存一下当前 key 对应的 _freq 和 _value size_t theFreq = _keyToItem[key]-&gt;_freq; value_type theValue = _keyToItem[key]-&gt;_value; // 在当前 _freq 所对应的条目列表中删除当前 key 对应的条目并将其添加到 _freq + 1 对应的链表里 _freqToKeys[theFreq].erase(_keyToItem[key]); _freqToKeys[theFreq + 1].push_front(Node&lt;value_type&gt;(key, theValue, theFreq + 1)); _keyToItem[key] = _freqToKeys[theFreq + 1].begin(); // 如果当前 _freq 对应的链表为空了, 则删除 _freq 对应的映射 if(_freqToKeys[theFreq].empty()) &#123; _freqToKeys.erase(theFreq); // 如果删除的这个 key 的 _freq 正好是 _minFreq, 则更新 _minFreq if(theFreq == _minFreq) &#123; _minFreq++; &#125; &#125; &#125;&#125;; 208. Implement Trie (Prefix Tree) Trie或者说前缀树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现Trie类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串word。 boolean search(String word) 如果字符串word在前缀树中，返回true（即，在检索之前已经插入）；否则，返回false。 boolean startsWith(String prefix) 如果之前已经插入的字符串word的前缀之一为prefix，返回true；否则，返回false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Trie &#123;private: vector&lt;Trie*&gt; child; bool isEnd; public: Trie() : child(26), isEnd(false) &#123;&#125; ~Trie() &#123; for(auto node : child) &#123; if(node) &#123; delete node; &#125; &#125; &#125; void insert(string word) &#123; Trie* node = this; for(char c : word) &#123; if(!node-&gt;child[c - 'a']) &#123; node-&gt;child[c] = new Trie; &#125; node = node-&gt;child[c - 'a']; &#125; node-&gt;isEnd = true; &#125; bool search(string word) &#123; Trie* node = searchPrefix(word); return node &amp;&amp; node-&gt;isEnd; &#125; bool startsWith(string prefix) &#123; return searchPrefix(prefix); &#125; private: Trie* searchPrefix(string prefix) &#123; Trie* node = this; for(char c : prefix) &#123; if(!node-&gt;child[c - 'a']) &#123; return nullptr; &#125; node = node-&gt;child[c - 'a']; &#125; return node; &#125;&#125;; 295. Find Median from Data Stream The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values. For example, for arr = [2,3,4], the median is 3. For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5. Implement the MedianFinder class: MedianFinder() initializes the MedianFinder object. void addNum(int num) adds the integer num from the data stream to the data structure. double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted. Example: 12345678910111213Input[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;][[], [1], [2], [], [3], []]Output[null, null, null, 1.5, null, 2.0]ExplanationMedianFinder medianFinder &#x3D; new MedianFinder();medianFinder.addNum(1); &#x2F;&#x2F; arr &#x3D; [1]medianFinder.addNum(2); &#x2F;&#x2F; arr &#x3D; [1, 2]medianFinder.findMedian(); &#x2F;&#x2F; return 1.5 (i.e., (1 + 2) &#x2F; 2)medianFinder.addNum(3); &#x2F;&#x2F; arr[1, 2, 3]medianFinder.findMedian(); &#x2F;&#x2F; return 2.0 Constraints: -10^5 &lt;= num &lt;= 10^5 There will be at least one element in the data structure before calling findMedian. At most 5 * 10^4 calls will be made to addNum and findMedian. Follow up: If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution? If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution? 1234567891011121314151617181920212223242526272829303132333435363738394041class MedianFinder&#123;private: priority_queue&lt;int&gt; maxTop; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minTop; public: MedianFinder() &#123;&#125; void addNum(int num) &#123; if(minTop.empty() || minTop.top() &lt;= num) minTop.push(num); else maxTop.push(num); // 放完后 balance balance(); &#125; double findMedian() &#123; if(minTop.size() == maxTop.size()) return (double(minTop.top()) + double(maxTop.top())) * 0.5; return minTop.top(); &#125; private: void balance() &#123; if(minTop.size() &lt; maxTop.size()) &#123; minTop.push(maxTop.top()); maxTop.pop(); &#125; if(minTop.size() &gt; maxTop.size() + 1) &#123; maxTop.push(minTop.top()); minTop.pop(); &#125; &#125;&#125;; 123456789101112131415161718192021222324252627282930// 优化了下逻辑, 减少代码class MedianFinder &#123;private: priority_queue&lt;int&gt; small; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; large; public: MedianFinder() &#123;&#125; void addNum(int num) &#123; // 巧妙实现交替放 if(small.size() == large.size()) &#123; large.push(num); small.push(large.top()); large.pop(); &#125; else &#123; small.push(num); large.push(small.top()); small.pop(); &#125; &#125; double findMedian() &#123; if(small.size() != large.size()) &#123; return small.top(); &#125; return (double(small.top()) + double(large.top())) * 0.5; &#125;&#125;; 170. 两数之和 III - 数据结构设计 设计一个TwoSum类，拥有两个API： 1234567&gt;class TwoSum &#123;&gt;public:&gt;// 向数据结构中添加一个数 number&gt;void add(int number);&gt;// 寻找当前数据结构中是否存在两个数的和为 value&gt;bool find(int value);&gt;&#125; 123456789101112131415161718192021222324252627// 此种解法适用于频繁 add 的情况class TwoSum &#123;private: unordered_map&lt;long, int&gt; mapping; public: // 向数据结构中添加一个数 number void add(int number) &#123; mapping[number]++; &#125; // 寻找当前数据结构中是否存在两个数的和为 value bool find(int value) &#123; for(auto&amp;&amp; [first, _] : mapping) &#123; long second = long(value) - first; // 两个相同的数相加等于 value if(second == first &amp;&amp; mapping[first] &gt; 1) &#123; return true; &#125; // 不同的两个数相加为 value if(second != first &amp;&amp; mapping.count(second) &amp;&amp; mapping[second] &gt; 0) &#123; return true; &#125; &#125; return false; &#125;&#125;; 123456789101112131415161718192021// 此种解法适用于频繁 find 的情况class TwoSum &#123;private: unordered_set&lt;int&gt; allSum; vector&lt;int&gt; nums; public: // 向数据结构中添加一个数 number void add(int number) &#123; // 记录所有可能的和 for(int num : nums) &#123; allSum.insert(num + number); &#125; nums.push_back(number); &#125; // 寻找当前数据结构中是否存在两个数的和为 value bool find(int value) &#123; return allSum.count(value); &#125;&#125;; 155. Min Stack 设计一个支持push，pop，top操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素x推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 123456789101112131415161718192021222324252627282930class MinStack &#123;private: // &#123;value, value 入栈的时候栈中的最小值&#125; stack&lt;pair&lt;int, int&gt;&gt; _data; public: /** initialize your data structure here. */ MinStack() &#123;&#125; void push(int x) &#123; if(_data.empty()) &#123; _data.push(&#123;x, x&#125;); &#125; else &#123; _data.push(&#123;x, min(x, _data.top().second)&#125;); &#125; &#125; void pop() &#123; _data.pop(); &#125; int top() &#123; return _data.top().first; &#125; int getMin() &#123; return _data.top().second; &#125;&#125;; 895. Maximum Frequency Stack 实现FreqStack，模拟类似栈的数据结构的操作的一个类。 FreqStack有两个函数： push(int x)，将整数x推入栈中。 pop()，它移除并返回栈中出现最频繁的元素。 如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。 提示： 对FreqStack.push(int x)的调用中0 &lt;= x &lt;= 10^9。 如果栈的元素数目为0，则保证不会调用FreqStack.pop()。 示例： 12345678910111213比如执行六次 push 操作后，栈自底向上为 [5,7,5,7,4,5]然后:pop() -&gt; 返回 5，因为 5 是出现频率最高的栈变成 [5,7,5,7,4]pop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶栈变成 [5,7,5,4]pop() -&gt; 返回 5栈变成 [5,7,4]pop() -&gt; 返回 4栈变成 [5,7] 1234567891011121314151617181920212223242526272829303132class FreqStack &#123;private: size_t _maxFreq; unordered_map&lt;int, size_t&gt; _valToFreq; unordered_map&lt;size_t, stack&lt;int&gt;&gt; _freqToVals; public: FreqStack() : _maxFreq(0) &#123;&#125; void push(int val) &#123; _valToFreq[val]++; int freq = _valToFreq[val]; if(_maxFreq &lt; freq) &#123; _maxFreq = freq; &#125; _freqToVals[freq].push(val); &#125; int pop() &#123; int res = _freqToVals[_maxFreq].top(); _freqToVals[_maxFreq].pop(); _valToFreq[res]--; if(_valToFreq[res] == 0) &#123; _valToFreq.erase(res); &#125; if(_freqToVals[_maxFreq].empty()) &#123; _freqToVals.erase(_maxFreq); _maxFreq--; &#125; return res; &#125;&#125;; 232. Implement Queue using Stacks 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作： 实现MyQueue类： void push(int x)：将元素x推到队列的末尾； int pop()：从队列的开头移除并返回元素； int peek()：返回队列开头的元素； bool empty()：如果队列为空，返回true；否则，返回false。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 如上图, 将两个栈这样放class MyQueue &#123;private: stack&lt;int&gt; _front; stack&lt;int&gt; _back; public: MyQueue() &#123;&#125; void push(int x) &#123; // 入栈的时候直接放进右边的栈即可 _back.push(x); &#125; int pop() &#123; // 出栈的时候从左边出 // 如果为空, 需要把右边栈的元素搬过来 if(_front.empty()) &#123; moveData(); &#125; // 搬过来之后直接 pop 左边的栈即可 int res = _front.top(); _front.pop(); return res; &#125; int peek() &#123; // 取的时候和 pop 的情况一样 if(_front.empty()) &#123; moveData(); &#125; // 只是不出栈, 只取元素 return _front.top(); &#125; bool empty() &#123; return _front.empty() &amp;&amp; _back.empty(); &#125; private: void moveData() &#123; // 搬移数据就是简单的将右边栈出栈 // 左边栈接收元素压入栈 while(!_back.empty()) &#123; _front.push(move(_back.top())); _back.pop(); &#125; &#125;&#125;; 225. Implement Stack using Queues 请你仅使用两个队列实现一个后入先出的栈，并支持普通队列的全部四种操作。 实现MyStack类： void push(int x)：将元素x压入栈顶； int pop()：移除并返回栈顶元素； int top()：返回栈顶元素； bool empty()：如果栈是空的，返回true；否则，返回false。 123456789101112131415161718192021222324252627282930313233343536373839404142// 这个复杂点，push 复杂度为 O(1)，pop 复杂度为 O(n)// 入栈操作很简单, 调用队列的 push 即可// 出栈麻烦点, 因为队列只能从队头出列, 队头相当于栈的栈底// 但我们是想 pop 掉队尾元素// 这时很暴力, 直接把队列中除了队尾之外的所有元素依次出队并依次入队即可// 这时对头就是原队尾元素了, 再出队就行// 获取栈顶元素的话, 为了实现 O(1) 复杂度// 使用一个变量实时记录队尾 (栈顶) 元素class MyStack &#123;private: queue&lt;int&gt; _queue; int _top; public: MyStack() &#123;&#125; void push(int x) &#123; // 入队的时候要更新栈顶变量 _top = x; _queue.push(x); &#125; int pop() &#123; int sz = _queue.size(); while(sz-- &gt; 1) &#123; _top = _queue.front(); _queue.pop(); _queue.push(_top); &#125; int res = _queue.front(); _queue.pop(); return res; &#125; int top() &#123; return _top; &#125; bool empty() &#123; return _queue.empty(); &#125;&#125;; 12345678910111213141516171819202122232425262728293031// 这个更简单，只是 push 复杂度为 O(n)，pop 复杂度为 O(1)class MyStack &#123;private: queue&lt;int&gt; _queue; public: MyStack() &#123;&#125; void push(int x) &#123; int sz = _queue.size(); _queue.push(x); while(sz-- &gt; 0) &#123; _queue.push(_queue.front()); _queue.pop(); &#125; &#125; int pop() &#123; int res = _queue.front(); _queue.pop(); return res; &#125; int top() &#123; return _queue.front(); &#125; bool empty() &#123; return _queue.empty(); &#125;&#125;; [432. All O`one Data Structure](https://leetcode.com/problems/all-oone-data-structure/) 请你实现一个数据结构支持以下操作： Inc(key) 插入一个新的值为1的key。或者使一个存在的key增加1，保证key不为空字符串。 Dec(key) 如果这个key的值是1，那么把他从数据结构中移除掉。否则使一个存在的key值减1。如果这个key不存在，这个函数不做任何事情。key保证不为空字符串。 GetMaxKey() 返回key中值最大的任意一个。如果没有元素存在，返回一个空字符串&quot;&quot;。 GetMinKey() 返回key中值最小的任意一个。如果没有元素存在，返回一个空字符串&quot;&quot;。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// hashmap + 双向 list// 值相同的 key 共用一个 node, keys 用 hashset 存储class AllOne&#123;private: typedef string key_type; typedef size_t value_type; unordered_map&lt;key_type, list&lt;pair&lt;value_type, unordered_set&lt;key_type&gt;&gt;&gt;::iterator&gt; _keyToNode; // 根据 value 的大小从首到尾递增 list&lt;pair&lt;value_type, unordered_set&lt;key_type&gt;&gt;&gt; _nodes; public: AllOne() &#123;&#125; void inc(string key) &#123; if(_keyToNode.count(key)) &#123; auto it = _keyToNode[key]; auto next_it = next(it); if(next_it == _nodes.end() || next_it-&gt;first != (it-&gt;first + 1)) &#123; _keyToNode[key] = _nodes.insert(next_it, &#123;it-&gt;first + 1, &#123;key&#125;&#125;); &#125; else &#123; next_it-&gt;second.insert(key); _keyToNode[key] = next_it; &#125; it-&gt;second.erase(key); if(it-&gt;second.empty()) _nodes.erase(it); &#125; else &#123; if(_nodes.empty() || _nodes.begin()-&gt;first != 1) &#123; _keyToNode[key] = _nodes.insert(_nodes.begin(), &#123;1, &#123;key&#125;&#125;); &#125; else &#123; _nodes.begin()-&gt;second.insert(key); _keyToNode[key] = _nodes.begin(); &#125; &#125; &#125; void dec(string key) &#123; if(_keyToNode.count(key)) &#123; auto it = _keyToNode[key]; auto prev_it = prev(it); if(it-&gt;first &gt; 1) &#123; if(it == _nodes.begin() || prev_it-&gt;first != (it-&gt;first - 1)) &#123; _keyToNode[key] = _nodes.insert(it, &#123;it-&gt;first - 1, &#123;key&#125;&#125;); &#125; else &#123; prev_it-&gt;second.insert(key); _keyToNode[key] = prev_it; &#125; &#125; else &#123; _keyToNode.erase(key); &#125; it-&gt;second.erase(key); if(it-&gt;second.empty()) _nodes.erase(it); &#125; &#125; string getMaxKey() &#123; return _nodes.empty() ? \"\" : *(_nodes.rbegin()-&gt;second.begin()); &#125; string getMinKey() &#123; return _nodes.empty() ? \"\" : *(_nodes.begin()-&gt;second.begin()); &#125;&#125;; 707. Design Linked List 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val和next。val是当前节点的值，next是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性prev以指示链表中的上一个节点。假设链表中的所有节点都是0 - index的。 在链表类中实现这些功能： get(index)：获取链表中第index个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为val的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为val的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第index个节点之前添加值为val的节点。如果index等于链表的长度，则该节点将附加到链表的末尾。如果index大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引index有效，则删除链表中的第index个节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 单链表class MyLinkedList&#123;private: ListNode* head_; int size_; public: struct ListNode &#123; int val; ListNode* next; ListNode(int val_, ListNode* next_ = nullptr) : val(val_), next(next_) &#123;&#125; &#125;; MyLinkedList() : head_(nullptr), size_(0) &#123;&#125; int get(int index) &#123; if(index &lt; 0 || index &gt;= size_) return -1; ListNode* p = head_; while(index--) p = p-&gt;next; return p-&gt;val; &#125; void addAtHead(int val) &#123; head_ = new ListNode(val, head_); size_++; &#125; void addAtTail(int val) &#123; if(size_ == 0) addAtHead(val); ListNode* p = head_; int size = size_; while(--size) p = p-&gt;next; p-&gt;next = new ListNode(val); size_++; &#125; void addAtIndex(int index, int val) &#123; if(index &lt; 0 || index &gt; size_) return; if(index == size_) &#123; addAtTail(val); return; &#125; if(index == 0) &#123; addAtHead(val); return; &#125; ListNode* p = head_; ListNode* q = p; while(index--) &#123; q = p; p = p-&gt;next; &#125; q-&gt;next = new ListNode(val, p); size_++; &#125; void deleteAtIndex(int index) &#123; if(index &lt; 0 || index &gt;= size_) return; if(index == 0) &#123; head_ = head_-&gt;next; size_--; return; &#125; ListNode* p = head_; ListNode* q = p; while(index-- &amp;&amp; p-&gt;next) &#123; q = p; p = p-&gt;next; &#125; q-&gt;next = p-&gt;next; size_--; &#125;&#125;; 380. Insert Delete GetRandom O(1)和381. Insert Delete GetRandom O(1) - Duplicates allowed 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 这是集合中元素唯一的情况// 为了使得能够以 O(1) 的复杂度随机访问元素, 用于存储数据的结构必须为 vector// 为了使得删除元素的复杂度为 O(1), 可以通过将被删除元素与末尾元素互换, 再 pop_back()// 但这必须能够知道每个元素对应的索引// 所以, 使用一个哈希表来记录 (元素) 和其 (索引)class RandomizedSet&#123;private: vector&lt;int&gt; nums; unordered_map&lt;int, int&gt; mapping; public: /** Initialize your data structure here. */ RandomizedSet() &#123;&#125; /** Returns true if the set did not already contain the specified element. */ bool insert(int val) &#123; if(mapping.count(val) &gt; 0) return false; mapping[val] = nums.size(); nums.push_back(val); return true; &#125; /** Returns true if the set contained the specified element. */ bool remove(int val) &#123; if(mapping.count(val) == 0) return false; int i = mapping[val]; // 先更新映射, 再操作数据 // 接下来两条语句的顺序不可颠倒 // 防止待删除的值就位于尾元素, 即 val == nums.back() mapping[nums.back()] = i; mapping.erase(val); swap(nums[i], nums.back()); nums.pop_back(); return true; &#125; /** Get a random element from the set. */ int getRandom() &#123; int i = rand() % nums.size(); return nums[i]; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 下面是集合中元素允许重复的情况// 由于要记录所有重复元素的索引, 就就不能采用 1 对 1 映射了// 需要采用 1 对 多 映射, 所以使用一个 unordered_map&lt;int, unordered_set&lt;int&gt;&gt;// 为什么映射到的是一个 unordered_set&lt;int&gt; 而不是 vector&lt;int&gt; 呢?// 原因是, 交换后, 需要 O(1) 删除末尾元素所对应的索引, 而这个索引值不一定存储在最后class RandomizedCollection&#123;private: vector&lt;int&gt; nums; unordered_map&lt;int, unordered_set&lt;int&gt;&gt; mapping; public: /** Initialize your data structure here. */ RandomizedCollection() &#123;&#125; /** Returns true if the collection did not already contain the specified element. */ bool insert(int val) &#123; bool res = true; if(mapping.count(val) &gt; 0) res = false; mapping[val].insert(nums.size()); nums.push_back(val); return res; &#125; /** Returns true if the collection contained the specified element. */ bool remove(int val) &#123; if(mapping.count(val) == 0) return false; int i = *(mapping[val].begin()); // 这个 i 相当于随机选的其中一个 if(val == nums.back()) &#123; // 如果要删除的值正好位于末元素的话 // 直接在索引集合中删掉索引即可 // 这是防止执行 else 中的 mapping[nums.back()].insert(i); 语句 // 插入另一个和尾元素值相等的位于其他位置的索引 mapping[nums.back()].erase(nums.size() - 1); &#125; else &#123; // 比如说数组中元素为 [2, 2, 2], 索引 set 中为 [0, 1, 2] // 现在删除 val == 2, 此时 i 为 0, nums.back() == val, 执行下面三条语句 // 语句 1 --&gt; set 变为 [0, 1] // 语句 2 --&gt; set 变为 [0, 0, 1] --&gt; [0, 1] // 语句 3 --&gt; set 变为 [1] // 但显然预期的结果为 [0, 1] // 否则, 需要删除末元素原本对应的索引, 插入新索引 mapping[nums.back()].erase(nums.size() - 1); mapping[nums.back()].insert(i); // 删掉待删除元素的索引之一 mapping[val].erase(i); &#125; // 如果待删除元素只有一个, 还要删除整个映射项 if(mapping[val].empty()) mapping.erase(val); swap(nums[i], nums.back()); nums.pop_back(); return true; &#125; /** Get a random element from the collection. */ int getRandom() &#123; int i = rand() % nums.size(); return nums[i]; &#125;&#125;; 多线程1114. 按序打印 三个不同的线程A、B、C将会共用一个Foo实例。 一个将会调用first()方法 一个将会调用second()方法 还有一个将会调用third()方法 请设计修改程序，以确保second()方法在first()方法之后被执行，third()方法在second()方法之后被执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;class Foo &#123;private: int counter; mutex _mutex; condition_variable _cond2b; condition_variable _cond2c;public: Foo() : counter(1), _mutex(), _cond2b(), _cond2c() &#123;&#125; void first() &#123; unique_lock&lt;mutex&gt; lock(_mutex); cout &lt;&lt; \"first\" &lt;&lt; endl; counter = 2; _cond2b.notify_one(); &#125; void second() &#123; unique_lock&lt;mutex&gt; lock(_mutex); _cond2b.wait(lock, [this] &#123; return this-&gt;counter == 2; &#125;); cout &lt;&lt; \"second\" &lt;&lt; endl; counter = 3; _cond2c.notify_one(); &#125; void third() &#123; unique_lock&lt;mutex&gt; lock(_mutex); _cond2c.wait(lock, [this] &#123; return this-&gt;counter == 3; &#125;); cout &lt;&lt; \"third\" &lt;&lt; endl; &#125;&#125;;int main() &#123; Foo foo; thread A(bind(Foo::first, &amp;foo)); thread B(bind(Foo::second, &amp;foo)); thread C(bind(Foo::third, &amp;foo)); A.join(); B.join(); C.join();&#125; 1115. 交替打印FooBar 两个不同的线程将会共用一个FooBar实例。其中一个线程将会调用foo()方法，另一个线程将会调用bar()方法。 请设计修改程序，以确保&quot;foobar&quot;被输出n次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 使用互斥锁 + 两个条件变量#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;#include &lt;thread&gt;#include &lt;iostream&gt;using namespace std;class FooBar &#123;private: int n; bool counter; mutex _mutex; condition_variable _cond;public: FooBar(int n) : counter(true) &#123; this-&gt;n = n; &#125; void foo() &#123; for(int i = 0; i &lt; n; i++) &#123; unique_lock&lt;mutex&gt; lock(_mutex); _cond.wait(lock, [this] &#123; return this-&gt;counter; &#125;); cout &lt;&lt; \"foo\" &lt;&lt; endl; counter = false; _cond.notify_one(); &#125; &#125; void bar() &#123; for(int i = 0; i &lt; n; i++) &#123; unique_lock&lt;mutex&gt; lock(_mutex); _cond.wait(lock, [this] &#123; return !this-&gt;counter; &#125;); cout &lt;&lt; \"bar\" &lt;&lt; endl; counter = true; _cond.notify_one(); &#125; &#125;&#125;;int main() &#123; FooBar foobar(3); thread foo(bind(FooBar::foo, &amp;foobar)); thread bar(bind(FooBar::bar, &amp;foobar)); foo.join(); bar.join();&#125; 1116. 打印零与奇偶数 相同的一个ZeroEvenOdd类实例将会传递给三个不同的线程： 线程A将调用zero()，它只输出0。 线程B将调用even()，它只输出偶数。 线程C将调用odd()，它只输出奇数。 每个线程都有一个printNumber方法来输出一个整数。请修改给出的代码以输出整数序列 010203040506...，其中序列的长度必须为2n。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class ZeroEvenOdd &#123;private: int n; mutex lockZero; mutex lockOdd; mutex lockEven;public: ZeroEvenOdd(int n) &#123; this-&gt;n = n; lockOdd.lock(); lockEven.lock(); &#125; void zero() &#123; for(int i = 1; i &lt;= n; i++) &#123; lockZero.lock(); cout &lt;&lt; 0 &lt;&lt; endl; if (i &amp; 1) &#123; lockOdd.unlock(); &#125; else &#123; lockEven.unlock(); &#125; &#125; &#125; void even() &#123; for(int i = 2; i &lt;= n; i += 2) &#123; lockEven.lock(); cout &lt;&lt; i &lt;&lt; endl; lockZero.unlock(); &#125; &#125; void odd() &#123; for(int i = 1; i &lt;= n; i += 2) &#123; lockOdd.lock(); cout &lt;&lt; i &lt;&lt; endl; lockZero.unlock(); &#125; &#125;&#125;;int main() &#123; ZeroEvenOdd zero(4); thread t1(bind(ZeroEvenOdd::zero, &amp;zero)); thread t2(bind(ZeroEvenOdd::even, &amp;zero)); thread t3(bind(ZeroEvenOdd::odd, &amp;zero)); t1.join(); t2.join(); t3.join();&#125; 1188. 设计有限阻塞队列 实现一个拥有如下方法的线程安全有限阻塞队列： BoundedBlockingQueue(int capacity)构造方法初始化队列，其中capacity代表队列长度上限。 void enqueue(int element)在队首增加一个element。如果队列满，调用线程被阻塞直到队列非满。 int dequeue()返回队尾元素并从队列中将其删除。如果队列为空，调用线程被阻塞直到队列非空。 int size()返回当前队列元素个数。 你的实现将会被多线程同时访问进行测试。每一个线程要么是一个只调用enqueue方法的生产者线程，要么是一个只调用dequeue方法的消费者线程。size方法将会在每一个测试用例之后进行调用。 12345678910111213141516171819202122232425262728293031323334353637// 互斥锁 + 两个条件变量 + 使用 notify_one()class BoundedBlockingQueue &#123;private: int _capacity; queue&lt;int&gt; _data; mutex _mutex; condition_variable _notEmpty; condition_variable _notFull; public: BoundedBlockingQueue(int capacity) : _capacity(capacity) &#123;&#125; void enqueue(int element) &#123; unique_lock&lt;mutex&gt; lock(_mutex); while(_data.size() &gt;= _capacity) &#123; _notFull.wait(lock); &#125; _data.push(element); _notEmpty.notify_one(); &#125; int dequeue() &#123; unique_lock&lt;mutex&gt; lock(_mutex); while(_data.size() &lt;= 0) &#123; _notEmpty.wait(lock); &#125; int res = _data.front(); _data.pop(); _notFull.notify_one(); return res; &#125; int size() &#123; unique_lock&lt;mutex&gt; lock(_mutex); return _data.size(); &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536// 互斥锁 + 一个条件变量 + 使用 notify_all()class BoundedBlockingQueue &#123;private: int _capacity; queue&lt;int&gt; _data; mutex _mutex; condition_variable _cond; public: BoundedBlockingQueue(int capacity) : _capacity(capacity) &#123;&#125; void enqueue(int element) &#123; unique_lock&lt;mutex&gt; lock(_mutex); while(_data.size() &gt;= _capacity) &#123; _cond.wait(lock); &#125; _data.push(element); _cond.notify_all(); &#125; int dequeue() &#123; unique_lock&lt;mutex&gt; lock(_mutex); while(_data.size() &lt;= 0) &#123; _cond.wait(lock); &#125; int res = _data.front(); _data.pop(); _cond.notify_all(); return res; &#125; int size() &#123; unique_lock&lt;mutex&gt; lock(_mutex); return _data.size(); &#125;&#125;; 1226. 哲学家进餐 5个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5根叉子） 所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。 假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。 设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。 哲学家从0到4按顺时针编号。请实现函数void wantsToEat(philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork)： philosopher哲学家的编号。 pickLeftFork和pickRightFork表示拿起左边或右边的叉子。 eat表示吃面。 putLeftFork和putRightFork表示放下左边或右边的叉子。 由于哲学家不是在吃面就是在想着啥时候吃面，所以思考这个方法没有对应的回调。 给你5个线程，每个都代表一个哲学家，请你使用类的同一个对象来模拟这个过程。在最后一次调用结束之前，可能会为同一个哲学家多次调用该函数。 123456789101112131415161718192021222324252627282930313233343536// 限制哲学家必须同时拿起左右的叉子后才能就餐// 否则，不允许持有任何一只叉子// 使用 C++11 的 lock 方法class DiningPhilosophers &#123;private: array&lt;mutex, 5&gt; mutexs; public: DiningPhilosophers() &#123;&#125; void wantsToEat(int philosopher) &#123; int left = philosopher; int right = (philosopher + 1) % 5; lock(mutexs[left], mutexs[right]); &#123; lock_guard&lt;mutex&gt; lock_left(mutexs[left], adopt_lock); lock_guard&lt;mutex&gt; lock_right(mutexs[right], adopt_lock); cout &lt;&lt; \"ID: \" &lt;&lt; philosopher &lt;&lt; \" eatting\" &lt;&lt; endl; &#125; &#125;&#125;;int main() &#123; DiningPhilosophers dining; thread t1(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 0); thread t2(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 1); thread t3(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 2); thread t4(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 3); thread t5(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 4); t1.join(); t2.join(); t3.join(); t4.join(); t5.join();&#125; 1234567891011121314151617181920212223242526272829303132333435// 使用一个额外的 互斥锁 充当门禁class DiningPhilosophers &#123;private: array&lt;mutex, 5&gt; mutexs; mutex door; public: DiningPhilosophers() &#123;&#125; void wantsToEat(int philosopher) &#123; int left = philosopher; int right = (philosopher + 1) % 5; door.lock(); lock_guard&lt;mutex&gt; lock_left(mutexs[left]); lock_guard&lt;mutex&gt; lock_right(mutexs[right]); door.unlock(); cout &lt;&lt; \"ID \" &lt;&lt; philosopher &lt;&lt; \" is eatting\" &lt;&lt; endl; &#125;&#125;;int main() &#123; DiningPhilosophers dining; thread t1(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 0); thread t2(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 1); thread t3(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 2); thread t4(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 3); thread t5(bind(DiningPhilosophers::wantsToEat, &amp;dining, placeholders::_1), 4); t1.join(); t2.join(); t3.join(); t4.join(); t5.join();&#125; Undetermined 343. Integer Break 给定一个整数n，将其分解为k个正整数之和，其中k &gt;= 2，并使这些整数的乘积最大化。返回你可以获得的最大乘积。 说明: 你可以假设n不小于2且不大于58。 1234567891011121314151617181920// 动态规划int integerBreak(int n) &#123; if(n &lt;= 3) &#123; return n - 1; &#125; vector&lt;int&gt; dp(n + 1); dp[2] = 1; dp[3] = 2; for(int i = 4; i &lt;= n; i++) &#123; // 枚举划分出第一段的长度 for(int j = 2; j &lt;= i - 2; j++) &#123; // 划分出第一段之后，剩下部分有两种选择 // 不划分的话长度为 j * (i - j) // 划分的话长度为 j * dp[i - j] // 两者取较大者 dp[i] = max(&#123;dp[i], j * (i - j), j * dp[i - j]&#125;); &#125; &#125; return dp[n];&#125; 12345678910111213141516// 贪心算法// 使用均值不等式可以证明当这 k 个整数相等时，乘积最大// 使用求导求极大值可以得出 k = 3 时乘积最大 int integerBreak(int n) &#123; if(n &lt;= 3) &#123; return n - 1; &#125; int a = n / 3, b = n % 3; if(b == 0) &#123; return pow(3, a); &#125; else if(b == 1) &#123; return 4 * pow(3, a - 1); &#125; return 2 * pow(3, a - 1);&#125; 509. Fibonacci Number 斐波那契数，通常用F(n)表示，形成的序列称为斐波那契数列 。该数列由0和1开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中n &gt; 1 给你n，请计算F(n)。 123456789101112// 迭代法int fib(int n) &#123; int dp_0 = 0; int dp_1 = 1; int mod = 1e9 + 7; // 防止溢出 while(n-- &gt; 0) &#123; int temp = dp_0 + dp_1; dp_0 = dp_1; dp_1 = temp % mod; &#125; return dp_0;&#125; 1234567891011121314// 递归 + 备忘录int fib(int n) &#123; vector&lt;int&gt; memo(n + 1); auto recur = [&amp;](auto&amp;&amp; recur, int n) &#123; if(n &lt; 2) &#123; return n; &#125; if(memo[n] != 0) &#123; return memo[n]; &#125; return memo[n] = recur(recur, n - 1) + recur(recur, n - 2); &#125;; return recur(recur, n);&#125; 从小白到大神都会遇到的经典面试题 —— 斐波那契数列_0 error(s)-CSDN博客 1// 矩阵幂次方 50. Pow(x, n) 实现pow(x, n)，即计算x的n次幂函数（即 x^n^ ）。 12345678910111213141516171819202122232425262728293031// 递归写法double myPow(double x, long n)&#123; if(n == 0) &#123; return 1; &#125; if(n &lt; 0) &#123; return myPow(1.0 / x, -n); &#125; if(n % 2 == 1) &#123; return x * myPow(x, n - 1); &#125; return myPow(x * x, n / 2);&#125;// 迭代写法double myPow(double x, long n) &#123; if(n &lt; 0) &#123; x = 1.0 / x; n = -n; &#125; double res = 1; while(n != 0) &#123; if(n &amp; 1) &#123; res *= x; &#125; n &gt;&gt;= 1; x *= x; &#125; return res;&#125; 372. Super Pow 你的任务是计算 a^b^ 对1337取模，a是一个正整数，b是一个非常大的正整数且会以数组形式给出。 Constraints: 1 &lt;= a &lt;= 231 - 1 1 &lt;= b.length &lt;= 2000 0 &lt;= b[i] &lt;= 9 b doesn’t contain leading zeros. Example 1: 12Input: a &#x3D; 2, b &#x3D; [1,0]Output: 1024 Example 2: 12Input: a &#x3D; 1, b &#x3D; [4,3,3,8,5,2]Output: 1 Example 3: 12Input: a &#x3D; 2147483647, b &#x3D; [2,0,0]Output: 1198 123456789101112131415161718192021222324252627282930313233343536373839// 模运算技巧 (a * b) % n = (a % n) * (b % n) % n// 就是说对乘积的结果求模, 等价于先对每个因子都求模, 再对因子求模的结果的乘积再求模// 可防止 a * b 过大导致溢出// 这题主要是学会如何处理指数部分以数组的形式给出// 处理办法就是找到规律, 利用递归将大问题分解为一个个子问题// 规律看上面给出的图片int superPow(int a, vector&lt;int&gt;&amp; b)&#123; if(b.empty()) return 1; int back = b.back(); b.pop_back(); return mypow(a, back) * mypow(superPow(a, b), 10) % 1337;&#125;int mypow(int a, int n)&#123; int res = 1; // 这题比较特殊, 因子都相同, 就是 a // 对每一个因子求模 a %= 1337; while(n-- &gt; 0) &#123; // 求每个因子求模结果的乘积 res *= a; // 将乘积结果再求模 res %= 1337; &#125; return res;&#125;// 求幂运算可通过判断 n 的奇偶性大幅度优化效率int mypow(int a, int n)&#123; if(n == 0) return 1; a %= 1337; if(n % 2 == 1) return a * mypow(a, n - 1) % 1337; return mypow(a * a % 1337, n / 2);&#125; 779. K-th Symbol in Grammar 在第一行我们写上一个0。接下来的每一行，将前一行中的0替换为01，1替换为10。 给定行数N和序数K，返回第N行中第K个字符。 Note: N will be an integer in the range [1, 30]. K will be an integer in the range [1, 2^(N-1)]. 123456789101112131415161718Examples:Input: N &#x3D; 1, K &#x3D; 1Output: 0Input: N &#x3D; 2, K &#x3D; 1Output: 0Input: N &#x3D; 2, K &#x3D; 2Output: 1Input: N &#x3D; 4, K &#x3D; 5Output: 1Explanation:row 1: 0row 2: 01row 3: 0110row 4: 01101001 1234567int kthGrammar(int N, int K)&#123; if(K == 1) return 0; int n = pow(2, N - 2); if(K &gt; n) return 1 - kthGrammar(N - 1, K - n); return kthGrammar(N - 1, K);&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"leetcode刷题系列之字符串","date":"2021-06-10T13:35:42.000Z","path":"LZqUbK3Z1CXKja4I/","text":"这篇文章是leetcode刷题系列的第3部分——字符串。这里把有代表性的题目发出来，共计21道。字符串的问题杂且难，这一块，面试时碰到字符串问题时只能随机应变，没有固定的套路。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！ 880. Decoded String at Index 给定一个编码字符串S。请你找出解码字符串并将其写入磁带。解码时，从编码字符串中每次读取一个字符 ，并采取以下步骤： 如果所读的字符是字母，则将该字母写在磁带上。 如果所读的字符是数字（例如d），则整个当前磁带总共会被重复写d - 1次。 现在，对于给定的编码字符串S和索引K，查找并返回解码字符串中的第K个字母。 Constraints: 2 &lt;= S.length &lt;= 100 S will only contain lowercase letters and digits 2 through 9. S starts with a letter. 1 &lt;= K &lt;= 10^9 It’s guaranteed that K is less than or equal to the length of the decoded string. The decoded string is guaranteed to have less than 2^63 letters. Example 1: 12345Input: S &#x3D; &quot;leet2code3&quot;, K &#x3D; 10Output: &quot;o&quot;Explanation: The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;.The 10th letter in the string is &quot;o&quot;. Example 2: 1234Input: S &#x3D; &quot;ha22&quot;, K &#x3D; 5Output: &quot;h&quot;Explanation: The decoded string is &quot;hahahaha&quot;. The 5th letter is &quot;h&quot;. 123456789101112131415161718192021222324252627282930313233343536// 一般来说, 当解码的字符串等于某个长度为 size 的单词重复一定次数// 例如 apple(size = 5) 组合重复 6 次时// 第 k == 24 个的结果与第 k % size == 4 个的结果相同// 根据这个思路来求解问题string decodeAtIndex(string s, int k) &#123; int n = s.size(); long sz = 0; // 先计算解码后的总字符串的长度 for(int i = 0; i &lt; n; i++) &#123; if(isalpha(s[i])) &#123; sz++; &#125; else &#123; sz *= s[i] - '0'; &#125; &#125; // 从后向前做逆向搜索 for(int i = n - 1; i &gt;= 0; i--) &#123; // 如果当前字符是字母, 那么它必然在解码后的最后位置 if(isalpha(s[i])) &#123; // 如果这时就是第 k 个字符的话, 直接返回答案 if(k % sz == 0) &#123; return string(1, s[i]); &#125; // 解码字符串的长度减 1 sz--; &#125; // 如果当前字符是数字 else &#123; // 此字符之前的解码字符串的长度就可以计算出来 sz /= s[i] - '0'; k %= sz; &#125; &#125; return \"\";&#125; 87. Scramble String 使用下面描述的算法可以扰乱字符串s得到字符串t： 如果字符串的长度为1，算法停止 如果字符串的长度&gt; 1，执行下述步骤： 在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串s，则可以将其分成两个子字符串x和y，且满足s = x + y。 随机决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s可能是s = x + y或者s = y + x。 在x和y这两个子字符串上继续从步骤1开始递归执行此算法。 给你两个长度相等的字符串s1和s2，判断s2是否是s1的扰乱字符串。如果是，返回true；否则，返回false。 示例： 1234567891011输入：s1 &#x3D; &quot;great&quot;, s2 &#x3D; &quot;rgeat&quot;输出：true解释：s1 上可能发生的一种情形是：&quot;great&quot; --&gt; &quot;gr&#x2F;eat&quot; 在一个随机下标处分割得到两个子字符串&quot;gr&#x2F;eat&quot; --&gt; &quot;gr&#x2F;eat&quot; 随机决定：「保持这两个子字符串的顺序不变」&quot;gr&#x2F;eat&quot; --&gt; &quot;g&#x2F;r &#x2F; e&#x2F;at&quot; 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割&quot;g&#x2F;r &#x2F; e&#x2F;at&quot; --&gt; &quot;r&#x2F;g &#x2F; e&#x2F;at&quot; 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」&quot;r&#x2F;g &#x2F; e&#x2F;at&quot; --&gt; &quot;r&#x2F;g &#x2F; e&#x2F; a&#x2F;t&quot; 继续递归执行此算法，将 &quot;at&quot; 分割得到 &quot;a&#x2F;t&quot;&quot;r&#x2F;g &#x2F; e&#x2F; a&#x2F;t&quot; --&gt; &quot;r&#x2F;g &#x2F; e&#x2F; a&#x2F;t&quot; 随机决定：「保持这两个子字符串的顺序不变」算法终止，结果字符串和 s2 相同，都是 &quot;rgeat&quot;这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true 1234567891011121314151617181920212223242526272829303132333435// 由于递归过程中会出现许多的重复参数// 使用一个哈希集合来记忆化递归过程// 由于函数参数是两个字符串, 可将它们拼接在一起做为 keyunordered_set&lt;string&gt; memo;bool isScramble(string s1, string s2) &#123; if(memo.count(s1 + s2)) &#123; return false; &#125; if(s1 == s2) &#123; return true; &#125; if(s1.size() == 1) &#123; return false; &#125; // 判断字符对应个数是否相等 // 先排序再判断 string s1Copy = s1, s2Copy = s2; sort(s1Copy.begin(), s1Copy.end()); sort(s2Copy.begin(), s2Copy.end()); if(s1Copy != s2Copy) &#123; return false; &#125; int sz = s1.size(); // s1 = L(s1) + R(s1), s2 = L(s2) + R(s2) // 两种情况, 看 L(s1) 是否可以转化为 L(s2) 以及 R(s1) 是否可以转化为 R(s2) for(int i = 1; i &lt; sz; i++) &#123; if(isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i, sz - i), s2.substr(i, sz - i))) return true; if(isScramble(s1.substr(i, sz - i), s2.substr(0, sz - i)) &amp;&amp; isScramble(s1.substr(0, i), s2.substr(sz - i, i))) return true; &#125; // 记录结果 memo.insert(s1 + s2); return false;&#125; 28. Implement strStr() 实现strStr()函数。给你两个字符串haystack和needle，请你在haystack字符串中找出needle字符串出现的第一个位置（下标从0开始）。如果不存在，则返回-1 。当needle是空字符串时，返回0。 Example 1: 12Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;Output: 2 Example 2: 12Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;Output: -1 Example 3: 12Input: haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;Output: 0 12345678910111213141516171819202122232425262728293031// kmp 算法int strStr(string haystack, string needle) &#123; int n = haystack.size(); int m = needle.size(); if(m == 0) &#123; return 0; &#125; vector&lt;vector&lt;int&gt;&gt; dfa(m, vector&lt;int&gt;(128)); buildStateTransition(needle, dfa); int j = 0; for(int i = 0; i &lt; n; i++) &#123; j = dfa[j][haystack[i]]; if(j == m) &#123; return i + 1 - m; &#125; &#125; return -1;&#125;void buildStateTransition(string&amp; needle, vector&lt;vector&lt;int&gt;&gt;&amp; dfa) &#123; // base case dfa[0][needle[0]] = 1; int x = 0; for(int i = 1; i &lt; needle.size(); i++) &#123; for(int c = 0; c &lt; 128; c++) &#123; dfa[i][c] = dfa[x][c]; &#125; dfa[i][needle[i]] = i + 1; x = dfa[x][needle[i]]; &#125;&#125; 1234567891011121314151617181920212223242526272829// sunday 算法int strStr(string haystack, string needle) &#123; int n = haystack.size(); int m = needle.size(); if(m == 0) &#123; return 0; &#125; unordered_map&lt;char, int&gt; shift; for(int i = 0; i &lt; m; i++) &#123; shift[needle[i]] = m - i; &#125; int pos_n = 0, pos_m = 0; while(pos_n &lt;= n - m) &#123; pos_m = 0; while(haystack[pos_n + pos_m] == needle[pos_m]) &#123; pos_m++; if(pos_m == m) &#123; return pos_n; &#125; &#125; if(shift.count(haystack[pos_n + m])) &#123; pos_n += shift[haystack[pos_n + m]]; &#125; else &#123; pos_n += m + 1; &#125; &#125; return -1;&#125; 187. Repeated DNA Sequences 所有DNA都由一系列缩写为&#39;A&#39;，&#39;C&#39;，&#39;G&#39;和&#39;T&#39;的核苷酸组成，例如：&quot;ACGAATTCCG&quot;。在研究DNA时，识别DNA中的重复序列有时会对研究非常有帮助。 编写一个函数来找出所有目标子串，目标子串的长度为10，且在DNA字符串s中出现次数超过一次。 Example 1: 12Input: s &#x3D; &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;Output: [&quot;AAAAACCCCC&quot;,&quot;CCCCCAAAAA&quot;] Example 2: 12Input: s &#x3D; &quot;AAAAAAAAAAAAA&quot;Output: [&quot;AAAAAAAAAA&quot;] Constraints: 1 &lt;= s.length &lt;= 105 s[i] is either &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, or &#39;T&#39; 123456789101112131415161718192021222324// 滑动窗口切片 + 哈希集合 切片复杂度为 O(k)// 总 O(k(n - k))vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; int size = s.size(); if(size &lt;= 10) &#123; return vector&lt;string&gt;(); &#125; unordered_set&lt;string&gt; visited; unordered_set&lt;string&gt; output; int k = 10; string subStr; for(int i = 0; i &lt;= size - k; i++) &#123; subStr = s.substr(i, k); if(visited.count(subStr)) &#123; output.insert(subStr); &#125; visited.insert(subStr); &#125; vector&lt;string&gt; res; for(auto str : output) &#123; res.push_back(str); &#125; return res;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*Rabin-Karp 字符串编码介绍由于我们需要频繁判断两个字串是否相同, 直接切片比较的话, 复杂度和子串的长度成正比这样, 我们将字符串中的字符(全小写)映射到 0-25 的数字给定窗口长度为 k 的字符串, 窗口内的字符序列可以表示成一个 base = 26 进制的数字序列比如 将 k = 4 的字符串 c1c2c3c4 转换为数字串 a1a2a3a4, 它对应的十进制值为key = a1*26^3 + a2*26^2 + a3*26^1 + a4*26 = a1*base^(k-1) + a2*base^(k-2) + a3*base^(k-3) + a4*base然后将 key 做哈希表的键, 这样我们比较 是否有相同的 key 就可以判断出是否有相同的串为什么说这样快呢? 对于窗口 a1a2a3a4 -&gt; a2a3a4a5key = ((a1*base^(k-1) + a2*base^(k-2) + a3*base^(k-3) + a4*base) - a1*base^(k-1))*base + a5*base = (key - a1*base^(k-1))*base + a5*base = key*base - a1*base^k + a5*base可以在 O(1) 时间算出新窗口的 key, 如果直接从字符串中切片的话需要 O(k) 时间*/// 滑动窗口切片 + Rabin-Karp 字符串编码使得切片复杂度为 O(1)// 总 O(n - k)vector&lt;string&gt; findRepeatedDnaSequences(string s)&#123; int size = s.size(); if(size &lt;= 10) &#123; return vector&lt;string&gt;(); &#125; unordered_map&lt;char, int&gt; encode; int i = 0; // 将这四个字符分别映射为 0 1 2 3, 所以 base 为 4 for(char c : &#123;'A', 'C', 'G', 'T'&#125;) &#123; encode[c] = i++; &#125; vector&lt;int&gt; nums(s.size()); // 将原字符串中的字符装成数字序列 for(i = 0; i &lt; nums.size(); i++) &#123; nums[i] = encode[s[i]]; &#125; int base = 4, k = 10; int baseK = pow(base, k); int key = 0; // 计算第一个窗口的 key for(i = 0; i &lt; k; i++) &#123; key = key * base + nums[i]; &#125; unordered_set&lt;int&gt; visited; unordered_set&lt;string&gt; output; // 将第一个窗口的 key 先放进去表示已经访问 visited.insert(key); // 下面开始滑动窗口 // i = 10; while(i &lt; size) &#123; // 计算新窗口的 key key = key * base - nums[i - k] * baseK + nums[i]; // 如果已经存在, 表示有重复的串 // 将串取出 if(visited.count(key)) &#123; output.insert(s.substr(i - k + 1, k)); &#125; // 新窗口也已访问 visited.insert(key); i++; &#125; vector&lt;string&gt; res; for(auto str : output) &#123; res.push_back(str); &#125; return res;&#125; 1044. Longest Duplicate Substring 给出一个字符串S，考虑其所有重复子串（S的连续子串，出现两次或多次，可能会有重叠）。 返回任何具有最长可能长度的重复子串。（如果S不含重复子串，那么答案为&quot;&quot;。） Example 1: 12Input: s &#x3D; &quot;banana&quot;Output: &quot;ana&quot; Example 2: 12Input: s &#x3D; &quot;abcd&quot;Output: &quot;&quot; Constraints: 2 &lt;= s.length &lt;= 3 * 104 s consists of lowercase English letters. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 滑动窗口切片 + Rabin-Karp 字符串编码使得切片复杂度为 O(1)// 由于我们希望找到一个最长的重复串, 最长莫不过 s.size()// 所以我们每次固定窗口的大小为 k, k 范围时[0, s.size())// 在这个区间可以使用 二分搜索 提高效率string longestDupSubstring(string s)&#123; unordered_map&lt;char, int&gt; digit; for(char c = 'a'; c &lt;= 'z'; c++) digit[c] = c - 'a'; string res; // 外循环二分搜索, 内循环滑动窗口 int minK = 0; int maxK = (int)s.size(); while(minK &lt; maxK) &#123; string subStr; unordered_set&lt;long&gt; visited; int k = minK + (maxK - minK &gt;&gt; 1); // 窗口大小 /* Rabin-Karp 编码算法 */ int base = 26; long baseK = pow(base, k); long key = 0; // 计算第一个窗口的 key int i = 0; for(; i &lt; k; i++) key = key * base + digit[s[i]]; visited.insert(key); while(i &lt; s.size()) &#123; key = key * base - (digit[s[i - k]] * baseK) + digit[s[i]]; if(visited.count(key)) &#123; subStr = s.substr(i - k + 1, k); break; &#125; visited.insert(key); i++; &#125; /* Rabin-Karp 编码算法 */ if(!subStr.empty()) &#123; minK = k + 1; res = subStr; &#125; else maxK = k; &#125; return res;&#125; 316. Remove Duplicate Letters 给你一个字符串s，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。 Example 1: 12Input: s &#x3D; &quot;bcabc&quot;Output: &quot;abc&quot; Example 2: 12Input: s &#x3D; &quot;cbacdcbc&quot;Output: &quot;acdb&quot; Constraints: 1 &lt;= s.length &lt;= 104 s consists of lowercase English letters. 123456789101112131415161718192021222324252627282930// 类似单调栈的技巧string removeDuplicateLetters(string s)&#123; unordered_map&lt;char, int&gt; counter; for(char c : s) counter[c]++; // 记录已经在栈中的字符, 栈中的字符唯一 unordered_set&lt;char&gt; existed; // 把字符串当栈使用 string res; // 顺序访问字符 for(char c : s) &#123; // 每访问一个字符, 相应数量减一 counter[c]--; // 如果该字符已经在栈中了, 直接删除即可 if(existed.count(c)) continue; // 否则, 如果字典序比栈顶元素小并且在后边还有栈顶的字符, 删除栈顶字符 // 因为反正后面还会遇到的嘛 while(!res.empty() &amp;&amp; res.back() &gt; c &amp;&amp; counter[res.back()] &gt; 0) &#123; existed.erase(res.back()); res.pop_back(); &#125; // 将当前字符入栈 res.push_back(c); existed.insert(c); &#125; return res;&#125; 1839. Longest Substring Of All Vowels in Order 当一个字符串满足如下条件时，我们称它是美丽的 ： 所有5个英文元音字母（&#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39;）都必须至少出现一次。 这些元音字母的顺序都必须按照字典序升序排布（也就是说所有的&#39;a&#39;都在&#39;e&#39;前面，所有的&#39;e&#39;都在&#39;i&#39;前面，以此类推） 比方说，字符串&quot;aeiou&quot;和&quot;aaaaaaeiiiioou&quot;都是美丽的，但是&quot;uaeio&quot; ，&quot;aeoiu&quot;和&quot;aaaeeeooo&quot;不是美丽的。 给你一个只包含英文元音字母的字符串word，请你返回word中最长美丽子字符串的长度。如果不存在这样的子字符串，请返回0。 子字符串是字符串中一个连续的字符序列。 示例 1： 123输入：word &#x3D; &quot;aeiaaioaaaaeiiiiouuuooaauuaeiu&quot;输出：13解释：最长子字符串是 &quot;aaaaeiiiiouuu&quot;, 长度为 13 示例 2： 123输入：word &#x3D; &quot;aeeeiiiioooauuuaeiou&quot;输出：5解释：最长子字符串是 &quot;aeiou&quot;, 长度为 5 提示： 1 &lt;= word.length &lt;= 5 * 10^5 word只包含字符&#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39; 和&#39;u&#39;。 12345678910111213141516171819202122232425262728int longestBeautifulSubstring(string word)&#123; unordered_set&lt;char&gt; setting; unordered_map&lt;char, unordered_set&lt;char&gt;&gt; mapping; mapping['a'].insert(&#123;'a', 'e'&#125;); mapping['e'].insert(&#123;'e', 'i'&#125;); mapping['i'].insert(&#123;'i', 'o'&#125;); mapping['o'].insert(&#123;'o', 'u'&#125;); mapping['u'].insert('u'); int res = 0; int left = 0, right = 0; while(right &lt; word.size()) &#123; char a = word[right]; if(right &gt; left &amp;&amp; !mapping[word[right - 1]].count(a)) &#123; window.clear(); left = right; continue; &#125; right++; setting.insert(a); if(setting.size() == 5) res = max(res, right - left); &#125; return res;&#125; 1234567891011121314151617181920int longestBeautifulSubstring(string word)&#123; int res = 0, types = 1, len = 1; for(int i = 1; i &lt; word.length(); i++) &#123; // 更新当前字符串长度 if(word[i] &gt;= word[i - 1]) len++; // 更新当前字符种类 if(word[i] &gt; word[i - 1]) types++; // 当前字符串不美丽，从当前字符重新开始 if(word[i] &lt; word[i - 1]) &#123; types = 1; len = 1; &#125; // 更新最大字符串 if(types == 5) res = max(res, len); &#125; return res;&#125; 5. Longest Palindromic Substring 给你一个字符串s，找到s中最长的回文子串。 Example 1: 123Input: s &#x3D; &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: s &#x3D; &quot;cbbd&quot;Output: &quot;bb&quot; 12345678910111213141516171819202122232425// 中心开花, 时间复杂度为 O(n2), 空间复杂度为 O(1)string longestPalindrome(string s) &#123; int n = s.size(); auto palindrome = [&amp;](int left, int right) &#123; while(left &gt;= 0 &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123; left--; right++; &#125; return make_pair(left + 1, right - left - 1); &#125;; int start = 0, len = 0; for(int i = 0; i &lt; n; i++) &#123; auto [start1, len1] = palindrome(i, i); auto [start2, len2] = palindrome(i, i + 1); if(len &lt; len1) &#123; start = start1; len = len1; &#125; if(len &lt; len2) &#123; start = start2; len = len2; &#125; &#125; return s.substr(start, len);&#125; 76. Minimum Window Substring 给你一个字符串s和一个字符串t。返回s中涵盖t所有字符的最小子串。如果s中不存在涵盖t所有字符的子串，则返回空字符串&quot;&quot;。 注意：如果s中存在这样的子串，我们保证它是唯一的答案。 Example 1: 12Input: s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;Output: &quot;BANC&quot; Example 2: 12Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;Output: &quot;a&quot; 1234567891011121314151617181920212223242526272829303132string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; window, need; for(char c : t) &#123; need[c]++; &#125; int left = 0, right = 0; size_t valid = 0; int start = 0, len = 0; while(right &lt; s.size()) &#123; char a = s[right++]; if(need.count(a)) &#123; window[a]++; if(window[a] == need[a]) &#123; valid++; &#125; &#125; while(valid == need.size()) &#123; if(len == 0 || right - left &lt; len) &#123; start = left; len = right - left; &#125; char d = s[left++]; if(need.count(d)) &#123; if(window[d] == need[d]) &#123; valid--; &#125; window[d]--; &#125; &#125; &#125; return s.substr(start, len);&#125; 567. Permutation in String 给定两个字符串s1和s2，写一个函数来判断s2是否包含s1的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 Example 1: 123Input: s1 &#x3D; &quot;ab&quot;, s2 &#x3D; &quot;eidbaooo&quot;Output: trueExplanation: s2 contains one permutation of s1 (&quot;ba&quot;). Example 2: 12Input: s1 &#x3D; &quot;ab&quot;, s2 &#x3D; &quot;eidboaoo&quot;Output: false 123456789101112131415161718192021222324252627282930bool checkInclusion(string s1, string s2) &#123; unordered_map&lt;char, int&gt; window, need; for(char c : s1) &#123; need[c]++; &#125; int left = 0, right = 0, n = s2.size(), m = s1.size(); size_t valid = 0; while(right &lt; n) &#123; char a = s2[right++]; if(need.count(a)) &#123; window[a]++; if(window[a] == need[a]) &#123; valid++; &#125; &#125; while(valid == need.size()) &#123; if(right - left == m) &#123; return true; &#125; char d = s2[left++]; if(need.count(d)) &#123; if(window[d] == need[d]) &#123; valid--; &#125; window[d]--; &#125; &#125; &#125; return false;&#125; 3. Longest Substring Without Repeating Characters 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 Example 1: 123Input: s &#x3D; &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: s &#x3D; &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: s &#x3D; &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3.Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Example 4: 12Input: s &#x3D; &quot;&quot;Output: 0 1234567891011121314int lengthOfLongestSubstring(string s) &#123; unordered_map&lt;char, int&gt; window; int left = 0, right = 0, res = 0; while(right &lt; s.size()) &#123; char a = s[right++]; window[a]++; while(window[a] &gt; 1) &#123; char d = s[left++]; window[d]--; &#125; res = max(res, right - left); &#125; return res;&#125; 12345678910111213int lengthOfLongestSubstring(string s) &#123; vector&lt;bool&gt; visited(128); int lo = 0, hi = 0, len = 0; int n = s.size(); while(hi &lt; n) &#123; while(visited[s[hi]]) &#123; visited[s[lo++]] = false; &#125; visited[s[hi++]] = true; len = max(len, hi - lo); &#125; return len;&#125; 438. Find All Anagrams in a String 给定一个字符串s和一个非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串s和p的长度都不超过20100。 说明： 字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 Example 1: 12345Input: s &#x3D; &quot;cbaebabacd&quot;, p &#x3D; &quot;abc&quot;Output: [0,6]Explanation:The substring with start index &#x3D; 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.The substring with start index &#x3D; 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;. Example 2: 123456Input: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot;Output: [0,1,2]Explanation:The substring with start index &#x3D; 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.The substring with start index &#x3D; 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.The substring with start index &#x3D; 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;. 123456789101112131415161718192021222324252627282930313233343536373839vector&lt;int&gt; findAnagrams(string s, string p) &#123; vector&lt;int&gt; window(26), need(26); for(char c : p) &#123; need[c - 'a']++; &#125; // 表示窗口内字符种类和所需要的字符种类数目的差距 int diff = 0; for(int cnt : need) &#123; if(cnt &gt; 0) &#123; diff++; &#125; &#125; vector&lt;int&gt; res; int n = s.size(), m = p.size(); int left = 0, right = 0; while(right &lt; n) &#123; char a = s[right++] - 'a'; if(need[a] &gt; 0) &#123; window[a]++; if(window[a] == need[a]) &#123; diff--; &#125; &#125; // 对每个窗口内数据都判断一下 if(right - left == m) &#123; if(diff == 0) &#123; res.push_back(left); &#125; char d = s[left++] - 'a'; if(need[d] &gt; 0) &#123; if(window[d] == need[d]) &#123; diff++; &#125; window[d]--; &#125; &#125; &#125; return res;&#125; 395. Longest Substring with At Least K Repeating Characters 给你一个字符串s和一个整数k，请你找出s中的最长子串， 要求该子串中的每一字符出现次数都不少于k。返回这一子串的长度。 Example 1: 123Input: s &#x3D; &quot;aaabb&quot;, k &#x3D; 3Output: 3Explanation: The longest substring is &quot;aaa&quot;, as &#39;a&#39; is repeated 3 times. Example 2: 123Input: s &#x3D; &quot;ababbc&quot;, k &#x3D; 2Output: 5Explanation: The longest substring is &quot;ababb&quot;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times. 12345678910111213141516171819202122232425262728293031323334353637// 这题有一个点很关键// 有一些字符的出现次数小于 k// 如果窗口内包含这些字符的话, 肯定是不符合要求的// 常规的滑动窗口思路需要做些改动int longestSubstring(string s, int k) &#123; int n = s.size(); // 总字符数量小于 k 肯定不符合条件 if(n &lt; k) &#123; return 0; &#125; unordered_map&lt;char, int&gt; char2cnt; for(char c : s) &#123; char2cnt[c]++; &#125; unordered_set&lt;int&gt; uniqueString(s.begin(), s.end()); vector&lt;string&gt; afterSplit; auto split = [&amp;](const char sep) &#123; // 清空数组 vector&lt;string&gt;().swap(afterSplit); istringstream iss(s); string str; while(getline(iss, str, sep)) &#123; afterSplit.emplace_back(str); &#125; &#125;; for(char c : uniqueString) &#123; if(char2cnt[c] &lt; k) &#123; split(c); int len = 0; for(auto&amp;&amp; str : afterSplit) &#123; len = max(len, longestSubstring(str, k)); &#125; return len; &#125; &#125; return s.size();&#125; 402. Remove K Digits 给定一个以字符串表示的非负整数num，移除这个数中的k位数字，使得剩下的数字最小。 注意： num的长度小于10002且≥ k。 num不会包含任何前导零。 Example 1: 123Input: num &#x3D; &quot;1432219&quot;, k &#x3D; 3Output: &quot;1219&quot;Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: 123Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3: 123Input: num &#x3D; &quot;10&quot;, k &#x3D; 2Output: &quot;0&quot;Explanation: Remove all the digits from the number and it is left with nothing which is 0. 1234567891011121314151617181920212223// 贪心思想 + 单调栈string removeKdigits(string num, int k) &#123; int n = num.size(); if(n &lt;= k) &#123; return \"0\"; &#125; int remain = n - k; string s; for(char c : num) &#123; while(k &gt; 0 &amp;&amp; !s.empty() &amp;&amp; s.back() &gt; c) &#123; s.pop_back(); k--; &#125; s += c; &#125; s = s.substr(0, remain); /删除前导零 int i = 0; while(i &lt; remain &amp;&amp; s[i] == '0') &#123; i++; &#125; return i == remain ? \"0\" : s.substr(i);&#125; 321. Create Maximum Number 给定长度分别为m和n的两个数组，其元素由0-9构成，表示两个自然数各位上的数字。现在从这两个数组中选出k (k &lt;= m + n)个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。 求满足该条件的最大数。结果返回一个表示该最大数的长度为k的数组。 说明：请尽可能地优化你算法的时间和空间复杂度。 Example 1: 12Input: nums1 &#x3D; [3,4,6,5], nums2 &#x3D; [9,1,2,5,8,3], k &#x3D; 5Output: [9,8,6,5,3] Example 2: 12Input: nums1 &#x3D; [6,7], nums2 &#x3D; [6,0,4], k &#x3D; 5Output: [6,7,6,0,4] Example 3: 12Input: nums1 &#x3D; [3,9], nums2 &#x3D; [8,9], k &#x3D; 3Output: [9,8,9] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 这题是上一题 402 的超级进阶vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; int m = nums1.size(), n = nums2.size(); vector&lt;int&gt; res; for(int i = 0; i &lt;= k; i++) &#123; if(i &lt;= m &amp;&amp; k - i &lt;= n) &#123; res = max(res, merge(maxNumber(nums1, i), maxNumber(nums2, k - i))); &#125; &#125; return res;&#125;// 从 nums 中取出能够拼接得到最大的 k 个数vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; s; int del = nums.size() - k; for(int num : nums) &#123; while(del &gt; 0 &amp;&amp; !s.empty() &amp;&amp; s.back() &lt; num) &#123; s.pop_back(); del--; &#125; s.push_back(num); &#125; while(s.size() &gt; k) &#123; s.pop_back(); &#125; return s;&#125;// 合并两个数组, 其中比较大小的规则比较特殊vector&lt;int&gt; merge(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2) &#123; int m = nums1.size(), n = nums2.size(); vector&lt;int&gt; merged(m + n); int i = 0, j = 0, k = 0; while(i &lt; m &amp;&amp; j &lt; n) &#123; if(compare(nums1, i, nums2, j)) &#123; merged[k++] = nums1[i++]; &#125; else &#123; merged[k++] = nums2[j++]; &#125; &#125; while(i &lt; m) &#123; merged[k++] = nums1[i++]; &#125; while(j &lt; n) &#123; merged[k++] = nums2[j++]; &#125; return merged;&#125;// 合并数组时特殊的比较规则, 主要是处理两个数相等的情况, 这时要看后面数字的大小bool compare(vector&lt;int&gt;&amp; nums1, int i, vector&lt;int&gt;&amp; nums2, int j) &#123; if(i &gt;= nums1.size()) &#123; return false; &#125; if(j &gt;= nums2.size()) &#123; return true; &#125; if(nums1[i] &gt; nums2[j]) &#123; return true; &#125; if(nums1[i] &lt; nums2[j]) &#123; return false; &#125; return compare(nums1, i + 1, nums2, j + 1);&#125; 1754. Largest Merge Of Two Strings 给你两个字符串word1和word2。你需要按下述方式构造一个新字符串merge：如果word1或word2非空，选择下面选项之一继续操作： 如果word1非空，将word1中的第一个字符附加到merge的末尾，并将其从word1中移除。例如，word1 = &quot;abc&quot;且merge = &quot;dv&quot;，在执行此选项操作之后，word1 = &quot;bc&quot;，同时merge = &quot;dva&quot;。 如果word2非空，将word2中的第一个字符附加到merge的末尾，并将其从word2中移除。例如，word2 = &quot;abc&quot;且merge = &quot;&quot;，在执行此选项操作之后，word2 = &quot;bc&quot;，同时merge = &quot;a&quot;。 返回你可以构造的字典序最大的合并字符串merge。 Example 1: 123456789Input: word1 &#x3D; &quot;cabaa&quot;, word2 &#x3D; &quot;bcaaa&quot;Output: &quot;cbcabaaaaa&quot;Explanation: One way to get the lexicographically largest merge is:- Take from word1: merge &#x3D; &quot;c&quot;, word1 &#x3D; &quot;abaa&quot;, word2 &#x3D; &quot;bcaaa&quot;- Take from word2: merge &#x3D; &quot;cb&quot;, word1 &#x3D; &quot;abaa&quot;, word2 &#x3D; &quot;caaa&quot;- Take from word2: merge &#x3D; &quot;cbc&quot;, word1 &#x3D; &quot;abaa&quot;, word2 &#x3D; &quot;aaa&quot;- Take from word1: merge &#x3D; &quot;cbca&quot;, word1 &#x3D; &quot;baa&quot;, word2 &#x3D; &quot;aaa&quot;- Take from word1: merge &#x3D; &quot;cbcab&quot;, word1 &#x3D; &quot;aa&quot;, word2 &#x3D; &quot;aaa&quot;- Append the remaining 5 a&#39;s from word1 and word2 at the end of merge. Example 2: 12Input: word1 &#x3D; &quot;abcabc&quot;, word2 &#x3D; &quot;abdcaba&quot;Output: &quot;abdcabcabcaba&quot; Constraints: 1 &lt;= word1.length, word2.length &lt;= 3000 word1 and word2 consist only of lowercase English letters. 12345678910111213141516171819202122232425262728293031323334353637// 这题就是用到上一题 321 的合并思路string largestMerge(string word1, string word2) &#123; int m = word1.size(), n = word2.size(); string merged(m + n); int i = 0, j = 0, k = 0; while(i &lt; m &amp;&amp; j &lt; n) &#123; if(compare(word1, i, word2, j)) &#123; merged[k++] = word1[i++]; &#125; else &#123; merged[k++] = word2[j++]; &#125; &#125; while(i &lt; m) &#123; merged[k++] = word1[i++]; &#125; while(j &lt; n) &#123; merged[k++] = word2[j++]; &#125; return merged;&#125;bool compare(string&amp; word1, int i, string&amp; word2, int j) &#123; if(i &gt;= word1.size()) &#123; return false; &#125; if(j &gt;= word2.size()) &#123; return true; &#125; if(word1[i] &lt; word2[j]) &#123; return false; &#125; if(word1[i] &gt; word2[j]) &#123; return true; &#125; return compare(word1, i + 1, word2, j + 1);&#125; 1234567891011121314151617181920212223// 因为这题是处理字符串, 比较函数可以不用单独写// 但是效率会降低很多string largestMerge(string word1, string word2) &#123; int m = word1.size(), n = word2.size(); string merged; int i = 0, j = 0, k = 0; while(i &lt; m &amp;&amp; j &lt; n) &#123; if(word1.substr(i) &gt; word2.substr(j)) &#123; merged += word1[i++]; &#125; else &#123; merged += word2[j++]; &#125; &#125; // 直接切片就行了 if(i &lt; m) &#123; merged += word1.substr(i); &#125; if(j &lt; n) &#123; merged += word2.substr(j); &#125; return merged;&#125; 8. 字符串转换整数 (atoi) 请你来实现一个myAtoi(string s)函数，使其能将字符串转换成一个32位有符号整数（类似C/C++中的atoi函数）。 函数myAtoi(string s)的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，&quot;123&quot;-&gt; 123，&quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为0。必要时更改符号（从步骤2开始）。 如果整数数超过32位有符号整数范围[−2^31, 2^31 − 1]，需要截断这个整数，使其保持在这个范围内。具体来说，小于−2^31的整数应该被固定为−2^31，大于2^31−1的整数应该被固定为2^31−1 。 返回整数作为最终结果。 注意： 本题中的空白字符只包括空格字符&#39; &#39;。 除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。 题解：尽量不使用库函数、一次遍历（Java） - 字符串转换整数 (atoi) - 力扣（LeetCode） 示例 1： 1234567891011输入：s &#x3D; &quot;42&quot;输出：42解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格） ^第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;） ^第 3 步：&quot;42&quot;（读入 &quot;42&quot;） ^解析得到整数 42由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 示例 2： 1234567891011输入：s &#x3D; &quot; -42&quot;输出：-42解释：第 1 步：&quot; -42&quot;（读入前导空格，但忽视掉） ^第 2 步：&quot; -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数） ^第 3 步：&quot; -42&quot;（读入 &quot;42&quot;） ^解析得到整数 -42 。由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 示例 3： 1234567891011输入：s &#x3D; &quot;4193 with words&quot;输出：4193解释：第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格） ^第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;） ^第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止） ^解析得到整数 4193由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 示例 4： 1234567891011输入：s &#x3D; &quot;words and 987&quot;输出：0解释：第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格） ^第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;） ^第 3 步：&quot;words and 987&quot;（由于当前字符 &#39;w&#39; 不是一个数字，所以读入停止） ^解析得到整数 0，因为没有读入任何数字。由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 示例 5： 1234567891011输入：s &#x3D; &quot;-91283472332&quot;输出：-2147483648解释：第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格） ^第 2 步：&quot;-91283472332&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数） ^第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;） ^解析得到整数 -91283472332由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -2^31 &#x3D; -2147483648 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 根据示例 1, 需要去掉前导空格// 根据示例 2, 需要判断第 1 个字符为 + 和 - 的情况// 因此, 可以设计一个变量 sign, 初始化的时候为 1, 如果遇到 -, 将 sign 修正为 -1// 判断是否是数字, 可以使用字符的 ASCII 码数值进行比较, 即 0 &lt;= c &lt;= '9'// 根据示例 3 和示例 4, 在遇到第 1 个不是数字的字符的情况下, 转换停止, 退出循环// 根据示例 5, 如果转换以后的数字超过了 int 类型的范围, 需要截取// 这里不能将结果 res 变量设计为 long 类型// 注意: 由于输入的字符串转换以后也有可能超过 long 类型// 因此需要在循环内部就判断是否越界, 只要越界就退出循环, 这样也可以减少不必要的计算// 由于涉及下标访问, 因此全程需要考虑数组下标是否越界的情况int myAtoi(string str) &#123; int n = str.size(); int idx = 0; // 去除前导空格 while(idx &lt; n &amp;&amp; str[idx] == ' ') &#123; idx++; &#125; if(idx == n) &#123; return 0; &#125; int sign = 1; // 处理第 1 个非空字符为正负符号, 这两个判断需要写在一起 if(str[idx] == '+') &#123; idx++; &#125; else if(str[idx] == '-') &#123; sign = -1; idx++; &#125; int number = 0; while(idx &lt; n) &#123; char c = str[idx]; if(c &lt; '0' || c &gt; '9') &#123; break; &#125; int num = c - '0'; // 溢出处理 if(number &gt; INT_MAX / 10 || (number == INT_MAX / 10 &amp;&amp; num &gt; INT_MAX % 10)) &#123; return INT_MAX; &#125; if(number &lt; INT_MIN / 10 || (number == INT_MIN / 10 &amp;&amp; num &gt; -(INT_MIN % 10))) &#123; return INT_MIN; &#125; number = number * 10 + sign * num; idx++; &#125; return number;&#125; 43. Multiply Strings 给定两个以字符串形式表示的非负整数num1和num2，返回num1和num2的乘积，它们的乘积也表示为字符串形式。 参考题解：优化版竖式(打败99.4%) - 字符串相乘 - 力扣（LeetCode） 示例 1: 12输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;输出: &quot;6&quot; 示例 2: 12输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;输出: &quot;56088&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 模拟普通竖式乘法// 将每一步的乘法结果相加即可string multiply(string num1, string num2) &#123; if(num1 == \"0\" || num2 == \"0\") &#123; return \"0\"; &#125; string res; int m = num1.size(); int n = num2.size(); int times = 0; for(int i = m - 1; i &gt;= 0; i--) &#123; string num; int carry = 0; for(int j = n - 1; j &gt;= 0; j--) &#123; int temp = (num1[i] - '0') * (num2[j] - '0') + carry; carry = temp / 10; num += to_string(temp % 10); &#125; if(carry != 0) &#123; num += to_string(carry); &#125; reverse(num.begin(), num.end()); for(int k = 0; k &lt; times; k++) &#123; num += '0'; &#125; times++; res = stringPlus(res, num); &#125; return res;&#125;// 字符串数字相加string stringPlus(const string&amp; num1, const string&amp; num2) &#123; int m = num1.size(); if(m == 0) &#123; return num2; &#125; int n = num2.size(); if(n == 0) &#123; return num1; &#125; string res; int i = m - 1, j = n - 1; int carry = 0; while(i &gt;= 0 || j &gt;= 0 || carry &gt; 0) &#123; // 这里的一个技巧就是短的字符串前面以 0 补齐 int x = i &lt; 0 ? 0 : num1[i] - '0'; int y = j &lt; 0 ? 0 : num2[j] - '0'; int temp = x + y + carry; res += to_string(temp % 10); carry = temp / 10; i--; j--; &#125; reverse(res.begin(), res.end()); return res;&#125; 93. 复原 IP 地址 给定一个只包含数字的字符串，用以表示一个IP地址，返回所有可能从s获得的有效IP地址 。你可以按任何顺序返回答案。 有效IP地址 正好由四个整数（每个整数位于0到255之间组成，且不能含有前导0），整数之间用&#39;.&#39;分隔。 例如：”0.1.2.201”和”192.168.1.1”是有效IP地址，但是”0.011.255.245”、”192.168.1.312”和”192.168@1.1“是无效IP地址。 示例 1： 12输入：s &#x3D; &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;] 示例 2： 12输入：s &#x3D; &quot;0000&quot;输出：[&quot;0.0.0.0&quot;] 示例 3： 12输入：s &#x3D; &quot;010010&quot;输出：[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;] 123456789101112131415161718192021222324252627282930// 回溯vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; res; auto dfs = [&amp;](auto&amp;&amp; dfs, int cnt, int idx, string&amp;&amp; str) &#123; if(cnt &gt;= 4) &#123; if(idx == s.size()) &#123; // 需要将最前面的 '.' 删掉 res.emplace_back(str.substr(1)); &#125; return; &#125; // 重要的剪枝, 前导符为 0 时, 这一段只能为 0 if(s[idx] == '0') &#123; dfs(dfs, cnt + 1, idx + 1, str + \".0\"); return; &#125; string temp; for(int i = idx; i &lt; s.size(); i++) &#123; temp += s[i]; if(stoi(temp) &lt;= 255) &#123; dfs(dfs, cnt + 1, i + 1, str + \".\" + temp); &#125; else &#123; break; &#125; &#125; &#125;; dfs(dfs, 0, 0, \"\"); return res;&#125; 468. 验证IP地址 编写一个函数来验证输入的字符串是否是有效的IPv4或IPv6地址。 如果是有效的IPv4地址，返回&quot;IPv4&quot;； 如果是有效的IPv6地址，返回&quot;IPv6&quot;； 如果不是上述类型的IP地址，返回&quot;Neither&quot;。 IPv4地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为0 - 255， 用(&quot;.&quot;)分割。比如，172.16.254.1；同时，IPv4地址内的数不会以0开头。比如，地址172.16.254.01是不合法的。 IPv6地址由8组16进制的数字来表示，每组表示16比特。这些组数字通过(&quot;:&quot;)分割。比如， 2001:0db8:85a3:0000:0000:8a2e:0370:7334是一个有效的地址。而且，我们可以加入一些以0开头的数字，字母可以使用大写，也可以是小写。所以，2001:db8:85a3:0:0:8A2E:0370:7334也是一个有效的IPv6 address地址 (即，忽略0开头，忽略大小写）。 然而，我们不能因为某个组的值为0，而使用一个空的组，以至于出现(::)的情况。 比如，2001:0db8:85a3::8A2E:0370:7334是无效的IPv6地址。 同时，在IPv6地址中，多余的0也是不被允许的。比如，02001:0db8:85a3:0000:0000:8a2e:0370:7334是无效的。 示例 1： 123输入：IP &#x3D; &quot;172.16.254.1&quot;输出：&quot;IPv4&quot;解释：有效的 IPv4 地址，返回 &quot;IPv4&quot; 示例 2： 123输入：IP &#x3D; &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;输出：&quot;IPv6&quot;解释：有效的 IPv6 地址，返回 &quot;IPv6&quot; 示例 3： 123输入：IP &#x3D; &quot;256.256.256.256&quot;输出：&quot;Neither&quot;解释：既不是 IPv4 地址，又不是 IPv6 地址 示例 4： 12输入：IP &#x3D; &quot;2001:0db8:85a3:0:0:8A2E:0370:7334:&quot;输出：&quot;Neither&quot; 示例 5： 12输入：IP &#x3D; &quot;1e1.4.5.6&quot;输出：&quot;Neither&quot; 提示： IP仅由英文字母，数字，字符&#39;.&#39;和&#39;:&#39;组成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123;public: string validIPAddress(string IP) &#123; if(validIPv4Address(IP)) &#123; return \"IPv4\"; &#125; if(validIPv6Address(IP)) &#123; return \"IPv6\"; &#125; return \"Neither\"; &#125; bool validIPv4Address(const string&amp; IPv4) &#123; vector&lt;string&gt; ip; split(IPv4, ip, '.'); if(ip.size() != 4) &#123; return false; &#125; for(auto&amp;&amp; elem : ip) &#123; if(elem.empty() || elem.size() &gt; 3) &#123; return false; &#125; // 处理前导符为 0 的情况 if(elem.size() &gt; 1 &amp;&amp; elem[0] == '0') &#123; return false; &#125; // 处理非法字符的情况，如 1e1等 for(char c : elem) &#123; if(c &lt; '0' || c &gt; '9') &#123; return false; &#125; &#125; if(stoi(elem) &gt; 255) &#123; return false; &#125; &#125; return true; &#125; bool validIPv6Address(const string&amp; IPv6) &#123; vector&lt;string&gt; ip; split(IPv6, ip, ':'); if(ip.size() != 8) &#123; return false; &#125; // unordered_set&lt;char&gt; hexs&#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'&#125;; string hexs&#123;\"0123456789abcdefABCDEF\"&#125;; for(auto&amp;&amp; elem : ip) &#123; if(elem.empty() || elem.size() &gt; 4) &#123; return false; &#125; // for(char c : elem) &#123; // if(hexs.count(c) == 0) &#123; // return false; // &#125; // &#125; for(char c : elem) &#123; if(hexs.find(c) == string::npos) &#123; return false; &#125; &#125; &#125; return true; &#125; void split(const string&amp; IP, vector&lt;string&gt;&amp; ip, char delim) &#123; if(IP.empty()) &#123; return; &#125; stringstream ss(IP); string temp; while(getline(ss, temp, delim)) &#123; ip.emplace_back(move(temp)); &#125; // 处理 IP 地址末尾有一个 '.' 或 ':' 的情况 if(IP.back() == ':' || IP.back() == '.') &#123; ip.push_back(\"\"); &#125; &#125;&#125;; 647. 回文子串 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 123&gt;输入：&quot;abc&quot;&gt;输出：3&gt;解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 示例 2： 123&gt;输入：&quot;aaa&quot;&gt;输出：6&gt;解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot; 1234567891011121314151617// 中心开花int countSubstrings(string s) &#123; int n = s.size(); int cnt = 0; auto palindrome = [&amp;](int left, int right) &#123; while(left &gt;= 0 &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123; left--; right++; cnt++; &#125; &#125;; for(int i = 0; i &lt; n; i++) &#123; palindrome(i, i); palindrome(i, i + 1); &#125; return cnt;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"leetcode刷题系列之动态规划","date":"2021-05-01T13:35:42.000Z","path":"RT66rbCYdVwFEsD8/","text":"这篇文章是leetcode刷题系列的第6部分——动态规划。这里把有代表性的题目发出来，共计56道。动态规划题目变化多端，目前旨在于习得通用的解题技巧，这些只是比较经典的动态规划题目。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！ 64. Minimum Path Sum 给定一个m × n的网格，其中填充了非负数，请找到从左上到右下的路径，这将沿其路径的所有数字的总和最小化。 注意：您只能在任何时间点向下或向右移动。 Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= grid[i][j] &lt;= 100 Example: 123Input: grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]Output: 7Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum. 12345678910111213141516171819202122232425262728293031323334// dp[i][j] 表示从起点走到第 i 行, 第 j 列的最小路径和// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; int m = grid.size(); int n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(i == 1 &amp;&amp; j == 1) dp[i][j] = grid[i - 1][j - 1]; else dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; &#125; &#125; return dp[m][n];&#125;// 这样写可避免循环内每次的判断语句, 效率提升那么一丢丢// dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; int m = grid.size(); int n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, INT_MAX)); dp[0][1] = 0; dp[1][0] = 0; for(int i = 1; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; return dp[m][n];&#125; 72. Edit Distance Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 123456Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)rorse -&gt; rose (remove &#39;r&#39;)rose -&gt; ros (remove &#39;e&#39;) Example 2: 12345678Input: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &#39;t&#39;)inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)exection -&gt; execution (insert &#39;u&#39;) Constraints: 0 &lt;= word1.length, word2.length &lt;= 500 word1 and word2 consist of lowercase English letters. 1234567891011121314151617181920212223242526272829303132333435363738394041// 一般来说, 解决字符串的动态规划问题, 是用两个指针 i, j 分别指向两个字符串的尾// 一步一步向前走, 缩小问题的规模// 如果我们定义一个 dp 函数 dp(i, j)// 表示将 word1[0, i] 变为 word2[0, j] 的最小编辑距离的话// 那么我们要求的就是 dp(word1.size() - 1, word2.size() - 1)// 那么 dp(i, j) 怎么求呢？// 考虑之前的状态, 共有 dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1) 三种// 在编辑 word1 的第 i + 1 个字符时// 1. 如果 word1[i] == word2[j], 那么直接跳过即可, dp(i, j) = dp(i - 1, j - 1)// 2. 如果 word1[i] != word2[j] 我们有三种选择// - 插入一个字符使得其与 word2[j] 匹配, 那么 dp(i, j) = dp(i, j - 1) + 1// - 删除这个字符, word2[j] 没有得到匹配, 那么 dp(i, j) = dp(i - 1, j) + 1// - 替换这个字符使得其与 word2[j] 匹配, 那么 dp(i, j) = dp(i - 1, j - 1) + 1// 要求最小编辑距离的话, 这三种都试一下, 取最小值// 上面相当于暴力解法, 把每一个操作都试一遍取最小值// 会出现非常多的重叠子问题, 因此需要用备忘录优化一下unordered_map&lt;string, int&gt; memo;int minDistance(string word1, string word2)&#123; return dp(word1, word2, word1.size() - 1, word2.size() - 1);&#125;int dp(string&amp; word1, string&amp; word2, int i, int j)&#123; // base case // 如果 word1 走到头了, word2 没有, 那么只能插入 word2 剩下的所有字符 if(i &lt; 0) return j + 1; // 如果 word2 走到头了, word1 没有, 那么只能删除 word1 剩下的所有字符 if(j &lt; 0) return i + 1; string key = to_string(i) + \",\" + to_string(j); if(memo.count(key)) return memo[key]; if(word1[i] == word2[j]) memo[key] = dp(word1, word2, i - 1, j - 1); else memo[key] = 1 + min(&#123;dp(word1, word2, i - 1, j), dp(word1, word2, i, j - 1), dp(word1, word2, i - 1, j - 1)&#125;); return memo[key];&#125; 12345678910111213141516171819202122// 使用 dp tableint minDistance(string word1, string word2)&#123; int m = word1.size(); int n = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1)); for(int i = 1; i &lt;= m; i++) dp[i][0] = i; for(int i = 1; i &lt;= n; i++) dp[0][i] = i; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = 1 + min(&#123;dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]&#125;); &#125; &#125; return dp[m][n];&#125;; 300. Longest Increasing Subsequence 给你一个整数数组nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7]是数组[0,3,1,6,2,2,7]的子序列。 Example 1: 123Input: nums &#x3D; [10,9,2,5,3,7,101,18]Output: 4Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Example 2: 12Input: nums &#x3D; [0,1,0,3,2,3]Output: 4 Example 3: 12Input: nums &#x3D; [7,7,7,7,7,7,7]Output: 1 Constraints: 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104 Follow up: Could you come up with the O(n2) solution? Could you improve it to O(n log(n)) time complexity? 123456789101112131415161718// 动态规划 dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度// 要求的目标为 dp 数组中的最大值// base case 以 nums[i] 结尾的最长递增子序列至少要包含它自己 dp[0..] = 1// dp[i] = max(dp[i], dp[j] + 1) j 属于 [0..i) 且 nums[j] &lt; nums[i]// 就是在前面找到结尾的比 nums[i] 小的子序列, 把 nums[i] 接到后面, 长度加 1 即可// 可能有很多个满足条件的接法, 选择长度最大的接法int lengthOfLIS(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); vector&lt;int&gt; dp(n, 1); for(int i = 1; i &lt; n; i++) for(int j = 0; j &lt; i; j++) if(nums[j] &lt; nums[i]) dp[i] = max(dp[i], dp[j] + 1); int res = *max_element(dp.begin(), dp.end()); return res;&#125; 12345678910111213141516171819202122232425262728293031// 既然题目提示我们这题的时间复杂度可以优化到 O(nlogn)// logn 的复杂度只有二分法能办到了// 我们把这些数分成许多堆, 按照下面定义的规则:// 1. 依次从数组中拿出一个数, 首先第一个数就放在第 1 个堆就行// 2. 之后每次取出的数必须放在所有堆顶的不小于它的数上面// 3. 如果有多个堆顶的数都不小于它, 就放在最靠左边的堆上面// 4. 如果没有这样的堆, 就从右边新起一个堆放// 这个规则的限制下, 所有堆顶的元素从左到右始终都是有序的// 这样我们就可以应用二分搜索, 来找第 1 个不小于待放数的堆了// 那么这和我们的问题: 寻找最长递增子序列有什么关系呢？// 可以证明, 最长递增子序列就是堆的个数int lengthOfLIS(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); vector&lt;int&gt; pilesTop; // 最多分了 n 个堆, 我们提前分配空间提升效率 pilesTop.reserve(n); for(int i = 0; i &lt; n; i++) &#123; // 寻找左边界二分搜索 auto left = lower_bound(pilesTop.begin(), pilesTop.end(), nums[i]); // 如果没有合适的堆, 自己单放 if(left == pilesTop.end()) pilesTop.push_back(nums[i]); // 否则, 放堆顶上 else *left = nums[i]; &#125; return pilesTop.size();&#125; 354. Russian Doll Envelopes 给你一个二维整数数组envelopes，其中envelopes[i] = [wi, hi]，表示第i个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 注意：不允许旋转信封。 Example 1: 123Input: envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]Output: 3Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]). Example 2: 12Input: envelopes &#x3D; [[1,1],[1,1],[1,1]]Output: 1 123456789101112131415// 按照信封的宽度递增排序, 宽度相等的信封按高度递减排序// 最大嵌套信封数就是高度序列的最长递增子序列// 动态规划解法int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes)&#123; auto cmp = [](auto&amp; a, auto&amp; b)&#123; return a[0] == b[0] ? b[1] &lt; a[1] : a[0] &lt; b[0]; &#125;; sort(envelopes.begin(), envelopes.end(), cmp); vector&lt;int&gt; dp(envelopes.size(), 1); for(int i = 1; i &lt; envelopes.size(); i++) for(int j = 0; j &lt; i; j++) if(envelopes[i][1] &gt; envelopes[j][1]) dp[i] = max(dp[i], dp[j] + 1); int res = *max_element(dp.begin(), dp.end()); return res;&#125; 1234567891011121314151617181920212223// 同样的使用二分搜索解法提升效率int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes)&#123; auto cmp = [](auto&amp; a, auto&amp; b)&#123; return a[0] == b[0] ? b[1] &lt; a[1] : a[0] &lt; b[0]; &#125;; sort(envelopes.begin(), envelopes.end(), cmp); int n = envelopes.size(); vector&lt;int&gt; nums(n); for(int i = 0; i &lt; n; i++) nums[i] = envelopes[i][1]; vector&lt;int&gt; piles; piles.reserve(n); for(int i = 0; i &lt; n; i++) &#123; auto it = lower_bound(piles.begin(), piles.end(), nums[i]); if(it == piles.end()) piles.push_back(nums[i]); else *it = nums[i]; &#125; return piles.size();&#125; 494. Target Sum 给定一个非负整数数组，a1, a2, ..., an和一个目标数S。现在你有两个符号+和-。对于数组中的任意一个整数，你都可以从+或-中选择一个符号添加在前面。 返回可以使最终数组和为目标数S的所有添加符号的方法数。 Example: 1234567891011Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 &#x3D; 3+1-1+1+1+1 &#x3D; 3+1+1-1+1+1 &#x3D; 3+1+1+1-1+1 &#x3D; 3+1+1+1+1-1 &#x3D; 3There are 5 ways to assign symbols to make the sum of nums be target 3. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 这道题虽然通常想到的都是 dfs 的方法// 现在让我们再转化一下思路, 看它和动态规划有什么关系// 数组中的数都是非负数, 把所有数得和表示为 sums// 我们把前面加正号的数的和 表示为 sumA, 把前面加负号的数的和 表示为 sumB// 有 sumA - sumB = target// 移项得 sumA = target + sumB// 两边加上 sumA 有 sumA + sumA = target + sumA + sumB = target + sums// 最后 sumA = (target + sums) / 2 = newTarget右边都是已知的// 也就是说我们把问题转化为了// 从这些数中选出一个子集, 问我们有多少种选法可使得子集的和等于目标数// 换种表达方式, 我们把目标数表示为一个背包的载重量// 数组中的值为一个个石头的重量, 问我们有多少种装法可以把背包装满// 这是动态规划中典型的背包问题// 首先在装石头的过程中, 问题中的状态和选择有: 状态就是背包的可载重量和可选择的石头序列// 选择就是装还是不装// 由于有两个状态, 所以我们定义一个二维 dp 数组// dp[i][j] 表示在前 i 个石头中, 背包的可载重量为 j 时, 有多少种装法// 那么当 i = 0 时, 没有石头, 装法为 0// 当 j = 0 时, 背包的可载重量为 0 时, 只有 1 种装法, 就是一个也不装// 那么状态转移方程怎么写呢?// 对于可选择前 i 个石头, 可载重量为 j 时// 1. 如果第 i 个石头不装, 那么 dp[i][j] = dp[i - 1][j]// 2. 如果第 i 个石头装, 那么 dp[i][j] = dp[i - 1][j - nums[i - 1]]// 它们都取决于上一次装的情况, 两种情况要加起来// 所以 dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]// 我们最终要求的目标就是 dp[n][m], 其中 n 表示给定数组的长度, m 表示新目标和int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target)&#123; // 问题转化 int sum = accumulate(nums.begin(), nums.end(), 0); // 如果总和都小于目标和(表示全加正号)或者 sum + target 为奇数(表示 sumA 都不是个整数) if(sum &lt; target || ((sum + target) &amp; 1)) return 0; int newTarget = (sum + target) / 2; // 定义 dp 数组 vector&lt;vector&lt;int&gt;&gt; dp(nums.size() + 1, vector&lt;int&gt;(newTarget + 1)); // base case // 注意 dp[0][0] 也是 1 for(int i = 0; i &lt;= nums.size(); i++) dp[i][0] = 1; for(int i = 1; i &lt; dp.size(); i++) &#123; for(int j = 0; j &lt;= newTarget; j++) &#123; if(j - nums[i - 1] &lt; 0) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]; &#125; &#125; return dp[nums.size()][newTarget];&#125; 91. Decode Ways、 639. Decode Ways II 一条包含字母A - Z的消息通过以下映射进行了编码： &#39;A&#39; -&gt; 1 &#39;B&#39; -&gt; 2 … &#39;Z&#39; -&gt; 26 要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&quot;11106&quot;可以映射为： &quot;AAJF&quot;，将消息分组为(1 1 10 6) &quot;KJF&quot;，将消息分组为(11 10 6) 注意，消息不能分组为(1 11 06)，因为&quot;06&quot;不能映射为&quot;F&quot;，这是由于&quot;6&quot;和&quot;06&quot;在映射中并不等价。 给你一个只含数字的非空字符串s，请计算并返回解码方法的总数 。 Example 1: 123Input: s &#x3D; &quot;12&quot;Output: 2Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12). Example 2: 123Input: s &#x3D; &quot;226&quot;Output: 3Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). Example 3: 12345Input: s &#x3D; &quot;0&quot;Output: 0Explanation: There is no character that is mapped to a number starting with 0.The only valid mappings with 0 are &#39;J&#39; -&gt; &quot;10&quot; and &#39;T&#39; -&gt; &quot;20&quot;, neither of which start with 0.Hence, there are no valid ways to decode this since all digits need to be mapped. Example 4: 123Input: s &#x3D; &quot;06&quot;Output: 0Explanation: &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;). Constraints: 1 &lt;= s.length &lt;= 100 s contains only digits and may contain leading zero(s). 123456789101112131415161718192021int numDecodings(string s)&#123; int n = s.size(); vector&lt;int&gt; dp(n + 1); // base case 前两个字符组成的串单放用 dp[0] = 1; if(s[0] != '0') dp[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; if(dp[i - 1] == 0) return 0; // 单放 int num = stoi(s[i - 1]); if(num &gt;= 1 &amp;&amp; num &lt;= 9) dp[i] += dp[i - 1]; // 拼着放 num = stoi(s.substr(i - 2, 2)); if(num &gt;= 10 &amp;&amp; num &lt;= 26) dp[i] += dp[i - 2]; &#125; return dp[n];&#125; 516. Longest Palindromic Subsequence 给定一个字符串s，找到其中最长的回文子序列，并返回该序列的长度。可以假设s的最大长度为1000。 Example 1: 123Input: s &#x3D; &quot;bbbab&quot;Output: 4Explanation: One possible longest palindromic subsequence is &quot;bbbb&quot;. Example 2: 123Input: s &#x3D; &quot;cbbd&quot;Output: 2Explanation: One possible longest palindromic subsequence is &quot;bb&quot;. 123456789101112131415161718192021222324// dp[i][j] 表示子串 s[i..j] 中的最长回文子序列// if s[i] == s[j]// dp[i][j] = dp[i + 1][j - 1] + 2// else// dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])// 我们的目标是求 dp[0][n - 1]// 显然 i == j 时 dp[i][j] = 1, i &gt; j 时 dp[i][j] = 0int longestPalindromeSubseq(string s)&#123; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); // base case for(int i = 0; i &lt; n; i++) dp[i][i] = 1; for(int i = n - 2; i &gt;= 0; i--) for(int j = i + 1; j &lt; n; j++) if(s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); return dp[0][n - 1];&#125; 1143. Longest Common Subsequence 给定两个字符串text1和text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回0。 一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&quot;ace&quot;是&quot;abcde&quot;的子序列，但&quot;aec&quot;不是&quot;abcde&quot;的子序列。两个字符串的公共子序列是这两个字符串所共同拥有的子序列。 Example 1: 123Input: text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; Output: 3 Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3. Example 2: 123Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;Output: 3Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3. Example 3: 123Input: text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;Output: 0Explanation: There is no such common subsequence, so the result is 0. 12345678910111213141516171819202122// dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度// if text1[i] == text1[j]// dp[i][j] = 1 + dp[i - 1][j - 1]// else// dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])// 我们的目标是求 dp[m][n]// 显然 i == 0 || j == 0 时 dp[i][j] = 0int longestCommonSubsequence(string text1, string text2)&#123; int m = text1.size(); int n = text2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1)); // base case // ... for(int i = 1; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) if(text1[i - 1] == text2[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1]; else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]); return dp[m][n];&#125; 583. Delete Operation for Two Strings Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string. Example 1: 123Input: word1 &#x3D; &quot;sea&quot;, word2 &#x3D; &quot;eat&quot;Output: 2Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;. Example 2: 12Input: word1 &#x3D; &quot;leetcode&quot;, word2 &#x3D; &quot;etco&quot;Output: 4 123456789101112131415161718192021222324252627282930// 可以看出来, 一番删除操作之后剩下的字符串就是它们的最长公共子序列// 所以就相当于问删除了多少字符后可以变成最长公共子序列int minDistance(string word1, string word2)&#123; int lcs = longestCommonSubsequence(word1, word2); return word1.size() - lcs + word2.size() - lcs;&#125;// dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的最长公共子序列长度// if text1[i] == text1[j]// dp[i][j] = 1 + dp[i - 1][j - 1]// else// dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])// 我们的目标是求 dp[m][n]// 显然 i == 0 || j == 0 时 dp[i][j] = 0int longestCommonSubsequence(string text1, string text2)&#123; int m = text1.size(); int n = text2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1)); // base case // ... for(int i = 1; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) if(text1[i - 1] == text2[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1]; else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]); return dp[m][n];&#125; 712. Minimum ASCII Delete Sum for Two Strings 给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。 Example 1: 12345Input: s1 &#x3D; &quot;sea&quot;, s2 &#x3D; &quot;eat&quot;Output: 231Explanation: Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.Deleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.At the end, both strings are equal, and 115 + 116 &#x3D; 231 is the minimum sum possible to achieve this. Example 2: 123456Input: s1 &#x3D; &quot;delete&quot;, s2 &#x3D; &quot;leet&quot;Output: 403Explanation: Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,adds 100[d]+101[e]+101[e] to the sum. Deleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.At the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 &#x3D; 403.If instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher. Note: 0 &lt; s1.length, s2.length &lt;= 1000. All elements of each string will have an ASCII value in [97, 122]. 12345678910111213141516171819202122232425262728// 和 LCS 的思路有些许相似之处// dp[i][j] 表示把 s1[0..i-1] 和 s2[0..j-1] 变相同所删除字符的最小和// if s1[i - 1] == s2[j - 1]// dp[i][j] = dp[i - 1][j - 1]// else// dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1])// 我们要求的目标是 dp[m][n]// 显然 i == 0 时 dp[i][j] = sum(s2[0..j-1])// j == 0 时 dp[i][j] = sum(s1[0..i-1])int minimumDeleteSum(string s1, string s2)&#123; int m = s1.size(); int n = s2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1)); // base case for(int i = 1; i &lt;= m; i++) dp[i][0] = dp[i - 1][0] + s1[i - 1]; for(int j = 1; j &lt;= n; j++) dp[0][j] = dp[0][j - 1] + s2[j - 1]; for(int i = 1; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) if(s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(dp[i][j - 1] + s2[j - 1], dp[i - 1][j] + s1[i - 1]); return dp[m][n];&#125; 368. Largest Divisible Subset 给你一个由无重复正整数组成的集合nums，请你找出并返回其中最大的整除子集answer，子集中每一元素对(answer[i], answer[j])都应当满足： answer[i] % answer[j] == 0，或answer[j] % answer[i] == 0 如果存在多个有效解子集，返回其中任何一个均可。 Example 1: 123Input: nums &#x3D; [1,2,3]Output: [1,2]Explanation: [1,3] is also accepted. Example 2: 12Input: nums &#x3D; [1,2,4,8]Output: [1,2,4,8] 1234567891011121314151617181920212223242526272829303132// 这题要先把数组按照升序排列, 排完序之后就是求最长倍增子序列// 动态规划 dp[i] 表示以 nums[i] 结尾的最长倍增子序列的长度// 要求的目标为 dp 数组中的最大值// base case 以 nums[i] 结尾的最长倍增子序列至少要包含它自己 dp[0..] = 1// dp[i] = max(dp[i], dp[j] + 1) j 属于 [0..i) 且 nums[i] % nums[j] == 0// 就是在前面找到可以被 nums[i] 整除的子序列, 把 nums[i] 接到后面, 长度加 1 即可// 可能有很多个满足条件的接法, 选择长度最大的接法// 但是由于这题不是让我们输出最长倍增子序列的个数, 而是把它们作为数组输出// 所以 dp 数组里存的不止是最大个数, 还有它上一个数的索引// 这样最后通过 dp 数组中的最大值, 找到前一个数的索引, 然后反推前面所有的数vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); sort(nums.begin(), nums.end()); // &#123;最长倍增子序列个数, 上一个数的索引&#125; vector&lt;pair&lt;int, int&gt;&gt; dp(n, &#123;1, -1&#125;); for(int i = 1; i &lt; n; i++) for(int j = 0; j &lt; i; j++) if(nums[i] % nums[j] == 0 &amp;&amp; dp[i].first &lt; dp[j].first + 1) dp[i] = &#123;dp[j].first + 1, j&#125;; auto it = max_element(dp.begin(), dp.end()); vector&lt;int&gt; res; res.push_back(nums[distance(dp.begin(), it)]); int index = it-&gt;second; while(index != -1) &#123; res.push_back(nums[index]); index = dp[index].second; &#125; return res;&#125; 121. Best Time to Buy and Sell Stock 给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。 你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。 Example 1: 1234Input: prices &#x3D; [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: 123Input: prices &#x3D; [7,6,4,3,1]Output: 0Explanation: In this case, no transactions are done and the max profit &#x3D; 0. 12345678910111213141516171819// 直接贪心算法// 要在价格最低点买, 价格最高点卖掉// 从前往后遍历, 记录史最低点// 今天卖掉的利润等于今天的价格减去历史最低点的价格// 每一天都考虑是否卖掉, 如果今天卖掉比之前卖掉得到的利润大就卖掉int maxProfit(vector&lt;int&gt;&amp; prices)&#123; int n = prices.size(); int minPrice = INT_MAX; int maxProfit = 0; for(int i = 0; i &lt; n; i++) // 如果今天的价格比历史最低点价格还低, 更新最低价格 if(prices[i] &lt; minPrice) minPrice = prices[i]; // 否则, 如果今天卖出的话比之前卖出得到的利润大, 就卖出 else if(prices[i] - minPrice &gt; maxProfit) maxProfit = prices[i] - minPrice; return maxProfit;&#125; 12345678910111213141516171819202122232425262728// 动态规划解法// 状态有两个 [天数] 和 [是否持有股票]// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润// 如果在第 i 天没有持有股票, 有两种可能// 1. 前一天持有股票, 当天将股票卖出了// 2. 前一天没有持有股票, 当天也没买进// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])// 如果在第 i 天持有股票, 有两种可能// 1. 前一天持有股票, 当天没有卖出// 2. 前一天没有持有股票, 当天买进股票// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])// 但是这种情况下, 【由于只能交易一次】, 你当天才买进的话, 之前的利润肯定是 0, 即 dp[i - 1][0] = 0// 所以, dp[i][1] = max(dp[i - 1][1], - prices[i - 1])// 我们的目标是求 dp[n][0]// 当 i == 0, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)int maxProfit(vector&lt;int&gt;&amp; prices)&#123; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2)); dp[0][1] = INT_MIN; for(int i = 1; i &lt;= n; i++) &#123; dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0]); dp[i][1] = max(dp[i - 1][1], 0 - prices[i - 1]); &#125; return dp[n][0];&#125; 122. Best Time to Buy and Sell Stock II 给定一个数组prices，其中prices[i]是一支给定股票第i天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 Example 1: 1234Input: prices &#x3D; [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3. Example 2: 1234Input: prices &#x3D; [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: prices &#x3D; [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e., max profit &#x3D; 0. 1234567891011121314151617181920212223242526// 这题交易次数不限// 状态有两个 [天数] 和 [是否持有股票]// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润// 如果在第 i 天没有持有股票, 有两种可能// 1. 前一天持有股票, 当天将股票卖出了// 2. 前一天没有持有股票, 当天也没买进// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])// 如果在第 i 天持有股票, 有两种可能// 1. 前一天持有股票, 当天没有卖出// 2. 前一天没有持有股票, 当天买进股票// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1])// 我们的目标是求 dp[n][0]// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)int maxProfit(vector&lt;int&gt;&amp; prices)&#123; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2)); dp[0][1] = INT_MIN; for(int i = 1; i &lt;= n; i++) &#123; dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1]); &#125; return dp[n][0];&#125; 123. Best Time to Buy and Sell Stock III 给定一个数组，它的第i个元素是一支给定的股票在第i天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 Example 1: 1234Input: prices &#x3D; [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3. Example 2: 1234Input: prices &#x3D; [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: prices &#x3D; [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0. Example 4: 12Input: prices &#x3D; [1]Output: 0 1234567891011121314151617181920// 这题就是下一题 k = 2 的情形int maxProfit(vector&lt;int&gt;&amp; prices)&#123; int k = 2; int n = prices.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;int&gt;&gt;(k + 1, vector&lt;int&gt;(2))); for(int i = 1; i &lt;= n; i++) dp[i][0][1] = INT_MIN; for(int j = 1; j &lt;= k; j++) dp[0][j][1] = INT_MIN; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) &#123; dp[i][j][0] = max(dp[i - 1][j][1] + prices[i - 1], dp[i - 1][j][0]); dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1]); &#125; &#125; return dp[n][k][0];&#125; 188. Best Time to Buy and Sell Stock IV 给定一个整数数组prices，它的第i个元素prices[i]是一支给定的股票在第i天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成k笔交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 Example 1: 123Input: k &#x3D; 2, prices &#x3D; [2,4,1]Output: 2Explanation: Buy on day 1 (price &#x3D; 2) and sell on day 2 (price &#x3D; 4), profit &#x3D; 4-2 &#x3D; 2. Example 2: 123Input: k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]Output: 7Explanation: Buy on day 2 (price &#x3D; 2) and sell on day 3 (price &#x3D; 6), profit &#x3D; 6-2 &#x3D; 4. Then buy on day 5 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3. 123456789101112131415161718192021222324252627282930313233// 这题我们最多可以完成 k 笔交易// 所以有三个状态 [天数], [交易次数] 和 [是否持有股票]// dp[i][j][0] 表示第 i 天没有持有股票, 交易次数为 j 时获得的全部利润// dp[i][j][1] 表示第 i 天持有股票, 交易次数为 j 时获得的全部利润// 如果在第 i 天没有持有股票, 有两种可能// 1. 前一天持有股票, 当天将股票卖出了// 2. 前一天没有持有股票, 当天也没买进// dp[i][j][0] = max(dp[i - 1][j][1] + prices[i - 1], dp[i - 1][j][0])// 如果在第 i 天持有股票, 有两种可能// 1. 前一天持有股票, 当天没有卖出// 2. 前一天没有持有股票, 当天买进股票 (买进的时候交易次数加 1)// dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1])// 我们的目标是求 dp[n][k][0]// 当 i == 0 时, dp[0][j][0] = 0, dp[0][j][1] = INT_MIN (表示不可能)// 当 j == 0 时, dp[i][0][0] = 0, dp[i][0][1] = INT_MIN (表示不可能)int maxProfit(int k, vector&lt;int&gt;&amp; prices)&#123; int n = prices.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;int&gt;&gt;(k + 1, vector&lt;int&gt;(2))); for(int i = 1; i &lt;= n; i++) dp[i][0][1] = INT_MIN; for(int j = 1; j &lt;= k; j++) dp[0][j][1] = INT_MIN; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) &#123; dp[i][j][0] = max(dp[i - 1][j][1] + prices[i - 1], dp[i - 1][j][0]); dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1]); &#125; &#125; return dp[n][k][0];&#125; 309. Best Time to Buy and Sell Stock with Cooldown 给定一个整数数组，其中第i个元素代表了第i天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为1天)。 Example 1: 123Input: prices &#x3D; [1,2,3,0,2]Output: 3Explanation: transactions &#x3D; [buy, sell, cooldown, buy, sell] Example 2: 12Input: prices &#x3D; [1]Output: 0 1234567891011121314151617181920212223242526272829// 这题交易次数不限, 但是有冷冻期, 因此买进的时候需要看大前天的状态// 状态有两个 [天数] 和 [是否持有股票]// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润// 如果在第 i 天没有持有股票, 有两种可能// 1. 前一天持有股票, 当天将股票卖出了// 2. 前一天没有持有股票, 当天也没买进// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])// 如果在第 i 天持有股票, 有两种可能// 1. 前一天持有股票, 当天没有卖出// 2. 只能大前天没有持有股票且没有卖出股票, 当天才能买进股票// dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i - 1])// 我们的目标是求 dp[n][0]// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)// 当 i == 1 时, dp[1][0] = 0, dp[1][1] = -prices[0]int maxProfit(vector&lt;int&gt;&amp; prices)&#123; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2)); dp[0][1] = INT_MIN; dp[1][1] = -prices[0]; // 第 1 天的情况已经知道了, 直接从第 2 天开始 for(int i = 2; i &lt;= n; i++) &#123; dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0]); dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i - 1]); &#125; return dp[n][0];&#125; 714. Best Time to Buy and Sell Stock with Transaction Fee 给定一个数组prices，其中prices[i]是一支给定股票第i天的价格。非负整数fee表示交易一次股票需要支付的费用。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 123456789101112131415161718192021222324252627// 这题交易次数不限// 状态有两个 [天数] 和 [是否持有股票]// dp[i][0] 表示当前在第 i 天没有持有股票时获得的全部利润// dp[i][1] 表示当前在第 i 天持有股票时获得的全部利润// 如果在第 i 天没有持有股票, 有两种可能// 1. 前一天持有股票, 当天将股票卖出了// 2. 前一天没有持有股票, 当天也没买进// dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0])// 如果在第 i 天持有股票, 有两种可能// 1. 前一天持有股票, 当天没有卖出// 2. 前一天没有持有股票, 当天买进股票// 这里选择买进股票时支付手续费, 相当于买进价格升高了呗// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1] - fee)// 我们的目标是求 dp[n][0]// 当 i == 0 时, dp[0][0] = 0, dp[0][1] = INT_MIN (表示不可能)int maxProfit(vector&lt;int&gt;&amp; prices, int fee)&#123; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2)); dp[0][1] = INT_MIN; for(int i = 1; i &lt;= n; i++) &#123; dp[i][0] = max(dp[i - 1][1] + prices[i - 1], dp[i - 1][0]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1] - fee); &#125; return dp[n][0];&#125; 377. Combination Sum IV 给你一个由不同整数组成的数组nums，和一个目标整数target。请你从nums中找出并返回总和为target的元素组合的个数。 题目数据保证答案符合32位整数范围。 示例 1： 123456789101112输入：nums &#x3D; [1,2,3], target &#x3D; 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。（这特么就是排列呀！！！） 示例 2： 12输入：nums &#x3D; [9], target &#x3D; 3输出：0 12345678910111213141516171819vector&lt;int&gt; memo;int combinationSum4(vector&lt;int&gt;&amp; nums, int target)&#123; memo.resize(target + 1, -1); return dfs(nums, target);&#125;// 函数的定义为凑够和为 target 的组合数int dfs(vector&lt;int&gt;&amp; nums, int target)&#123; if(target &lt; 0) return 0; if(target == 0) return 1; if(memo[target] != -1) return memo[target]; int res = 0; for(int num : nums) res += dfs(nums, target - num); memo[target] = res; return res;&#125; 1234567891011121314151617181920212223242526272829303132// 这题其实并不是组合问题, 而是排列问题// 组合不关注元素顺序, 排列才关注元素顺序, 而这题关注元素的顺序!// 状态有 [排列和 target]// dp[i] 表示组合的和等于 i 时的不同组合个数// 我们的目标是求 dp[target]// 如果我们考虑将 nums[j] 加入组合中去, 并且放在最后的位置// [[也就是关注排列中的最后一个数是多少]]// 那么此时 dp[i] 就等于所有的 dp[i - nums[j]] (j = 0, ...) 之和// dp[0] = 1 表示 1 种空组合int combinationSum4(vector&lt;int&gt;&amp; nums, int target)&#123; vector&lt;int&gt; dp(target + 1); dp[0] = 1; for(int i = 0; i &lt;= target; i++) for(int num : nums) // dp[i] + dp[i - num] 有可能溢出, 这里为了清晰起见没有考虑 if(i - num &gt;= 0) dp[i] += dp[i - num]; return dp[target];&#125;// 这题还可以将其看作一个爬楼梯问题// 楼梯的阶数一共为 target, 一次可以走的步数为 nums[i]// 问你一共有多少种走法 (相当于登上最高阶所走步数的所有排列)// [[只要关注最后一步走多少阶数就容易写出状态转移方程了]]// 还可以看作是完全背包问题// 背包的容量为 target, 有物品 nums[i] 可以无限选取// 并且相同的物品选择, 物品选取的顺序不同算是不同的选择// 问你把背包装满有多少种方法// 这题为了考虑不同的顺序, 因此外循环遍历背包的容量, 内循环遍历物品// 对于下题 [换零钱 2] 由于顺序不同也算一种选择, 就要外循环遍历物品, 内循环遍历背包的容量 322. Coin Change 给定不同面额的硬币coins和一个总金额amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。 你可以认为每种硬币的数量是无限的。 Constraints: 1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 231 - 1 0 &lt;= amount &lt;= 10^4 Example 1: 123Input: coins &#x3D; [1,2,5], amount &#x3D; 11Output: 3Explanation: 11 &#x3D; 5 + 5 + 1 Example 2: 12Input: coins &#x3D; [2], amount &#x3D; 3Output: -1 123456789101112131415161718// 状态只有 金额数// 选择有若干枚硬币// 定义 dp[i] 表示凑够金额 i 元的最少硬币数// dp[i] = min(dp[i - k] + 1) k 为每种硬币的面值// 目标是求 dp[amount]// 显然 dp[0] = 0 就是不用任何面值的硬币就凑够了int coinChange(vector&lt;int&gt;&amp; coins, int amount)&#123; // 数组中每个值初始化为 amount + 1 表示不可能 // 因为只使用 1 元硬币最多也就需要 amount 个硬币 vector&lt;int&gt; dp(amount + 1, amount + 1); dp[0] = 0; for(int i = 1; i &lt;= amount; i++) for(int coin : coins) if(i &gt;= coin) dp[i] = min(dp[i], dp[i - coin] + 1); return dp[amount] == amount + 1 ? -1 : dp[amount];&#125; 12345678910111213141516171819202122232425262728293031// 也可以看成是一个完全背包问题// 状态有 [使用的硬币] 和 [凑成的总金额]// 定义 dp[i][j] 表示只使用前 i 个硬币凑成金额为 j 时的最少硬币数// 对于第 i 枚硬币有使用和不使用两种选择// 如果不使用// dp[i][j] = dp[i - 1][j] 继承之前的硬币数// 如果使用// dp[i][j] = dp[i][j - coins[i - 1]] + 1// 表示只使用前 i 种硬币凑够 j - coins[i - 1] 的硬币数, 再加上使用的这枚硬币// 因为要求最少的硬币数, 这两种选择的结果取小值// 所以 dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1);// 显然 j == 0 时 dp[i][0] = 0 就是不凑就够了, 数量为 0int coinChange(vector&lt;int&gt;&amp; coins, int amount)&#123; int n = coins.size(); // 都初始化为 amount + 1 表示不可能的结果, min 时会排除掉 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(amount + 1, amount + 1)); for(int i = 0; i &lt;= n; i++) dp[i][0] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= amount; j++) &#123; if(j &gt;= coins[i - 1]) dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1); else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[n][amount] == amount + 1 ? -1 : dp[n][amount];&#125; 518. Coin Change 2 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 Constraints: 1 &lt;= coins.size() &lt;= 300 1 &lt;= coins[i] &lt;= 5000 0 &lt;= amount &lt;= 5000 Example 1: 1234567Input: amount &#x3D; 5, coins &#x3D; [1,2,5]Output: 4Explanation: there are four ways to make up the amount:5 &#x3D; 55 &#x3D; 2 + 2 + 15 &#x3D; 2 + 1 + 1 + 15 &#x3D; 1 + 1 + 1 + 1 + 1 Example 2: 123Input: amount &#x3D; 3, coins &#x3D; [2]Output: 0Explanation: the amount of 3 cannot be made up just with coins of 2. 123456789101112131415161718192021222324252627282930// 完全背包问题// 状态有 [使用的硬币] 和 [凑成的总金额]// 定义 dp[i][j] 表示只使用前 i 个硬币凑成金额为 j 时的组合数// 对于第 i 枚硬币有使用和不使用两种选择// 如果不使用// dp[i][j] = dp[i - 1][j] 继承之前的组合数// 如果使用// dp[i][j] = dp[i][j - coins[i - 1]] 表示使用前 i 种硬币凑够 j - coins[i - 1] 的组合数// 因为要求总的组合数, 这两种选择的结果相加// 所以 dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]// 显然 i == 0 时 dp[0][j] = 0 不使用任何硬币// j == 0 时 dp[i][0] = 1 就是不凑就够了int change(int amount, vector&lt;int&gt;&amp; coins)&#123; int n = coins.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(amount + 1)); for(int i = 0; i &lt;= n; i++) dp[i][0] = 1; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= amount; j++) &#123; if(j &gt;= coins[i - 1]) dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[n][amount];&#125; 474. Ones and Zeroes 给你一个二进制字符串数组strs和两个整数m和n。 请你找出并返回strs的最大子集的大小，该子集中最多有m个0和n个1。 如果x的所有元素也是y的元素，集合x是集合y的子集 。 Example 1: 12345Input: strs &#x3D; [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m &#x3D; 5, n &#x3D; 3Output: 4Explanation: The largest subset with at most 5 0&#39;s and 3 1&#39;s is &#123;&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, so the answer is 4.Other valid but smaller subsets include &#123;&quot;0001&quot;, &quot;1&quot;&#125; and &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;.&#123;&quot;111001&quot;&#125; is an invalid subset because it contains 4 1&#39;s, greater than the maximum of 3. Example 2: 123Input: strs &#x3D; [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m &#x3D; 1, n &#x3D; 1Output: 2Explanation: The largest subset is &#123;&quot;0&quot;, &quot;1&quot;&#125;, so the answer is 2. Constraints: 1 &lt;= strs.length &lt;= 600 1 &lt;= strs[i].length &lt;= 100 strs[i] consists only of digits &#39;0&#39; and &#39;1&#39;. 1 &lt;= m, n &lt;= 100 12345678910111213141516171819202122232425262728293031323334353637383940414243// 01背包问题// 这里有两个背包, 一个装 0, 一个装 1// 每个物品(串)同时消耗两个背包的容量, 每个物品的价值为 1// 状态有 [可选择的物品], [背包 0 的容量] 和 [背包 1 的容量]// 定义 dp[i][j][k] 表示只装前 i 个物品, 背包 0 和 1 的容量分别为 j 和 k 时所能装的最大价值// 对于第 i 个物品 strs[i - 1] 你的选择就是装与不装// 1. 不装// dp[i][j][k] = dp[i - 1][j][k]// 2. 装// dp[i][j][k] = dp[i - 1][j - cost_0(strs[i - 1])][k - cost_1(strs[i - 1])]// 因为要求的是最大价值, 那就比较两种选择孰大孰小// dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - cost_0(strs[i - 1])][k - cost_1(strs[i - 1])])// 显然当 i == 0 时, dp[0][j][k] = 0, 没有物品可以装, 价值只能是 0// j == 0 || k == 0 时, dp[0][j][k] = 0, 背包没有容量了价值也是 0// 我们的目标是求 dp[sz][m][n]int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n)&#123; int sz = strs.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(sz + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(n + 1))); for(int i = 1; i &lt;= sz; i++) &#123; auto [zeros, ones] = count_01(strs[i - 1]); // 注意 j 和 k 的起始索引, 有可能物品只消耗其中一种背包的容量 for(int j = 0; j &lt;= m; j++) &#123; for(int k = 0; k &lt;= n; k++) &#123; if(j &lt; zeros || k &lt; ones) dp[i][j][k] = dp[i - 1][j][k]; else dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1); &#125; &#125; &#125; return dp[sz][m][n];&#125;pair&lt;int, int&gt; count_01(const string&amp; str)&#123; int cnt = 0, n = str.size(); for(char c : str) if(c == '0') cnt++; return &#123;cnt, n - cnt&#125;;&#125; 139. Word Break 给定一个非空字符串s和一个包含非空单词的列表wordDict，判定s是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 Example 1: 123Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;,&quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. Example 2: 1234Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.Note that you are allowed to reuse a dictionary word. Example 3: 12Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]Output: false 1234567891011121314151617181920212223// 和背包问题有点类似, 但有不同之处// 状态有 [可选择的字符]// 定义 dp[i] 表示对于前 i 个字符是否有满足条件的划分// 和背包之处不同在于, 对于第 i 个字符 s[i - 1] 只有一个选择, 就是必须选择// 这时我们需要将前 i 个字符用索引 j 划分为两部分// 对于前半部分 s[0..j-1] 可以利用已经算出来的 dp[j]// 后半部分 s[j..i-1] 需要单独判断是否在单词集合中// 所以 dp[i] = dp[i] || (dp[j] &amp;&amp; (s[j..i-1] in wordDict)) j 从 0 到 i - 1// 我们的目标是求 dp[n]bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123; unordered_set&lt;string&gt; setting; setting.insert(wordDict.begin(), wordDict.end()); int n = s.size(); vector&lt;bool&gt; dp(n + 1); // 为了需要, 我们定义空串是有效的 dp[0] = true; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt; i; j++) dp[i] = dp[i] || (dp[j] &amp;&amp; setting.count(s.substr(j, i - j))); return dp[n];&#125; 12345678910111213141516171819// 记忆化递归unordered_map&lt;string, bool&gt; memo;bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123; unordered_set&lt;string&gt; setting; setting.insert(wordDict.begin(), wordDict.end()); return dfs(s, setting);&#125;bool dfs(string s, unordered_set&lt;string&gt;&amp; setting)&#123; if(s.empty()) return true; if(memo.count(s)) return memo[s]; int n = s.size(); for(int i = 1; i &lt;= n; i++) if(setting.count(s.substr(0, i)) &amp;&amp; dfs(s.substr(i), setting)) return memo[s] = true; return memo[s] = false;&#125; 140. Word Break II 给定一个非空字符串s和一个包含非空单词列表的字典wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。 说明： 分隔时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 1 &lt;= s.size() &lt;= 20 Example 1: 12Input: s &#x3D; &quot;catsanddog&quot;, wordDict &#x3D; [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]Output: [&quot;cats and dog&quot;,&quot;cat sand dog&quot;] Example 2: 123Input: s &#x3D; &quot;pineapplepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]Output: [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]Explanation: Note that you are allowed to reuse a dictionary word. Example 3: 12Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]Output: [] 1234567891011121314151617181920212223242526// 回溯vector&lt;string&gt; sentences;vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict)&#123; unordered_set&lt;string&gt; setting; setting.insert(wordDict.begin(), wordDict.end()); dfs(s, \"\", setting); return sentences;&#125;void dfs(string s, string sentence, unordered_set&lt;string&gt;&amp; setting)&#123; if(s.empty()) &#123; sentence.pop_back(); sentences.push_back(sentence); return; &#125; int n = s.size(); for(int i = 1; i &lt;= n; i++) &#123; if(!setting.count(s.substr(0, i))) continue; dfs(s.substr(i), sentence + s.substr(0, i) + \" \", setting); &#125;&#125; 416. Partition Equal Subset Sum Given a non-empty array num containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Example 1: 123Input: nums &#x3D; [1,5,11,5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: 123Input: nums &#x3D; [1,2,3,5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets. Constraints: 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 12345678910111213141516171819202122232425262728293031323334353637383940// 转化为背包问题进行求解// 我们把数组分成两部分// 1. sumA = sumB// 2. sumA + sumB = sum// 所以有 sumA = sum / 2// 也就是说现在有一个背包的容量恰好是 sum / 2// 问我们是否有一种装法恰好装满背包// 背包问题的状态一般就两个 [可选择的物品] 和 [背包的容量]// 所以我们定义 dp[i][j] 表示使用前 i 个物品, 背包容量为 j 时是否有一种装法给装满// 对于第 i 个物品 nums[i - 1] 可以选择装进去和不装进去// 1. 不装 就要看前 i - 1 个物品能不能装满容量为 j 的背包// dp[i][j] = dp[i - 1][j]// 2. 装 就要看前 i - 1 个物品能不能装满容量为 j - nums[i - 1] 的背包// dp[i][j] = dp[i - 1][j - nums[i - 1]]// 这两种任意一种选择为真的话, 就为真// 所以 dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]// 我们的目标是求 dp[n][sum/2]// 显然 i == 0 时, dp[0][j] = false, 没有物品装肯定装不满// j == 0 时, dp[i][0] = true, 容量为 0 了就是装满了啊bool canPartition(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); int sum = accumulate(nums.begin(), nums.end(), 0); // 如果 sum 为奇数, 显然不可能 if(sum &amp; 1) return false; vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(sum/2 + 1)); for(int i = 0; i &lt;= n; i++) dp[i][0] = true; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= sum/2; j++) &#123; if(j &lt; nums[i - 1]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]; &#125; &#125; return dp[n][sum/2];&#125; 698. Partition to K Equal Sum Subsets 给定一个整数数组nums和一个正整数k，找出是否有可能把这个数组分成k个非空子集，其总和都相等。 Example 1: 123Input: nums &#x3D; [4,3,2,3,5,2,1], k &#x3D; 4Output: trueExplanation: It&#39;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Example 2: 12Input: nums &#x3D; [1,2,3,4], k &#x3D; 3Output: false Constraints: 1 &lt;= k &lt;= nums.length &lt;= 16 0 &lt;= nums[i] &lt;= 104 1234567891011121314151617181920212223242526272829303132333435// 其实上题 416(k = 2) 以及 473(k = 4) 都是这题的特例// 这题很容易超时, 为了尽可能地剪枝我额外做的工作// 1. 降序排序, 到大于的时候直接 continue// 2. 去重，相邻元素必须从左往右被使用// 3. 索引从 start 开始int targetSum;vector&lt;bool&gt; used;bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k)&#123; int total = accumulate(nums.begin(), nums.end(), 0); if(total % k &gt; 0) return false; used.resize(nums.size()); targetSum = total / k; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); return canPartitionKSubsets(nums, k, 0, 0);&#125;bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k, int start, int curSum)&#123; if(k == 0) return true; if(curSum == targetSum) return canPartitionKSubsets(nums, k - 1, 0, 0); for(int i = start; i &lt; nums.size(); i++) &#123; // 剪枝 1 if(curSum + nums[i] &gt; targetSum) continue; // 剪枝 2 if(used[i] || (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !used[i - 1])) continue; used[i] = true; if(canPartitionKSubsets(nums, k, start + 1, curSum + nums[i])) return true; used[i] = false; &#125; return false;&#125; 55. Jump Game 给定一个非负整数数组nums，你最初位于数组的第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。 Example 1: 123Input: nums &#x3D; [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 123Input: nums &#x3D; [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints: 1 &lt;= nums.length &lt;= 3 * 104 0 &lt;= nums[i] &lt;= 105 123456789101112// 也就是问你最多能跳多远bool canJump(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); int farthest = 0; for(int i = 0; i &lt; n - 1; i++) &#123; farthest = max(farthest, i + nums[i]); if(i == farthest) return false; &#125; return true;&#125; 45. Jump Game II 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。 Example 1: 123Input: nums &#x3D; [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 12Input: nums &#x3D; [2,3,0,1,4]Output: 2 1234567891011121314// 动态规划// 定义 dp[i] 表示从索引 i 开始跳, 跳到最后需要跳的最少次数// 显然 dp[n - 1] = 0, 我们要求的是 dp[0]// dp[i] = 1 + min(dp[j]) j = i .. (i + nums[i])int jump(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); vector&lt;int&gt; dp(n, n); dp[n - 1] = 0; for(int i = n - 2; i &gt;= 0; i--) for(int j = 1; j &lt;= nums[i] &amp;&amp; i + j &lt; n; j++) dp[i] = min(dp[i], 1 + dp[i + j]); return dp[0];&#125; 索引 2 的覆盖范围最远 就以其最远索引作为下次起跳的位置 1234567891011121314151617// 贪心, 优先跳到下次能跳最远的索引int jump(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); int farthest = 0, end = 0; int jumps = 0; for(int i = 0; i &lt; n - 1; i++) &#123; farthest = max(farthest, i + nums[i]); if(i == end) &#123; jumps++; end = farthest; &#125; &#125; return jumps;&#125; 1306. Jump Game III 这里有一个非负整数数组arr，你最开始位于该数组的起始下标start处。当你位于下标i处时，你可以跳到i + arr[i]或者i - arr[i]。请你判断自己是否能够跳到对应元素值为0的任一下标处。注意，不管是什么情况下，你都无法跳到数组之外。 Example 1: 123456Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 5Output: trueExplanation: All possible ways to reach at index 3 with value 0 are: index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3 index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3 Example 2: 12345Input: arr &#x3D; [4,2,3,0,3,1,2], start &#x3D; 0Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3 Example 3: 123Input: arr &#x3D; [3,0,2,1,2], start &#x3D; 2Output: falseExplanation: There is no way to reach at index 1 with value 0. Constraints: 0 &lt;= start &lt; arr.length 1234567891011121314151617181920// bfsbool canReach(vector&lt;int&gt;&amp; arr, int start) &#123; int n = arr.size(); vector&lt;bool&gt; visited(n); queue&lt;int&gt; q; q.push(start); while(!q.empty()) &#123; int pos = q.front(); q.pop(); if(visited[pos]) continue; visited[pos] = true; if(arr[pos] == 0) return true; if(pos + arr[pos] &lt; n) q.push(pos + arr[pos]); if(pos - arr[pos] &gt;= 0) q.push(pos - arr[pos]); &#125; return false;&#125; 1234567891011121314151617181920// dfsbool canReach(vector&lt;int&gt;&amp; arr, int start)&#123; vector&lt;bool&gt; visited(arr.size()); return canReach(arr, start, visited);&#125;bool canReach(vector&lt;int&gt;&amp; arr, int start, vector&lt;bool&gt;&amp; visited)&#123; if(start &lt; 0 || start &gt;= arr.size() || visited[start]) return false; if(arr[start] == 0) return true; visited[start] = true; if(canReach(arr, start - arr[start], visited)) return true; if(canReach(arr, start + arr[start], visited)) return true; visited[start] = false; return false;&#125; 1345. Jump Game IV 给你一个整数数组arr，你一开始在数组的第一个元素处（下标为0）。每一步，你可以从下标i跳到下标： i + 1满足：i + 1 &lt; arr.length i - 1满足：i - 1 &gt;= 0 j满足：arr[i] == arr[j]且i != j 请你返回到达数组最后一个元素的下标处所需的最少操作次数。 注意：任何时候你都不能跳到数组外面。 Example 1: 123Input: arr &#x3D; [100,-23,-23,404,100,23,23,23,3,404]Output: 3Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array. Example 2: 123Input: arr &#x3D; [7]Output: 0Explanation: Start index is the last index. You don&#39;t need to jump. Example 3: 123Input: arr &#x3D; [7,6,9,6,9,6,9,7]Output: 1Explanation: You can jump directly from index 0 to index 7 which is last index of the array. Example 4: 12Input: arr &#x3D; [6,1,9]Output: 2 Example 5: 12Input: arr &#x3D; [11,22,7,7,7,7,7,7,7,22,13]Output: 3 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 搜索最短路径显然用 bfsint minJumps(vector&lt;int&gt;&amp; arr)&#123; int n = arr.size(); vector&lt;bool&gt; visited(n); unordered_map&lt;int, vector&lt;int&gt;&gt; canJumpTo; for(int i = 0; i &lt; n; i++) canJumpTo[arr[i]].push_back(i); queue&lt;int&gt; q; q.push(0); int step = 0; while(!q.empty()) &#123; int sz = q.size(); while(sz-- &gt; 0) &#123; int pos = q.front(); q.pop(); if(pos == n - 1) return step; visited[pos] = true; if(pos - 1 &gt;= 0 &amp;&amp; !visited[pos - 1]) q.push(pos - 1); if(pos + 1 &lt; n &amp;&amp; !visited[pos + 1]) q.push(pos + 1); for(auto jumpTo : canJumpTo[arr[pos]]) if(!visited[jumpTo]) q.push(jumpTo); // 同一高度的都已经放入队列等待访问了, 下次就不用再放一次了 // 必须清空, 否则会 TLE canJumpTo[arr[pos]] = &#123;&#125;; &#125; step++; &#125; return 0;&#125;// 这题遇到一个新情况, 把 unordered_map&lt;int, vector&lt;int&gt;&gt; canJumpTo;// 里的 vector&lt;int&gt; 换成 unordered_set&lt;int&gt;// 把清空语句 canJumpTo[arr[pos]] = &#123;&#125;; 变成// canJumpTo[arr[pos]].clear(); 会超时, 但用 swap 函数就不会// unordered_set&lt;int&gt; temp; canJumpTo[arr[pos]]swap(temp);// 奇了怪了! 403. Frog Jump 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。 给你石子的位置列表stones（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。 开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。 如果青蛙上一步跳跃了k个单位，那么它接下来的跳跃距离只能选择为k - 1、k或k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。 Example 1: 123Input: stones &#x3D; [0,1,3,5,6,8,12,17]Output: trueExplanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone. Example 2: 123Input: stones &#x3D; [0,1,2,3,4,8,9,11]Output: falseExplanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large. Constraints: 2 &lt;= stones.length &lt;= 2000 0 &lt;= stones[i] &lt;= 231 - 1 stones[0] == 0 12345678910111213141516171819202122232425// 记忆化搜索unordered_map&lt;string, bool&gt; memo;bool canCross(vector&lt;int&gt;&amp; stones)&#123; return dfs(stones, 0, 0);&#125;bool dfs(vector&lt;int&gt; &amp;stones, int pos, int lastJump)&#123; if(pos + 1 == stones.size()) return true; string key = to_string(pos) + \",\" + to_string(lastJump); if(memo.count(key)) return memo[key]; for(int i = pos + 1; i &lt; stones.size(); i++) &#123; // k 是下一次必须跳的步数 int k = stones[i] - stones[pos]; if(k &lt; lastJump - 1) continue; if(k &gt; lastJump + 1) return memo[key] = false; if(dfs(stones, i, k)) return memo[key] = true; &#125; return memo[key] = false;&#125; 123456789101112131415161718192021222324// 动态规划// dp[i][j] 表示是否可以用 j 步 跳到 第 i 块石头上bool canCross(vector&lt;int&gt;&amp; stones)&#123; int n = stones.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n)); dp[0][0] = true; for(int i = 1; i &lt; n; i++) &#123; for(int j = i - 1; j &gt;= 0; j--) &#123; int k = stones[i] - stones[j]; // k 是每次跳的步数, 每跳 1 次下次最多加 1 步 // 但是升序数组的索引 j 每次至少会加 1 所以 k &lt;= j // 在第 j 块石头时，再次起跳距离最大为 j + 1 // 如果和后一块石头的距离大于最大起跳距离, 就不可能跳过去 if(k &gt; j + 1) break; dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1]; if(dp[n - 1][k]) return true; &#125; &#125; return false;&#125; 10. Regular Expression Matching 给你一个字符串s和一个模式串p，请你来实现一个支持&#39;.&#39;和&#39;*&#39;的正则表达式匹配。 &#39;.&#39;匹配任意单个字符 &#39;*&#39;匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。 Example 1: 123Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 123Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a*&quot;Output: trueExplanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;. Example 3: 123Input: s &#x3D; &quot;ab&quot;, p &#x3D; &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 123Input: s &#x3D; &quot;aab&quot;, p &#x3D; &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;. Example 5: 12Input: s &#x3D; &quot;mississippi&quot;, p &#x3D; &quot;mis*is*p*.&quot;Output: false Constraints: 0 &lt;= s.length &lt;= 20 0 &lt;= p.length &lt;= 30 s contains only lowercase English letters. p contains only lowercase English letters, &#39;.&#39;, and &#39;*&#39;. It is guaranteed for each appearance of the character &#39;*&#39;, there will be a previous valid character to match. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 动态规划// dp[i][j] 表示 s 的前 i 个字符是否和 p 的前 j 个字符相匹配// 显然我们的目标是求 dp[n][m]// 1. 当 p 中的第 j 个字符 p[j - 1] != '*' 时// p[j - 1] 只能选择和 s[i - 1] 进行匹配// 所以 dp[i][j] = dp[i - 1][j - 1] if s[i - 1] == p[j - 1] or p[j - 1] == '.'// dp[i][j] = false if s[i - 1] != p[j - 1] and p[j - 1] != '.'// 2. 当 p 中的第 j 个字符 p[j - 1] == '*' 时// p[j - 2] 和 '*' 就组合在一起看// 2.1 匹配 0 次// dp[i][j] = dp[i][j - 2] 不管 p[j - 2] 是否匹配 s[i - 1]// 2.1 匹配多次// dp[i][j] = dp[i - 1][j] if s[i - 1] == p[j - 2] or p[j - 2] == '.'// 两个空串默认可以匹配 dp[0][0] = true// 但是这题要特别注意的是, 当 s 为空串时, p 为空串的情况可以是// \"\", \"c*\", \"c*c*\", ... 它们都应该为 truebool isMatch(string s, string p)&#123; int n = s.size(), m = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1)); dp[0][0] = true; // 特别处理 p 为 c*c*... 的情况 for(int j = 1; j &lt;= m; j++) if(p[j - 1] == '*') dp[0][j] = dp[0][j - 2]; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; // 1. 当 p 中的第 j 个字符 p[j - 1] != '*' 时 if(p[j - 1] != '*') &#123; if(s[i - 1] == p[j - 1] || p[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1]; // else // dp[i][j] = false; &#125; // 2. 当 p 中的第 j 个字符 p[j - 1] == '*' 时 else &#123; // 2.1 匹配 0 次 dp[i][j] = dp[i][j - 2]; // 2.1 匹配多次 if(s[i - 1] == p[j - 2] || p[j - 2] == '.') dp[i][j] = dp[i][j] || dp[i - 1][j]; &#125; &#125; &#125; return dp[n][m];&#125; 312. Burst Balloons 有n个气球，编号为0到n - 1，每个气球上都标有一个数字，这些数字存在数组nums中。 现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1]枚硬币。这里的i - 1和i + 1代表和i相邻的两个气球的序号。如果i - 1或i + 1超出了数组的边界，那么就当它是一个数字为1的气球。 求所能获得硬币的最大数量。 Example 1: 12345Input: nums &#x3D; [3,1,5,8]Output: 167Explanation:nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins &#x3D; 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &#x3D; 167 Example 2: 12Input: nums &#x3D; [1,5]Output: 10 Constraints: n == nums.length 1 &lt;= n &lt;= 500 0 &lt;= nums[i] &lt;= 100 123456789101112131415161718192021// 动态规划// 定义 dp[i][j] 表示将第 i 个气球和第 j 个气球(左右开区间)之间的气球戳破最多得到的硬币数// 显然我们是要求 dp[0][n+1]// 对于第 i 个气球和第 j 个气球之间的所有气球, 我们考虑最后戳破的那一个气球 k// 于是可得 dp[i][j] = dp[i][k] + dp[k][j] + nums[i - 1] * nums[k - 1] * nums[j - 1]// 因为我们要求最大得到的硬币数量, 就对每一个 k 分别计算, 取最大呗// 当 (i, j) 区间内没有气球时得分显然是 0, 即当 i &gt;= j 时 dp[i][j] = 0int maxCoins(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); // 考虑到边界条件, 在最左最右各放两个虚拟气球 nums.insert(nums.begin(), 1); nums.insert(nums.end(), 1); vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2)); for(int i = n; i &gt;= 0; i--) for(int j = i + 1; j &lt; n + 2; j++) for(int k = i + 1; k &lt; j; k++) dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]); return dp[0][n+1];&#125; 887. Super Egg Drop 给你k枚相同的鸡蛋，并可以使用一栋从第1层到第n层共有n层楼的建筑。 已知存在楼层f，满足0 &lt;= f &lt;= n，任何从高于f的楼层落下的鸡蛋都会碎，从f楼层或比它低的楼层落下的鸡蛋都不会破。 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层x扔下（满足1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中重复使用这枚鸡蛋。 请你计算并返回要确定f确切的值的最坏情况下的最小尝试次数？ Example 1: 1234567Input: k &#x3D; 1, n &#x3D; 2Output: 2Explanation: Drop the egg from floor 1. If it breaks, we know that f &#x3D; 0.Otherwise, drop the egg from floor 2. If it breaks, we know that f &#x3D; 1.If it does not break, then we know f &#x3D; 2.Hence, we need at minimum 2 moves to determine with certainty what the value of f is. Example 2: 12Input: k &#x3D; 2, n &#x3D; 6Output: 3 Example 3: 12Input: k &#x3D; 3, n &#x3D; 14Output: 4 Constraints: 1 &lt;= k &lt;= 100 1 &lt;= n &lt;= 104 12345678910111213141516171819202122232425262728293031323334// 记忆化递归 TLE!// 定义 dp(k, n) 表示有 k 个鸡蛋和 n 层楼时的最坏情况下的最少尝试次数// 对于从第 1 层到第 n 层中间的某一层 i, 我们扔完之后有两种情况// 1. 鸡蛋没碎// 这时我们要寻找的楼层 f 显然在第 i + 1 层到第 n 层之间的共 n - i 层楼// 于是问题规模缩小至 dp(k, n - i)// 2. 鸡蛋碎了// 这时我们要寻找的楼层 f 显然在第 1 层到第 i - 1 层之间的共 i - 1 层楼// 于是问题规模缩小至 dp(k - 1, i - 1)// 因为我们要求最坏情况下的最少尝试次数, 什么叫最坏情况下呢？// 就是说我们并不知道扔完之后鸡蛋碎不碎, 我们要考虑碎或者不碎时的最多尝试次数// 什么是最少尝试次数呢？就是说我们从第 1 层, 第 2 层...第 n 层依次试一遍, 取最小值// 所以 dp(k, n) = min(max(dp(k, n - i), dp(k - 1, i - 1))) for x in 1...n// 当 n == 0 时, 不用扔就可以确定, dp(k, 1) = 0// 当 n == 1 时, 显然至多至少都是要扔 1 次, dp(k, 1) = 1// 当 k == 1 时, 显然需要从 1 到 n 一层一层尝试 dp(1, n) = nint superEggDrop(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; memo(k + 1, vector&lt;int&gt;(n + 1, -1)); return dp(k, n, memo);&#125;int dp(int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; memo) &#123; if(k == 1 || n == 0) &#123; return n; &#125; if(memo[k][n] != -1) &#123; return memo[k][n]; &#125; int res = INT_MAX; for(int i = 1; i &lt;= n; i++) &#123; res = min(res, 1 + max(dp(k, n - i, memo), dp(k - 1, i - 1, memo))); &#125; return memo[k][n] = res;&#125; 12345678910111213141516171819202122232425262728293031323334353637// 记忆化递归 + 二分搜索优化 AC!int superEggDrop(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; memo(k + 1, vector&lt;int&gt;(n + 1, -1)); return dp(k, n, memo);&#125;// 对于 dp(k, n) 我们观察到 这是一个关于 n 的单调递增函数// 也就是说在鸡蛋数固定的情况下, 楼层 n 越多, 需要的尝试次数一定不会变少// 对于我们得出的这两个子问题 dp(k, n - i) 和 dp(k - 1, i - 1)// 前者随着 i 的增加而减少, 后者随着 i 的增加而增加// 将其想象成两条直线, 一个单调递增一个单调递减, 我们要求得一个位置 i 使得它们的最大值最小// 交点处！没错在它们的交点处能满足// 我们可以利用二分来查找它们的交点, 看上面的图形就明白如何应用二分了int dp(int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; memo) &#123; if(k == 1 || n == 0) &#123; return n; &#125; if(memo[k][n] != -1) &#123; return memo[k][n]; &#125; int res = INT_MAX; int lo = 1, hi = n; while(lo &lt;= hi) &#123; int mi = lo + ((hi - lo) &gt;&gt; 1); int notBroken = dp(k, n - mi, memo); int broken = dp(k - 1, mi - 1, memo); if(notBroken &gt;= broken) &#123; lo = mi + 1; res = min(res, notBroken + 1); &#125; else &#123; hi = mi - 1; res = min(res, broken + 1); &#125; &#125; return memo[k][n] = res;&#125; 198. House Robber 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 Example 1: 1234Input: nums &#x3D; [1,2,3,1]Output: 4Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).Total amount you can rob &#x3D; 1 + 3 &#x3D; 4. Example 2: 1234Input: nums &#x3D; [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12. Constraints: 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 1234567891011121314151617181920212223242526272829303132// 解法一// 定义 dp[i] 表示从第 i 间 (i 从 0 算起) 房屋开始打劫最多能抢到的钱// 对于第 i 间房屋我们有 2 个选择// 1. 不抢// dp[i] = dp[i + 1]// 2. 抢// dp[i] = nums[i] + dp[i + 2]// 要求最多能抢多少钱, 两种选择取大值// 即 dp[i] = max(dp[i + 1], nums[i] + dp[i + 2])// 我们要求的目标是 dp[0]// 当 i == n 时, 没房子抢了, dp[n] = 0int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp(n + 2); for(int i = n - 1; i &gt;= 0; i--) &#123; dp[i] = max(dp[i + 1], nums[i] + dp[i + 2]); &#125; return dp[0];&#125;// 当前状态只依赖前两个状态, 可进行空间优化int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int dp_1 = 0, dp_2 = 0; int dp_0 = 0; for(int i = n - 1; i &gt;= 0; i--) &#123; dp_0 = max(dp_1, nums[i] + dp_2); dp_2 = dp_1; dp_1 = dp_0; &#125; return dp_0;&#125; 12345678910111213141516// 解法二: 重新定义 dp 数组// dp[i][0] 表示不抢第 i 间房屋时, 经过了前 i 间所获得的金钱// dp[i][1] 表示抢第 i 间房屋, 经过了前 i 间所获得的金钱// 那么 dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])// dp[i][1] = dp[i - 1][0] + nums[i - 1]int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2)); for(int i = 1; i &lt;= n; i++) &#123; // 此家不抢, 上家可抢可不抢, 看哪个收益大 dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]); // 此家抢, 上家不能抢 dp[i][1] = dp[i - 1][0] + nums[i - 1]; &#125; return max(dp[n][0], dp[n][1]);&#125; 213. House Robber II 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，今晚能够偷窃到的最高金额。 Example 1: 123Input: nums &#x3D; [2,3,2]Output: 3Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2), because they are adjacent houses. Example 2: 1234Input: nums &#x3D; [1,2,3,1]Output: 4Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).Total amount you can rob &#x3D; 1 + 3 &#x3D; 4. Example 3: 12Input: nums &#x3D; [0]Output: 0 1234567891011121314151617181920212223// 在题 I 的基础上, 只需考虑三种情况// 1. 第 0 间和第 n - 1 间都不抢// 2. 第 0 间抢那么第 n - 1 间就不能抢// 3. 第 n - 1 间抢那么第 0 间就不能抢// 比较这三种情况, 取大值即可int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n == 1) &#123; return nums[0]; &#125; return max(&#123;rob(nums, 1, n - 2), rob(nums, 0, n - 2), rob(nums, 1, n - 1)&#125;);&#125;int rob(vector&lt;int&gt;&amp; nums, int start, int end) &#123; int dp_1 = 0, dp_2 = 0; int dp_0 = 0; for(int i = end; i &gt;= start; i--) &#123; dp_0 = max(dp_1, nums[i] + dp_2); dp_2 = dp_1; dp_1 = dp_0; &#125; return dp_0;&#125; 337. House Robber III 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 Example 1: 123Input: root &#x3D; [3,2,3,null,3,null,1]Output: 7Explanation: Maximum amount of money the thief can rob &#x3D; 3 + 3 + 1 &#x3D; 7. Example 2: 123Input: root &#x3D; [3,4,5,1,3,null,1]Output: 9Explanation: Maximum amount of money the thief can rob &#x3D; 4 + 5 &#x3D; 9. 123456789101112131415161718// 在 I 题方法 2 的思路下int rob(TreeNode* root) &#123; // &lt;不抢 root 最多得到的钱, 抢 root 最多得到的钱&gt; auto dfs = [](auto&amp;&amp; dfs, TreeNode* root) &#123; if(root == nullptr) &#123; return make_pair(0, 0); &#125; auto [l_norob, l_rob] = dfs(dfs, root-&gt;left); auto [r_norob, r_rob] = dfs(dfs, root-&gt;right); // 不抢, 左右两家家可抢可不抢, 看哪个收益大 auto norob = max(l_norob, l_rob) + max(r_norob, r_rob); // 抢, 左右两家不能抢 auto rob = l_norob + root-&gt;val + r_norob; return make_pair(norob, rob); &#125;; auto [norob, rob] = dfs(dfs, root); return max(norob, rob);&#125; 740. Delete and Earn 给你一个整数数组nums，你可以对它进行一些操作。 每次操作中，选择任意一个nums[i]，删除它并获得nums[i]的点数。之后，你必须删除每个等于nums[i] - 1或nums[i] + 1的元素。 开始你拥有0个点数。返回你能通过这些操作获得的最大点数。 Example 1: 12345Input: nums &#x3D; [3,4,2]Output: 6Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted.Then, delete 2 to earn 2 points.6 total points are earned. Example 2: 12345Input: nums &#x3D; [2,2,3,3,3,4]Output: 9Explanation: Delete 3 to earn 3 points, deleting both 2&#39;s and the 4.Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.9 total points are earned. Constraints: 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= nums[i] &lt;= 104 1234567891011121314151617// 在选择了元素 x 后, x, x - 1, x + 1 都会被删除// 并且我们可以一下选择剩余的所有 x 以尽可能多的获得点数// 如果我们定义 dp[i] 表示元素 i 开始选择可以获得的点数// 选择元素 i 获得的点数等于 i * (i 出现的次数)// 那么这题就和上面的打家劫舍题 I 相同了// 也即是说抢劫了第 i 间房屋, i - 1 和 i + 1 都不能抢了int deleteAndEarn(vector&lt;int&gt;&amp; nums)&#123; int maxVal = *max_element(nums.begin(), nums.end()); vector&lt;int&gt; counts(maxVal + 1); for(int num : nums) counts[num]++; vector&lt;int&gt; dp(maxVal + 3); for(int i = maxVal; i &gt;= 0; i--) dp[i] = max(dp[i + 1], i * counts[i] + dp[i + 2]); return dp[0];&#125; 12345678910111213141516171819// 预处理一下, 可以直接调用打家劫舍的 rob 函数int deleteAndEarn(vector&lt;int&gt;&amp; nums)&#123; int maxVal = *max_element(nums.begin(), nums.end()); // sum[x] 等于所有 x 之和 vector&lt;int&gt; sum(maxVal + 1); for(int num : nums) sum[num] += num; return rob(sum);&#125;int rob(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); vector&lt;int&gt; dp(n + 2); for(int i = n - 1; i &gt;= 0; i--) dp[i] = max(dp[i + 1], nums[i] + dp[i + 2]); return dp[0];&#125; 53. Maximum Subarray 给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 Example 1: 123Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1] has the largest sum &#x3D; 6. Example 2: 12Input: nums &#x3D; [1]Output: 1 Example 3: 12Input: nums &#x3D; [5,4,-1,7,8]Output: 23 1234567891011121314// 暴力 超时// 时间复杂度 O(n2) 空间复杂度 O(1)int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int res = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; int sum = 0; for(int j = i; j &lt; n; j++) &#123; sum += nums[j]; res = max(res, sum); &#125; &#125; return res;&#125; 1234567891011121314151617181920212223242526272829303132333435// 动态规划 dp[i] 表示以 nums[i] 结尾的连续子数组的最大和// 时间复杂度和空间复杂度均为 O(n)int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n == 0) &#123; return 0; &#125; vector&lt;int&gt; dp(n); dp[0] = nums[0]; int res = dp[0]; for(int i = 1; i &lt; n; i++) &#123; dp[i] = max(dp[i - 1] + nums[i], nums[i]); res = max(res, dp[i]); &#125; return res;&#125;// 由于 dp[i] 只与上一个状态 dp[i - 1] 和 nums[i] 有关// 通过一个变量记录上一个状态值将空间复杂度压缩到 O(1)// 并且同时使用一个变量更新状态中的最大值// 时间复杂度 O(n) 空间复杂度 O(1)int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int preState = 0, curState = 0; int res = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; curState = nums[i]; if(preState &gt; 0) &#123; curState += preState; &#125; res = max(res, curState); preState = curState; &#125; return res;&#125; 123456789101112131415161718192021222324252627282930// 二分法 (还没搞懂)// 时间复杂度 O(nlogn) 空间复杂度 O(1)int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n == 0) &#123; return 0; &#125; return binary_search(nums, 0, n - 1);&#125;int binary_search(vector&lt;int&gt;&amp;nums, int left, int right) &#123; if(left &gt;= right) &#123; return nums[left]; &#125; int mid = (left + right) &gt;&gt; 1; int leftMax = binary_search(nums, left, mid - 1); int rightMax = binary_search(nums, mid + 1, right); int midMax = nums[mid], t = midMax; // 开始计算左边的最大值 for(int i = mid - 1; i &gt;= left; i--) &#123; t += nums[i]; midMax = max(midMax, t); &#125; t = midMax; for(int i = mid + 1; i &lt;= right; i++) &#123; t += nums[i]; midMax = max(midMax, t); &#125; return max(midMax, max(leftMax, rightMax));&#125; 152. Maximum Product Subarray 给你一个整数数组nums，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 参考链接：动态规划（理解无后效性） - 乘积最大子数组 Example 1: 123Input: nums &#x3D; [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6. Example 2: 123Input: nums &#x3D; [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Constraints: 1 &lt;= nums.length &lt;= 2 * 104 -10 &lt;= nums[i] &lt;= 10 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. 1234567891011121314151617181920212223242526272829303132// 如果还是定义 dp[i] 表示以 nums[i] 结尾的连续子数组的最大乘积// 继续以 53 题的思路解决这道题是错误的做法// 因为数组中负数的出现会使得正的最大值乘以负数而可能变成最小值// 而负的最小值乘以一个负数而可能会变成最大值// 也就是说乘积的最大值和最小值会由于当前的数的正负而发生转化// 所以这题要根据 nums[i] 的正负来分别考虑以 nums[i] 结尾的子数组的最大值和最小值两种情况// 定义 dp[0][i] 和 dp[1][i] 分别表示以 nums[i] 结尾的子数组的乘积的最小值和最大值// 当 nums[i] &gt; 0 时// dp[0][i] = min(nums[i] * dp[0][i - 1], nums[i])// dp[1][i] = max(nums[i] * dp[1][i - 1], numa[i])// 当 nums[i] &lt; 0 时// dp[0][i] = min(nums[i] * dp[1][i - 1], nums[i])// dp[1][i] = max(nums[i] * dp[0][i - 1], numa[i])// 这题也可以问你连续子数组的最小乘积是多少int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2)); dp[0][0] = dp[0][1] = nums[0]; int res = nums[0]; for(int i = 1; i &lt; n; i++) &#123; if(nums[i] &gt; 0) &#123; dp[i][0] = min(dp[i - 1][0] * nums[i], nums[i]); dp[i][1] = max(dp[i - 1][1] * nums[i], nums[i]); &#125; else &#123; dp[i][0] = min(dp[i - 1][1] * nums[i], nums[i]); dp[i][1] = max(dp[i - 1][0] * nums[i], nums[i]); &#125; res = max(res, dp[i][1]); &#125; return res;&#125; 1234567891011121314151617181920212223// 当前状态只依赖前一个状态, 故可以使用滚动变量进行空间优化int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int dp_0_0 = nums[0]; int dp_1_0 = nums[0]; int res = dp_1_0; // 滚动变量 int dp_0_1, dp_1_1; for(int i = 1; i &lt; n; i++) &#123; if(nums[i] &gt; 0) &#123; dp_0_1 = min(nums[i] * dp_0_0, nums[i]); dp_1_1 = max(nums[i] * dp_1_0, nums[i]); &#125; else &#123; dp_0_1 = min(nums[i] * dp_1_0, nums[i]); dp_1_1 = max(nums[i] * dp_0_0, nums[i]); &#125; dp_0_0 = dp_0_1; dp_1_0 = dp_1_1; res = max(res, dp_1_1); &#125; return res;&#125; 1262. Greatest Sum Divisible by Three 给你一个整数数组nums，请你找出并返回能被3整除的元素最大和。 Example 1: 123Input: nums &#x3D; [3,6,5,1,8]Output: 18Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3). Example 2: 123Input: nums &#x3D; [4]Output: 0Explanation: Since 4 is not divisible by 3, do not pick any number. Example 3: 123Input: nums &#x3D; [1,2,3,4,4]Output: 12Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3). Constraints: 1 &lt;= nums.length &lt;= 4 * 10^4 1 &lt;= nums[i] &lt;= 10^4 12345678910111213141516171819202122232425262728293031323334353637383940// dp[i][j] 表示对于前 i 个数, 选取的数字和对 3 取余为 j 的最大和 (j == 0, 1, 2)// 我们的目标是要求 dp[n][0]// 那么如果进行状态转移呢？// 需要看第 i 个数 nums[i - 1] 对 3 取余的情况// 1. 余数为 0 // 加到哪一个最大和身上对 3 取余的结果不变 // dp[i][0] = max(dp[i - 1][0], dp[i - 1][0] + nums[i - 1]) // dp[i][1] = max(dp[i - 1][1], dp[i - 1][1] + nums[i - 1]) // dp[i][2] = max(dp[i - 1][2], dp[i - 1][2] + nums[i - 1])// 2. 余数为 1 // 加到原来余 2 的最大和身上, 余数变成 0 // 所以 dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] + nums[i - 1]) // 加到原来余 0 的最大和身上, 余数变成 1 // 所以 dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + nums[i - 1]) // 加到原来余 1 的最大和身上, 余数变成 2 // 所以 dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + nums[i - 1])// 3. 余数为 2 // 加到原来余 1 的最大和身上, 余数变成 0 // 所以 dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + nums[i - 1]) // 加到原来余 2 的最大和身上, 余数变成 1 // 所以 dp[i][1] = max(dp[i - 1][1], dp[i - 1][2] + nums[i - 1]) // 加到原来余 0 的最大和身上, 余数变成 2 // 所以 dp[i][2] = max(dp[i - 1][2], dp[i - 1][0] + nums[i - 1])int maxSumDivThree(vector&lt;int&gt; &amp;nums) &#123; // k 为任意数的一般情况 int k = 3; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(k)); // 这个初始化有点不太好想到 for(int j = 1; j &lt; k; j++) &#123; dp[0][j] = INT_MIN; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; k; j++) &#123; int mod = nums[i - 1] % k; dp[i][j] = max(dp[i - 1][j], dp[i - 1][(k - mod + j) % k] + nums[i - 1]); &#125; &#125; return dp[n][0];&#125; 1234567891011121314151617181920// 在理解了上一种解法的基础上, 下面这种思路更好// dp[i] 表示选择的数字累加和模 3 == i 的数字和// 对于 nums[i], 如果 nums[i] % 3 == 1, 那么将其加到之前模 3 == 2 的最大和上面// 就变成了模 3 == 0 了, 所以 dp[0] = max(dp[0], dp[2] + nums[i])// 依次类推, 对于每一个 nums[i] 都要更新 dp 数组的值int maxSumDivThree(vector&lt;int&gt; &amp;nums) &#123; // k 为任意数的一般情况 int k = 3; vector&lt;int&gt; dp(k); for(int num : nums) &#123; // 备份上一个状态 // 因为要用上一个状态的值来更新当前状态 auto temp = dp; for(int maxSum : temp) &#123; int mod = (maxSum + num) % k; dp[mod] = max(dp[mod], maxSum + num); &#125; &#125; return dp[0];&#125; 486. Predict the Winner 给定一个表示分数的非负整数数组。 玩家A从数组任意一端拿取一个分数，随后玩家B继续从剩余数组任意一端拿取分数，然后玩家A拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。 给定一个表示分数的数组，预测作为先手的玩家A是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。 如果最终两个玩家的分数相等，那么玩家A仍为赢家。 示例： 12345678输入：[5,3,4,5]输出：true解释：亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 定义 dp[i][j][0] 表示先手在面对 nums[i..j] 的石头堆时能拿到的最大分数// dp[i][j][1] 表示后手在面对 nums[i..j] 的石头堆时能拿到的最大分数// 1. 对于石头堆 nums[i..j]// 先手需要判断拿左边堆分数高还是拿右边堆分数高// 如果先手拿了左边堆, 先手面对 nums[i+1..j] 时就变成了后手// 此时的得分是 dp[i + 1][j][1] + nums[i]// 如果先手拿了右边堆, 先手面对 nums[i..j-1] 时就变成了后手// 此时的得分是 dp[i][j - 1][1] + nums[j]// 肯定取较高的情况// dp[i][j][0] = max(dp[i + 1][j][1] + nums[i], dp[i][j - 1][1] + nums[j])// 2. 先手的选择对后手会产生影响, 如果先手选择了左边堆// 后手在面对 nums[i+1..j] 时就变成了先手// dp[i][j][1] = dp[i + 1][j][0]// 如果先手选择了右边堆// 后手在面对 nums[i..j-1] 时就变成了先手// dp[i][j][1] = dp[i][j - 1][0]// 当 i &gt; j 时, 没有石头堆了 dp[i][j][0,1] = 0// 当 i == j 时, dp[i][j][0] = nums[i], dp[i][j][1] = 0bool PredictTheWinner(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(2))); for(int i = 0; i &lt; n; i++) &#123; dp[i][i][0] = nums[i]; dp[i][i][1] = 0; &#125; for(int i = n - 2; i &gt;= 0; i--) &#123; for(int j = i + 1; j &lt; n; j++) &#123; // 比较拿左边堆之后和拿右边堆之后的分数 int left = dp[i + 1][j][1] + nums[i]; int right = dp[i][j - 1][1] + nums[j]; if(left &gt; right) &#123; dp[i][j][0] = left; dp[i][j][1] = dp[i + 1][j][0]; &#125; else &#123; dp[i][j][0] = right; dp[i][j][1] = dp[i][j - 1][0]; &#125; // 不可以写成这样, 不能仅仅比较当前左右两堆石头的大小 // 比如 [1, 5, 233, 7] 的情况 // if(nums[i] &gt; nums[j]) // &#123; // dp[i][j][0] = dp[i + 1][j][1] + nums[i]; // dp[i][j][1] = dp[i + 1][j][0]; // &#125; // else // &#123; // dp[i][j][0] = dp[i][j - 1][1] + nums[j]; // dp[i][j][1] = dp[i][j - 1][0]; // &#125; &#125; &#125; return dp[0][n - 1][0] &gt;= dp[0][n - 1][1];&#125; 1234567891011121314151617181920212223// 动态规划的另一种思路// 甲乙比赛, 甲先手面对区间 [i...j] 时, dp[i][j] 表示甲对乙的净胜分// 最终求的就是, 甲先手面对区间 [0...n-1] 时, 甲对乙的净胜分 dp[0][n-1] 是否 &gt;= 0// 甲先手面对区间[i...j]时// 1. 如果甲拿 nums[i], 那么变成乙先手面对区间 [i+1...j], 这段区间内乙对甲的净胜分为 dp[i+1][j]// 那么甲对乙的净胜分就应该是 nums[i] - dp[i+1][j]// 如果甲拿 nums[j], 同理可得甲对乙的净胜分为是 nums[j] - dp[i][j-1]// 以上两种情况二者取大即可// 状态转移方程 dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])bool PredictTheWinner(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); // 当 i == j 时先手对后手的净胜分就是 nums[i] for(int i = 0; i &lt; n; i++) dp[i][i] = nums[i]; for(int i = n - 2; i &gt;= 0; i--) for (int j = i + 1; j &lt; n; j++) dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]); return dp[0][n - 1] &gt;= 0;&#125; 12345678910111213141516171819202122232425262728// 记忆化递归unordered_map&lt;string, int&gt; memo;bool PredictTheWinner(vector&lt;int&gt;&amp; nums)&#123; return totalScores(nums, 0, nums.size() - 1, 1) &gt;= 0;&#125;// 返回拿走 [i, j] 的石头堆后的的得分// flag = 1 表示当前是先手, flag = -1 表示当前是后手// flag 可用于控制先手的得分均为正值, 后手的得分均为负值// 交替选择的过程中将他们的分数加起来// 显然, 最后总得分为正时先后获胜, 为负时后手获胜int totalScores(vector&lt;int&gt;&amp; nums, int i, int j, int flag)&#123; if(i == j) &#123; return flag * nums[i]; &#125; string key = to_string(i) + \",\" + to_string(j) + \",\" + to_string(flag); if(memo.count(key)) &#123; return memo[key]; &#125; int selectLeft = flag * nums[i] + totalScores(nums, i + 1, j, -flag); int selectRight = flag * nums[j] + totalScores(nums, i, j - 1, -flag); // 无论当前是先后还是后手, 其选择左或右后, 目前得分的总和可能为正也可能为负 // 所以需要去掉正负号后再选出较大的值, 方法就是 得分*flag 就可以 // 也就是说先手会尽量的把数变正变大 // 后手会尽量把数变负变小 return memo[key] = flag * max(flag * selectLeft, flag * selectRight);&#125; 664. Strange Printer 有台奇怪的打印机有以下两个特殊要求： 打印机每次只能打印由 同一个字符 组成的序列。 每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。 给你一个字符串s，你的任务是计算这个打印机打印它需要的最少打印次数。 Example 1: 123&gt;Input: s &#x3D; &quot;aaabbb&quot;&gt;Output: 2&gt;Explanation: Print &quot;aaa&quot; first and then print &quot;bbb&quot;. Example 2: 123&gt;Input: s &#x3D; &quot;aba&quot;&gt;Output: 2&gt;Explanation: Print &quot;aaa&quot; first and then print &quot;b&quot; from the second place of the string, which will cover the existing character &#39;a&#39;. 1234567891011121314151617181920212223242526272829303132333435363738394041// 定义 dp[i][j] 表示打印出字符串区间 s[i..j] 中的字符所需要的最少次数// 对于 s[i] == s[j]// 我们在第一次打印出 s[i] 的同时可以顺便打印出 s[j]// 因此只需要关注如何更快的打印出 s[i..j-1] 中的字符即可// dp[i][j] = dp[i][j - 1]// 对于 s[i] != s[j]// 我们要分别完成以 s[i] 开头的左半部分字符和以 s[j] 结尾的右半部分字符的打印// 具体的需要在 i 到 j 之间找一个分界点 k// 找到最小的 dp[i][k] + dp[k + 1][j]// dp[i][j] = min(dp[i][k] + dp[k + 1][j]) for k in [i, j)// 我们的目标是求 dp[0][n - 1]// 当 i == j 时 dp[i][j] = 1 只需要一次打印即可int strangePrinter(string s)&#123; // 可能想到的优化点 // 注意到本题中连续的相同字符等价于单个字符 // 所以可以先进行一个相邻元素去重处理 // auto last = unique(s.begin(), s.end()); // s.resize(distance(s.begin(), last)); int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, INT_MAX)); for(int i = 0; i &lt; n; i++) &#123; dp[i][i] = 1; &#125; // 由于 dp[i][j] 依赖于 dp[i + k][j] // 所以画出二维矩阵图之后知道我们要对 i 从下往上, j 从左往右遍历 for(int i = n - 2; i &gt;= 0; i--) &#123; for(int j = i + 1; j &lt; n; j++) &#123; if(s[i] == s[j]) &#123; dp[i][j] = dp[i][j - 1]; &#125; else &#123; for(int k = i; k &lt; j; k++) &#123; dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]); &#125; &#125; &#125; &#125; return dp[0][n - 1];&#125; 546. Remove Boxes 给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。 你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续k个盒子（k &gt;= 1），这样一轮之后你将得到k * k个积分。 当你将所有盒子都去掉之后，求你能获得的最大积分和。 Example: 12345678Input: boxes &#x3D; [1,3,2,2,2,3,4,3,1]Output: 23Explanation:[1, 3, 2, 2, 2, 3, 4, 3, 1]----&gt; [1, 3, 3, 4, 3, 1] (3*3&#x3D;9 points)----&gt; [1, 3, 3, 3, 1] (1*1&#x3D;1 points)----&gt; [1, 1] (3*3&#x3D;9 points)----&gt; [] (2*2&#x3D;4 points) 12345// 太特么难了int removeBoxes(vector&lt;int&gt;&amp; boxes)&#123; &#125; 338. Counting Bits 给定一个非负整数num。对于0 ≤ i ≤ num范围中的每个数字i，计算其二进制数中的1的数目并将它们作为数组返回。 进阶：给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ Example: 123456789Input: n &#x3D; 5Output: [0, 1, 1, 2, 1, 2]Explanation:0 --&gt; 01 --&gt; 12 --&gt; 103 --&gt; 114 --&gt; 1005 --&gt; 101 12345678910111213141516vector&lt;int&gt; countBits(int n) &#123; vector&lt;int&gt; bits(n + 1); for(int i = 0; i &lt;= n; i++) &#123; bits[i] = countOnes(i); &#125; return bits;&#125;int countOnes(int x) &#123; int ones = 0; while(x &gt; 0) &#123; x = x &amp; (x - 1); ones++; &#125; return ones;&#125; 123456789101112// 计算当前状态的值时通过最高位的 1 转移到之前的状态vector&lt;int&gt; countBits(int n) &#123; vector&lt;int&gt; bits(n + 1); int highBit = 0; for(int i = 1; i &lt;= n; i++) &#123; if((i &amp; (i - 1)) == 0) &#123; highBit = i; &#125; bits[i] = bits[i - highBit] + 1; &#125; return bits;&#125; 123456789101112// 计算当前状态的值时通过最低位的 1 转移到之前的状态// 实际上就是通过把值变小, 使当前值中的 1 的个数和更小的值中 1 的个数具有数量关系vector&lt;int&gt; countBits(int n) &#123; vector&lt;int&gt; bits(n + 1); for(int i = 1; i &lt;= n; i++) &#123; // 方式一: 右移一位, 最右边的位可能为 0 或 1 bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1); // 方式二: 去掉最低位 1 bits[i] = bits[i &amp; (i - 1)] + 1; &#125; return bits;&#125; 1866. Number of Ways to Rearrange Sticks With K Sticks Visible 有n根长度互不相同的木棍，长度为从1到n的整数。请你将这些木棍排成一排，并满足从左侧可以看到恰好k根木棍。 从左侧可以看到木棍的前提是这个木棍的左侧不存在比它更长的木棍。例如，如果木棍排列为[1,3,2,5,4]，那么从左侧可以看到的就是长度分别为1、3 、5的木棍。 给你n和k，返回符合题目要求的排列数目 。由于答案可能很大，请返回对10^9 + 7取余的结果。 Example 1: 1234Input: n &#x3D; 3, k &#x3D; 2Output: 3Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible.The visible sticks are underlined. Example 2: 1234Input: n &#x3D; 5, k &#x3D; 5Output: 1Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible.The visible sticks are underlined. Example 3: 123Input: n &#x3D; 20, k &#x3D; 11Output: 647427950Explanation: There are 647427950 (mod 10^9 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible. 12345678910111213141516171819202122232425// 定义 dp[i][j] 表示对于高度为 [1..i] 的所有柱子进行排列, 从左侧能看到 j 根的排列数// 我们考虑最后一根柱子能不能被看见// 1. 如果最后一根柱子能被看见, 那么它的高度一定为 i// 这样对于左侧 [1..i-1] 高度的柱子看到 j-1 根柱子的排列数就是之前的状态// dp[i][j] = dp[i - 1][ j - 1]// 2. 如果最后一根柱子不能被看见, 那么它的高度可以为 [1..i-1] 中的任意一个// 由于一根木棍能否被看到只与它和它左侧木棍的「相对高度关系」有关，而与「绝对高度关系」无关// 因此, 此时最后一根柱子的高度有 [1..i-1] 中 i-1 种选择// 固定每种选择后, 对于左侧的柱子看到 j 根柱子的排列数就是之前状态// dp[i][j] = (i - 1) * dp[i - 1][j]// 综合两种情况 dp[i][j] = dp[i - 1][ j - 1] + (i - 1) * dp[i - 1][j]// 我们的目标是求 dp[n][k]// 当 i == 0 &amp;&amp; j == 0 时 dp[0][0] = 1, 其它情况都初始化为 0int rearrangeSticks(int n, int k) &#123; int mod = 1e9+7; vector&lt;vector&lt;long&gt;&gt; dp(n + 1, vector&lt;long&gt;(k + 1)); dp[0][0] = 1; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) &#123; dp[i][j] = dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j]; dp[i][j] %= mod; &#125; &#125; return dp[n][k];&#125; 410. Split Array Largest Sum 给定一个非负整数数组nums和一个整数m，你需要将这个数组分成m个非空的连续子数组。设计一个算法使得这m个子数组各自和的最大值最小。 Example: 123456Input: nums &#x3D; [7,2,5,10,8], m &#x3D; 2Output: 18Explanation:There are four ways to split nums into two subarrays.The best way is to split it into [7,2,5] and [10,8],where the largest sum among the two subarrays is only 18. 1234567891011121314151617181920// 定义 dp[i][j] 表示将前 i 个数划分成 j 个连续的子数组, 各自和的最大值int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; int n = nums.size(); vector&lt;int&gt; prefix(n + 1); for(int i = 1; i &lt;= n; i++) &#123; prefix[i] = prefix[i - 1] + nums[i - 1]; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, INT_MAX)); dp[0][0] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; // 枚举将前 k 个数划分为 j - 1 个子数组 // 因为子数组非空, 所以 k in [j - 1, i - 1] for(int k = j - 1; k &lt; i; k++) &#123; dp[i][j] = min(dp[i][j], max(dp[k][j - 1], prefix[i] - prefix[k])); &#125; &#125; &#125; return dp[n][m];&#125; 123456789101112131415161718192021222324252627282930313233// 二分 + 贪心 checkint splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; auto check = [&amp;](int maxVal) &#123; int cnt = 1, sum = 0; for(int num : nums) &#123; if(sum + num &lt;= maxVal) &#123; sum += num; &#125; else &#123; cnt++; sum = num; &#125; &#125; return cnt &lt;= m; &#125;; int lo = 0, hi = 0; for(int num : nums) &#123; hi += num; if(lo &lt; num) &#123; lo = num; &#125; &#125; while(lo &lt;= hi) &#123; int mi = lo + (hi - lo) / 2; if(check(mi)) &#123; hi = mi - 1; &#125; else &#123; lo = mi + 1; &#125; &#125; return lo;&#125; 1049. 最后一块石头的重量 II 有一堆石头，用整数数组stones表示。其中stones[i]表示第i块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为x和y，且x &lt;= y。那么粉碎的可能结果如下： 如果x == y，那么两块石头都会被完全粉碎； 如果x != y，那么重量为x的石头将会完全粉碎，而重量为y的石头新重量为y - x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回0。 Example 1: 1234567Input: stones &#x3D; [2,7,4,1,8,1]Output: 1Explanation:We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,we can combine 1 and 1 to get 0, so the array converts to [1], then that&#39;s the optimal value. Example 2: 12Input: stones &#x3D; [31,26,33,21,40]Output: 5 1234567891011121314151617181920212223242526272829303132// 每一回合的操作相当于在较大的数前面放置一个 '+' 号, 在较小的数前面放置一个 '-' 号// 经过若干回合之后, 所有的数前面都被放置了相应的正负号// 最后形成的表达式求值就是最终剩下的石头的重量// 我们假设前面被放正号的数之和是 sumP, 前面放负号的数之和为 sumN// 所有石头总和为 sum, 最后剩下的石头重量为 w// 则 w = sumP - sumN = sum - sumN - sumN = sum - 2*sumN// 为了保证 w 最小, 那么我们就是要保证 sum - 2*sumN 为非负值的情况下// 也就是在 sumN &lt;= sum/2 时, 找到尽可能大的 sumN// 此时问题就转换为了一个 01 背包问题// 有一个容量为 sum/2 的背包和一堆重量已知的石头// 问我们如何装能够装的石头总重量最大// 定义 dp[i][j] 表示对于前 i 堆石头, 背包容量为 j 时能装的最大重量// 对于第 i 块石头有两个选择// 1. 不装 dp[i][j] = dp[i - 1][j]// 2. 装 dp[i][j] = dp[i - 1][j - stones[i - 1]] + stones[i - 1]// 我们要求最大可能的重量, 所以两者取最大值即可// 对于初始条件, 当 i == 0 时, 即没有石头可装, dp[i][j] = 0// 当 j == 0, 即背包容量为 0, dp[i][j] = 0int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; int n = stones.size(); int sum = accumulate(stones.begin(), stones.end(), 0); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(sum/2 + 1)); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= sum/2; j++) &#123; dp[i][j] = dp[i - 1][j]; if(j &gt;= stones[i - 1]) &#123; dp[i][j] = max(dp[i][j] , dp[i - 1][j - stones[i - 1]] + stones[i - 1]); &#125; &#125; &#125; return sum - 2*dp[n][sum/2];&#125; 123456789101112// 由于 i 的当前状态只与前一个状态有关, 使用滚动数组优化int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; int n = stones.size(); int sum = accumulate(stones.begin(), stones.end(), 0); vector&lt;int&gt; dp(sum/2 + 1); for(int i = 0; i &lt; n; i++) &#123; for(int j = sum/2; j &gt;= stones[i]; j--) &#123; dp[j] = max(dp[j] , dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - 2*dp[sum/2];&#125; 879. 盈利计划 集团里有n名员工，他们可以完成各种各样的工作创造利润。第i种工作会产生profit[i]的利润，它要求group[i]名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。 工作的任何至少产生minProfit利润的子集称为盈利计划。并且工作的成员总数最多为n。 有多少种计划可以选择？因为答案可能很大，所以返回结果模10^9 + 7的值。 示例 1： 1234输入：n &#x3D; 5, minProfit &#x3D; 3, group &#x3D; [2,2], profit &#x3D; [2,3]输出：2解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。总的来说，有两种计划。 示例 2： 1234输入：n &#x3D; 10, minProfit &#x3D; 5, group &#x3D; [2,3,5], profit &#x3D; [6,7,8]输出：7解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。 提示： 1 &lt;= n &lt;= 100，0 &lt;= minProfit &lt;= 100，1 &lt;= group.length &lt;= 100 1 &lt;= group[i] &lt;= 100，profit.length == group.length，0 &lt;= profit[i] &lt;= 100 1234567891011121314151617181920212223242526272829303132// 状态有工作, 员工数以及当前利润// 我们定义 dp[i][j][k] 表示对于前 i 种工作, 参与的员工数为 j 时, 在利润 [至少] 为 k 的情况下的计划数// 对于第 i 种工作我们有选择和不选两种选择// 1. 不选 显然有// dp[i][j][k] = dp[i - 1][j][k]// 2. 选// dp[i][j][k] = dp[i - 1][j - group[i - 1]][k - profit[i - 1]]// 注意到对于状态 k 我们定义的是至少获得的利润// 因此, 当 k - profit[i - 1] 为负时, 我们都取 0// 也就是说所有大于 k 的利润都归为等于 k, 这就是至少的定义嘛// 当 i == 0 时, 无论你用了多少个员工, 至少获得的利润 k 显然都为 0, 这属于 1 种计划// dp[0][j][0] = 1 for j in [1..n]int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) &#123; int m = group.size(); int mod = 1e9 + 7; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(m + 1, vector&lt;vector&lt;int&gt;&gt;(n + 1, vector&lt;int&gt;(minProfit + 1))); for(int j = 0; j &lt;= n; j++) &#123; dp[0][j][0] = 1; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 0; j &lt;= n; j++) &#123; for(int k = 0; k &lt;= minProfit; k++) &#123; dp[i][j][k] = dp[i - 1][j][k]; if(j &gt;= group[i - 1]) &#123; dp[i][j][k] += dp[i - 1][j - group[i - 1]][max(0, k - profit[i - 1])]; &#125; dp[i][j][k] = dp[i][j][k] % mod; &#125; &#125; &#125; return dp[m][n][minProfit];&#125; 123456789101112131415161718// 滚动数组优化空间复杂度int profitableSchemes(int n, int minProfit, vector&lt;int&gt;&amp; group, vector&lt;int&gt;&amp; profit) &#123; int m = group.size(); int mod = 1e9 + 7; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(minProfit + 1)); for(int j = 0; j &lt;= n; j++) &#123; dp[j][0] = 1; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = n; j &gt;= group[i - 1]; j--) &#123; for(int k = 0; k &lt;= minProfit; k++) &#123; dp[j][k] += dp[j - group[i - 1]][max(0, k - profit[i - 1])]; dp[j][k] = dp[j][k] % mod; &#125; &#125; &#125; return dp[n][minProfit];&#125; 1155. 掷骰子的N种方法 这里有d个一样的骰子，每个骰子上都有f个面，分别标号为1, 2, ..., f。 我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。 如果需要掷出的总点数为target，请你计算出有多少种不同的组合情况（所有的组合情况总共有f^d种），模1e9+7后返回。 提示： 1 &lt;= d, f &lt;= 30 1 &lt;= target &lt;= 1000 12345678910111213141516// 01 背包问题int numRollsToTarget(int d, int f, int target) &#123; vector&lt;vector&lt;int&gt;&gt; dp(d + 1, vector&lt;int&gt;(target + 1)); dp[0][0] = 1; for(int i = 1; i &lt;= d; i++) &#123; for(int j = 1; j &lt;= target; j++) &#123; for(int k = 1; k &lt;= f; k++) &#123; if(k &lt;= j) &#123; dp[i][j] += dp[i - 1][j - k]; dp[i][j] = dp[i][j] % int(1e9+7); &#125; &#125; &#125; &#125; return dp[d][target];&#125; 1234567891011121314151617181920// 滚动数组优化空间int numRollsToTarget(int d, int f, int target) &#123; int mod = 1e9+7; vector&lt;int&gt; dp(target + 1); dp[0] = 1; for(int i = 1; i &lt;= d; i++) &#123; for(int j = target; j &gt;= 0; j--) &#123; // 这个不太容易想到 // 它表示降维前, dp[1..d][0] = 0 的情况 // 即, 使用了多于一个骰子的话, 和为 0 的情况不可能出现 // 因此, 每次迭代时要将这种情况的组合数设为 0 dp[j] = 0; for(int k = 1; k &lt;= f &amp;&amp; k &lt;= j; k++) &#123; dp[j] += dp[j - k]; dp[j] = dp[j] % mod; &#125; &#125; &#125; return dp[target];&#125; 801. 使序列递增的最小交换次数 我们有两个长度相等且不为空的整型数组A和B。我们可以交换A[i]和B[i]的元素。注意这两个元素在各自的序列中应该处于相同的位置。在交换过一些元素之后，数组A和B都应该是严格递增的。 给定数组A和B，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 对于第 i 个元素, 有交换和不交换两种选择// 定义 dp[i][0] 表示第 i 个元素交换时, 将前 i 个元素交换操作之后严格递增的最小操作次数// 定义 dp[i][1] 表示第 i 个元素不交换时, 将前 i 个元素交换操作之后严格递增的最小操作次数// 那么在考虑第 i 个元素时, 需要连同第 i - 1 个元素一起考虑// 也就是 A[i - 1], A[i], B[i - 1] 和 B[i] 这四个元素// 1. A[i - 1] &lt; A[i] &amp;&amp; B[i - 1] &lt; B[i]// 此时若 A[i - 1] &lt; B[i] &amp;&amp; B[i - 1] &lt; A[i]// 前一个元素可以交换也可以不交换// 1.1 当前元素不交换 dp[i][0] = min(dp[i - 1][0], dp[i - 1][1])// 1.2 当前元素交换 dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + 1// 此时若 A[i - 1] &gt;= B[i] || B[i - 1] &gt;= A[i]// 当前元素和前一个元素必须同时交换或不交换// 1.3 当前元素不交换 dp[i][0] = dp[i - 1][0]// 1.4 当前元素交换 dp[i][1] = dp[i - 1][1] + 1// 2. A[i - 1] &gt;= A[i] || B[i - 1] &gt;= B[i]// 当前元素若不交换则前一元素需要交换, 当前元素若交换则前一元素不能交换// dp[i][0] = d[i - 1][1]// dp[i][1] = d[i - 1][0] + 1// 作为 base case, 第 0 个元素可以交换也可以不交换// 若不交换 dp[0][0] = 0// 若交换 dp[0][1] = 1int minSwap(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; int n = A.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2)); dp[0][0] = 0; dp[0][1] = 1; for(int i = 1; i &lt; n; i++) &#123; if(A[i - 1] &lt; A[i] &amp;&amp; B[i - 1] &lt; B[i]) &#123; if(A[i - 1] &lt; B[i] &amp;&amp; B[i - 1] &lt; A[i]) &#123; dp[i][0] = min(dp[i - 1][0], dp[i - 1][1]); dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + 1; &#125; else &#123; dp[i][0] = dp[i - 1][0]; dp[i][1] = dp[i - 1][1] + 1; &#125; &#125; else &#123; dp[i][0] = dp[i - 1][1]; dp[i][1] = dp[i - 1][0] + 1; &#125; &#125; return min(dp[n - 1][0], dp[n - 1][1]);&#125; LCP 07. 传递信息 小朋友A在和ta的小伙伴们玩传信息游戏，游戏规则如下： 有n名玩家，所有玩家编号分别为0～n-1，其中小朋友A的编号为0； 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如A可以向B传信息，但B不能向A传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数n，以及按[玩家编号，对应可传递玩家编号]关系组成的二维数组relation。返回信息从小A (编号0) 经过k轮传递到编号为n-1的小伙伴处的方案数；若不能到达，返回0。 示例 1： 123输入：n &#x3D; 5, relation &#x3D; [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k &#x3D; 3输出：3解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4 示例 2： 123输入：n &#x3D; 3, relation &#x3D; [[0,2],[2,1]], k &#x3D; 2输出：0解释：信息不能从小 A 处经过 2 轮传递到编号 2 限制： 2 &lt;= n &lt;= 10 1 &lt;= k &lt;= 5 1 &lt;=relation.length &lt;= 90, 且 relation[i].length == 2 0 &lt;= relation[i][0], relation[i][1]&lt; n 且 relation[i][0] != relation[i][1] 123456789101112131415161718192021// 比较容易想到的是 dfsint numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) &#123; vector&lt;vector&lt;int&gt;&gt; edges(n); for(auto&amp;&amp; r : relation) &#123; edges[r[0]].push_back(r[1]); &#125; int res = 0; auto dfs = [&amp;](auto&amp;&amp; dfs, int idx, int step) &#123; if(step == k) &#123; if(idx == n - 1) &#123; res++; &#125; return; &#125; for(auto&amp;&amp; to : edges[idx]) &#123; dfs(dfs, to, step + 1); &#125; &#125;; dfs(dfs, 0, 0); return res;&#125; 123456789101112131415161718192021// 动态规划解法// 假设当前我们已经走了 i 步, 所在位置为 j, 那么剩余 k - j 步, 能否到达位置 n - 1// 仅取决于 [剩余步数 k - i] 和 [边权关系 relation], 与如何到达位置 i 无关// 对于方案数而言, 如果已经走了 i 步, 所在位置为 j, 到达位置 n - 1 的方案数仅取决于// [剩余步数 k - i], [边权关系 relation] 和 [花费 i 步到达位置 j 的方案数]// 以上分析归纳到边界 [走了 0 步, 所在位置 0] 同样成立// 这就是动态规划中需要满足的 [无后效性]// 定义 dp[i][j] 表示走了 i 步, 到达位置 j 的方案数// 最终要求 dp[k][n - 1], 初始时 dp[0][0] = 1// dp[i][j] = dp[i - 1][p] for [p, j] in relationint numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) &#123; vector&lt;vector&lt;int&gt;&gt; dp(k + 1, vector&lt;int&gt;(n)); dp[0][0] = 1; for(int i = 1; i &lt;= k; i++) &#123; for(auto&amp;&amp; edge : relation) &#123; int src = edge[0], dst = edge[1]; dp[i][dst] += dp[i - 1][src]; &#125; &#125; return dp[k][n - 1];&#125; 313. 超级丑数 编写一段程序来查找第n个超级丑数。超级丑数是指其所有质因数都是长度为k的质数列表primes中的正整数。 示例： 1234输入: n &#x3D; 12, primes &#x3D; [2,7,13,19]输出: 32 解释: 给定长度为 4 的质数列表 primes &#x3D; [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 说明： 1是任何给定primes的超级丑数； 给定primes中的数字以升序排列。 12345678910111213// 利用 set 的去重和有序特性int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; set&lt;long&gt; uglys; long res = 1; for(int i = 1; i &lt; n; i++) &#123; for(int prime : primes) &#123; uglys.insert(prime * res); &#125; res = *uglys.begin(); uglys.erase(res); &#125; return res;&#125; 12345678910111213141516171819// 动态规划: 多指针int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; int k = primes.size(); vector&lt;int&gt; p(k); vector&lt;int&gt; su(n); su[0] = 1; for(int i = 1; i &lt; n; i++) &#123; su[i] = INT_MAX; for(int j = 0; j &lt; k; j++) &#123; su[i] = min(su[i], primes[j] * su[p[j]]); &#125; for(int j = 0; j &lt; k; j++) &#123; if(su[i] == primes[j] * su[p[j]]) &#123; p[j]++; &#125; &#125; &#125; return su[n - 1];&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 263. 丑数//https://leetcode-cn.com/problems/ugly-number/bool isUgly(int n) &#123; if(n &lt;= 0) &#123; return false; &#125; for(int factor : &#123;2, 3, 5&#125;) &#123; while(n % factor == 0) &#123; n /= factor; &#125; &#125; return n == 1;&#125;// 264. 丑数II// https://leetcode-cn.com/problems/ugly-number-ii/// 使用 set 的自动排序与降重功能// 时间复杂度为外围的 n 次循环 O(n)// 内部 set 的插入和删除操作都是 O(logn)// 所以时间复杂度总共是 O(nlogn)// 空间复杂度总共为 set 使用的 O(n)int nthUglyNumber(int n) &#123; set&lt;long&gt; setting; long res = 1; while(--n &gt; 0) &#123; setting.insert(res * 2); setting.insert(res * 3); setting.insert(res * 5); // 每次取出最小的丑数用于下一次循环 res = *setting.begin(); // 取出来之后它就没用了, 及时剔除 setting.erase(res); &#125; return res;&#125;// 使用动态规划: 三指针// p2 代表的是第几个数的 2 倍// p3 代表的是第几个数的 3 倍// p5 代表的是第几个数的 5 倍// 时间复杂度就只有外层的 n 次循环 O(n)// 空间复杂度为 O(n)int nthUglyNumber(int n) &#123; vector&lt;int&gt; u(n); u[0] = 1; int p2 = 0, p3 = 0, p5 = 0; for(int i = 1; i &lt; n; i++) &#123; u[i] = min(&#123;2 * u[p2], 3 * u[p3], 5 * u[p5]&#125;); if(u[i] == 2 * u[p2]) &#123; p2++; &#125; if(u[i] == 3 * u[p3]) &#123; p3++; &#125; if(u[i] == 5 * u[p5]) &#123; p5++; &#125; &#125; return u[n - 1];&#125;// 助你理解一:/*这段代码两个关键点.1. 每次对计算出三个丑数并取最小，这里需要计算三个丑数，一定有两个丑数是在上一次中就已经被计算并比较过的, 因为较大所以被筛掉了两个（这两个进入下次比较中）, 留下较小的那个, 并自增一次最小值的下标 i, 使得参与下次计算时能稍微增大, 并同该次比较中淘汰的两个稍大数比较, 经过这样的不断比较 + 迭代, 能保证结果集是按从小到大的2. 自增每次的最小丑数值的下标, 这么做一是可以迭代避免重复计算, 从而避免出现重复值, 二是避免遗漏. 因为按照最直接的理解与解法, 每个数都需分别 *2、*3、*5 加入数组, 历经n次，最后再排序，但通过设置三个从 0 开始的下标, 使其对应的值分别只与 2 或 3 或 5 相乘, 而每个下标都有机会迭代, 这样可以保证数组中的每个数实际都是分别与 2、3、5 乘一次, 数组中的前四个数是 1,2,3,5, 后面的数都是由前面的数分别与 2、3、5 相乘计算出来的, 这样也满足了丑数的定义, 并且每次计算的数都是先排序再加入的, 如此可以避免不漏且排序. 而不重是通过三个 if 判断解决的, 因为假如一个数既可通过 *2 得到又可以通过 *3 得到, 此时必然会重复计算并重复加入到数组, 因此此时需要既迭代 2 对应的下标 p2, 也迭代 3 对应的下标 p3, 所以 if 如果换成 if-else, 必然会有大量重复值出现.*/// 助你理解二:/* 动态规划方法对于三指针的解释令人费解, 实际上这三个指针是用于对三个子序列归并排序的.1. 令 nums 为升序的全部丑数序列, nums[n - 1] 即为所求, 初始只有一个元素 1, 即 nums[0] 为 1.2. 根据丑数的定义可知, 除 1 外其他丑数都可以通过更小的丑数乘以 2、3、5 得到, 因此由 nums 可生成三个有序丑数子序列 nums_j, j 为 2、3、5. nums_j 元素生成规则为 nums[p_j] * j, p_j 为指向 nums 元素的指针,对这三个有序丑数子序列进行归并排序可以求得 nums 中的其他元素.3. nums 和三个子序列 nums_j 的元素都是动态生成的, 且生成 nums_j 的规则 nums[p_j] * j 中 j 是固定的, 不必预先创建出三个完整的子序列，只需维护三个指向 nums 的指针 p_j 用于归并排序即可.4. 归并排序每生成一个最小丑数 min 时，将 min 追加到 nums 中, 然后生成 min 所在子序列 nums_j 的下一个元素, 即将 p_j 右移，pj++, 注意 min 可能同时存在于多个子序列，需要同时右移 p_j, 避免产生重复元素.5. nums 每追加一个丑数后, pj 只可能右移 1 个位置, 所以不会发生越界的情况.*/","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"牛客2021年4月15号模拟笔试题","date":"2021-04-17T13:35:42.000Z","path":"ZUdtS6UUmrVCKLed/","text":"前两天在牛客网做了模拟笔试题，有两道感觉挺有意思的，这里总结一下。其中一道题稍微修改了点条件，进阶一下。 特么的我都不想说，其实这修改的条件是我笔试时没读清题，直接往难了去想的，就没做出来（呜呜呜，哭晕在厕所）。以后做题一定要审清题啊！！！ 第1题 牛牛和牛妹最近迷上了新版消消看，该游戏规则如下： 在一个01串中，每一轮，玩家都可以选择一串连续相同字符进行消除，消除之后，左右两侧剩余的字符自动拼接，重新形成一个字符串。 例如，在101001中，牛牛选择了第四个和第五个字符，它们连续且都是0，满足消除条件，而当它们消除之后，左侧剩余的101和右侧剩余的1会拼接到一起，即，消除后剩余的01串为：1011。 计分规则如下：消除了几个1就计几分。允许消除单个字符，因此，直到消成空串时游戏结束。 对于给定的01串，由牛妹先手进行消除，两个人都以最优策略且以得分高为目标进行消除，请问最后，哪个人的得分会比较高？返回一个二元数组，分别是先手得分和后者得分。 进阶：如果不允许只消除单个字符，也就是说，直到消成没有连续的1或0后游戏就结束。 例子1： 123输入: s &#x3D; &quot;0110110101001111&quot;输出: [7, 3]解释: 先手得分为 4 + 2 + 1 &#x3D; 7, 后手得分为 2 + 1 &#x3D; 3 进阶的例子2： 123456789输入: s &#x3D; &quot;011011001001001111&quot;输出: [8, 2]解释: 先手得分为 4 + 2 + 2 &#x3D; 8, 后手得分为 2原始串 --&gt; 011011001001001111 消 1 --&gt; 000000001001000000 得分：6, 2后手消 0 --&gt; 1001000000 得分：6, 2先手消 0 --&gt; 1001 得分：6, 2后手消 0 --&gt; 11 得分：6, 2 消 1 --&gt; 00 得分：8, 2 12345678910111213141516171819202122232425262728293031323334353637// 对于允许消除单个字符的情况// 1. 先消除 1, 先手必定选择先消除最长的 1 串// 2. 后手同样如此, 如此交替下去, 直到串中没有 1// 3. 此时剩下的全为 0, 消除也不得分// 因此, 只需要统计串中连续 1 的个数组成数组// 对数组排序, 偶数索引的值累加为先手的得分// 奇数索引的值累加为后手的得分vector&lt;int&gt; eliminate_01_series(string series)&#123; vector&lt;int&gt; scores(2); vector&lt;int&gt; ones = countOnes(series); sort(ones.begin(), ones.end(), greater&lt;int&gt;()); for(int i = 0; i &lt; ones.size(); i += 2) scores[0] += ones[i]; for(int i = 1; i &lt; ones.size(); i += 2) scores[1] += ones[i]; return scores;&#125;vector&lt;int&gt; countOnes(string series)&#123; vector&lt;int&gt; ones; int left = 0, right = 0; while(right &lt; series.size()) &#123; if(series[right] == '1') &#123; left = right; while(right &lt; series.size() &amp;&amp; series[right] != '0') right++; ones.push_back(right - left); &#125; else right++; &#125; return ones;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// (也可能是我想复杂了, 如果你有更简单的方法一定告诉我!)/*不允许消除单个字符的话，情况就复杂的多了1. 先按照上题的方案双方先消 1 (消连续 1 的时候有个小技巧, 不实际地把串中连续的 1 擦除, 而把这些 1 反转为 0 即可), 消完 1 之后再开始消连续的 02. 这时候要根据上次消 1 时的 (1 的个数的数组) 的 (连续多个 1) 的个数奇偶性 来判断谁先消 0 (奇数话就是原先的后手先消 0，偶数的话是原先的先手先消 0)3. 因为消 0 又不得分. 消一次 0, 在串中实际地擦除 0, 得新串, 对新串递归调用回到第 1 步4. 擦除 0 的时候还要注意, 对于这样的串 0001000101000 优先从最前面或最后面擦除 可让对手不得分下面是调试输出原始串 --&gt; 00111010011100101001010010010000111011 消 1 --&gt; 00000010000000101001010010010000000000 得分：6, 5先手消 0 --&gt; 10000000101001010010010000000000 得分：6, 5后手消 0 --&gt; 1000000010100101001001 得分：6, 5先手消 0 --&gt; 110100101001001 得分：6, 5 消 1 --&gt; 000100101001001 得分：6, 7先手消 0 --&gt; 100101001001 得分：6, 7后手消 0 --&gt; 1001010011 得分：6, 7 消 1 --&gt; 1001010000 得分：8, 7后手消 0 --&gt; 100101 得分：8, 7先手消 0 --&gt; 1101 得分：8, 7 消 1 --&gt; 0001 得分：8, 9先手消 0 --&gt; 1 得分：8, 9下面具体看代码注释*/vector&lt;int&gt; eliminate_01_series(string series)&#123; // 得分数组, [先手得分, 后手得分] vector&lt;int&gt; scores(2); // 调试代码 cout &lt;&lt; \"原始串 --&gt; \" &lt;&lt; series &lt;&lt; endl; helper(series, scores, 0); return scores;&#125;// series 为当前串// flag == 0 表示本次先手先消, flag == 1 表示本次后手先消void helper(string series, vector&lt;int&gt; &amp;scores, int flag)&#123; // 首先计算串中 1 的个数数组, 注意返回的是一个 pair 数组 // pair 中的元素为 &#123;连续 1 的个数, 对应在串中的起始索引&#125; vector&lt;pair&lt;int, int&gt;&gt; ones = countContinuousChar(series, '1'); // 没有 1 就直接返回, 再消也不得分了 if(ones.empty()) return; // 排序, 从大到小 sort(ones.begin(), ones.end(), greater&lt;pair&lt;int, int&gt;&gt;()); // 如果有多个连续的 1 进入 // 没有的话说明这时该消 0 了, 跳过下一步 if(ones.front().first &gt; 1) &#123; int i = 0; // 偶数索引元素之和为先手得分 for (; i &lt; ones.size() &amp;&amp; ones[i].first &gt; 1; i += 2) &#123; scores[flag] += ones[i].first; turnToZeros(series, ones[i].second, ones[i].first); &#125; int j = 1; // 奇数索引元素之和为先手得分 for (; j &lt; ones.size() &amp;&amp; ones[j].first &gt; 1; j += 2) &#123; scores[1 - flag] += ones[j].first; turnToZeros(series, ones[j].second, ones[j].first); &#125; // 调试代码 cout &lt;&lt; \" 消 1 --&gt; \" &lt;&lt; series &lt;&lt; \" 得分：\" &lt;&lt; scores[0] &lt;&lt; \", \" &lt;&lt; scores[1] &lt;&lt; endl; // 判断先后手是否转换 if(i &gt; j) flag = 1 - flag; helper(series, scores, flag); return; &#125; // 到这里说明串中没有连续的 1 了 // 计算 0 串的个数数组 vector&lt;pair&lt;int, int&gt;&gt; zeros = countContinuousChar(series, '0'); // 如果为空直接返回 if(zeros.empty()) return; sort(zeros.begin(), zeros.end(), greater&lt;pair&lt;int, int&gt;&gt;()); // 如果有连续的 0 if(zeros.front().first &gt; 1) &#123; // 优先擦除从 0 索引起始的或最后结尾的 0 串 // 因为这样可以让下次对手不得分 // 比如 0001001000 的情况 if(series[0] == '0' &amp;&amp; series[1] == '0') series.erase(0, series.find_first_of('1')); else if(series[series.size() - 2] == '0' &amp;&amp; series[series.size() - 1] == '0') series.erase(series.find_last_of('1') + 1); else // 否则擦除中间任何 0 串都一样 series.erase(zeros.front().second, zeros.front().first); // 调试代码 if(flag == 0) cout &lt;&lt; \"先手消 0 --&gt; \" &lt;&lt; series &lt;&lt; \" 得分：\" &lt;&lt; scores[0] &lt;&lt; \", \" &lt;&lt; scores[1] &lt;&lt; endl; else cout &lt;&lt; \"后手消 0 --&gt; \" &lt;&lt; series &lt;&lt; \" 得分：\" &lt;&lt; scores[0] &lt;&lt; \", \" &lt;&lt; scores[1] &lt;&lt; endl; // 注意这里始终要先后手转换 helper(series, scores, 1 - flag); &#125; // 如果也没有连续的 0, 那就游戏结束&#125;vector&lt;pair&lt;int, int&gt;&gt; countContinuousChar(string series, char c)&#123; vector&lt;pair&lt;int, int&gt;&gt; ones; int left = 0, right = 0; while(right &lt; series.size()) &#123; if(series[right] == c) &#123; left = right; while(right &lt; series.size() &amp;&amp; series[right] != ('0' + '1' - c)) right++; ones.push_back(&#123;right - left, left&#125;); &#125; else right++; &#125; return ones;&#125;void turnToZeros(string&amp; series, int pos, int len)&#123; for(int i = 0; i &lt; len; i++) series[pos + i] = '0';&#125; 第2题 西部世界有n个赏金猎人，每个赏金猎人都有两个属性战斗里和所拥有金钱。attack[i]和money[i]分别表示第i个赏金猎人的战斗力和所拥有金钱，保证每个赏金猎人的战斗力不相同。每个赏金猎人都只有k发子弹，这意味着他最多可以击败k个战斗力比他小的赏金猎人并获取他们的金钱。输出每一个赏金猎人最多拥有多少金钱。 Constraints: 1 &lt;= n &lt;= 10^5^, 0 &lt;= k &lt;= min(n - 1, 10). 1 &lt;= attack[i], money[i] &lt;= 10^9^. 1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; maxMoney(vector&lt;int&gt; &amp;attack, vector&lt;int&gt; &amp;money, int k)&#123; // 记录每个赏金猎人的战斗里和他所对应的索引 // 并利用其自动排序的特性 // 对赏金猎人的战斗力进行排序 // 这样在遍历的时候就能保证之前遍历的都是比他战斗力小的 map&lt;int, int&gt; mapping; for(int i = 0; i &lt; attack.size(); i++) mapping[attack[i]] = i; // 返回金钱数组里初始化为自身拥有的本金 vector&lt;int&gt; res(money); // 维护一个最小堆, 堆固定大小为 k // 最多存储 k 个比当前赏金猎人的战斗力小的赏金猎人 vector&lt;int&gt; heap; for(auto&amp; p : mapping) &#123; // 如果堆不为空的话, 堆里的金钱数就是当前赏金猎人增加的金钱数 // 因为排序后遍历的原因, 堆里的猎人的战斗力都比他小 if(!heap.empty()) res[p.second] += accumulate(heap.begin(), heap.end(), 0); // 定制成最小堆 heap.push_back(money[p.second]); push_heap(heap.begin(), heap.end(), greater&lt;int&gt;()); if(heap.size() &gt; k) &#123; pop_heap(heap.begin(), heap.end(), greater&lt;int&gt;()); heap.pop_back(); &#125; &#125; return res;&#125; 123456789101112131415161718192021222324252627282930313233343536// 使用用优先级队列做为堆// 使用一个整数变量 sum 时刻保持为堆内元素总和// 这样代码更简单, 还不用每次求堆内元素和vector&lt;int&gt; maxMoney(vector&lt;int&gt; &amp;attack, vector&lt;int&gt; &amp;money, int k)&#123; // 记录每个赏金猎人的战斗里和他所对应的索引 // 并利用其自动排序的特性 // 对赏金猎人的战斗力进行排序 // 这样在遍历的时候就能保证之前遍历的都是比他战斗力小的 map&lt;int, int&gt; mapping; for(int i = 0; i &lt; attack.size(); i++) mapping[attack[i]] = i; // 返回金钱数组里初始化为自身拥有的本金 vector&lt;int&gt; res(money); // 维护一个最小堆, 堆固定大小为 k // 最多存储 k 个比当前赏金猎人的战斗力小的赏金猎人 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; int sum = 0; // 堆内元素总和 for(auto &amp;p : mapping) &#123; // 如果堆不为空的话, 堆里的金钱数就是当前赏金猎人增加的金钱数 // 因为排序后遍历的原因, 堆里的猎人的战斗力都比他小 if(!heap.empty()) res[p.second] += sum; // 定制成最小堆 sum += money[p.second]; heap.push(money[p.second]); if(heap.size() &gt; k) &#123; sum -= heap.top(); heap.pop(); &#125; &#125; return res;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"leetcode刷题系列之数组","date":"2021-04-10T13:35:42.000Z","path":"qD0F57Dbj7HjnZou/","text":"这篇文章是leetcode刷题系列的第1部分——数组。这里把有代表性的题目发出来，共计82道。主要涉及滑动窗口、哈希表、堆、二分搜索、扫描线、区间相关、拓扑排序、树状数组等算法。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！ 167. 两数之和 II - 输入有序数组 给定一个有序整数数组和一个目标数，在数组中找到总和等于目标数的两个元素，返回它们的索引。 Example: 123Input: numbers &#x3D; [2,7,11,15], target &#x3D; 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 &#x3D; 1, index2 &#x3D; 2. 12345678910111213141516171819// 左右指针vector&lt;int&gt; twoSum(vector&lt;int&gt; nums, int target) &#123; int n = nums.size(); int left = 0; int right = n - 1; while(left &lt; right) &#123; int sum = nums[left] + nums[right]; if(sum == target) &#123; return &#123;left + 1, right + 1&#125;; &#125; else if(sum &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; return &#123;&#125;;&#125; 1. 两数之和 给定一个无序整数数组和一个目标数，在数组中找到总和等于目标数的两个元素，返回它们的索引。 Example: 12Input: nums &#x3D; [3,2,4], target &#x3D; 6Output: [1,2] 12345678910111213// 借助 hashtable 记录元素的存在情况vector&lt;int&gt; twoSum(vector&lt;int&gt; nums, int target) &#123; unordered_map&lt;int, int&gt; mapping; for(int i = 0; i &lt; nums.size(); i++) &#123; if(mapping.count(target - nums[i])) &#123; return &#123;mapping[target - nums[i]], i&#125;; &#125; else &#123; mapping[nums[i]] = i; &#125; &#125; return &#123;&#125;;&#125; 560. Subarray Sum Equals K 给定一个整数数组和一个目标数，返回数组中其总和等于目标数的连续子数组的个数。 Example: 12Input: nums &#x3D; [1,1,1], k &#x3D; 2Output: 2 12345678910111213141516// 因为这题数组中可以存在负数, 所有不能使用滑动窗口方法// 暴力解法 超时int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); int res = 0; for(int i = 0; i &lt; n; i++) &#123; int sum = 0; for(int j = i; j &lt; n; j++) &#123; sum += nums[j]; if(sum == k) &#123; res++; &#125; &#125; &#125; return res;&#125; 123456789101112131415161718// 借助前缀和思想// 使用 hashtable 记录所有的前缀和及其对应的数目int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); unordered_map&lt;int, int&gt; mapping; int res = 0, sum = 0; // 必须存在的 base case // 表示 sum 直接等于 k 的情况 mapping[0] = 1; for(int i = 0; i &lt; n; i++) &#123; sum += nums[i]; if(mapping.count(sum - k)) &#123; res += mapping[sum - k]; &#125; mapping[sum]++; &#125; return res;&#125; 724. Find Pivot Index 给定一个整数数组，请计算该数组的枢轴索引。枢轴索引使得该索引左侧的所有数字的总和等于在该索引右侧的所有数字的总和。 如果索引在数组的左边缘，则左总和为0，因为左侧没有元素，这也适用于数组的右边缘。如果存在多个枢轴索引，返回最左边的。 如果不存在这样的索引，则返回-1。 Example 1: 123456Input: nums &#x3D; [1,7,3,6,5,6]Output: 3Explanation:The pivot index is 3.Left sum &#x3D; nums[0] + nums[1] + nums[2] &#x3D; 1 + 7 + 3 &#x3D; 11Right sum &#x3D; nums[4] + nums[5] &#x3D; 5 + 6 &#x3D; 11 Example 2: 1234Input: nums &#x3D; [1,2,3]Output: -1Explanation:There is no index that satisfies the conditions in the problem statement. Example 3: 123456Input: nums &#x3D; [2,1,-1]Output: 0Explanation:The pivot index is 0.Left sum &#x3D; 0 (no elements to the left of index 0)Right sum &#x3D; nums[1] + nums[2] &#x3D; 1 + -1 &#x3D; 0 12345678910111213141516// T: O(N), S: O(N)int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; prefix(n + 1); // 计算前缀和数组 // 子数组和 nums[i..j] = prefix[j + 1] - prefix[i] for(int i = 0; i &lt; n; i++) &#123; prefix[i + 1] = prefix[i] + nums[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; if((prefix[i] - prefix[0]) == (prefix[n] - prefix[i + 1])) &#123; return i; &#125; &#125; return -1;&#125; 12345678910111213// T: O(N), S: O(1)int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int sum = accumulate(nums.begin(), nums.end(), 0); int leftSum = 0; for(int i = 0; i &lt; n; i++) &#123; if(sum - leftSum - nums[i] == leftSum) &#123; return i; &#125; leftSum += nums[i]; &#125; return -1;&#125; 523. Continuous Subarray Sum 给定一个非负整数数组和目标整数k，编写一个函数以检查该数组是否具有大小至少为2的连续子数组，该子数组的总和为k的倍数。 Example 1: 123&gt;Input: [23, 2, 4, 6, 7], k &#x3D; 6&gt;Output: True&gt;Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6. Example 2: 123&gt;Input: [23, 2, 6, 4, 7], k &#x3D; 6&gt;Output: True&gt;Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42. 12345678910111213141516171819202122232425262728// 基本数学知识 (a - b) % c = 0 --&gt; a % c = b % c// 借助前缀和思想// 使用哈希表记录所有的 (前缀和对 k 的余数) 及其 (对应的索引)bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); unordered_map&lt;int, int&gt; mapping; int sum = 0; // 必须存在的 base case // 为了处理 sum 本身 对 k 取余为 0 的情况 // 也就是说这时满足条件的数组是首元素打头的子数组 mapping[0] = -1; for(int i = 0; i &lt; n; i++) &#123; sum += nums[i]; int mod = sum % k; // 记住对于前缀和数组 // 子数组和 nums[i..j] = prefixSum[j + 1] - prefixSum[i] // 就理解了为什么是 &gt; 1 而不是 &gt;= 1 了 if(mapping.count(mod)) &#123; if(i - mapping[mod] &gt; 1) &#123; return true; &#125; &#125; else &#123; mapping[mod] = i; &#125; &#125; return false;&#125; 1089. 复写零 给定固定长度的整数数组arr，请复制每次出现的零，将其余元素向右移动。请注意，不会写入超出原始数组长度的元素。 对输入数组进行就地修改，不要从函数中返回任何内容。 Example 1: 123Input: [1,0,2,3,0,4,5,0]Output: nullExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] Example 2: 123Input: [1,2,3]Output: nullExplanation: After calling your function, the input array is modified to: [1,2,3] 12345678910111213141516171819202122232425262728293031// 好的解法, 时间复杂度为 O(n)void duplicateZeros(vector&lt;int&gt; &amp;arr) &#123; int n = arr.size(); // 提前计算出原始数组中 0 的个数 int zerosCnt = count(arr.begin(), arr.end(), 0); if(zerosCnt == 0) &#123; return; &#125; for(int i = n - 1; i &gt;= 0; i--) &#123; if(arr[i] != 0) &#123; // 计算非零元素的新索引 // 在此处, 保证 zerosCnt 变量始终是大于 0 的 // 且表示此非零元素前面的 0 的个数 int newPos = i + zerosCnt; // 如果有效就搬过去 if(newPos &lt; n) &#123; arr[newPos] = arr[i]; &#125; // 原索引处赋 0 arr[i] = 0; &#125; else &#123; // 每次遇到一个 0, 就减 1 zerosCnt--; // 前面没有 0 了, 就不需要搬移了 if(zerosCnt == 0) &#123; break; &#125; &#125; &#125;&#125; 941. Valid Mountain Array 给定一个整数数组arr，当且仅当它是有效的山峰数组时，才返回true。当且仅当满足以下条件时，arr是一个山峰数组： arr.size() &gt;= 3 There exists some i with 0 &lt; i &lt; arr.size() - 1 such that： arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.size() - 1] Example 1: 12Input: arr &#x3D; [2,1]Output: false Example 2: 12Input: arr &#x3D; [3,5,5]Output: false Example 3: 12Input: arr &#x3D; [0,3,2,1]Output: true 123456789101112131415161718// 直接模拟就行bool validMountainArray(vector&lt;int&gt;&amp; arr) &#123; int n = arr.size(); int i = 0; // 递增扫描 while(i + 1 &lt; n &amp;&amp; arr[i] &lt; arr[i + 1]) &#123; i++; &#125; // 最高点不能是数组的第一个位置或最后一个位置 if(i == 0 || i == n - 1) &#123; return false; &#125; // 递减扫描 while(i + 1 &lt; n &amp;&amp; arr[i] &gt; arr[i + 1]) &#123; i++; &#125; return i == n - 1;&#125; 448. Find All Numbers Disappeared in an Array 给定一个整数数组，其中1 ≤ a[i] ≤ n (n = 数组大小)，某些元素出现两次，而另一些元素出现一次。查找[1，n]包含的所有未出现在此数组中的元素。 Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 123456789101112131415161718vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // 将所有出现过的值作为索引 (值减 1 ), 将该索引所在处的值映射为负数 for(int i = 0; i &lt; n; i++) &#123; int index = abs(nums[i]) - 1; if(nums[index] &gt; 0) &#123; nums[index] = -nums[index]; &#125; &#125; vector&lt;int&gt; res; // 最后没被映射为负数的值, 其对应的索引 +1 就是未出现的值 for(int i = 0; i &lt; n; i++) &#123; if(nums[i] &gt; 0) &#123; res.push_back(i + 1); &#125; &#125; return res;&#125; 442. Find All Duplicates in an Array 给定一个整数数组，即1 ≤ a[i] ≤ n (n = 数组大小)，其中有些元素出现两次而其他元素出现一次。找到所有出现两次的元素。 Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[2,3] 123456789101112131415vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; // 将所有出现过的值作为索引 (值减 1 ), 将该索引所在处的值映射为负数 for(int i = 0; i &lt; nums.size(); i++) &#123; int index = abs(nums[i]) - 1; // 如果已经被映射为负数, 说明之前这个数出现过一次了 if(nums[index] &lt; 0) &#123; res.push_back(index + 1); &#125; else &#123; nums[index] = -nums[index]; &#125; &#125; return res;&#125; 1744. Can You Eat Your Favorite Candy on Your Favorite Day? 给你一个下标从0开始的正整数数组candiesCount，其中candiesCount[i]表示你拥有的第i类糖果的数目。同时给你一个二维数组queries，其中queries[i] = [favoriteTypei, favoriteDayi, dailyCapi]。 你按照如下规则进行一场游戏： 你从第0天开始吃糖果。 你在吃完所有第i - 1类糖果之前，不能吃任何一颗第i类糖果。 在吃完所有糖果之前，你必须每天至少吃一颗糖果。 请你构建一个布尔型数组answer，满足answer.length == queries.length。answer[i]为true的条件是：在每天吃不超过dailyCap_i颗糖果的前提下，你可以在第favoriteDay_i天吃到第favoriteType_i类糖果；否则answer[i]为false。注意，只要满足上面3条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。 请你返回得到的数组answer。 示例： 123456输入：candiesCount &#x3D; [7,4,5,3,8], queries &#x3D; [[0,2,2],[4,2,4],[2,13,1000000000]]输出：[true,false,true]提示：1. 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果2. 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果3. 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果 12345678910111213141516171819202122232425// 前缀和 + 区间交集// 对每一颗糖果依次进行编号vector&lt;bool&gt; canEat(vector&lt;int&gt; candiesCount, vector&lt;vector&lt;int&gt;&gt; queries)&#123; int n = candiesCount.size(); // 用 long 防止后面的乘法和加法溢出 vector&lt;long&gt; prefixSum(n + 1); for(int i = 1; i &lt;= n; i++) prefixSum[i] = prefixSum[i - 1] + candiesCount[i - 1]; vector&lt;bool&gt; res; res.reserve(queries.size()); for(auto &amp;query : queries) &#123; // 每天至少吃 1 颗, 至多吃 query[2] 颗 // 因此在第 query[1] 天能吃到的糖果的编号范围是 [x1, y1] long x1 = query[1] + 1; long y1 = long((query[1] + 1)) * query[2]; // 类型为 query[0] 的糖果的编号范围为 [x2, y2] long x2 = prefixSum[query[0]] + 1; long y2 = prefixSum[query[0] + 1]; // 如果有交集就满足条件 res.push_back(x1 &lt;= y2 &amp;&amp; x2 &lt;= y1); &#125; return res;&#125; 710. 黑名单中的随机数 给你输入一个正整数N，代表左闭右开区间[0,N)，再给你输入一个数组blacklist，其中包含一些「黑名单数字」，且blacklist中的数字都是区间[0,N)中的数字。 编写一个函数以随机返回[0，N)中的一个整数，该整数不在blacklist中。 123456789101112131415161718192021222324252627282930313233343536373839// 基本思路是记录下实际有效的数字的个数 actual// 通过一个哈希表将黑名单中的在 [0, actual) 范围内的数字映射到 [actual N) 中不在黑名单中的数字身上class Solution &#123;private: int actual; unordered_map&lt;int, int&gt; mapping; public: Solution(int N, vector&lt;int&gt;&amp; blacklist) &#123; // 先把黑名单中的所有数字放在哈希表中 // 便于快速得到 [actual, N) 范围内的数字是否在黑名单中 for(int val : blacklist) &#123; mapping[val] = 0; &#125; actual = N - blacklist.size(); for(int val : blacklist) &#123; // 黑名单中在 [0, actual) 范围内的数字才需要映射 if(val &lt; actual) &#123; N--; // 从后向前映射 // 如果映射为的数字已经在黑名单中了 // 就跳过 while(mapping.count(N)) &#123; N--; &#125; mapping[val] = N; &#125; &#125; &#125; int pick() &#123; int i = rand() % actual; // 如果这个数字在黑名单中, 需要返回其映射 if(mapping.count(i) &gt; 0) &#123; return mapping[i]; &#125; return i; &#125;&#125;; 528. Random Pick with Weight 给定一个正整数数组w，其中w[i]描述第i个索引的权重。 我们需要调用函数pickIndex()，该函数随机返回范围为[0，w.size())的整数。 pickIndex()应该返回与其在w数组中的权重成比例的数。 例如，对于w = [1，3]，选择索引0的概率为1 / (1 + 3) = 0.25，而选择索引1的概率为3 / (1 + 3) = 0.75。或者说，选择索引i的概率为w[i] / sum(w)。 1234567891011121314151617181920212223242526272829303132333435363738// 采用前缀和数组// 从 [0, sum(w)) 区间内随机产生一个数// 看这个随机数落在前缀和数组的哪个区间内// 比如 w = &#123;1, 4, 7, 2&#125;;// prefixSum = &#123;0, 1, 5, 12, 14&#125;;// 从 [0, 14) 区间内随机产生一个数// 落在 [0, 1) 区间返回 0// 落在 [1, 5) 区间返回 1// 落在 [5, 12) 区间返回 2// 落在 [12, 14) 区间返回 3class Solution &#123;private: vector&lt;int&gt; prefixSum; public: Solution(vector&lt;int&gt;&amp; w) : prefixSum(w.size() + 1) &#123; for(int i = 0; i &lt; w.size(); i++) &#123; prefixSum[i + 1] = prefixSum[i] + w[i]; &#125; &#125; int pickIndex() &#123; int target = rand() % prefixSum.back(); // 通过二分搜索加快搜索速度 // 右边界搜索第一个大于目标值的索引 int lo = 0, hi = prefixSum.size(); while(lo &lt; hi) &#123; int mi = (hi + lo) / 2; if(prefixSum[mi] &lt;= target) &#123; lo = mi + 1; &#125; else &#123; hi = mi; &#125; &#125; return lo - 1; &#125;&#125;; 11. Container With Most Water 给你n个非负整数a1, a2, ..., an，每个数代表坐标中的一个点(i, ai) 。在坐标内画n条垂直线，垂直线i的两个端点分别为(i, ai)和(i, 0) 。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。 返回容纳的水量。 Example: 123Input: height &#x3D; [1,8,6,2,5,4,8,3,7]Output: 49Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. 12345678910111213141516171819int maxArea(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); // 左右指针解法 int left = 0, right = n - 1; int res = 0; while(left &lt; right) &#123; if(height[left] &lt;= height[right]) &#123; res = max(res, (right - left) * height[left]); // 小的变化, 大的不变 left++; &#125; else &#123; res = max(res, (right - left) * height[right]); // 小的变化, 大的不变 right--; &#125; &#125; return res;&#125; 42. Trapping Rain Water 给定n个表示海拔图的非负整数，其中每个条的宽度为1，计算下雨后它可以捕集多少水。 Example: 123Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. 123456789101112131415161718192021222324252627282930// 对于每一个槽, 它所能接的水量取决于它左边最高的柱子和右边最高的柱子中的较低者// 较低的值减去自身的高度就为该槽所能接的水量// 使用了备忘录的方法// 提前计算出每个槽左边最高的柱子和右边最高的柱子(包括它自己的高度)// left_max[i] 表示第 i 个槽左边最高的柱子的高度// right_max[i] 表示第 i 个槽右边最高的柱子的高度// 时间复杂度为 O(n), 但空间复杂度也为 O(n)int trap(vector&lt;int&gt;&amp; height) &#123; if(height.empty()) &#123; return 0; &#125; int n = height.size(); vector&lt;int&gt; left_max(n); vector&lt;int&gt; right_max(n); // base case left_max.front() = height.front(); right_max.back() = height.back(); for(int i = 1; i &lt; n; i++) &#123; left_max[i] = max(height[i], left_max[i - 1]); &#125; for(int i = n - 2; i &gt;= 0; i--) &#123; right_max[i] = max(height[i], right_max[i + 1]); &#125; int res = 0; for(int i = 0; i &lt; n; i++) &#123; res += min(left_max[i], right_max[i]) - height[i]; &#125; return res;&#125; 12345678910111213141516171819202122// 使用双指针解法// 边走边记录左边柱子最高值和右边柱子最高值// 优化后的时间复杂度为 O(n), 空间复杂度为 O(1)int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); int left = 0, right = n - 1; int left_max = 0, right_max = 0; int res = 0; while(left &lt; right) &#123; left_max = max(left_max, height[left]); right_max = max(right_max, height[right]); if(left_max &lt; right_max) &#123; res += left_max - height[left]; left++; &#125; else &#123; res += right_max - height[right]; right--; &#125; &#125; return res;&#125; 1395. Count Number of Teams n名士兵站成一排。每个士兵都有一个独一无二的评分rating。每3个士兵可以组成一个作战单位，分组规则如下： 从队伍中选出下标分别为i、j、k的3名士兵，他们的评分分别为rating[i]、rating[j]、rating[k]； 作战单位需满足：rating[i] &lt; rating[j] &lt; rating[k]或者rating[i] &gt; rating[j] &gt; rating[k]，其中0 &lt;= i &lt; j &lt; k &lt; n。 你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。 Example 1: 123Input: rating &#x3D; [2,5,3,4,1]Output: 3Explanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). Example 2: 123Input: rating &#x3D; [2,1,3]Output: 0Explanation: We can&#39;t form any team given the conditions. Example 3: 12Input: rating &#x3D; [1,2,3,4]Output: 4 1234567891011121314151617181920212223242526272829// 提前求得每个元素右边的比它大的元素个数和比它小的元素个数// 通过两次 O(n2) 的循环, 将时间复杂度减少到 O(n2), 但空间复杂度为 O(n)int numTeams(vector&lt;int&gt;&amp; rating) &#123; int n = rating.size(); vector&lt;int&gt; right_max(n); vector&lt;int&gt; right_min(n); for(int i = 0; i &lt; n; i++) &#123; for(int j = i + 1; j &lt; n; j++) &#123; if(rating[i] &lt; rating[j]) &#123; right_max[i]++; &#125; else &#123; right_min[i]++; &#125; &#125; &#125; int res = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = i + 1; j &lt; n; j++) &#123; if(rating[i] &lt; rating[j]) &#123; res += right_max[j]; &#125; else &#123; res += right_min[j]; &#125; &#125; &#125; return res;&#125; 1// 480. Sliding Window Median 中值是有序整数列表中的中间值。 如果列表的大小是偶数，则没有中间值，此时，中位数是两个中间值的平均值。 给定一个数组num，存在一个大小为k的滑动窗口，该窗口从数组的最左边移到最右边。 你只能在窗口中看到k个数字。 每次滑动窗口向右移动一个位置。 你的工作是输出原始数组中每个窗口的中值数组。 For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. 12345678Window position Median--------------- ------[1 3 -1] -3 5 3 6 7 11 [3 -1 -3] 5 3 6 7 -11 3 [-1 -3 5] 3 6 7 -11 3 -1 [-3 5 3] 6 7 31 3 -1 -3 [5 3 6] 7 51 3 -1 -3 5 [3 6 7] 6 Therefore, return the median sliding window as[1,-1,-1,3,5,6]. 12345678910111213141516171819202122232425262728293031vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;double&gt; median; multiset&lt;int&gt; window(nums.begin(), next(nums.begin(), k)); // k 为奇数, mid 指向中间元素, k 为偶数, mid 指向中间两个元素的后一个元素 // 之后每一次插入和删除元素都要维护 mid 正确性 auto mid = next(window.begin(), k / 2); for(int i = k; ; i++) &#123; if(k &amp; 1) &#123; median.push_back(*mid); &#125; else &#123; median.push_back((double(*prev(mid)) + double(*mid)) * 0.5); &#125; if(i == n) &#123; break; &#125; // 如果插入相同的元素 // multiset 的 insert 操作将其插入到范围上界 window.insert(nums[i]); if(nums[i] &lt; *mid) &#123; mid--; &#125; if(nums[i - k] &lt;= *mid) &#123; mid++; &#125; // 删除时从范围下界删除可保证 mid 不失效 window.erase(window.lower_bound(nums[i - k])); &#125; return median;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; if(k &amp; 1) &#123; return medianSlidingWindowForOdd(nums, k); &#125; return medianSlidingWindowForEven(nums, k);&#125;// 只考虑 k 为奇数的情况vector&lt;double&gt; medianSlidingWindowForOdd(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;double&gt; median; multiset&lt;int&gt; window(nums.begin(), next(nums.begin(), k)); // 窗口内有奇数个元素时, mid 指向中间元素 // 窗口内有偶数个元素时, mid 指向中间两个元素的后一个元素 // 之后每一次插入和删除元素都要维护 mid 正确性 auto mid = next(window.begin(), k / 2); for(int i = k; ; i++) &#123; median.push_back(*mid); if(i == nums.size()) &#123; break; &#125; // 注意, 插入前集合中的元素数为奇数个 // 如果插入相同的元素, multiset 的 insert 操作将其插入到范围上界 window.insert(nums[i]); if(nums[i] &gt;= *mid) &#123; // 如果插入在 mid 右边 ++mid; &#125; // 插入后变为偶数个元素了 if(nums[i - k] &lt; *mid) &#123; // 如果在 mid 左边删除 window.erase(window.find(nums[i - k])); &#125; else if(nums[i - k] &gt; *mid) &#123; // 如果在 mid 右边删除 window.erase(window.find(nums[i - k])); --mid; &#125; else &#123; // 如果删除的就是 mid mid = window.erase(mid); // 注意 erase 会返回删除元素的后继元素迭代器 --mid; &#125; &#125; return median;&#125;// 只考虑 k 为偶数的情况vector&lt;double&gt; medianSlidingWindowForEven(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;double&gt; median; multiset&lt;int&gt; window(nums.begin(), next(nums.begin(), k)); // 窗口内有偶数个元素时, mid 指向中间元素 // 窗口内有奇数个元素时, mid 指向中间两个元素的后一个元素 // 之后每一次插入和删除元素都要维护 mid 正确性 auto mid = next(window.begin(), k / 2); for(int i = k; ; i++) &#123; median.push_back((double(*prev(mid)) + double(*mid)) * 0.5); if(i == nums.size()) &#123; break; &#125; // 注意, 插入前集合中的元素数为偶数个 // 如果插入相同的元素, multiset 的 insert 操作将其插入到范围上界 window.insert(nums[i]); if(nums[i] &lt; *mid) &#123; // 如果插入在 mid 左边 --mid; &#125; // 插入后变为奇数个元素了 if(nums[i - k] &lt; *mid) &#123; // 如果在 mid 左边删除 window.erase(window.find(nums[i - k])); ++mid; &#125; else if(nums[i - k] &gt; *mid) &#123; // 如果在 mid 右边删除 window.erase(window.find(nums[i - k])); &#125; else &#123; // 如果删除的就是 mid mid = window.erase(mid); // 注意 erase 会返回删除元素的后继元素迭代器 &#125; &#125; return median;&#125; 239. Sliding Window Maximum 给你一个整数数组num，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的k个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 Example: 1234567891011Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3Output: [3,3,5,5,6,7]Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 31 [3 -1 -3] 5 3 6 7 31 3 [-1 -3 5] 3 6 7 51 3 -1 [-3 5 3] 6 7 51 3 -1 -3 [5 3 6] 7 61 3 -1 -3 5 [3 6 7] 7 12345678910111213141516171819202122232425262728293031323334353637383940414243// 单调队列保证从队头到队尾是递减的class MonoQ &#123;private: deque&lt;int&gt; monoQ; public: // 如果入队的值比队尾的值大, 就把队尾元素 pop 掉, 这样保证是递减的 void push(int val) &#123; while(!monoQ.empty() &amp;&amp; monoQ.back() &lt; val) &#123; monoQ.pop_back(); &#125; monoQ.push_back(val); &#125; // pop 的时候如果不是队头元素就什么也不做 void pop(int val) &#123; if(monoQ.front() == val) &#123; monoQ.pop_front(); &#125; &#125; // 最大值就是队头元素 int maxVal() &#123; return monoQ.front(); &#125;&#125;;// 维护一个大小为 k 的递减队列// 这个队列就相当于是题目中的滑动窗口// 只是单调之后取其中的最大值很方便vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; res; MonoQ monoQ; for(int i = 0; i &lt; n; i++) &#123; monoQ.push(nums[i]); // 如果窗口内的元素数等于 k if(i &gt;= k - 1) &#123; // 最大值就是队头元素 res.push_back(monoQ.maxVal()); // pop 掉最左边的将要出窗口的元素 monoQ.pop(nums[i - k + 1]); &#125; &#125; return res;&#125; 1234567891011121314151617181920// 当然也可以不先写好一个单调队列类vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; res; // 用 deque 模拟队列 deque&lt;int&gt; monoQ; for(int i = 0; i &lt; n; i++) &#123; while(!monoQ.empty() &amp;&amp; monoQ.back() &lt; nums[i]) &#123; monoQ.pop_back(); &#125; monoQ.push_back(nums[i]); if(i &gt;= k - 1) &#123; res.push_back(monoQ.front()); if(monoQ.front() == nums[i - k + 1]) &#123; monoQ.pop_front(); &#125; &#125; &#125; return res;&#125; 1834. Single-Threaded CPU 给你一个二维数组tasks，用于表示n项从0到n - 1编号的任务。其中tasks[i] = [enqueueTimei, processingTimei]意味着第i项任务将会于enqueueTimei时进入任务队列，需要processingTimei的时长完成执行。 现有一个单线程CPU，同一时间只能执行最多一项任务，该CPU将会按照下述方式运行： 如果CPU空闲，且任务队列中没有需要执行的任务，则CPU保持空闲状态。 如果CPU空闲，但任务队列中有需要执行的任务，则CPU将会选择执行时间最短的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。 一旦某项任务开始执行，CPU在执行完整个任务前都不会停止。 CPU可以在完成一项任务后，立即开始执行一项新任务。 返回CPU处理任务的顺序。 Example 1: 123456789101112&gt;Input: tasks &#x3D; [[1,2],[2,4],[3,2],[4,1]]&gt;Output: [0,2,3,1]&gt;Explanation: The events go as follows: &gt;- At time &#x3D; 1, task 0 is available to process. Available tasks &#x3D; &#123;0&#125;.&gt;- Also at time &#x3D; 1, the idle CPU starts processing task 0. Available tasks &#x3D; &#123;&#125;.&gt;- At time &#x3D; 2, task 1 is available to process. Available tasks &#x3D; &#123;1&#125;.&gt;- At time &#x3D; 3, task 2 is available to process. Available tasks &#x3D; &#123;1, 2&#125;.&gt;- Also at time &#x3D; 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks &#x3D; &#123;1&#125;.&gt;- At time &#x3D; 4, task 3 is available to process. Available tasks &#x3D; &#123;1, 3&#125;.&gt;- At time &#x3D; 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks &#x3D; &#123;1&#125;.&gt;- At time &#x3D; 6, the CPU finishes task 3 and starts processing task 1. Available tasks &#x3D; &#123;&#125;.&gt;- At time &#x3D; 10, the CPU finishes task 1 and becomes idle. Example 2: 12345678910&gt;Input: tasks &#x3D; [[7,10],[7,12],[7,5],[7,4],[7,2]]&gt;Output: [4,3,2,0,1]&gt;Explanation: The events go as follows:&gt;- At time &#x3D; 7, all the tasks become available. Available tasks &#x3D; &#123;0,1,2,3,4&#125;.&gt;- Also at time &#x3D; 7, the idle CPU starts processing task 4. Available tasks &#x3D; &#123;0,1,2,3&#125;.&gt;- At time &#x3D; 9, the CPU finishes task 4 and starts processing task 3. Available tasks &#x3D; &#123;0,1,2&#125;.&gt;- At time &#x3D; 13, the CPU finishes task 3 and starts processing task 2. Available tasks &#x3D; &#123;0,1&#125;.&gt;- At time &#x3D; 18, the CPU finishes task 2 and starts processing task 0. Available tasks &#x3D; &#123;1&#125;.&gt;- At time &#x3D; 28, the CPU finishes task 0 and starts processing task 1. Available tasks &#x3D; &#123;&#125;.&gt;- At time &#x3D; 40, the CPU finishes task 1 and becomes idle. 1234567891011121314151617181920212223242526using Pair = pair&lt;int, int&gt;;vector&lt;int&gt; getOrder(vector&lt;vector&lt;int&gt;&gt;&amp; tasks) &#123; int taskCount = tasks.size(); for(int taskId = 0; taskId &lt; taskCount; taskId++) &#123; tasks[taskId].push_back(taskId); &#125; sort(tasks.begin(), tasks.end()); vector&lt;int&gt; res; priority_queue&lt;Pair, vector&lt;Pair&gt;, greater&lt;Pair&gt;&gt; tasksQueue; int taskId = 0; long timeStamp = 0; // 时刻 while(taskId &lt; taskCount || !tasksQueue.empty()) &#123; if(tasksQueue.empty()) &#123; timeStamp = max(timeStamp, (long)tasks[taskId][0]); &#125; while(taskId &lt; taskCount &amp;&amp; tasks[taskId][0] &lt;= timeStamp) &#123; tasksQueue.push(&#123;tasks[taskId][1], tasks[taskId][2]&#125;); taskId++; &#125; auto [duration, id] = tasksQueue.top(); tasksQueue.pop(); timeStamp += duration; res.push_back(id); &#125; return res;&#125; 912. 排序数组 给你一个整数数组nums，请你将该数组升序排列。 1234567891011121314151617181920212223242526272829303132333435363738void sortArray(vector&lt;int&gt; &amp;nums) &#123; // 下滤操作, 复杂度正比于完全二叉树的高度为 log(n) // 参数 n 代表 [有效堆] 数组的长度, 可用于验证待下滤元素 hole 的左右孩子节点的合法性 auto down = [&amp;](int hole, int n) &#123; // 先保存待下滤的值, hole 代表洞号 int holeVal = nums[hole]; // 先找到待下滤元素的左孩子 for(int lc = 2 * hole + 1; lc &lt; n; lc = 2 * hole + 1) &#123; // 如果右子节点存在并且左子节点的值小于等于右子节点 if(lc + 1 &lt; n &amp;&amp; nums[lc] &lt;= nums[lc + 1]) &#123; lc++; &#125; // 此时, lc 指向孩子节点中较大的那一个 // 如果待下滤的值比孩子中较大的还大, 就不需要下滤了 if(nums[lc] &lt;= holeVal) &#123; break; &#125; nums[hole] = nums[lc]; // 产生新的洞号 hole = lc; &#125; nums[hole] = holeVal; &#125;; int n = nums.size(); // 获取末元素的父亲, 也就是最后一个内部节点 int lastInternal = (n - 1 - 1) / 2; // 建堆操作, 复杂度为 O(n) while(lastInternal &gt;= 0) &#123; down(lastInternal--, n); &#125; for(int i = n - 1; i &gt; 0; i--) &#123; // 此时最大元素是首元素 // 首尾交换, 末元素就位 swap(nums[i], nums[0]); // 将新首元素下滤 down(0, i); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 归并排序, 自顶向下递归实现vector&lt;int&gt; sortArray(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); // 排序 [0, n - 1] 之间的元素 mergeSort(nums, 0, n - 1); return nums;&#125;// 左闭右闭区间void mergeSort(vector&lt;int&gt; &amp;nums, int lo, int hi) &#123; // 单元素自动有序 if(hi - lo &lt; 1) &#123; return; &#125; int mi = lo + (hi - lo) / 2; mergeSort(nums, lo, mi); mergeSort(nums, mi + 1, hi); merge(nums, lo, mi, hi);&#125;// 左闭右闭区间// [lo, mi] 和 [mi + 1, hi] 分别是有序的void merge(vector&lt;int&gt; &amp;nums, int lo, int mi, int hi) &#123; // 辅助空间, 存储 [mi + 1, hi] 元素 vector&lt;int&gt; helper(next(nums.begin(), mi + 1), next(nums.begin(), hi + 1)); // 对两个数组中的元素, 依次从后向前比较 // 从后向前放置元素, 先放较大者 int i = mi; int j = hi - mi - 1; int k = hi; // 注意 i 的终止条件 while(i &gt;= lo &amp;&amp; j &gt;= 0) &#123; // 注意, 这里如果是 &gt;= 就不稳定了 if(nums[i] &gt; helper[j]) &#123; nums[k--] = nums[i--]; &#125; else &#123; nums[k--] = helper[j--]; &#125; &#125; while(j &gt;= 0) &#123; nums[k--] = helper[j--]; &#125;&#125;/* 归并排序, 自底向上迭代实现 */vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int sz = nums.size(); // 中间节点相对于起点的位置是 1 个 step // 终点相对于起点是 2 个 step // step 从 1 开始直到等于数组的长度 sz for(int step = 1; step &lt;= sz; step *= 2) &#123; // 注意, 这里 lo 从 0 开始直到等于 sz - 1 for(int lo = 0; lo &lt; sz; lo += 2 * step) &#123; // 因为 merge 函数实现的原因, 都是闭区间, 而且 [lo, mi] 和 [mi + 1, hi] 分别是有序的 // 所以这里求出的 mi 和 hi 都需要减 1 merge(nums, lo, min(lo + step - 1, sz - 1), min(lo + 2 * step - 1, sz - 1)); &#125; &#125; return nums;&#125; 12345678910111213141516171819202122232425262728293031323334// quick sortvector&lt;int&gt; sortArray(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); quickSort(nums, 0, n - 1); return nums;&#125;// 左闭右闭区间void quickSort(vector&lt;int&gt; &amp;nums, int lo, int hi) &#123; if(lo &gt;= hi) &#123; return; &#125; // 随机置乱闭区间 [lo, hi] 内的元素 auto shuffle = [&amp;](int lo, int hi) &#123; for(int i = lo; i &lt;= hi; i++) &#123; int j = rand() % (hi - i + 1) + i; swap(nums[i], nums[j]); &#125; &#125;; auto partition = [&amp;](int lo, int hi) &#123; shuffle(lo, hi); int i = lo, j = lo; while(++j &lt;= hi) &#123; if(nums[j] &lt;= nums[lo]) &#123; swap(nums[++i], nums[j]); &#125; &#125; swap(nums[lo], nums[i]); return i; &#125;; int pivot = partition(lo, hi); quickSort(nums, lo, pivot - 1); quickSort(nums, pivot + 1, hi);&#125; 34. Find First and Last Position of Element in Sorted Array 给定一个以升序排列的整数nums数组，请找到给定目标值的开始和结束位置。如果在数组中未找到目标，则返回[-1，-1]。 Example 1: 12Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8Output: [3,4] Example 2: 12Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6Output: [-1,-1] 1234567891011121314151617181920212223vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int left = right_bound(nums, target - 1); int right = right_bound(nums, target); if(left &lt; 0 || left &gt;= nums.size() || nums[left] != target) &#123; return &#123;-1, -1&#125;; &#125; return &#123;left, right - 1&#125;;&#125;// 右边界搜索是返回第一个大于目标值的位置int right_bound(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = nums.size(); while(lo &lt; hi) &#123; int mi = lo + (hi - lo &gt;&gt; 1); if(target &gt;= nums[mi]) &#123; lo = mi + 1; &#125; else &#123; hi = mi; &#125; &#125; return lo;&#125; 240. Search a 2D Matrix II 编写一个高效的算法来搜索m x n矩阵matrix中的一个目标值target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 Example 1: 12Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20Output: false Example 2: 12Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5Output: true 12345678910111213141516171819bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int n = matrix.size(); if(n == 0) &#123; return false; &#125; int r = 0, c = matrix[0].size() - 1; while(r &lt; n &amp;&amp; c &gt;= 0) &#123; if(target &lt; matrix[r][c]) &#123; c--; &#125; else if(target &gt; matrix[r][c]) &#123; r++; &#125; else &#123; return true; &#125; &#125; return false;&#125; 162. Find Peak Element 峰值元素是指其值严格大于左右相邻值的元素。给你一个输入数组nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设nums[-1] = nums[n] = -∞。 Example 1: 123Input: nums &#x3D; [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2. Example 2: 123Input: nums &#x3D; [1,2,1,3,5,6,4]Output: 5Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. 12345678910111213int findPeakElement(vector&lt;int&gt;&amp; nums)&#123; int lo = 0, hi = nums.size() - 1; while(lo &lt; hi) &#123; int mi = lo + (hi - lo &gt;&gt; 1); if(nums[mi] &gt; nums[mi + 1]) hi = mi; else lo = mi + 1; &#125; return lo;&#125; 658. Find K Closest Elements 给定一个排序好的数组arr，两个整数k和x，从数组中找到最靠近x（两数之差最小）的k个数。返回的结果必须要是按升序排好的。 整数a比整数b更接近x需要满足： |a - x| &lt; |b - x|或者 |a - x| == |b - x|且a &lt; b. 123456789101112131415// 按照与 x 差值的绝对值进行排序// 返回排序后数组的前 k 个元素的原始顺序即可// 时间复杂度为排序的复杂度 O(nlogn)vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x)&#123; vector&lt;int&gt; res(arr); sort(res.begin(), res.end(), [x](int a, int b) &#123; return abs(a - x) == abs(b - x) ? a &lt; b : abs(a - x) &lt; abs(b - x); &#125;); res.resize(k); sort(res.begin(), res.end()); return res;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 因为数组已经是有序的, 先通过二分搜索找到 x 在数组中的位置// 根据 x 的位置不同有几种情况vector&lt;int&gt; findClosestElements(vector&lt;int&gt; &amp;arr, int k, int x) &#123; // vector&lt;int&gt; res(k); vector&lt;int&gt; res; // 里面这段二分搜索是左边界搜索 // lo 最后指向第一个大于等于 x 的元素 int lo = 0, hi = arr.size(); while(lo &lt; hi) &#123; int mi = lo + (hi - lo &gt;&gt; 1); if(x &lt;= arr[mi]) &#123; hi = mi; &#125; else &#123; lo = mi + 1; &#125; &#125; // 如果 x 小于等于数组中的任何数, 那离 x 最近的就是前 k 个元素 if(lo == 0) &#123; // copy_n(arr.begin(), k, res.begin()); copy(arr.begin(), arr.end(), back_inserter(res)); &#125; // 如果 x 大于等于数组中的任何数, 那离 x 最近的就是后 k 个元素 else if(lo == arr.size()) &#123; // copy_n(arr.end() - k, k, res.begin()); copy(prev(arr.end(), k), arr.end(), back_inserter(res)); &#125; else &#123; // 如果在中间, 就设置两个指针 // 左右指针离 lo 的位置都为 k, 组成一个窗口 // 在窗口中移动双指针使得窗口内元素数缩减为最接近 x 的 k 个数即可 int left = max(lo - k, 0); int right = min(lo + k, int(arr.size()) - 1); while(right - left &gt; k - 1) &#123; if(abs(arr[left] - x) &lt;= abs(arr[right] - x)) &#123; right--; &#125; else &#123; left++; &#125; &#125; // copy_n(arr.begin() + left, k, res.begin()); copy(next(arr.begin(), left), next(arr.begin(), left + k), back_inserter(res)); &#125; return res;&#125; 719. Find K-th Smallest Pair Distance 给定一个整数数组，返回所有数对之间的第k个最小距离。一对(A, B) 的距离被定义为A和B之间的绝对差值。 Note: 2 &lt;= len(nums) &lt;= 10000. 0 &lt;= nums[i] &lt; 1000000. 1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2. Example: 12345678910Input:nums &#x3D; [1,3,1]k &#x3D; 1Output: 0 Explanation:Here are all the pairs:(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2Then the 1st smallest distance pair is (1,1), and its distance is 0. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 暴力解法// Time Limit Exceededint smallestDistancePair(vector&lt;int&gt;&amp; nums, int k)&#123; vector&lt;int&gt; distances; for(int i = 0; i &lt; nums.size(); i++) for(int j = i + 1; j &lt; nums.size(); j++) distances.push_back(abs(nums[i] - nums[j])); int lo = 0, hi = distances.size() - 1; while(lo &lt;= hi) &#123; int pivot = partition(distances, lo, hi); if(pivot == k - 1) return distances[pivot]; else if(pivot &lt; k - 1) lo = pivot + 1; else hi = pivot - 1; &#125; return 0;&#125;int partition(vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; int i = lo, j = lo; while(++j &lt;= hi) if(nums[j] &lt; nums[lo]) swap(nums[++i], nums[j]); swap(nums[lo], nums[i]); return i;&#125;// 用一个 multiset 实现起来更简单, 但还是 Time Limit Exceeded!int smallestDistancePair(vector&lt;int&gt;&amp; nums, int k)&#123; multiset&lt;int&gt; setting; // 因为核心在这, 计算所有的 pair 复杂度为 O(n2) for(int i = 0; i &lt; nums.size(); i++) for(int j = i + 1; j &lt; nums.size(); j++) setting.insert(abs(nums[i] - nums[j])); auto it = next(setting.begin(), k - 1); return *it;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// binary search, a good idea.// another problem, 373. Find K Pairs with Smallest Sumsint smallestDistancePair(vector&lt;int&gt;&amp; nums, int k)&#123; // 先把数组排序 sort(nums.begin(), nums.end()); // pairs 之间的差值最小无非就是 0 int lo = 0; // 最大就是尾元素减去首元素嘛 int hi = nums.back() - nums[0]; // 问题转化为在这个范围内找到一个差值 // 使得有 k - 1 个 pair 的差值不比它大 // 这种在有序的数值范围内搜索一个特定值就是典型的二分搜索的应用 while(lo &lt; hi) &#123; // 取差值的中间 int mi = lo + (hi - lo) / 2; // 下面应用一个滑动窗口算法计算有多少个比 mi 小的差值 // 不要被两个 while 循环吓到了, 实际复杂度只有 O(n), 不清楚看最下面注释 int count = 0, left = 0, right = 1; while(right &lt; nums.size()) &#123; while(nums[right] - nums[left] &gt; mi) left++; count += right - left; right++; &#125; // count == number of pairs with distance &lt;= mi if(k &lt;= count) hi = mi; else lo = mi + 1; &#125; return lo;&#125;/*1. Time Complexity:O(NlogW + NlogN), where N is the length of nums, and W is equal to nums[nums.length - 1] - nums[0]. The logW factor comes from our binary search, and we do O(N) work inside our call to possible (or to calculate count). The final O(NlogN) factor comes from sorting.2. Space Complexity: O(1). No additional space is used except for integer variables.*//*It is O(N). the possible function is a classic sliding windowing solution, left and right would always increment in each outer loop iteration, that is 'left' and 'right' sweeps elements in the array only once. So time complexity is O(2N) = O(N).*/ 373. Find K Pairs with Smallest Sums 给定两个以升序排列的整形数组nums1和nums2，以及一个整数k。 定义一对值(u,v)，其中第一个元素来自nums1，第二个元素来自nums2。 找到和最小的k对数字(u1,v1),(u2,v2)...(uk,vk)。 Constraints: 1 &lt;= nums1.length, nums2.length &lt;= 104 -109 &lt;= nums1[i], nums2[i] &lt;= 109 nums1 and nums2 both are sorted in ascending order. 1 &lt;= k &lt;= 1000 Example 1: 123Input: nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3Output: [[1,2],[1,4],[1,6]]Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: 123Input: nums1 &#x3D; [1,1,2], nums2 &#x3D; [1,2,3], k &#x3D; 2Output: [[1,1],[1,1]]Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: 123Input: nums1 &#x3D; [1,2], nums2 &#x3D; [3], k &#x3D; 3Output: [[1,3],[2,3]]Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; auto cmp = [](auto&amp; a, auto&amp; b) &#123; return a.first + a.second &lt; b.first + b.second; &#125;; vector&lt;vector&lt;int&gt;&gt; res; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; pq(cmp); for(int num1 : nums1) &#123; for(int num2 : nums2) &#123; pq.push(&#123;num1, num2&#125;); if(pq.size() &gt; k) &#123; pq.pop(); &#125; &#125; &#125; while(!pq.empty()) &#123; res.push_back(&#123;pq.top().first, pq.top().second&#125;); pq.pop(); &#125; return res;&#125; 209. Minimum Size Subarray Sum 给定一个含有n个正整数的数组和一个正整数target。 找出该数组中满足其和≥ target的长度最小的连续子数组[numsl, numsl+1, ..., numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。 Example 1: 123Input: target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]Output: 2Explanation: The subarray [4,3] has the minimal length under the problem constraint. Example 2: 12Input: target &#x3D; 4, nums &#x3D; [1,4,4]Output: 1 Example 3: 12Input: target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]Output: 0 123456789101112131415161718192021// T: O(n), S: O(n)int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums)&#123; vector&lt;int&gt; prefix(nums.size() + 1); for(int i = 0; i &lt; nums.size(); i++) prefix[i + 1] = prefix[i] + nums[i]; int left = 0, right = 0; int res = INT_MAX; while(right &lt; nums.size()) &#123; right++; while(prefix[right] - prefix[left] &gt;= target) &#123; res = min(res, right - left); left++; &#125; &#125; return res == INT_MAX ? 0 : res;&#125; 12345678910111213141516171819// T: O(n), S: O(1)int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums)&#123; int left = 0, right = 0, sum = 0; int res = INT_MAX; while(right &lt; nums.size()) &#123; sum += nums[right]; right++; while(sum &gt;= target) &#123; res = min(res, right - left); sum -= nums[left]; left++; &#125; &#125; return res == INT_MAX ? 0 : res;&#125; 12345678910111213141516171819202122232425262728293031323334353637// T: O(nlogn), S: O(n)int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums)&#123; vector&lt;int&gt; prefixSum(nums.size() + 1, 0); for(int i = 1; i &lt;= nums.size(); i++) prefixSum[i] = prefixSum[i - 1] + nums[i - 1]; int res = INT_MAX; for(int i = 0; i &lt; nums.size(); i++) &#123; int to_find = target + prefixSum[i]; // auto it = lower_bound(prefixSum.begin(), prefixSum.end(), to_find); // if(it != prefixSum.end()) // res = min(res, int(distance(prefixSum.begin(), it)) - i); int it = _lower_bound(prefixSum, to_find); if(it != prefixSum.size()) res = min(res, it - i); &#125; return res == INT_MAX ? 0 : res;&#125;int _lower_bound(vector&lt;int&gt;&amp; nums, int target)&#123; int lo = 0, hi = nums.size() - 1; while(lo &lt;= hi) &#123; int mi = lo + (hi - lo &gt;&gt; 1); if(target &lt;= nums[mi]) hi = mi - 1; else lo = mi + 1; &#125; return lo;&#125; 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit 给你一个整数数组nums，和一个表示限制的整数limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于limit。如果不存在满足条件的子数组，则返回0。 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 109 0 &lt;= limit &lt;= 109 Example 1: 1234567891011121314&gt;Input: nums &#x3D; [8,2,4,7], limit &#x3D; 4&gt;Output: 2 &gt;Explanation: All subarrays are: &gt;[8] with maximum absolute diff |8-8| &#x3D; 0 &lt;&#x3D; 4.&gt;[8,2] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4. &gt;[8,2,4] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.&gt;[8,2,4,7] with maximum absolute diff |8-2| &#x3D; 6 &gt; 4.&gt;[2] with maximum absolute diff |2-2| &#x3D; 0 &lt;&#x3D; 4.&gt;[2,4] with maximum absolute diff |2-4| &#x3D; 2 &lt;&#x3D; 4.&gt;[2,4,7] with maximum absolute diff |2-7| &#x3D; 5 &gt; 4.&gt;[4] with maximum absolute diff |4-4| &#x3D; 0 &lt;&#x3D; 4.&gt;[4,7] with maximum absolute diff |4-7| &#x3D; 3 &lt;&#x3D; 4.&gt;[7] with maximum absolute diff |7-7| &#x3D; 0 &lt;&#x3D; 4. &gt;Therefore, the size of the longest subarray is 2. Example 2: 123&gt;Input: nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5&gt;Output: 4 &gt;Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| &#x3D; 5 &lt;&#x3D; 5. Example 3: 12&gt;Input: nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0&gt;Output: 3 1234567891011121314151617181920212223242526272829// 这题使用一个滑动窗口是毋庸置疑的// 关键是我们希望实时的知道窗口内元素的最大值和最小值// 那么我们要将窗口内的元素存储在哪种合适的数据结构中// 满足我们要求的同时还能保证效率呢// 1. 二叉搜索树, 我们可以方便的获得其中的最大值和最小值, 并且插入的效率为 o(logn)// 最小值在树的最左边, 最大值在树的最右边// 2. 单调队列, 使用两个单调队列, 一个是从队首到队尾递减的顺序, 一个是从队首到队尾递增的顺序// 这样最大值和最小值分别都在它们的队首, 插入的效率为 O(1)// 注意窗口中可能存在的重复值的情况// 这些重复值在搜索树或者在队列中都要同时存在// 滑动窗口 + multiset// 时间复杂度为 O(nlogn)int longestSubarray(vector&lt;int&gt;&amp; nums, int limit)&#123; multiset&lt;int&gt; setting; int res = 0; int left = 0, right = 0; while(right &lt; nums.size()) &#123; setting.insert(nums[right++]); while(*setting.rbegin() - *setting.begin() &gt; limit) setting.erase(setting.find(nums[left++])); res = max(res, right - left); &#125; return res;&#125; 12345678910111213141516171819202122232425262728293031323334// 小技巧: 对于需要实时获取序列中最大值或最小值的问题, 单调队列是非常适合的数据结构!// 滑动窗口 + 单调队列// 时间复杂度为 O(n)int longestSubarray(vector&lt;int&gt;&amp; nums, int limit)&#123; deque&lt;int&gt; minQ; deque&lt;int&gt; maxQ; int res = 0; int left = 0, right = 0; while(right &lt; nums.size()) &#123; while(!minQ.empty() &amp;&amp; minQ.back() &gt; nums[right]) minQ.pop_back(); while(!maxQ.empty() &amp;&amp; maxQ.back() &lt; nums[right]) maxQ.pop_back(); minQ.push_back(nums[right]); maxQ.push_back(nums[right]); right++; while(!minQ.empty() &amp;&amp; !maxQ.empty() &amp;&amp; (maxQ.front() - minQ.front() &gt; limit)) &#123; if(minQ.front() == nums[left]) minQ.pop_front(); if(maxQ.front() == nums[left]) maxQ.pop_front(); left++; &#125; res = max(res, right - left); &#125; return res;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// 用一个数组模拟两个单调队列是真的秀啊int longestSubarray(vector&lt;int&gt;&amp; nums, int limit)&#123; int res = 0; // minL 和 minR 是最小值区间的左右指针, maxL 和 maxR 是最大值区间的左右指针 int minL = 0, minR = -1, maxL = nums.size(), maxR = nums.size() - 1; // l, r 是 nums 的左右指针 int l = 0, r = 0; // 这个数组用来记录最小值和最大值 vector&lt;int&gt; ascending(nums.size()); // 开始遍历 nums while(r &lt; nums.size()) &#123; // 如果遍历到的数字在最小值区间内, 就收缩最小值区间 while(minR &gt;= minL &amp;&amp; nums[r] &lt; ascending[minR]) minR--; // 如果遍历到的数字在最大值区间内, 就收缩最大值区间 while(maxR &gt;= maxL &amp;&amp; nums[r] &gt; ascending[maxL]) maxL++; // 拓展最小值和最大值区间 ascending[++minR] = nums[r]; ascending[--maxL] = nums[r]; r++; // 判断子集长度是否符合 limit 的要求, 如果不符合要求, 就收缩子集 while(ascending[maxR] - ascending[minL] &gt; limit) &#123; // 开始收缩子集, 使子集左指针右移 // 如果子集左指针是最小值, 那么最小值将被移除, 所以更新存储最小值的区间 if(nums[l] == ascending[minL]) minL++; // 如果子集左指针是最大值, 那么最大值将被移除, 所以更新存储最大值的区间 if(nums[l] == ascending[maxR]) maxR--; l++; &#125; res = max(res, r - l); &#125; // 返回结果 return res;&#125; 220. Contains Duplicate III 给你一个整数数组nums和两个整数k和t。请你判断是否存在两个不同下标i和j，使得abs(nums[i] - nums[j]) &lt;= t，同时又满足abs(i - j) &lt;= k。如果存在则返回true，不存在返回false。 Example 1: 12Input: nums &#x3D; [1,2,3,1], k &#x3D; 3, t &#x3D; 0Output: true Example 2: 12Input: nums &#x3D; [1,0,1,1], k &#x3D; 1, t &#x3D; 2Output: true Example 3: 12Input: nums &#x3D; [1,5,9,1,5,9], k &#x3D; 2, t &#x3D; 3Output: false 123456789101112131415161718192021222324252627282930313233343536// 滑动窗口 + 二叉搜索树// 在 set 中维护一个元素数为 k 的滑动窗口// 这可保证在 set 中的元素的索引满足 abs(i - j) &lt;= k// 我们每迭代到数组中的下一个元素 [nums[i], 在更新 set 前// 都要在其中找到一个在 [nums[i] - k, nums[i] + k] 范围内的值// 如果存在, 那么就满足 abs(nums[i] - nums[j]) &lt;= t// 为什么选择 multiset?// 因为 set 具有自动排序的特性, 并且每次查找、删除和插入的复杂度都为// 高效的 log(n). 因为我们要频繁地查找在范围 [nums[i] - k,// nums[i] + k] 内的值, 还要频繁地删除和插入元素以维持固定地滑动窗口大小// 注意一点, 在计算 nums[i] - k 和 nums[i] + k 的时候可能会出现数值溢出// 所以要全部用 longbool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t)&#123; set&lt;long&gt; ms; for(size_t i = 0; i &lt; nums.size(); i++) &#123; // 注意此时 nums[i] 是不包含在窗口内的 // 并且窗口内的元素数量 ? &lt;= k, 我们以第 ? + 1 个元素为对象 // 寻找满足条件的另一个元素, 这样每一个元素都会 [被看作对象] 一次 long valMin = (long)nums[i] - (long)t; // iter 指向首次进入 [nums[i] - k, ... 范围的数 // 因此还要验证这个数是否也在 ..., nums[i] + k] 范围内 auto iter = ms.lower_bound(valMin); // 如果存在这么一个数, 就找到满足条件的两个数了 if(iter != ms.end() &amp;&amp; *iter &lt;= (long)nums[i] + (long)t) return true; // 当前对象已经处理过了, 将它放进窗口 // 如果窗口大小超过 k 了, 还要将最左边的那个数剔出窗口 ms.insert(nums[i]); if(ms.size() &gt; k) ms.erase(nums[i - k]); &#125; return false;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142// 滑动窗口 + 分桶// 将数组中的数值按照映射函数分配到相应桶中// 映射函数为 桶号 id = value / (t + 1)// 这样可保证// 1. 映射到同一个桶的数值之差一定小于等于 t// 2. 相邻桶中也有可能存在差值小于等于 t 的情况// 3. 不相邻的桶中元素差值必定大于 t// 如数组为 [1 5 9 1 3 7 8], k = 2, t = 3, 桶宽度为 t + 1 = 4// 0 号桶: [1 1 3], 1 号桶: [5 7], 2 号桶: [9 8]bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t)&#123; long bucketsWidth = long(t) + 1; unordered_map&lt;long, long&gt; buckets; for(int i = 0; i &lt; nums.size(); i++) &#123; int id = getKey(nums[i], bucketsWidth); // 在一个桶中一定满足条件 if(buckets.count(id)) return true; // 在左边相邻桶中, 再判断差值是否满足条件 if(buckets.count(id - 1) &amp;&amp; nums[i] - buckets[id - 1] &lt;= t) return true; // 在右边相邻桶中, 再判断差值是否满足条件 if(buckets.count(id + 1) &amp;&amp; buckets[id + 1] - nums[i] &lt;= t) return true; buckets[id] = nums[i]; // 保证所有桶中的元素小于等于 k 个 // 如果大于 k, 就将窗口最左边的元素剔除 if(buckets.size() &gt; k) buckets.erase(getKey(nums[i - k], bucketsWidth)); &#125; return false;&#125;int getKey(int value, long bucketsWidth)&#123; int id = value / bucketsWidth; // 注意这里如果 value 为负数, 需要将桶号减 1 // 保证 0 号桶的正确性 if(value &lt; 0) id--; return id;&#125; 498. Diagonal Traverse 给定一个含有m x n个元素的矩阵（m行，n列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。 Example 1: 12Input: mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,4,7,5,3,6,8,9] Example 2: 12Input: mat &#x3D; [[1,2],[3,4]]Output: [1,2,3,4] 123456789101112131415161718192021vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)&#123; if(matrix.empty()) return vector&lt;int&gt;(); int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; v(m + n - 1); for(int i = 0; i &lt; m; i++) for(int j = 0; j &lt; n; j++) v[i + j].push_back(matrix[i][j]); vector&lt;int&gt; res; for(int i = 0; i &lt; v.size(); i++) &#123; if(i % 2 == 0) reverse(v[i].begin(), v[i].end()); res.insert(res.end(), v[i].begin(), v[i].end()); &#125; return res;&#125; 123456789101112131415161718vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)&#123; map&lt;int, vector&lt;int&gt;&gt; mapping; for(int i = 0; i &lt; matrix.size(); i++) for(int j = 0; j &lt; matrix[i].size(); j++) mapping[i + j].push_back(matrix[i][j]); vector&lt;int&gt; res; for(auto&amp; p: mapping) &#123; if(p.first % 2 == 0) res.insert(res.end(), p.second.rbegin(), p.second.rend()); else res.insert(res.end(), p.second.begin(), p.second.end()); &#125; return res;&#125; 1424. Diagonal Traverse II 给你一个列表num，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回num中对角线上的整数。 Example 1: 12&gt;Input: nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]&gt;Output: [1,4,2,7,5,3,8,6,9] Example 2: 12&gt;Input: nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]&gt;Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] 12345678910111213vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; nums)&#123; map&lt;int, vector&lt;int&gt;&gt; mapping; for(int i = 0; i &lt; nums.size(); i++) for(int j = 0; j &lt; nums[i].size(); j++) mapping[i + j].push_back(nums[i][j]); vector&lt;int&gt; res; for(auto&amp; p: mapping) res.insert(res.end(), p.second.rbegin(), p.second.rend()); return res;&#125; 54. Spiral Matrix 给你一个m行n列的矩阵matrix，请按照顺时针螺旋顺序，返回矩阵中的所有元素。 Example 1: 12Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,3,6,9,8,7,4,5] Example 2: 12Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] 1234567891011121314151617181920212223242526272829303132// Traverse the matrix in the spiral order by keeping four variables// u for the uppermost row, d for the downmost row// l for the leftmost column, r for the rightmost column.vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)&#123; int m = matrix.size(); int n = matrix[0].size(); int u = 0, d = m - 1, l = 0, r = n - 1; int p = 0; vector&lt;int&gt; order(m * n); while (u &lt;= d &amp;&amp; l &lt;= r) &#123; for(int col = l; col &lt;= r; col++) order[p++] = matrix[u][col]; if(++u &gt; d) break; for(int row = u; row &lt;= d; row++) order[p++] = matrix[row][r]; if(--r &lt; l) break; for(int col = r; col &gt;= l; col--) order[p++] = matrix[d][col]; if(--d &lt; u) break; for(int row = d; row &gt;= u; row--) order[p++] = matrix[row][l]; if(l++ &gt; r) break; &#125; return order;&#125; 1288. Remove Covered Intervals Given a list of intervals, remove all intervals that are covered by another interval in the list. Interval [a,b) is covered by interval [c,d) if and only if c &lt;= a and b &lt;= d. After doing so, return the number of remaining intervals. Constraints: 1 &lt;= intervals.length &lt;= 1000 intervals[i].length == 2 0 &lt;= intervals[i][0] &lt; intervals[i][1] &lt;= 10^5 All the intervals are unique. Example 1: 123Input: intervals &#x3D; [[1,4],[3,6],[2,8]]Output: 2Explanation: Interval [3,6] is covered by [2,8], therefore it is removed. Example 2: 12Input: intervals &#x3D; [[1,4],[2,3]]Output: 1 12345678910111213141516171819202122232425262728293031323334// 所谓区间问题, 就是线段问题, 让你合并所有线段、找出线段的交集等等.// 主要有两个技巧:// 1. 排序, 常见的排序方法就是按照区间起点或者终点排序. 一般都是先按照起点升序排序.// 若起点相同，则按照终点降序排序// 2. 画图, 就是说不要偷懒, 勤动手, 两个区间的相对位置到底有几种可能,// 不同的相对位置我们的代码应该怎么去处理int removeCoveredIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals)&#123; auto cmp = [](auto&amp; a, auto&amp; b)&#123; return a[0] == b[0] ? b[1] &lt; a[1] : a[0] &lt; b[0]; &#125;; sort(intervals.begin(), intervals.end(), cmp); vector&lt;vector&lt;int&gt;&gt; res; res.reserve(intervals.size()); res.push_back(intervals[0]); int left = intervals[0][0], right = intervals[0][1]; for(int i = 1; i &lt; intervals.size(); i++) &#123; auto&amp; interval = intervals[i]; // 区间相交 if(right &gt;= interval[0] &amp;&amp; right &lt; interval[1]) &#123; right = interval[1]; res.push_back(interval); &#125; // 区间不相交 else if(right &lt;= interval[0]) &#123; left = interval[0]; right = interval[1]; res.push_back(interval); &#125; // 区间被覆盖的扔掉就行了 &#125; return res.size();&#125; 56. Merge Intervals Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Constraints: 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 Example 1: 123Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: 123Input: intervals &#x3D; [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. 12345678910111213141516171819202122232425262728vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals)&#123; auto cmp = [](auto&amp; a, auto&amp; b)&#123; return a[0] == b[0] ? b[1] &lt; a[1] : a[0] &lt; b[0]; &#125;; sort(intervals.begin(), intervals.end(), cmp); vector&lt;vector&lt;int&gt;&gt; res; int left = intervals[0][0], right = intervals[0][1]; for(int i = 1; i &lt; intervals.size(); i++) &#123; auto&amp; interval = intervals[i]; // 区间相交 // 可能会有 [3, 3] 这样的区间, 判定和 [1, 3] 相交就行了 // 不然的话会被当做不相交被加进去 if(right &gt;= interval[0] &amp;&amp; right &lt;= interval[1]) right = interval[1]; // 区间不相交 else if(right &lt; interval[0]) &#123; res.push_back(&#123;left, right&#125;); left = interval[0]; right = interval[1]; &#125; // 区间被覆盖的扔掉就行了 &#125; // 注意最后一个区间可能没被加进去 if(res.empty() || res.back() != vector&lt;int&gt;(&#123;left, right&#125;)) res.push_back(&#123;left, right&#125;); return res;&#125; 57. Insert Interval 给你一个无重叠的，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 Example 1: 12Input: intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]Output: [[1,5],[6,9]] Example 2: 123Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Example 3: 12Input: intervals &#x3D; [], newInterval &#x3D; [5,7]Output: [[5,7]] Example 4: 12Input: intervals &#x3D; [[1,5]], newInterval &#x3D; [2,7]Output: [[1,7]] 123456789101112131415161718192021222324252627282930vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval)&#123; vector&lt;vector&lt;int&gt;&gt; res; int a1 = newInterval[0], b1 = newInterval[1]; bool found = false; for(int i = 0; i &lt; intervals.size(); i++) &#123; int a2 = intervals[i][0], b2 = intervals[i][1]; // 相交 if(b2 &gt;= a1 &amp;&amp; b1 &gt;= a2) &#123; a1 = min(a1, a2); b1 = max(b1, b2); &#125; // 不相交 else if(b1 &lt; a2 &amp;&amp; !found) &#123; res.push_back(&#123;a1, b1&#125;); res.push_back(&#123;a2, b2&#125;); found = true; &#125; else &#123; res.push_back(&#123;a2, b2&#125;); &#125; &#125; if(!found) res.push_back(&#123;a1, b1&#125;); return res;&#125; 986. Interval List Intersections 给定两个由一些闭区间组成的列表，firstList和secondList，其中firstList[i] = [start_i, end_i]而secondList[j] = [start_j, end_j]。每个区间列表都是成对不相交的，并且已经排序。 返回这两个区间列表的交集 。 形式上，闭区间[a, b]（其中a &lt;= b）表示实数x的集合，而a &lt;= x &lt;= b。 两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3]和[2, 4]的交集为[2, 3]。 Example 1: 12Input: firstList &#x3D; [[0,2],[5,10],[13,23],[24,25]], secondList &#x3D; [[1,5],[8,12],[15,24],[25,26]]Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Example 2: 12Input: firstList &#x3D; [[1,3],[5,9]], secondList &#x3D; []Output: [] Example 3: 12Input: firstList &#x3D; [], secondList &#x3D; [[4,8],[10,12]]Output: [] Constraints: 0 &lt;= firstList.length, secondList.length &lt;= 1000 firstList.length + secondList.length &gt;= 1 0 &lt;= start_i &lt; end_i &lt;= 109 endi &lt; start_(i + 1) 0 &lt;= start_j &lt; end_j &lt;= 109 endj &lt; start_(j + 1) 123456789101112131415vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; firstList, vector&lt;vector&lt;int&gt;&gt;&amp; secondList)&#123; vector&lt;vector&lt;int&gt;&gt; res; int i = 0, j = 0; while(i &lt; firstList.size() &amp;&amp; j &lt; secondList.size()) &#123; int a1 = firstList[i][0], b1 = firstList[i][1]; int a2 = secondList[j][0], b2 = secondList[j][1]; if(b1 &gt;= a2 &amp;&amp; b2 &gt;= a1) res.push_back(&#123;max(a1, a2), min(b1, b2)&#125;); if(b1 &lt;= b2) i++; else j++; &#125; return res;&#125; 435. Non-overlapping Intervals 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间[1,2]和[2,3]的边界相互“接触”，但没有相互重叠。 Constraints: 1 &lt;= intervals.size() &lt;= 2 * 10^4 Example 1: 123Input: intervals &#x3D; [[1,2],[2,3],[3,4],[1,3]]Output: 1Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping. Example 2: 123Input: intervals &#x3D; [[1,2],[1,2],[1,2]]Output: 2Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping. Example 3: 123Input: intervals &#x3D; [[1,2],[2,3]]Output: 0Explanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping. 1234567891011121314151617181920212223242526// 这题问的是至少删除多少个区间使得不再存在重叠区间// 按照区间起点排序, 起点相同按终点排序// 计数相交区间int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals)&#123; sort(intervals.begin(), intervals.end()); int res = 0; int a1 = intervals[0][0], b1 = intervals[0][1]; for(int i = 1; i &lt; intervals.size(); i++) &#123; int a2 = intervals[i][0], b2 = intervals[i][1]; // 如果相交就移除后面那个区间 if(b2 &gt; a1 &amp;&amp; b1 &gt; a2) &#123; a1 = min(a1, a2); b1 = min(b1, b2); res++; &#125; else &#123; a1 = a2; b1 = b2; &#125; &#125; return res;&#125; 123456789101112131415161718192021// 这题问的是至少删除多少个区间使得不再存在重叠区间// 换个思路// 按照区间终点排序int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals)&#123; auto cmp = [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125;; sort(intervals.begin(), intervals.end(), cmp); int count = 0; int n = intervals.size(); int pre_end = intervals[0][1]; for(int i = 1; i &lt; n; i++) &#123; int start = intervals[i][0]; // 如果后一个区间的起点比前一个的终点小就重叠了 if(start &lt; pre_end) count++; else pre_end = intervals[i][1]; &#125; return count;&#125; 452. Minimum Number of Arrows to Burst Balloons 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为xstart，xend， 且满足xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 给你一个数组points，其中points [i] = [xstart, xend]，返回引爆所有气球所必须射出的最小弓箭数。 Example 1: 123Input: points &#x3D; [[10,16],[2,8],[1,6],[7,12]]Output: 2Explanation: One way is to shoot one arrow for example at x &#x3D; 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x &#x3D; 11 (bursting the other two balloons). Example 2: 12Input: points &#x3D; [[1,2],[3,4],[5,6],[7,8]]Output: 4 Example 3: 12Input: points &#x3D; [[1,2],[2,3],[3,4],[4,5]]Output: 2 12345678910111213141516171819202122232425// 按照区间终点排序// 最多有多少个不重叠的区间 == n - 至少删除多少个区间使得不再存在重叠区间// 最多有多少个不重叠的区间就是题目所问的至少需要的箭的数量int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points)&#123; auto cmp = [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125;; sort(points.begin(), points.end(), cmp); // count 是最多有多少个不重叠的区间 int count = 1; int n = points.size(); int pre_end = points[0][1]; for(int i = 1; i &lt; n; i++) &#123; int start = points[i][0]; // 如果后一个区间的起点比前一个的终点小就重叠了 // 因为这题边界触碰也能引爆气球, 所以属于重叠区间 // 因此不是 &gt;= 号 if(start &gt; pre_end) &#123; count++; pre_end = points[i][1]; &#125; &#125; return count;&#125; 436. Find Right Interval 给你一个区间数组intervals，其中intervals[i] = [starti, endi]，且每个starti都不同 。 区间i的右侧区间可以记作区间j，并满足startj &gt;= endi，且startj最小化 。 返回一个由每个区间i的右侧区间的最小起始位置组成的数组。如果某个区间i不存在对应的右侧区间，则下标i处的值设为-1。 Constraints: 1 &lt;= intervals.length &lt;= 2 * 10^4 intervals[i].length == 2 -10^6 &lt;= starti &lt;= endi &lt;= 10^6 The start point of each interval is unique. Example 1: 123Input: intervals &#x3D; [[1,2]]Output: [-1]Explanation: There is only one interval in the collection, so it outputs -1. Example 2: 12345Input: intervals &#x3D; [[3,4],[2,3],[1,2]]Output: [-1,0,1]Explanation: There is no right interval for [3,4].The right interval for [2,3] is [3,4] since start0 &#x3D; 3 is the smallest start that is &gt;&#x3D; end1 &#x3D; 3.The right interval for [1,2] is [2,3] since start1 &#x3D; 2 is the smallest start that is &gt;&#x3D; end2 &#x3D; 2. Example 3: 1234Input: intervals &#x3D; [[1,4],[2,3],[3,4]]Output: [-1,2,-1]Explanation: There is no right interval for [1,4] and [3,4].The right interval for [2,3] is [3,4] since start2 &#x3D; 3 is the smallest start that is &gt;&#x3D; end1 &#x3D; 3. 12345678910111213141516171819202122// 排序后顺序搜索, 最差情况下时间复杂度为 O(n2)vector&lt;int&gt; findRightInterval(vector&lt;vector&lt;int&gt;&gt;&amp; intervals)&#123; int n = intervals.size(); for(int i = 0; i &lt; n; i++) intervals[i].push_back(i); sort(intervals.begin(), intervals.end()); vector&lt;int&gt; res(n, -1); for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; if(intervals[i][1] &lt;= intervals[j][0]) &#123; res[intervals[i][2]] = intervals[j][2]; break; &#125; &#125; &#125; return res;&#125; 12345678910111213141516171819202122232425262728293031// 排序后二分搜索, 时间复杂度降为 O(nlogn)vector&lt;int&gt; findRightInterval(vector&lt;vector&lt;int&gt;&gt;&amp; intervals)&#123; int n = intervals.size(); for(int i = 0; i &lt; n; i++) intervals[i].push_back(i); sort(intervals.begin(), intervals.end()); vector&lt;int&gt; res(n, -1); for(int i = 0; i &lt; n; i++) &#123; int index = left_bound(intervals, i, n, intervals[i]); if(index &lt; n) res[intervals[i][2]] = intervals[index][2]; &#125; return res;&#125;int left_bound(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, int lo, int hi, vector&lt;int&gt;&amp; interval)&#123; while(lo &lt; hi) &#123; int mi = lo + ((hi - lo) &gt;&gt; 1); if(interval[1] &lt;= intervals[mi][0]) hi = mi; else lo = mi + 1; &#125; return lo;&#125; 713. Subarray Product Less Than K 给定一个正整数数组nums。找出该数组内乘积小于k的连续的子数组的个数。 Example: 1234Input: nums &#x3D; [10, 5, 2, 6], k &#x3D; 100Output: 8Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. Note: 0 &lt; nums.length &lt;= 50000. 0 &lt; nums[i] &lt; 1000. 0 &lt;= k &lt; 10^6. 1234567891011121314int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k)&#123; if(k &lt;= 1) return 0; int left = 0, right = 0; int product = 1, count = 0; while(right &lt; nums.size()) &#123; product *= nums[right++]; while(product &gt;= k) product /= nums[left++]; count += right - left; &#125; return count;&#125; 525. Contiguous Array Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. 解题方法说明图： The following figure illustrates the observation for the sequence [0 0 1 0 0 0 1 1]。 Example 1: 123Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2: 123Input: [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. 12345678910111213141516171819// 设置一个计数器 counter, 遇 0 减 1, 遇 1 加 1// 出现相等的 counter 时则说明从第 1 次出现时的索引开始到当前索引的子数组满足条件// 并且是最长的int findMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); unordered_map&lt;int, int&gt; mapping; mapping[0] = -1; int res = 0, cnt = 0; for(int i = 0; i &lt; n; i++) &#123; cnt += nums[i] == 1 ? 1 : -1; if(mapping.count(cnt)) &#123; res = max(res, i - mapping[cnt]); &#125; else &#123; mapping[cnt] = i; &#125; &#125; return res;&#125; 18. 四数之和 给定一个包含n个整数的数组nums和一个目标值target，判断nums中是否存在四个元素a，b，c和d，使得a + b + c + d的值与target相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; return nTargetSum(nums, target, 4);&#125;vector&lt;vector&lt;int&gt;&gt; nTargetSum(vector&lt;int&gt;&amp; nums, int target, int n) &#123; sort(nums.begin(), nums.end()); int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; nSumResult; vector&lt;int&gt; curVals; auto twoSum = [&amp;](int start, int target) &#123; int lo = start, hi = len - 1; while(lo &lt; hi) &#123; int sum = nums[lo] + nums[hi]; int loVal = nums[lo], hiVal = nums[hi]; if(sum &lt; target) &#123; // 跳过重复数字，避免出现重复结果 while(lo &lt; hi &amp;&amp; nums[lo] == loVal) &#123; lo++; &#125; &#125; else if(target &lt; sum) &#123; // 跳过重复数字，避免出现重复结果 while(lo &lt; hi &amp;&amp; nums[hi] == hiVal) &#123; hi--; &#125; &#125; else &#123; nSumResult.push_back(&#123;loVal, hiVal&#125;); for(int val : curVals) &#123; nSumResult.back().push_back(val); &#125; // 跳过重复数字，避免出现重复结果 while(lo &lt; hi &amp;&amp; nums[lo] == loVal) &#123; lo++; &#125; while(lo &lt; hi &amp;&amp; nums[hi] == hiVal) &#123; hi--; &#125; &#125; &#125; &#125;; auto nSum = [&amp;](auto&amp;&amp; nSum, int start, int target, int n) &#123; if(n &lt;= 2) &#123; // 递归基 twoSum(start, target); return; &#125; for(int i = start; i &lt; len; i++) &#123; curVals.push_back(nums[i]); nSum(nSum, i + 1, target - nums[i], n - 1); curVals.pop_back(); // 跳过重复数字，避免出现重复结果 while(i &lt; len - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123; i++; &#125; &#125; &#125;; nSum(nSum, 0, target, n); return nSumResult;&#125; 面试题 17.10. 主要元素 数组中占比超过一半的元素称之为主要元素。给你一个整数数组，找出其中的主要元素。若没有，返回-1。 请设计时间复杂度为O(n)、空间复杂度为O(1)的解决方案。 123456789101112131415// 快速选择，使中间元素就位int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); nth_element(nums.begin(), nums.begin() + n / 2, nums.end()); int cnt = 0; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] == nums[n / 2]) &#123; cnt++; &#125; &#125; if(cnt &gt; n/2) &#123; return nums[n / 2]; &#125; return -1;&#125; 12345678910111213141516171819202122232425262728// 摩尔投票int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int cnt = 0; int lastNum = 0; for(int num : nums) &#123; if(cnt == 0) &#123; lastNum = num; cnt = 1; &#125; else if(num == lastNum) &#123; cnt++; &#125; else &#123; cnt--; &#125; &#125; cnt = 0; for(int num : nums) &#123; if(num == lastNum) &#123; cnt++; &#125; &#125; if(cnt &gt; n/2) &#123; return lastNum; &#125; return -1;&#125; 123456789101112131415161718192021222324252627// 位运算int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int res = 0, cnt = 0; for(int i = 0; i &lt; 32; i++) &#123; int mask = (1 &lt;&lt; i); cnt = 0; for(int num : nums) &#123; if(num &amp; mask) &#123; cnt++; &#125; &#125; if(cnt &gt; n/2) &#123; res |= mask; &#125; &#125; cnt = 0; for(int num : nums) &#123; if(num == res) &#123; cnt++; &#125; &#125; if(cnt &gt; n/2) &#123; return res; &#125; return -1;&#125; 253. Meeting Rooms II 给你一个会议时间安排的数组intervals，每个会议时间都会包括开始和结束的时间intervals[i] = [start_i, end_i]，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。 示例 1： 12输入：intervals &#x3D; [[0,30],[5,10],[15,20]]输出：2 示例 2： 12输入：intervals &#x3D; [[7,10],[2,4]]输出：1 12345678910111213141516int minMeetingRooms(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt;pair&lt;int, int&gt;&gt; times; for(auto&amp;&amp; interval : intervals) &#123; times.emplace_back(interval[0], 1); times.emplace_back(interval[1], -1); &#125; sort(times.begin(), times.end()); // cnt 记录当前正在进行的会议数 // res 记录最多的同时进行的会议数 int cnt = 0, res = 0; for(auto&amp;&amp; [_, flag] : times) &#123; cnt += flag; res = max(res, cnt); &#125; return res;&#125; 1094. Car Pooling 假设你是一位顺风车司机，车上最初有capacity个空座位可以用来载客。由于道路的限制，车只能向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。 这儿有一份乘客行程计划表trips[][]，其中trips[i] = [num_passengers, start_location, end_location]包含了第i组乘客的行程信息： 必须接送的乘客数量； 乘客的上车地点； 以及乘客的下车地点。 这些给出的地点位置是从你的初始出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。 请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回true，否则请返回false）。 Example 1: 12Input: trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4Output: false Example 2: 12Input: trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 5Output: true Example 3: 12Input: trips &#x3D; [[2,1,5],[3,5,7]], capacity &#x3D; 3Output: true Example 4: 12Input: trips &#x3D; [[3,2,7],[3,7,9],[8,3,9]], capacity &#x3D; 11Output: true Constraints: trips.length &lt;= 1000 trips[i].length == 3 1 &lt;= trips[i][0] &lt;= 100 0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000 1 &lt;= capacity &lt;= 100000 12345678910111213141516// 将这 1000 个距离点看作一个数组, 数组中元素是那一距离点的乘客数// 把路程中每一个位置的乘客数在数组中构造出来// 时时比较乘客数是否超过客容量bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) &#123; // 距离最远就 1000 个距离单位 vector&lt;int&gt; passengers(1001); for(auto&amp;&amp; trip : trips) &#123; for(int i = trip[1]; i &lt; trip[2]; i++) &#123; passengers[i] += trip[0]; if(passengers[i] &gt; capacity) &#123; return false; &#125; &#125; &#125; return true;&#125; 123456789101112131415161718// 差分数组// 将这 1000 个距离点看作一个数组, 数组中元素是那一距离点的乘客数, 初始数组元素都为 0// 对每一个 trip 更新数组区间的值, 使用差分数组记录这些更新// 最后还原数组的时候, 判断是否出现超载bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) &#123; vector&lt;int&gt; diff(1001); for(auto&amp;&amp; trip : trips) &#123; diff[trip[1]] += trip[0]; diff[trip[2]] -= trip[0]; &#125; for(int i = 1; i &lt; 1000; i++) &#123; diff[i] += diff[i - 1]; if(diff[i] &gt; capacity) &#123; return false; &#125; &#125; return true;&#125; 1840. Maximum Building Height 在一座城市里，你需要建n栋新的建筑。这些新的建筑会从1到n编号排成一列。 这座城市对这些新建筑有一些规定： 每栋建筑的高度必须是一个非负整数。 第一栋建筑的高度必须是0。 任意两栋相邻建筑的高度差不能超过1。 除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组restrictions的形式给出，其中restrictions[i] = [idi, maxHeighti]，表示建筑idi的高度 不能超过maxHeighti。 题目保证每栋建筑在restrictions中至多出现一次 ，同时建筑1不会 出现在restrictions中。 请你返回最高建筑能达到的最高高度 。 示例 1： 1234输入：n &#x3D; 5, restrictions &#x3D; [[2,1],[4,1]]输出：2解释：上图中的绿色区域为每栋建筑被允许的最高高度。我们可以使建筑高度分别为 [0,1,2,1,2] ，最高建筑的高度为 2 。 示例 2： 1234输入：n &#x3D; 6, restrictions &#x3D; []输出：5解释：上图中的绿色区域为每栋建筑被允许的最高高度。我们可以使建筑高度分别为 [0,1,2,3,4,5] ，最高建筑的高度为 5 。 示例 3： 1234输入：n &#x3D; 10, restrictions &#x3D; [[5,3],[2,5],[7,4],[10,3]]输出：5解释：上图中的绿色区域为每栋建筑被允许的最高高度。我们可以使建筑高度分别为 [0,1,2,3,3,4,4,5,4,3] ，最高建筑的高度为 5 。 Constraints: 2 &lt;= n &lt;= 10^9 0 &lt;= restrictions.length &lt;= min(n - 1, 10^5) 2 &lt;= idi &lt;= n idi is unique. 0 &lt;= maxHeighti &lt;= 10^9 12345678910111213141516171819202122232425int maxBuilding(int n, vector&lt;vector&lt;int&gt;&gt;&amp; r) &#123; // 增加限制 (1, 0) r.push_back(&#123;1, 0&#125;); sort(r.begin(), r.end()); // 增加限制 (n, n-1) if(r.back()[0] != n) &#123; r.push_back(&#123;n, n - 1&#125;); &#125; int m = r.size(); // 从左向右传递限制 for(int i = 1; i &lt; m; i++) &#123; r[i][1] = min(r[i][1], r[i - 1][1] + (r[i][0] - r[i - 1][0])); &#125; // 从右向左传递限制 for(int i = m - 2; i &gt;= 0; i--) &#123; r[i][1] = min(r[i][1], r[i + 1][1] + (r[i + 1][0] - r[i][0])); &#125; int res = 0; for(int i = 0; i &lt; m - 1; ++i) &#123; // 计算 r[i][0] 和 r[i + 1][0] 之间的建筑的最大高度 int best = ((r[i + 1][0] - r[i][0]) + r[i][1] + r[i + 1][1]) / 2; res = max(res, best); &#125; return res;&#125; 1838. Frequency of the Most Frequent Element 元素的频数是该元素在一个数组中出现的次数。 给你一个整数数组nums和一个整数k。在一步操作中，你可以选择nums的一个下标，并将该下标对应元素的值增加1。 执行最多k次操作后，返回数组中最高频元素的最大可能频数。 Example 1: 1234Input: nums &#x3D; [1,2,4], k &#x3D; 5Output: 3Explanation: Increment the first element three times and the second element two times to make nums &#x3D; [4,4,4].4 has a frequency of 3. Example 2: 123456Input: nums &#x3D; [1,4,8,13], k &#x3D; 5Output: 2Explanation: There are multiple optimal solutions:- Increment the first element three times to make nums &#x3D; [4,4,8,13]. 4 has a frequency of 2.- Increment the second element four times to make nums &#x3D; [1,8,8,13]. 8 has a frequency of 2.- Increment the third element five times to make nums &#x3D; [1,4,13,13]. 13 has a frequency of 2. Example 3: 12Input: nums &#x3D; [3,9,6], k &#x3D; 2Output: 1 123456789101112131415161718192021// 降序排序后顺序模拟操作即可// 时间复杂度为 O(n2), 超时！int maxFrequency(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); int n = nums.size(); int cnt = 0; for(int i = 0; i &lt; n; i++) &#123; int temp_k = k; int j = i + 1; for(; j &lt; n; j++) &#123; if(nums[i] - nums[j] &lt;= temp_k) &#123; temp_k -= nums[i] - nums[j]; &#125; else &#123; break; &#125; &#125; cnt = max(cnt, j - i); &#125; return cnt;&#125; 1234567891011121314151617// 降序排序后, 滑动窗口模拟操作// 时间复杂度为 O(n)int maxFrequency(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); long res = 0, sum = 0; long left = 0, right = 0; while(right &lt; nums.size()) &#123; sum += nums[right]; right++; while((right - left) * nums[right - 1] &gt; sum + k) &#123; sum -= nums[left]; left++; &#125; res = max(res, right - left); &#125; return res;&#125; 1011. Capacity To Ship Packages Within D Days 传送带上的包裹必须在days天内从一个港口运送到另一个港口。 传送带上的第i个包裹的重量为weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。 返回能在days天内将传送带上的所有包裹送达的船的最低运载能力。 Example 1: 12345678910Input: weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5Output: 15Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:1st day: 1, 2, 3, 4, 52nd day: 6, 73rd day: 84th day: 95th day: 10Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. Example 2: 123456Input: weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3Output: 6Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:1st day: 3, 22nd day: 2, 43rd day: 1, 4 Example 3: 1234567Input: weights &#x3D; [1,2,3,1,1], D &#x3D; 4Output: 3Explanation:1st day: 12nd day: 23rd day: 34th day: 1, 1 1234567891011121314151617181920212223242526272829303132// 船的最低运载能力至少为所有包裹的最大重量// 最高运载能力充其量不过是一次把所有货物全部运完, 也就是所有货物重量之和// 知道了最小值和最大值, 现在要我们求中间满足条件的一个最小值// 如果说从最小值到最大值一个一个去试的话时间复杂度显然是线性的// 其实这是二分搜索的一个典型应用场景// 具体使用的是二分法的左边界搜索 (因为要求最低运载量嘛)int shipWithinDays(vector&lt;int&gt;&amp; weights, int days) &#123; auto computeDays = [&amp;](int limit) &#123; int days = 1; int load = 0; for(int weight : weights) &#123; if(load + weight &gt; limit) &#123; days++; load = 0; &#125; load += weight; &#125; return days; &#125;; int minLoad = *max_element(weights.begin(), weights.end()); int maxLoad = accumulate(weights.begin(), weights.end(), 0); while(minLoad &lt; maxLoad) &#123; int midLoad = minLoad + ((maxLoad - minLoad) &gt;&gt; 1); if(days &gt;= computeDays(midLoad)) &#123; maxLoad = midLoad; &#125; else &#123; minLoad = midLoad + 1; &#125; &#125; return minLoad;&#125; 875. Koko Eating Bananas 珂珂喜欢吃香蕉。这里有N堆香蕉，第i堆中有piles[i]根香蕉。警卫已经离开了，将在hours小时后回来。 珂珂可以决定她吃香蕉的速度K（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉K根。如果这堆香蕉少于K根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。 返回她可以在hours小时内吃掉所有香蕉的最小速度K（K为整数）。 Example 1: 12&gt;Input: piles &#x3D; [3,6,7,11], h &#x3D; 8&gt;Output: 4 Example 2: 12&gt;Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 5&gt;Output: 30 Example 3: 12&gt;Input: piles &#x3D; [30,11,23,4,20], h &#x3D; 6&gt;Output: 23 12345678910111213141516171819202122232425262728// 和上题一样, 吃香蕉的速度至少为 1 吧// 最大速度充其量不过是一次把最大的一堆全部吃完, 也就是最大堆的香蕉个数// 知道了最小值和最大值, 现在要我们求中间满足条件的一个最小值// 如果说从最小值到最大值一个一个去试的话时间复杂度显然是线性的// 其实这是二分搜索的一个典型应用场景// 具体使用的是二分法的左边界搜索 (因为要求最小速度嘛)int minEatingSpeed(vector&lt;int&gt;&amp; piles, int hours) &#123; auto computeHours = [&amp;](int speed) &#123; int hours = 0; for(int pile : piles) &#123; // pile / speed 向上取整 hours += (pile + speed - 1) / speed; &#125; return hours; &#125;; int minSpeed = 1; int maxSpeed = *max_element(piles.begin(), piles.end()) + 1; while(minSpeed &lt; maxSpeed) &#123; int midSpeed = minSpeed + ((maxSpeed - minSpeed) &gt;&gt; 1); if(hours &gt;= computeHours(midSpeed)) &#123; maxSpeed = midSpeed; &#125; else &#123; minSpeed = midSpeed + 1; &#125; &#125; return minSpeed;&#125; 1760. Minimum Limit of Balls in a Bag 给你一个整数数组nums，其中nums[i]表示第i个袋子里球的数目。同时给你一个整数maxOperations。你可以进行如下操作至多maxOperations次： 选择任意一个袋子，并将袋子里的球分到2个新的袋子中，每个袋子里都有正整数个球。 比方说，一个袋子里有5个球，你可以把它们分到两个新袋子里，分别有1个和4个球，或者分别有2个和3个球。 你的开销是单个袋子里球数目的最大值 ，你想要最小化开销。请你返回进行上述操作后的最小开销。 Example 1: 123456Input: nums &#x3D; [9], maxOperations &#x3D; 2Output: 3Explanation: - Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -&gt; [6,3].- Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -&gt; [3,3,3].The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3. Example 2: 12345678Input: nums &#x3D; [2,4,8,2], maxOperations &#x3D; 4Output: 2Explanation:- Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -&gt; [2,4,4,4,2].- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -&gt; [2,2,2,4,4,2].- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -&gt; [2,2,2,2,2,4,2].- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -&gt; [2,2,2,2,2,2,2,2].The bag with the most number of balls has 2 balls, so your penalty is 2 an you should return 2. Example 3: 12Input: nums &#x3D; [7,17], maxOperations &#x3D; 2Output: 7 1234567891011121314151617181920212223int minimumSize(vector&lt;int&gt;&amp; nums, int maxOperations) &#123; int minCost = 1; int maxCost = *max_element(nums.begin(), nums.end()) + 1; while(minCost &lt; maxCost) &#123; int midCost = minCost + (maxCost - minCost &gt;&gt; 1); int need = operations(nums, midCost); if(need &lt;= maxOperations) &#123; maxCost = midCost; &#125; else &#123; minCost = midCost + 1; &#125; &#125; return minCost;&#125;int operations(vector&lt;int&gt;&amp; nums, int cost) &#123; int op = 0; for(int num : nums) &#123; op += (num - 1) / cost; &#125; return op;&#125; 153. Find Minimum in Rotated Sorted Array 已知一个长度为n的数组，预先按照升序排列，经由1到n次旋转后，得到输入数组。例如，原数组nums = [0,1,2,4,5,6,7]在变化后可能得到： 若旋转4次，则可以得到[4,5,6,7,0,1,2] 若旋转7次，则可以得到[0,1,2,4,5,6,7] 注意，数组[a[0], a[1], a[2], ..., a[n-1]]旋转一次的结果为数组[a[n-1], a[0], a[1], a[2], ..., a[n-2]]。 给你一个元素值互不相同的数组nums，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素 。 Example 1: 123Input: nums &#x3D; [3,4,5,1,2]Output: 1Explanation: The original array was [1,2,3,4,5] rotated 3 times. Example 2: 123Input: nums &#x3D; [4,5,6,7,0,1,2]Output: 0Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times. Example 3: 123Input: nums &#x3D; [11,13,15,17]Output: 11Explanation: The original array was [11,13,15,17] and it was rotated 4 times. Constraints: 1 &lt;= nums.length &lt;= 5000 All the integers of nums are unique. nums is sorted and rotated between 1 and nums.length times. 1234567891011121314int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int lo = 0, hi = n - 1; while(lo &lt; hi) &#123; int mi = lo + (hi - lo &gt;&gt; 1); if(nums[mi] &lt;= nums[hi]) &#123; hi = mi; &#125; else &#123; lo = mi + 1; &#125; &#125; return nums[lo];&#125; 154. Find Minimum in Rotated Sorted Array II 已知一个长度为n的数组，预先按照升序排列，经由1到n次旋转后，得到输入数组。例如，原数组nums = [0,1,2,4,5,6,7]在变化后可能得到： 若旋转4次，则可以得到[4,5,6,7,0,1,2] 若旋转7次，则可以得到[0,1,2,4,5,6,7] 注意，数组[a[0], a[1], a[2], ..., a[n-1]]旋转一次的结果为数组[a[n-1], a[0], a[1], a[2], ..., a[n-2]]。 给你一个可能存在重复元素值的数组nums，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素。 Example 1: 12Input: nums &#x3D; [1,3,5]Output: 1 Example 2: 12Input: nums &#x3D; [2,2,2,0,1]Output: 0 1234567891011121314151617int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int lo = 0, hi = n - 1; while(lo &lt; hi) &#123; int mi = lo + (hi - lo &gt;&gt; 1); if(nums[mi] &lt; nums[hi]) &#123; hi = mi; &#125; else if(nums[mi] &gt; nums[hi]) &#123; lo = mi + 1; &#125; else &#123; hi--; &#125; &#125; return nums[lo];&#125; 33. Search in Rotated Sorted Array 整数数组nums按升序排列，数组中的值互不相同。给你旋转后的数组nums和一个整数target，如果nums中存在这个目标值target，则返回它的下标，否则返回-1。 Example 1: 12Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0Output: 4 Example 2: 12Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3Output: -1 Example 3: 12Input: nums &#x3D; [1], target &#x3D; 0Output: -1 123456789101112131415161718192021222324252627// 没有重复值int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = nums.size() - 1; while(lo &lt;= hi) &#123; int mi = lo + (hi - lo &gt;&gt; 1); if(target == nums[mi]) &#123; return mi; &#125; if(nums[mi] &gt;= nums[lo]) &#123; if(target &lt; nums[mi] &amp;&amp; target &gt;= nums[lo]) &#123; hi = mi - 1; &#125; else &#123; lo = mi + 1; &#125; &#125; else &#123; if(target &gt; nums[mi] &amp;&amp; target &lt;= nums[hi]) &#123; lo = mi + 1; &#125; else &#123; hi = mi - 1; &#125; &#125; &#125; return -1;&#125; 81. Search in Rotated Sorted Array II 已知存在一个按非降序排列的整数数组nums，数组中的值不必互不相同。 给你旋转后的数组nums和一个整数target，请你编写一个函数来判断给定的目标值是否存在于数组中。如果nums中存在这个目标值target，则返回true，否则返回false。 Example 1: 12Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0Output: true Example 2: 12Input: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3Output: false 123456789101112131415161718192021222324252627282930313233// 有重复值int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = nums.size() - 1; while(lo &lt;= hi) &#123; int mi = lo + (hi - lo &gt;&gt; 1); if(target == nums[mi]) &#123; return true; &#125; // 和 I 题相比, 就添加这一个判断语句就行了 // 跳过 nums[lo] == nums[mi] == nums[hi] 的情况 if(nums[lo] == nums[mi] &amp;&amp; nums[mi] == nums[hi]) &#123; lo++; hi--; &#125; else if(nums[mi] &gt;= nums[lo]) &#123; if(target &lt; nums[mi] &amp;&amp; target &gt;= nums[lo]) &#123; hi = mi - 1; &#125; else &#123; lo = mi + 1; &#125; &#125; else &#123; if(target &gt; nums[mi] &amp;&amp; target &lt;= nums[hi]) &#123; lo = mi + 1; &#125; else &#123; hi = mi - 1; &#125; &#125; &#125; return false;&#125; 1004. Max Consecutive Ones III Given a binary array nums and an integer k, return the maximum number of consecutive 1‘s in the array if you can flip at most k 0‘s. Example 1: 123Input: nums &#x3D; [1,1,1,0,0,0,1,1,1,1,0], k &#x3D; 2Output: 6Explanation: [1,1,1,0,0,1,1,1,1,1,1] Example 2: 123Input: nums &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k &#x3D; 3Output: 10Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] 1234567891011121314151617181920212223242526// 滑动窗口, 关注窗口中 0 的个数int longestOnes(vector&lt;int&gt;&amp; nums, int k) &#123; int res = 0; int left = 0, right = 0; int zeros = 0; while(right &lt; nums.size()) &#123; zeros += 1 - nums[right++]; while(zeros &gt; k) &#123; zeros += nums[left++] - 1; &#125; res = max(res, right - left); &#125; return res;&#125;// 魔改到让人看不懂为止int longestOnes(vector&lt;int&gt;&amp; nums, int k)&#123; int l = 0, r = 0; while(r &lt; nums.size()) &#123; k += nums[r++] - 1; if(k &lt; 0) k += 1 - nums[l++]; &#125; return r - l;&#125; 391. 数飞机 给出飞机的起飞和降落时间，用interval序列表示，请计算出天上同时最多有多少架飞机？ 如果多架飞机降落和起飞在同一时刻，我们认为降落有优先权。 样例 1: 12345678&gt;输入: [[1, 10], [2, 3], [5, 8], [4, 7]&gt;输出: 3&gt;解释: &gt;第一架飞机在 1 时刻起飞, 10 时刻降落.&gt;第二架飞机在 2 时刻起飞, 3 时刻降落.&gt;第三架飞机在 5 时刻起飞, 8 时刻降落.&gt;第四架飞机在 4 时刻起飞, 7 时刻降落.&gt;在 5 时刻到 6 时刻之间, 天空中有三架飞机. 样例 2: 123&gt;输入: [[1, 2], [2, 3], [3, 4]]&gt;输出: 1&gt;解释: 降落优先于起飞. 1234567891011121314151617// 扫描线算法int countOfAirplanes(vector&lt;vector&lt;int&gt;&gt; &amp;airplanes) &#123; vector&lt;pair&lt;int, int&gt;&gt; timeSeries; for(auto&amp; interval : airplanes) &#123; timeSeries.push_back(&#123;interval[0], 1&#125;); // 起飞是 1 timeSeries.push_back(&#123;interval[1], -1&#125;); // 降落是 -1 &#125; // 排序时就决定了降落在前, 起飞在后 // 因为如果起飞时间和降落时间相等的话, 降落的第二个值是 -1, 小于起飞的 1 sort(timeSeries.begin(), timeSeries.end()); int count = 0, res = 0; for(auto&amp;&amp; [_, p] : timeSeries) &#123; count += p; res = max(res, count); &#125; return res;&#125; 218. The Skyline Problem 城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的天际线 。 每个建筑物的几何信息由数组buildings表示，其中三元组buildings[i] = [lefti, righti, heighti]表示： lefti是第i座建筑物左边缘的x坐标。 righti是第i座建筑物右边缘的x坐标。 heighti是第i座建筑物的高度。 天际线应该表示为由 “关键点” 组成的列表，格式[[x1,y1],[x2,y2],...]，并按x坐标进行排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y坐标始终为0，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。 注意：输出天际线中不得有连续的相同高度的水平线。例如[...[2 3], [4 5], [7 5], [11 5], [12 7]...]是不正确的答案；三条高度为5的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...] 示例： 12345输入：buildings &#x3D; [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]解释：图 A 显示输入的所有建筑物的位置和高度，图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 使用扫描线算法求解的关键点就在于找出 [高度发生突变] 的位置vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; vector&lt;pair&lt;int, int&gt;&gt; geometrixPoints; // 将每一个建筑分成两个部分, 每部分都代表这栋建筑的几何点 // 例如: [2, 9, 10] 可以转换成 [2, -10] [9, 10] // 我们用高度是否为负值来标志 左/右 边界点 for(auto&amp;&amp; building : buildings) &#123; geometrixPoints.emplace_back(building[0], 0 - building[2]); geometrixPoints.emplace_back(building[1], building[2]); &#125; // 根据 x 值对这些关键点进行排序 // 由于 pair 比较的特性, 排序完之后将保证扫描线从左往右走 // 先出现的建筑先被扫描到, 后出现的建筑后被扫描到 sort(geometrixPoints.begin(), geometrixPoints.end()); multiset&lt;int&gt; heights; // 将 0 提前放入高度集中可以处理扫描线没有扫到任何建筑导致高度突变到 0 时的情况 heights.insert(0); int maxHeight = 0; vector&lt;vector&lt;int&gt;&gt; keyPoints; for(auto&amp;&amp; [x_pos, height] : geometrixPoints) &#123; if(height &lt; 0) &#123; // 是左边界点, 将高度入堆 heights.insert(abs(height)); &#125; else &#123; // 是右边界点, 将高度出堆 heights.erase(heights.find(height)); &#125; // 当前最大高度 int curMaxHeight = *heights.rbegin(); // 看新加入/删除的建筑高度是否影响了建筑的最大高度 // 当前最大高度不等于原先的最大高度就表示这是一个高度突变点 if(curMaxHeight != maxHeight) &#123; // 添加坐标 keyPoints.emplace_back(vector&#123;&#123;x_pos, curMaxHeight&#125;&#125;); // 更新最大高度 maxHeight = curMaxHeight; &#125; &#125; return keyPoints;&#125;/*vector&lt;pair&lt;int, int&gt;&gt; 对 pair 排序默认的方式是，先比较 first，哪个小则排在前first 相等则 second 小的排在前。而 first 这里表示横坐标，second 为负时，表示建筑的左侧在这一位置；second 为正时，表示建筑的右侧在这一位置。所以对 geometrixPoints 遍历时，首先会取出横坐标小的点。如果 2 个点横坐标相等，会先取出 second 小的点，对于负数来说，其实就是高度更高的建筑。也就是说，两个点上有高度不同的建筑，会先取高的出来放入高度集合，集合中高度最大值和之前高度不同，就直接以更高的高度作为关键点的高度。后面更低高度的建筑加入并不会改变最大高度，因此不会错误的当作关键点。如果 second 为正，表示建筑物在此处结束，需要把相应高度从高度集合中删除。有相同建筑同时在此结束，则会先让较低的建筑离开，因为它们不会改变最大高度。只有当最高的建筑物离开时，才进行改变。如果一个位置既有建筑物进来，又有建筑物离开，会先以进来的建筑的高度来更新高度集，原因同理。这一系列正确的遍历顺序都取决于把高度的负值作为左边界点地标志, 高度的正值作为右边界点的标志, 并将它们组合成一个 pair 这一巧妙的设计！！！*/ 4. Median of Two Sorted Arrays 给定两个大小分别为m和n的有序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数。 进阶：你能设计一个时间复杂度为O(log(m+n))的算法解决此问题吗？ Example 1: 123Input: nums1 &#x3D; [1,3], nums2 &#x3D; [2]Output: 2.00000Explanation: merged array &#x3D; [1,2,3] and median is 2. Example 2: 123Input: nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]Output: 2.50000Explanation: merged array &#x3D; [1,2,3,4] and median is (2 + 3) &#x2F; 2 &#x3D; 2.5. Example 3: 12Input: nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]Output: 0.00000 Example 4: 12Input: nums1 &#x3D; [], nums2 &#x3D; [1]Output: 1.00000 12345678910111213141516// 方法一, 双指针归并两个有序数组// 时间和空间复杂度都为 O(m + n)double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(); vector&lt;int&gt; merged(m + n); int i = 0, j = 0, k = 0; while(i &lt; m || j &lt; n) &#123; if(j &gt;= n || (i &lt; m &amp;&amp; nums1[i] &lt; nums2[j])) &#123; merged[k++] = nums1[i++]; &#125; else &#123; merged[k++] = nums2[j++]; &#125; &#125; return double(merged[(m + n) / 2] + merged[(m + n - 1) / 2]) / 2;&#125; 1234567891011121314151617// 方法二, [伪归并] 双指针寻找中位数的位置// 时间复杂度为 O(m + n), 空间复杂度为 O(1)double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(); int i = 0, j = 0; int preValue = 0, curValue = 0; while((i &lt; m || j &lt; n) &amp;&amp; (i + j) &lt;= (m + n) / 2) &#123; preValue = curValue; if(j &gt;= n || (i &lt; m &amp;&amp; nums1[i] &lt; nums2[j])) &#123; curValue = nums2[i++]; &#125; else &#123; curValue = nums2[j++]; &#125; &#125; return (m + n) &amp; 1 ? curValue : double(preValue + curValue) / 2;&#125; 1// 方法三, 划分数组 + 二分查找, 时间复杂度为 O(log(min(m, n))), 空间复杂度为 O(1) 457. Circular Array Loop 存在一个不含0的环形数组nums，每个nums[i]都表示位于下标i的角色应该向前或向后移动的下标个数： 如果nums[i]是正数，向前移动nums[i]步 如果nums[i]是负数，向后移动nums[i]步 因为数组是环形的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。 数组中的循环由长度为k的下标序列seq： 遵循上述移动规则将导致重复下标序列seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...所有nums[seq[j]]应当不是全正就是全负 k &gt; 1 如果nums中存在循环，返回true；否则，返回false。 Example 1: 12345Input: nums &#x3D; [2,-1,1,2,2]Output: trueExplanation:There is a cycle from index 0 -&gt; 2 -&gt; 3 -&gt; 0 -&gt; ...The cycle&#39;s length is 3. Example 2: 12345Input: nums &#x3D; [-1,2]Output: falseExplanation:The sequence from index 1 -&gt; 1 -&gt; 1 -&gt; ... is not a cycle because the sequence&#39;s length is 1.By definition the sequence&#39;s length must be strictly greater than 1 to be a cycle. Example 3: 12345Input: nums &#x3D; [-2,1,-1,-2,-2]Output: falseExplanation:The sequence from index 1 -&gt; 2 -&gt; 1 -&gt; ... is not a cycle because nums[1] is positive, but nums[2] is negative.Every nums[seq[j]] must be either all positive or all negative. 12345678910111213141516171819202122232425262728293031323334// 时间复杂度为 O(n), 空间复杂度为 O(1)bool circularArrayLoop(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); auto getnext = [&amp;](int i) &#123; return ((i + nums[i]) % n + n) % n; &#125;; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] == 0) continue; int slow = i, fast = i; // 符号相同则乘积 &gt; 0 while(nums[i] * nums[getnext(fast)] &gt; 0 &amp;&amp; nums[i] * nums[getnext(getnext(fast))] &gt; 0) &#123; slow = getnext(slow); fast = getnext(getnext(fast)); // 出现环 if(slow == fast) &#123; // 排除长度为 1 的环 if(slow == getnext(slow)) break; return true; &#125; &#125; // 上面的 while 循环没有返回, 说明上面访问过的点的路径不会出现环 // 把访问过的点置 0, 下次不会再次进入同样的无效路径 slow = i; while(nums[i] * nums[slow] &gt; 0) &#123; int temp = getnext(slow); nums[slow] = 0; slow = temp; &#125; &#125; return false;&#125; 41. First Missing Positive 给你一个未排序的整数数组nums，请你找出其中没有出现的最小的正整数。 请你实现时间复杂度为O(n) 并且只使用常数级别额外空间的解决方案。 参考题解：缺失的第一个正数 - 缺失的第一个正数 Example 1: 12Input: nums &#x3D; [1,2,0]Output: 3 Example 2: 12Input: nums &#x3D; [3,4,-1,1]Output: 2 Example 3: 12Input: nums &#x3D; [7,8,9,11,12]Output: 1 Constraints: 1 &lt;= nums.length &lt;= 300 -2^31 &lt;= nums[i] &lt;= 2^31 - 1 123456789101112131415161718// 实际上, 对于一个长度为 n 的数组// 其中没有出现的最小正整数只能在 [1, n+1] 中// 这是因为如果 [1, n] 都出现了, 那么答案是 n+1// 否则答案是 [1, n] 中没有出现的最小正整数// 哈希表, 时间和空间复杂度都为 O(n)int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); unordered_set&lt;int&gt; setting; for(int num : nums) &#123; setting.insert(num); &#125; for(int i = 1; i &lt;= n; i++) &#123; if(!setting.count(i)) &#123; return i; &#125; &#125; return n + 1;&#125; 123456789101112131415161718192021222324252627282930// 对于本题来说 O(n) 的空间复杂度是不符合要求的// 由于我们已经得出了一个关键的结论:// 没有出现的正整数只能在 [1, n+1] 中// 这和数组的索引就存在着对应关系了int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // 由于我们只关注 [1, n+1] 内的正整数 // 因此, 将数组中 &lt;= 0 的数都映射为 n+1 (足够大的正数) for(int i = 0; i &lt; n; i++) &#123; if(nums[i] &lt;= 0) &#123; nums[i] = n + 1; &#125; &#125; // 将数值对应的索引处的数值映射为负数 for(int i = 0; i &lt; n; i++) &#123; int num = abs(nums[i]); if(num &lt;= n &amp;&amp; nums[num - 1] &gt; 0) &#123; nums[num - 1] *= -1; &#125; &#125; // 没有被映射为负数的第一个数的下标 +1 // 就是缺失的第一个正整数 for(int i = 0; i &lt; n; i++) &#123; if(nums[i] &gt; 0) &#123; return i + 1; &#125; &#125; // 否则 return n + 1;&#125; 1482. Minimum Number of Days to Make m Bouquets 给你一个整数数组bloomDay，以及两个整数m和k。现需要制作m束花。制作花束时，需要使用花园中相邻的k朵花 。花园中有n朵花，第i朵花会在bloomDay[i]时盛开，恰好可以用于一束花中。请你返回从花园中摘m束花需要等待的最少的天数。如果不能摘到m束花则返回-1。 Example 1: 1234567Input: bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1Output: 3Explanation: Let&#39;s see what happened in the first three days. x means flower bloomed and _ means flower didn&#39;t bloom in the garden.We need 3 bouquets each should contain 1 flower.After day 1: [x, _, _, _, _] &#x2F;&#x2F; we can only make one bouquet.After day 2: [x, _, _, _, x] &#x2F;&#x2F; we can only make two bouquets.After day 3: [x, _, x, _, x] &#x2F;&#x2F; we can make 3 bouquets. The answer is 3. Example 2: 123Input: bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 2Output: -1Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1. Example 3: 12345678Input: bloomDay &#x3D; [7,7,7,7,12,7,7], m &#x3D; 2, k &#x3D; 3Output: 12Explanation: We need 2 bouquets each should have 3 flowers.Here&#39;s the garden after the 7 and 12 days:After day 7: [x, x, x, x, _, x, x]We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.After day 12: [x, x, x, x, x, x, x]It is obvious that we can make two bouquets in different ways. Example 4: 123Input: bloomDay &#x3D; [1000000000,1000000000], m &#x3D; 1, k &#x3D; 1Output: 1000000000Explanation: You need to wait 1000000000 days to have a flower ready for a bouquet. Example 5: 12Input: bloomDay &#x3D; [1,10,2,9,3,8,4,7,5,6], m &#x3D; 4, k &#x3D; 2Output: 9 Constraints: bloomDay.length == n 1 &lt;= n &lt;= 10^5 1 &lt;= bloomDay[i] &lt;= 10^9 1 &lt;= m &lt;= 10^6 1 &lt;= k &lt;= n 12345678910111213141516171819202122232425262728293031323334353637int minDays(vector&lt;int&gt;&amp; bloomDay, int m, int k)&#123; if(m &gt; bloomDay.size() / k) return -1; auto [minVal, maxVal] = minmax_element(bloomDay.begin(), bloomDay.end()); int lo = *minVal, hi = *maxVal; while(lo &lt;= hi) &#123; int mi = lo + (hi - lo) / 2; if(canMake(bloomDay, m, k, mi)) hi = mi - 1; else lo = mi + 1; &#125; return lo;&#125;bool canMake(vector&lt;int&gt;&amp; bloomDay, int m, int k, int days)&#123; int flowers = 0; for(int i = 0; i &lt; bloomDay.size() &amp;&amp; m &gt; 0; i++) &#123; if(bloomDay[i] &gt; days) &#123; flowers = 0; &#125; else &#123; flowers++; if(flowers == k) &#123; m--; flowers = 0; &#125; &#125; &#125; return m == 0;&#125; 1109. Corporate Flight Bookings 这里有n个航班，它们分别从1到n进行编号。 有一份航班预订表bookings，表中第i条预订记录bookings[i] = [first_i, last_i, seats_i]意味着在从first_i到last_i（包含first_i和last_i）的每个航班上预订了seats_i个座位。 请你返回一个长度为n的数组answer，其中answer[i]是航班i上预订的座位总数。 Example 1: 123456789Input: bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5Output: [10,55,45,25,25]Explanation:Flight labels: 1 2 3 4 5Booking 1 reserved: 10 10Booking 2 reserved: 20 20Booking 3 reserved: 25 25 25 25Total seats: 10 55 45 25 25Hence, answer &#x3D; [10,55,45,25,25] Example 2: 12345678Input: bookings &#x3D; [[1,2,10],[2,2,15]], n &#x3D; 2Output: [10,25]Explanation:Flight labels: 1 2Booking 1 reserved: 10 10Booking 2 reserved: 15Total seats: 10 25Hence, answer &#x3D; [10,25] Constraints: 1 &lt;= n &lt;= 2 * 10^4 1 &lt;= bookings.length &lt;= 2 * 10^4 bookings[i].length == 3 1 &lt;= firsti &lt;= lasti &lt;= n 1 &lt;= seatsi &lt;= 10^4 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 差分数组类class Difference &#123;private: vector&lt;int&gt; diff; public: Difference(const vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); diff.resize(n); for(int i = 0; i &lt; n; i++) &#123; if(i == 0) &#123; diff[i] = nums[i]; &#125; else &#123; diff[i] = nums[i] - nums[i - 1]; &#125; &#125; &#125; // 将闭区间 [i, j] 元素加上 val void add(int i, int j, int val) &#123; diff[i] += val; if(j + 1 &lt; diff.size()) &#123; diff[j + 1] -= val; &#125; &#125; // 返回结果 vector&lt;int&gt; result() &#123; vector&lt;int&gt; res(diff.size()); res[0] = diff[0]; for(int i = 1; i &lt; diff.size(); i++) &#123; res[i] = res[i - 1] + diff[i]; &#125; return res; &#125;&#125;;vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) &#123; // 本题相当于原数组元素均为 0 // 因此其差分数组的元素也都为 0 vector&lt;int&gt; diff(n); Difference difference(diff); for(auto&amp; booking : bookings) &#123; int i = booking[0] - 1; int j = booking[1] - 1; int val = booking[2]; // 将数组 [i..j] 区间内元素加上 val difference.add(i, j, val); &#125; return difference.result();&#125; 123456789101112131415161718192021// 差分数组vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) &#123; // 本题相当于原数组元素均为 0 // 因此其差分数组的元素也都为 0 vector&lt;int&gt; difference(n); for(auto&amp;&amp; booking : bookings) &#123; int i = booking[0] - 1; int j = booking[1] - 1; int val = booking[2]; // 将数组 [i..j] 区间内元素加上 val difference[i] += val; if(j + 1 &lt; n) &#123; difference[j + 1] -= val; &#125; &#125; // 根据差分数组构造原数组 for(int i = 1; i &lt; n; i++) &#123; difference[i] += difference[i - 1]; &#125; return difference;&#125; 1.64 995. Minimum Number of K Consecutive Bit Flips 在仅包含0和1的数组A中，一次K位翻转包括选择一个长度为K的（连续）子数组，同时将子数组中的每个0更改为1，而每个1更改为0。 返回所需的k位翻转的最小次数，以便数组没有值为0的元素。如果不可能，返回-1。 xample 1: 123Input: A &#x3D; [0,1,0], K &#x3D; 1Output: 2Explanation: Flip A[0], then flip A[2]. Example 2: 123Input: A &#x3D; [1,1,0], K &#x3D; 2Output: -1Explanation: No matter how we flip subarrays of size 2, we can&#39;t make the array become [1,1,1]. Example 3: 123456Input: A &#x3D; [0,0,0,1,0,1,1,0], K &#x3D; 3Output: 3Explanation:Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1] Note: 1 &lt;= A.length &lt;= 30000 1 &lt;= K &lt;= A.length 1234567891011121314151617181920212223// 直接模拟反转过程// 时间复杂度为 O(nk), 空间复杂度为 O(1)// 超时 TLE!int minKBitFlips(vector&lt;int&gt;&amp; A, int K)&#123; int n = A.size(); int i = 0, cnt = 0; while(1) &#123; // 找到下一个 0 所在的位置 while(i &lt; n &amp;&amp; A[i] != 0) i++; // 如果没有 0 了, 就全部翻转成功 if(i == n) break; // 如果需要翻转的不够 K 位, 就不可能翻转成功 if(i + K &gt; n) return -1; // 实际地进行翻转 for(int j = 0; j &lt; K; j++) A[i + j] = 1 - A[i + j]; // 翻转次数加一 cnt++; &#125; return cnt;&#125; 1234567891011121314151617181920212223242526272829// 差分数组// 自然而然, 我们会想到使用一个数组来记录每一位的翻转次数// 但是我们又不希望是通过 [遍历数组的 K 位进行 +1 操作] 来完成记录// 所以可以借助差分数组来记录每个区间元素被翻转的次数// 当翻转的次数为奇数次时, 才真的要翻转, 为偶数次时并不需要实际地翻转// 时间复杂度为 O(n), 空间复杂度为 O(n)int minKBitFlips(vector&lt;int&gt;&amp; A, int K)&#123; int n = A.size(); int cnt = 0, sum = 0; // 多一个位置防止越位 vector&lt;int&gt; diff(n + 1); for(int i = 0; i &lt; n; i++) &#123; // 实时计算数组索引 i 处的翻转次数 // 这时计算的是从索引 i 开始的 K 位被翻转之前的该位已经被翻转的次数 if(i &gt; 0) diff[i] += diff[i - 1]; // 判断索引 i 处开始的 K 位是否需要被翻转 if((A[i] + diff[i]) % 2 == 0) &#123; if(i + K &gt; n) return -1; diff[i] += 1; diff[i + K] -= 1; cnt++; &#125; // 这里的逻辑需要好好理一理, 这里相当于一边更新 diff 数组, 一边还原数组的值 &#125; return cnt;&#125; 307. Range Sum Query - Mutable 给你一个数组nums，请你完成两类查询，其中一类查询要求更新数组下标对应的值，另一类查询要求返回数组中某个范围内元素的总和。 实现NumArray类： NumArray(int[] nums)：用整数数组nums初始化对象 void update(int index, int val)：将nums[index]的值更新为val int sumRange(int left, int right)：返回子数组nums[left, right]的总和（即，nums[left] + nums[left + 1], ..., nums[right]） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 树状数组又称二叉索引树 (Binary Indexed Tree)class NumArray&#123;public: // O(nlogn) 的复杂度建立树状数组 NumArray(vector&lt;int&gt;&amp; nums) : _nums(nums), bit(_nums.size()) &#123; for(int i = 0; i &lt; _nums.size(); i++) add(i + 1, _nums[i]); &#125; /* // O(n) 的复杂度建立树状数组 NumArray(vector&lt;int&gt;&amp; nums) &#123; &#125; */ void update(int index, int val) &#123; // 原有的值为 _nums[index], 要更新为 val, 需要加上 val - _nums[index] add(index + 1, val - _nums[index]); _nums[index] = val; &#125; int sumRange(int left, int right) &#123; return getsum(right + 1) - getsum(left); &#125; private: vector&lt;int&gt; _nums; // 注意 bit 数组的索引 [语义] 是从 1 开始 // 长度和原数组相同 vector&lt;int&gt; bit; int lowbit(int x) &#123; return x &amp; (-x); &#125; // 将第 pos 个数加上 val // 时间复杂度为 O(logn) void add(int pos, int val) &#123; for(int i = pos; i &lt;= bit.size(); i += lowbit(i)) bit[i - 1] += val; &#125; // 返回前 pos 个数的和 // 时间复杂度为 O(logn) int getsum(int pos) &#123; int res = 0; for(int i = pos; i &gt; 0; i -= lowbit(i)) res += bit[i - 1]; return res; &#125;&#125;; 1310. XOR Queries of a Subarray 有一个正整数数组arr，现给你一个对应的查询数组queries，其中queries[i] = [Li, Ri]。 对于每个查询i，请你计算从Li到Ri的XOR值（即arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。并返回一个包含给定查询queries所有结果的数组。 123456789101112131415161718192021222324252627282930vector&lt;int&gt; bit;int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int pos, int val)&#123; for(; pos &lt;= bit.size(); pos += lowbit(pos)) bit[pos - 1] ^= val;&#125;int getsum(int pos)&#123; int res; for(; pos &gt; 0; pos -= lowbit(pos)) res ^= bit[pos - 1]; return res;&#125;vector&lt;int&gt; xorQueries(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; queries)&#123; bit.resize(arr.size()); for(int i = 0; i &lt; arr.size(); i++) add(i + 1, arr[i]); vector&lt;int&gt; res; for(auto&amp; query : queries) res.push_back(getsum(query[1] + 1) ^ getsum(query[0])); return res;&#125; 315. Count of Smaller Numbers After Self 给定一个整数数组nums，按要求返回一个新数组counts。数组counts有该性质：counts[i]的值是nums[i]右侧小于nums[i]的元素的数量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 树状数组类class Bit &#123;private: int n; vector&lt;int&gt; bit; int lowbit(int x) &#123; return x &amp; (-x); &#125; public: Bit(int _n) : n(_n), bit(n + 1) &#123; // 本题原数组相当于全 0 数组, 不需要创建 bit // for(int i = 0; i &lt; nums.size(); i++) // add(i + 1, nums[i]); &#125; void add(int pos, int val) &#123; while(pos &lt;= n) &#123; bit[pos] += val; pos += lowbit(pos); &#125; &#125; int getsum(int pos) &#123; int sum = 0; while(pos &gt; 0) &#123; sum += bit[pos]; pos -= lowbit(pos); &#125; return sum; &#125;&#125;;// 离散化树状数组vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; temp(nums); sort(temp.begin(), temp.end()); // 离散化数组的方式, 将数组中的元素按照排名映射为 1 ... // 这种离散方式, 离散化前后并不需要保留元素的绝对大小, 只关心元素的相对大小 for(int i = 0; i &lt; n; i++) &#123; nums[i] = lower_bound(temp.begin(), temp.end(), nums[i]) - temp.begin() + 1; &#125; Bit bit(n); vector&lt;int&gt; res; for(int i = n - 1; i &gt;= 0; i--) &#123; res.push_back(bit.getsum(nums[i] - 1)); bit.add(nums[i], 1); &#125; reverse(res.begin(), res.end()); return res;&#125; 剑指 Offer 51. 数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例: 12输入: [7,5,6,4]输出: 5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 树状数组类class Bit &#123;private: int n; vector&lt;int&gt; bit; int lowbit(int x) &#123; return x &amp; (-x); &#125; public: Bit(int _n) : n(_n), bit(n + 1) &#123; // 本题原数组相当于全 0 数组, 不需要创建 bit // for(int i = 0; i &lt; nums.size(); i++) // add(i + 1, nums[i]); &#125; void add(int pos, int val) &#123; while(pos &lt;= n) &#123; bit[pos] += val; pos += lowbit(pos); &#125; &#125; int getsum(int pos) &#123; int sum = 0; while(pos &gt; 0) &#123; sum += bit[pos]; pos -= lowbit(pos); &#125; return sum; &#125;&#125;;// 离散化树状数组 (具体思想参考官方题解)int reversePairs(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; temp(nums); sort(temp.begin(), temp.end()); // 离散化数组的另一种方式, 通常需要保留原数组中元素大小时采用, 这里最然不需要 // 将每个数按次序映射到数组中的对应的位置 unordered_map&lt;int, int&gt; mapping; int i = 1; for(int num : temp) &#123; mapping[num] = i++; &#125; Bit bit(n); int res = 0; for(int i = n - 1; i &gt;= 0; i--) &#123; res += bit.getsum(mapping[nums[i]] - 1); bit.add(mapping[nums[i]], 1); &#125; return res;&#125; 123456789101112131415161718192021222324252627282930313233343536373839int reversePairs(vector&lt;int&gt; data) &#123; int n = data.size(); int cnt = 0; // 提前分配空间优化构造析构函数效率 vector&lt;int&gt; helper(n/2+1); // 合并闭区间 [lo, mi] 和 [mi + 1, hi] 的子数组 auto merge = [&amp;](int lo, int mi, int hi) &#123; for(int i = mi + 1; i &lt;= hi; i++) &#123; helper[i - mi - 1] = data[i]; &#125; int i = mi; int j = hi - mi - 1; int k = hi; while(i &gt;= lo &amp;&amp; j &gt;= 0) &#123; if(data[i] &gt; helper[j]) &#123; data[k--] = data[i--]; // 就增加这一行 cnt += j + 1; &#125; else &#123; data[k--] = helper[j--]; &#125; &#125; while(j &gt;= 0) &#123; data[k--] = helper[j--]; &#125; &#125;; function&lt;void(int, int)&gt; mergeSort = [&amp;](int lo, int hi) &#123; if(lo &gt;= hi) &#123; return; &#125; int mi = lo + (hi - lo) / 2; mergeSort(lo, mi); mergeSort(mi + 1, hi); merge(lo, mi, hi); &#125;; mergeSort(0, n - 1); return cnt;&#125; 1442. Count Triplets That Can Form Two Arrays of Equal XOR 给你一个整数数组nums。 现需要从数组中取三个下标i、j和k，其中(0 &lt;= i &lt; j &lt;= k &lt; nums.size())。 a和b定义如下： a = nums[i] ^ nums[i + 1] ^ ... ^ nums[j - 1] b = nums[j] ^ nums[j + 1] ^ ... ^ nums[k] 请返回能够令a == b成立的三元组(i, j , k)的数目。 12345678910111213141516// 前缀异或数组 + 三重循环枚举 i, j, k// 时间复杂度为 O(n3), 空间复杂度为 O(n)int countTriplets(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); vector&lt;int&gt; prefix(n + 1); for(int i = 1; i &lt;= n; i++) prefix[i] = prefix[i - 1] ^ nums[i - 1]; int res = 0; for(int i = 0; i &lt; n; i++) for(int j = i + 1; j &lt; n; j++) for(int k = j; k &lt; n; k++) if(prefix[j] ^ prefix[i] == prefix[k + 1] ^ prefix[j]) res++; return res;&#125; 12345678910111213141516171819// 注意到如果 a == b// 那么就有 nums[i] ^ ... ^ nums[j] ^ ... ^ nums[k] == 0// 也就是说有 prefix[k + 1] == prefix[i]// 此时对于 (i, k] 中的每一个 j 都是满足的// 前缀异或数组 + 二重循环枚举 i, k// 时间复杂度为 O(n2), 空间复杂度为 O(n)int countTriplets(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); vector&lt;int&gt; prefix(n + 1); for(int i = 1; i &lt;= n; i++) prefix[i] = prefix[i - 1] ^ nums[i - 1]; int res = 0; for(int i = 0; i &lt; n; i++) for(int k = i + 1; k &lt; n; k++) if(prefix[i] == prefix[k + 1]) res += k - i; return res;&#125; 123456789101112131415161718192021// 哈希表 + 一重循环int countTriplets(vector&lt;int&gt; &amp;nums)&#123; int n = nums.size(); vector&lt;int&gt; prefix(n + 1); for(int i = 1; i &lt;= n; i++) prefix[i] = prefix[i - 1] ^ nums[i - 1]; unordered_map&lt;int, int&gt; cnt, total; int res = 0; for(int k = 0; k &lt; n; ++k) &#123; if(cnt.count(prefix[k + 1])) res += cnt[prefix[k + 1]] * k - total[prefix[k + 1]]; cnt[prefix[k]]++; total[prefix[k]] += k; &#125; return res;&#125; 421. Maximum XOR of Two Numbers in an Array 给你一个整数数组nums，返回nums[i] ^ nums[j]的最大运算结果，其中0 ≤ i ≤ j &lt; n。 进阶：你可以在O(n)的时间解决这个问题吗？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct Trie&#123; Trie* child[2] = &#123;nullptr, nullptr&#125;;&#125;;Trie* root = new Trie;void insert(int num)&#123; Trie* cur = root; for(int i = 30; i &gt;= 0; i--) &#123; int a = (num &gt;&gt; i) &amp; 1; if(!cur-&gt;child[a]) cur-&gt;child[a] = new Trie; cur = cur-&gt;child[a]; &#125;&#125;int check(int num)&#123; Trie* cur = root; int res = 0; for(int i = 30; i &gt;= 0; i--) &#123; int a = (num &gt;&gt; i) &amp; 1; int b = 1 - a; if(cur-&gt;child[b]) &#123; res |= (b &lt;&lt; i); cur = cur-&gt;child[b]; &#125; else &#123; res |= (a &lt;&lt; i); cur = cur-&gt;child[a]; &#125; &#125; return res;&#125;int findMaximumXOR(vector&lt;int&gt;&amp; nums)&#123; int res = 0; for(int num : nums) &#123; insert(num); res = max(res, num ^ check(num)); &#125; return res;&#125; 1707. Maximum XOR With an Element From Array 给你一个由非负整数组成的数组nums。另有一个查询数组queries，其中queries[i] = [xi, mi]。 第i个查询的答案是xi和任何nums数组中不超过mi的元素按位异或得到的最大值。换句话说，答案是max(nums[j] XOR xi)，其中所有j均满足nums[j] &lt;= mi。如果nums中的所有元素都大于mi，最终答案就是-1。 返回一个整数数组answer作为查询的答案，其中answer.length == queries.length且answer[i]是第i个查询的答案。 题解：与数组中元素的最大异或值 - 与数组中元素的最大异或值 - 力扣（LeetCode） Example: 123456Input: nums &#x3D; [0,1,2,3,4], queries &#x3D; [[3,1],[1,3],[5,6]]Output: [3,3,7]Explanation:1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 &#x3D; 3 and 1 XOR 3 &#x3D; 2. The larger of the two is 3.2) 1 XOR 2 &#x3D; 3.3) 5 XOR 2 &#x3D; 7. Constraints: 1 &lt;= nums.length, queries.length &lt;= 10^5 queries[i].length == 2 0 &lt;= nums[j], xi, mi &lt;= 10^9 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution&#123;public: vector&lt;int&gt; maximizeXor(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123; for(int num : nums) insert(num); vector&lt;int&gt; res; res.reserve(queries.size()); for(auto query : queries) res.push_back(getVal(query[0], query[1])); return res; &#125; private: struct Trie &#123; int minVal = INT_MAX; Trie* child[2] = &#123;nullptr, nullptr&#125;; &#125;; Trie* root = new Trie; void insert(int num) &#123; root-&gt;minVal = min(root-&gt;minVal, num); Trie* cur = root; for(int i = 30; i &gt;= 0; i--) &#123; int bit = (num &gt;&gt; i) &amp; 1; if(!cur-&gt;child[bit]) cur-&gt;child[bit] = new Trie; cur-&gt;child[bit]-&gt;minVal = min(cur-&gt;child[bit]-&gt;minVal, num); cur = cur-&gt;child[bit]; &#125; &#125; int getVal(int num, int m) &#123; if(m &lt; root-&gt;minVal) return -1; Trie* cur = root; int res = 0; for(int i = 30; i &gt;= 0; i--) &#123; int bit = (num &gt;&gt; i) &amp; 1; if(cur-&gt;child[bit ^ 1] &amp;&amp; cur-&gt;child[bit ^ 1]-&gt;minVal &lt;= m) &#123; res |= (1 &lt;&lt; i); bit = bit ^ 1; &#125; cur = cur-&gt;child[bit]; &#125; return res; &#125;&#125;; 1074. Number of Submatrices That Sum to Target 给出矩阵matrix和目标值target，返回元素总和等于目标值的非空子矩阵的数量。 如果(x1, y1, x2, y2)和(x1&#39;, y1&#39;, x2&#39;, y2&#39;)两个子矩阵中部分坐标不同（如：x1 != x1&#39;），那么这两个子矩阵也不同。 题解：【宫水三叶】优化枚举的基本思路与进阶内容 - 元素和为目标值的子矩阵数量 - 力扣（LeetCode） 1234567891011121314151617181920// 前缀子矩阵和 + 暴力枚举// 从「点」上来确定一个子矩阵, 在 n 和 m 同阶的情况下, 时间复杂度是 O(n^4)int numSubmatrixSumTarget(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target)&#123; int m = matrix.size(); int n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; prefixsumOfSubMatrix(m + 1, vector&lt;int&gt;(n + 1)); for(int i = 1; i &lt;= m; i++) for(int j = 1; j &lt;= n; j++) prefixsumOfSubMatrix[i][j] = matrix[i - 1][j - 1] + prefixsumOfSubMatrix[i - 1][j] + prefixsumOfSubMatrix[i][j - 1] - prefixsumOfSubMatrix[i - 1][ j - 1]; int res = 0; for(int rl = 1; rl &lt;= m; rl++) for(int cu = 1; cu &lt;= n; cu ++) for(int rr = rl; rr &lt;= m; rr++) for(int cd = cu; cd &lt;= n; cd++) if(prefixsumOfSubMatrix[rr][cd] - prefixsumOfSubMatrix[rr][cu - 1] - prefixsumOfSubMatrix[rl - 1][cd] + prefixsumOfSubMatrix[rl - 1][cu - 1] == target) res++; return res;&#125; 123456789101112131415161718192021222324252627282930313233343536373839// 从「边」上来确定一个子矩阵, 通过枚举三条边// 使用哈希表 + 前缀和来加速查找第四条边// 在 n 和 m 同阶的情况下, 时间复杂度可降到 O(n3)int numSubmatrixSumTarget(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int target)&#123; int m = matrix.size(), n = matrix[0].size(); int res = 0; // 枚举上边界 for(int i = 0; i &lt; m; ++i) &#123; vector&lt;int&gt; sum(n); // 枚举下边界 for(int j = i; j &lt; m; ++j) &#123; // 更新每列的元素和 for(int c = 0; c &lt; n; ++c) sum[c] += matrix[j][c]; // 遍历 sum 子数组的和 res += sumsOfSubArrayEqualTarget(sum, target); &#125; &#125; return res;&#125;// 计算数组中和等于 target 的子数组个数// 前缀和 + 哈希表优化 时间复杂度为 O(n)int sumsOfSubArrayEqualTarget(vector&lt;int&gt;&amp; nums, int target)&#123; unordered_map&lt;int, int&gt; mapping; // 表示以首元素开头的子数组的和等于 target mapping[0] = 1; int res = 0, preSum = 0; for(int num : nums) &#123; preSum += num; if(mapping.count(preSum - target)) res += mapping[preSum - target]; ++mapping[preSum]; &#125; return res;&#125; 1738. Find Kth Largest XOR Coordinate Value 给你一个二维矩阵matrix和一个整数k，矩阵大小为m x n由非负整数组成。矩阵中坐标(a, b)的值可由对所有满足0 &lt;= i &lt;= a &lt; m且0 &lt;= j &lt;= b &lt; n的元素matrix[i][j]（下标从0开始计数）执行异或运算得到。 请你找出matrix的所有坐标中第k大的值（k的值从1开始计数）。 12345678910111213141516171819// 前缀子矩阵异或 + 小顶堆int kthLargestValue(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k)&#123; int m = matrix.size(); int n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; subMatrixXors(m + 1, vector&lt;int&gt;(n + 1)); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; subMatrixXors[i][j] = subMatrixXors[i - 1][j - 1] ^ subMatrixXors[i][j - 1] ^ subMatrixXors[i - 1][j] ^ matrix[i - 1][j - 1]; pq.push(subMatrixXors[i][j]); if(pq.size() &gt; k) pq.pop(); &#125; &#125; return pq.top();&#125; 12345678910111213141516171819// 前缀子矩阵异或 + 快速选择int kthLargestValue(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k)&#123; int m = matrix.size(); int n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; subMatrixXors(m + 1, vector&lt;int&gt;(n + 1)); vector&lt;int&gt; temp; temp.reserve(m * n); for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; subMatrixXors[i][j] = subMatrixXors[i - 1][j - 1] ^ subMatrixXors[i][j - 1] ^ subMatrixXors[i - 1][j] ^ matrix[i - 1][j - 1]; temp.push_back(subMatrixXors[i][j]); &#125; &#125; nth_element(temp.begin(), prev(temp.end(), k), temp.end()); return temp[m * n - k];&#125; 581. Shortest Unsorted Continuous Subarray 给你一个整数数组nums，你需要找出一个连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的最短子数组，并输出它的长度。 Example 1: 123Input: nums &#x3D; [2,6,4,8,10,9,15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Example 2: 12Input: nums &#x3D; [1,2,3,4]Output: 0 1234567891011121314151617// 先排序 + 再比较// 时间复杂度为 O(nlogn)int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; temp(nums); sort(temp.begin(), temp.end()); // 初始化为 -1 和 -2 方便处理数组已经是升序的情况 int left = -1, right = -2; for(int i = 0; i &lt; nums.size(); i++) &#123; if(nums[i] != temp[i]) &#123; if(left == -1) &#123; left = i; &#125; right = i; &#125; &#125; return right - left + 1;&#125; 123456789101112131415// 双层循环暴力法// 时间复杂度为 O(n2)int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int res = 0, left = INT_MAX, right = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; if(nums[j] &lt; nums[i]) &#123; left = min(left, i); right = max(right, j); &#125; &#125; &#125; return left == INT_MAX ? 0 : right - left + 1;&#125; 1234567891011121314151617181920212223242526// 正序和逆序分别遍历// 时间复杂度为 O(n)int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // 初始化为 -1 和 -2 方便处理数组已经是升序的情况 int left = -1, right = -2; int maximun = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] &lt; maximun) &#123; right = i; &#125; else &#123; maximun = nums[i]; &#125; &#125; int minimum = INT_MAX; for(int i = n - 1; i &gt;= 0; i--) &#123; if(nums[i] &gt; minimum) &#123; left = i; &#125; else &#123; minimum = nums[i]; &#125; &#125; return right - left + 1;&#125; 48. Rotate Image 给定一个n × n的二维矩阵matrix表示一个图像。请你将图像顺时针旋转90度。你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1： 12输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] 12345678910// 使用额外空间就比较容易了void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); vector&lt;vector&lt;int&gt;&gt; res(matrix); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; matrix[j][n - i - 1] = res[i][j]; &#125; &#125;&#125; 1234567891011121314151617// 不使用额外空间// 用翻转实现旋转void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); // 上下翻转 for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[n - i - 1][j]); &#125; &#125; // 主对角线翻转 for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; i; j++) &#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125;&#125; 5777. 使数组元素相等的减少操作次数 给你一个整数数组nums，你的目标是令nums中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤： 找出nums中的最大值。记这个值为largest并取其下标i（下标从0开始计数）。如果有多个元素都是最大值，则取最小的i。 找出nums中的下一个最大值，这个值严格小于largest，记为nextLargest。 将nums[i]减少到nextLargest。 返回使nums中的所有元素相等的操作次数。 参考题解：使数组元素相等的减少操作次数 - 使数组元素相等的减少操作次数 - 力扣（LeetCode） 示例 1： 1234567输入：nums &#x3D; [5,1,3]输出：3解释：需要 3 次操作使 nums 中的所有元素相等：1. largest &#x3D; 5 下标为 0 。nextLargest &#x3D; 3 。将 nums[0] 减少到 3 。nums &#x3D; [3,1,3] 。2. largest &#x3D; 3 下标为 0 。nextLargest &#x3D; 1 。将 nums[0] 减少到 1 。nums &#x3D; [1,1,3] 。3. largest &#x3D; 3 下标为 2 。nextLargest &#x3D; 1 。将 nums[2] 减少到 1 。nums &#x3D; [1,1,1] 。 示例 3： 12345678输入：nums &#x3D; [1,1,2,2,3]输出：4解释：需要 4 次操作使 nums 中的所有元素相等：1. largest &#x3D; 3 下标为 4 。nextLargest &#x3D; 2 。将 nums[4] 减少到 2 。nums &#x3D; [1,1,2,2,2] 。2. largest &#x3D; 2 下标为 2 。nextLargest &#x3D; 1 。将 nums[2] 减少到 1 。nums &#x3D; [1,1,1,2,2] 。 3. largest &#x3D; 2 下标为 3 。nextLargest &#x3D; 1 。将 nums[3] 减少到 1 。nums &#x3D; [1,1,1,1,2] 。 4. largest &#x3D; 2 下标为 4 。nextLargest &#x3D; 1 。将 nums[4] 减少到 1 。nums &#x3D; [1,1,1,1,1] 。 提示： 1 &lt;= nums.length &lt;= 5 * 10^4 1 &lt;= nums[i] &lt;= 5 * 10^4 1234567891011121314// 升序排序做法int reductionOperations(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int res = 0; // 总操作次数 int cnt = 0; // 每个元素操作次数 for(int i = 1; i &lt; n; ++i) &#123; if(nums[i] != nums[i-1]) &#123; ++cnt; &#125; res += cnt; &#125; return res;&#125; 123456789101112131415161718// 降序排序做法int reductionOperations(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); vector&lt;int&gt; count; int i = 0, n = nums.size(); while(i &lt; n) &#123; int max_value = nums[i]; int cnt = 0; while(i &lt; n &amp;&amp; nums[i] == max_value) &#123; cnt++; i++; &#125; count.push_back(cnt); &#125; count.pop_back(); partial_sum(count.begin(), count.end(), count.begin()); return accumulate(count.begin(), count.end(), 0);&#125; 645. 错误的集合 集合s包含从1到n的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制成了集合里面的另外一个数字的值，导致集合丢失了一个数字并且有一个数字重复。 给定一个数组nums代表了集合s发生错误后的结果。请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。 示例 1： 12输入：nums &#x3D; [1,2,2,4]输出：[2,3] 提示： 2 &lt;= nums.length &lt;= 1e4 1 &lt;= nums[i] &lt;= 1e4 123456789101112131415161718// 法一：哈希表vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); unordered_set&lt;int&gt; existed; vector&lt;int&gt; res(2); for(int num : nums) &#123; if(existed.count(num)) &#123; res[0] = num; &#125; existed.insert(num); &#125; for(int i = 1; i &lt;= n; i++) &#123; if(existed.count(i) == 0) &#123; res[1] = i; &#125; &#125; return res;&#125; 1234567891011121314151617181920// 法二：下标索引原地哈希vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int a = 0, b = 0; for(int i = 0; i &lt; n; i++) &#123; int num = abs(nums[i]); if(nums[num - 1] &lt; 0) &#123; a = num; &#125; else &#123; nums[num - 1] *= -1; &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] &gt; 0) &#123; b = i + 1; &#125; &#125; return &#123;a, b&#125;;&#125; 123456789101112131415// 法三：数学vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int sum = (1 + n) * n / 2; int sum_1 = 0, sum_2 = 0; vector&lt;bool&gt; sets(n + 1); for(int num : nums) &#123; sum_1 += num; if(!sets[num]) &#123; sum_2 += num; &#125; sets[num] = true; &#125; return &#123;sum_1 - sum_2, sum - sum_2&#125;;&#125; 123456789101112131415161718192021222324252627282930// 法四：位运算vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int xors = 0; for(int i = 0; i &lt; n; i++) &#123; xors = xors ^ (i + 1) ^ nums[i]; &#125; int lowbit = xors &amp; (-xors); int a = 0, b = 0; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] &amp; lowbit) &#123; a = a ^ nums[i]; &#125; else &#123; b = b ^ nums[i]; &#125; if((i + 1) &amp; lowbit) &#123; a = a ^ (i + 1); &#125; else &#123; b = b ^ (i + 1); &#125; &#125; for(int num : nums) &#123; if(a == num) &#123; return &#123;a, b&#125;; &#125; &#125; return &#123;b, a&#125;;&#125; 462. 最少移动次数使数组元素相等 II 给定一个非空整数数组，找到使所有数组元素相等所需的最小操作数，其中每次操作可将选定的一个元素加1或减1。 参考题解： C++｜中位数｜简单证明 - 最少移动次数使数组元素相等 II 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 要使得操作数最小, 最终的值一定是中位数int minMoves2(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // nth_element(nums.begin(), next(nums.begin(), n/2), nums.end()); _nth_element(nums, n/2); int midVal = nums[n/2]; int res = 0; for(int num : nums) &#123; res += abs(num - midVal); &#125; return res;&#125;// 快速选择算法，使得 k 索引处的元素就位void _nth_element(vector&lt;int&gt;&amp; nums, int k) &#123; // 对 [lo, hi] 区间内的元素进行洗牌算法 auto shuffle = [&amp;](int lo, int hi) &#123; for(int i = lo; i &lt;= hi; i++) &#123; int j = rand() % (hi - i + 1) + i; swap(nums[i], nums[j]); &#125; &#125;; // 以首元素为轴点，对 [lo, hi] 区间内元素进行划分 auto partition = [&amp;](int lo, int hi) &#123; shuffle(lo, hi); int i = lo, j = lo; while(++j &lt;= hi) &#123; if(nums[j] &lt; nums[lo]) &#123; swap(nums[++i], nums[j]); &#125; &#125; swap(nums[lo], nums[i]); return i; &#125;; int lo = 0, hi = int(nums.size()) - 1; while(lo &lt;= hi) &#123; int mi = lo + ((hi - lo) &gt;&gt; 1); int p = partition(lo, hi); if(p == k) &#123; return; &#125; else if(p &lt; k) &#123; lo = p + 1; &#125; else &#123; hi = p - 1; &#125; &#125;&#125; 31. 下一个排列 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 参考链接：下一个排列算法详解：思路+推导+步骤，看不懂算我输 12345678910111213141516void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; // next_permutation(nums.begin(), nums.end()); int n = nums.size(); int left = n - 2; while(left &gt;= 0 &amp;&amp; nums[left] &gt;= nums[left + 1]) &#123; left--; &#125; if(left &gt;= 0) &#123; int right = n - 1; while(right &gt;= 0 &amp;&amp; nums[right] &lt;= nums[left]) &#123; right--; &#125; swap(nums[left], nums[right]); &#125; reverse(next(nums.begin(), left + 1), nums.end());&#125; 128. 最长连续序列 给定一个未排序的整数数组nums，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为O(n)的算法解决此问题。 示例 1： 123输入：nums &#x3D; [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 1234567891011121314151617181920// 排序 + 去重 + 计数int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n == 0) &#123; return 0; &#125; sort(nums.begin(), nums.end()); unique(nums.begin(), nums.end()); int res = 0, cnt = 1; for(int i = 1; i &lt; n; i++) &#123; if(nums[i] == nums[i - 1] + 1) &#123; cnt++; &#125; else &#123; res = max(res, cnt); cnt = 1; &#125; &#125; return max(res, cnt);&#125; 123456789101112131415161718// 哈希表int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; existed; for(int num : nums) &#123; existed.insert(num); &#125; int res = 0; for(int num : existed) &#123; if(existed.count(num - 1) == 0) &#123; int maxVal = num; while(existed.count(maxVal + 1)) &#123; maxVal++; &#125; res = max(res, maxVal - num + 1); &#125; &#125; return res;&#125; 207. 课程表 你这个学期必须选修n门课程，记为0到n - 1。在选修某些课程之前需要一些先修课程。 先修课程按数组p给出，其中p[i] = [ai, bi]，表示如果要学习课程ai则必须先学习课程bi。例如，先修课程对[0, 1]表示：想要学习课程0，你需要先完成课程1。 请你判断是否可能完成所有课程的学习？如果可以，返回true；否则，返回false。 示例： 123输入：n &#x3D; 2, p &#x3D; [[1,0],[0,1]]输出：false解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。 12345678910111213141516171819202122232425262728// 拓扑排序bool canFinish(int n, vector&lt;vector&lt;int&gt;&gt;&amp; p) &#123; vector&lt;vector&lt;int&gt;&gt; adj(n); vector&lt;int&gt; in(n); for(auto&amp;&amp; v : p) &#123; adj[v[1]].push_back(v[0]); in[v[0]]++; &#125; queue&lt;int&gt; q; for(int i = 0; i &lt; n; i++) &#123; if(in[i] == 0) &#123; q.push(i); &#125; &#125; vector&lt;int&gt; res; while(!q.empty()) &#123; int from = q.front(); q.pop(); res.push_back(from); for(auto to : adj[from]) &#123; in[to]--; if(in[to] == 0) &#123; q.push(to); &#125; &#125; &#125; return res.size() == n;&#125; 1462. 课程表 IV 你总共需要上n门课，课程编号依次为0到n-1。有的课会有直接的先修课程，比如如果想上课程0，你必须先上课程1，那么会以[1, 0]数对的形式给出先修课程数对。 给你课程总数n和一个直接先修课程数对列表p和一个查询对列表q。 对于每个查询对q[i]，请判断q[i][0]是否是q[i][1]的先修课程。请返回一个布尔值列表，列表中每个元素依次分别对应q每个查询对的判断结果。 注意：如果课程a是课程b的先修课程且课程b是课程c的先修课程，那么课程a也是课程c的先修课程。 参考链接：图最短路径算法之弗洛伊德算法（Floyd） | Echo Blog 123456789101112131415161718vector&lt;bool&gt; checkIfPrerequisite(int n, vector&lt;vector&lt;int&gt;&gt;&amp; p, vector&lt;vector&lt;int&gt;&gt;&amp; q) &#123; vector&lt;vector&lt;bool&gt;&gt; adj(n, vector&lt;bool&gt;(n)); for(auto&amp;&amp; v : p) &#123; adj[v[0]][v[1]] = true; &#125; for(int k = 0; k &lt; n; k++) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; adj[i][j] = adj[i][j] || (adj[i][k] &amp;&amp; adj[k][j]); &#125; &#125; &#125; vector&lt;bool&gt; res; for(auto&amp;&amp; v : q) &#123; res.push_back(adj[v[0]][v[1]]); &#125; return res;&#125; 329. 矩阵中的最长递增路径 给定一个m x n整数矩阵matrix，找出其中最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到 边界外（即不允许环绕）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 1. 建图: 对于每一个点, 都有一个指向比其大的方向的路径// 2. 从所有入度为 0 的点出发分别进行 dfs// 3. 相当于是找到以各个出发节点为根的树的最大深度int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; adj(m * n); vector&lt;int&gt; in(m * n); auto getId = [n](int i, int j) &#123; return i * n + j; &#125;; vector&lt;int&gt; memo(m * n, -1); auto dfs = [&amp;](auto&amp;&amp; dfs, int from) &#123; if(adj[from].empty()) &#123; return 1; &#125; if(memo[from] != -1) &#123; return memo[from]; &#125; int len = 0; for(auto to : adj[from]) &#123; len = max(len, 1 + dfs(dfs, to)); &#125; return memo[from] = len; &#125;; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(i + 1 &lt; m &amp;&amp; matrix[i][j] &lt; matrix[i + 1][j]) &#123; adj[getId(i, j)].push_back(getId(i + 1, j)); in[getId(i + 1, j)]++; &#125; if(j + 1 &lt; n &amp;&amp; matrix[i][j] &lt; matrix[i][j + 1]) &#123; adj[getId(i, j)].push_back(getId(i, j + 1)); in[getId(i, j + 1)]++; &#125; if(i - 1 &gt;= 0 &amp;&amp; matrix[i][j] &lt; matrix[i - 1][j]) &#123; adj[getId(i, j)].push_back(getId(i - 1, j)); in[getId(i - 1, j)]++; &#125; if(j - 1 &gt;= 0 &amp;&amp; matrix[i][j] &lt; matrix[i][j - 1]) &#123; adj[getId(i, j)].push_back(getId(i, j - 1)); in[getId(i, j - 1)]++; &#125; &#125; &#125; int res = 1; for(int i = 0; i &lt; m * n; i++) &#123; if(in[i] == 0) &#123; res = max(res, dfs(dfs, i)); &#125; &#125; return res;&#125; 444. 序列重建 验证原始的序列org是否可以从序列集seqs中唯一地重建。序列org是1到n整数的排列，其中1 ≤ n ≤ 10^4。重建是指在序列集seqs中构建最短的公共超序列。（即使得所有seqs中的序列都是该最短序列的子序列）。确定是否只可以从seqs重建唯一的序列，且该序列就是org。 示例 1： 1234输入：org: [1,2,3], seqs: [[1,2],[1,3]]输出：false解释：[1,2,3] 不是可以被重建的唯一的序列，因为 [1,3,2] 也是一个合法的序列。 示例 2： 123输入：org: [1,2,3], seqs: [[1,2]]输出：false解释：可以重建的序列只有 [1,2]。 示例 3： 123输入：org: [1,2,3], seqs: [[1,2],[1,3],[2,3]]输出：true解释：序列 [1,2], [1,3] 和 [2,3] 可以被唯一地重建为原始的序列 [1,2,3]。 示例 4： 12输入：org: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]输出：true 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 拓扑排序bool sequenceReconstruction(vector&lt;int&gt;&amp; org, vector&lt;vector&lt;int&gt;&gt;&amp; seqs) &#123; if(seqs.empty()) &#123; return false; &#125; int n = org.size(); vector&lt;int&gt; in(n + 1); vector&lt;vector&lt;int&gt;&gt; adj(n + 1); unordered_set&lt;int&gt; all_set; for(auto&amp;&amp; seq : seqs) &#123; int m = seq.size(); for(int i = 0; i &lt; m; i++) &#123; if(seq[i] &lt;= 0 || seq[i] &gt; n) &#123; return false; &#125; if(i == 0) &#123; all_set.insert(seq[i]); continue; &#125; int from = seq[i - 1]; int to = seq[i]; adj[from].push_back(to); in[to]++; all_set.insert(to); &#125; &#125; vector&lt;int&gt; res; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) &#123; if(in[i] == 0) &#123; q.push(i); &#125; &#125; while(!q.empty()) &#123; if(q.size() &gt; 1) &#123; return false; &#125; int from = q.front(); q.pop(); res.push_back(from); for(int to : adj[from]) &#123; in[to]--; if(in[to] == 0) &#123; q.push(to); &#125; &#125; &#125; return org == res;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"重要知识点详细解读之僵尸进程和孤儿进程","date":"2021-03-28T13:35:42.000Z","path":"rakjPpyIOCsd0MoJ/","text":"什么是僵尸进程？简单的说，僵尸进程就是子进程先于父进程退出，并且父进程并没有调用wait系统调用，即使其进程映像中占用的系统资源（比如内存，页表等）都会被释放回收，但这时子进程的进程描述符（PCB）结构仍然存在于系统中得不到释放，就称这样的进程为僵尸进程（Zombie）。 为什么会产生僵尸进程？12void exit(int status);pid_t wait(int* status); 首先，如果一个进程不成为僵尸进程的话，就要请求内核来回收它最后遗留的PCB。而内核给出了exit和wait系统调用来提供回收进程PCB的途径。进程到最后或者是主动调用exit结束运行，或者是通过return语句使得编译器安插exit调用代码，目的都是向父进程传递一个“退出状态值”（这个状态值就是exit函数的那个参数，或者是return语句后面那个整数），我们就叫它临终遗言吧。这个遗言就保存在进程遗留的PCB中，等待着父进程调用wait系统调用去取它的遗言，也就是内核会把这个遗言放在wait函数的参数所指向的内存，取完之后，内核就会回收这块PCB资源。这些都是在执行系统调用期间发生的，也就是说调用了这两个系统调用，给了内核机会来回收遗留的PCB。 如果父进程在派生出子进程后并没有调用wait等待接收子进程的返回值，这时某个子进程调用exit退出了，自然没人来接收返回值了。因此其PCB所占的空间不能释放，没人为其“收尸”，自然就成了“僵 尸”。 僵尸进程有什么危害以及如何处理？虽然进程的退出状态未被父进程取出前，除了PCB以外，其他所有资源都可以释放。但由于PCB不释放，它原本的pid也会继续被占用，当僵尸进程数量很大时，系统将无可用pid分配给新进程，从而加载进程失败。 既然产生了僵尸进程，就说明父进程违背了和内核的约定，不想回收子进程。那么，内核也提供了毫不客气的办法来处理，那就是直接kill掉父进程，在Linux中可以利用ps –ef查看所有任务的pid和ppid，找到状态为Z的进程，查看其ppid，跟着向pid为ppid的进程发送kill -9。 什么是孤儿进程？在子进程提交给父进程返回值的时候，有这样一种情况，当父进程提前退出时，它所有的子进程还在运行，没有一个执行了exit，因为它们的生命周期尚未结束，还在运行中，个个都拥有“全尸”（完整的进程映像）， 这些进程就称为孤儿进程。这时候所有的子进程会被pid为1的init进程收养，init进程会成为这些子进程的新父亲，当子进程退出时会由init负责为其“收尸”。init进程是所有进程的祖先进程，所有进程最初都是通过它派生出来的。 对系统而言，有了init进程的“收养“，孤儿进程并没有什么危害，init会很好地为其善后，因此并不会额外占用资源，它和普通的进程一样，原理上对系统不会产生不良影响。 总结exit是由子进程调用的，表面上功能是使子进程结束运行并传递返回值给内核，本质上是内核在幕后会将进程除PCB以外的所有资源都回收。wait是父进程调用的，表面上功能是使父进程阻塞自己，直到子进程调用exit结束运行，然后获得子进程的返回值，本质上是内核在幕后将子进程的返回值传递给父进程并会唤醒父进程，然后将子进程的PCB回收。 其它可参考链接孤儿进程与僵尸进程产生及其处理_Eunice_fan1207的博客-CSDN博客 Linux下僵尸进程的处理回收详解_CSer-CSDN博客","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"操作系统之进程间通信（含内核实现）","date":"2021-03-25T13:35:42.000Z","path":"tRettVqCkfzWbulf/","text":"背景知识 IPC对象 内核中用于进程间通信的数据结构，全局可见，如消息队列的msg_queue结构体、信号量的sem_array结构体，共享内存的shmid_kernel结构体。类似于普通文件是通过文件名（文件描述符）进行读写操作，通过IPC key和IPC标识符进行IPC对象的读写操作。 IPC标识符ID 类似于文件描述符fd，可以用一个IPC标识符来引用一个IPC对象，是一个32位整数，是IPC对象的外部名字。返回给用户进程的。 IPC key（魔数）IPC对象的内部名，是一个独一无二的整数，用来确保IPC对象的唯一性。该整数类型为key_t，在sys/types.h中被定义为长整型。类似于普通文件通过文件名open一个文件，获得文件描述符；IPC对象是get函数根据给定的key去创建一个IPC对象，并返回IPC标识符ID。根据新资源是信号量、消息队列还是共享内存，分别调用semget()、msgget()或者shmget()函数创建IPC资源。 这三个函数的主要目的都是从IPC key（作为第一个参数传递）中导出相应的IPC标识符ID，进程以后就可以使用这个标识符对资源进行访问。如果还没有IPC资源和IPC关键字相关联，就创建一个新的资源。如果一切都顺利，那么函数就返回一个正的IPC标识符，否则，就返回一个错误码。 在各个独立进程能够访问IPC对象之前，IPC对象必须在系统内唯一标识。为此，每种IPC结构在创建时分配了一个IPC key（程序员自由分配）。凡知道这个IPC key的各个程序，都能够通过它得到一个标识符ID，进而访问对应的IPC对象。如果独立的应用程序需要彼此通信，则通常需要将该魔数永久地编译到程序中。 在访问IPC对象时，操作系统采用了基于文件访问权限的一个权限系统。每个IPC对象都有一个用户ID和一个组ID，依赖于产生IPC对象的程序在何种UID/GID之下运行。读写权限在初始化时分配。类似于普通的文件，这些控制了3种不同用户类别的访问：所有者、组、其他。 IPC在内核中的默认命名空间通过ipc_namespace的静态实例init_ipc_ns实现，每个命名空间都包含如下信息： 1234567// ipc.hstruct ipc_namespace&#123; ... struct ipc_ids* ids[3]; ...&#125;; 该结构体中我们更感兴趣的是数组ids。每个数组元素对应于一种IPC机制：共享内存、信号量、消息队列。每个数组项指向一个struct ipc_ids实例，该结构用于跟踪各类别现存的IPC对象。比如，索引0对应的是信号量，其后是消息队列，最后是共享内存。 123456789// ipc/util.hstruct ipc_ids&#123; int in_use; unsigned short seq; unsigned short seq_max; struct rw_semaphore rw_mutex; struct idr ipcs_idr; // 通过类似于基数树的方式管理 内核内部 ID 到指向 kern_ipc_perm 的指针的映射&#125;; 前几个成员保存了有关IPC对象状态的一般信息。 in_use保存了当前使用中IPC对象的数目。 seq和seq_max用于连续产生用户空间IPC标识符ID。计算方式为ID = seq * M + id。M是固定的宏，值为32768，seq被初始化为0，每次产生一个ID后加1，id为内核内部使用的一个数。 rw_mutex是一个内核信号量。它用于实现信号量操作，避免用户空间中的竞态条件。该互斥量有效地保护了包含信号量值的数据结构。 每个IPC对象都由kern_ipc_perm的一个实例表示，并且都有一个IPC标识符ID，ipcs_idr用于将ID关联到指向对应的kern_ipc_perm实例的指针。 kern_ipc_perm的成员保存了有关IPC对象的所有者和访问权限等信息。 1234567891011struct kern_ipc_perm&#123; /*int id;*/ key_t key; uid_t uid; gid_t gid; uid_t cuid; gid_t cgid; mode_t mode; unsigned long seq;&#125;; key保存了用户程序用来标识IPC对象的IPC key，id就是前面用来计算标识符ID的公式中的id。 uid和gid分别指定了所有者的用户ID和组ID。cuid和cgid保存了产生信号量的进程的用户ID和组ID。 seq是一个序号，在分配IPC对象时使用，和ipc_ids结构中意思相同，为创建该资源是使用的seq。 mode保存了位掩码，指定了所有者、组、其他用户的访问权限。 应用场景 数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。 共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。 进程控制：有些进程希望完全控制另一个进程的运行（如Debug进程）模式，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 每个进程的用户地址空间都是独立的，但是内核空间是共享的，所以，进程之间要想相互通信都要经过内核。Linux提供的几种进程间通信方式有管道、消息队列、信号量、信号、共享内存和本地套接字 管道管道只能单向传输数据，如果要想双向传输数据，需要创建两个管道。管道分为命名管道和匿名管道。 命名管道的可通过mkfifo命令来创建，并且指定管道名。 1$ mkfifo mypipe 命名管道是以文件的方式存在于文件系统中，类型为p。进程之间可以通过这个文件进行通信。它是为了解决下面将要介绍的匿名管道只能用于具有亲缘关系的进程间通信的局限性的。 匿名管道通过pipe系统调用创建： 1int pipe(int fd[2]); 该函数通过传出参数返回两个文件描述符，如果不清楚文件描述符的概念，参考这篇文章。一个是管道读取端描述符fd[0]，一个是管道的写入端描述符fd[1]。匿名管道是只存在内存中的特殊文件，实际上就是内核中的一块缓存。管道传输的数据是无格式的字节流且大小受限。 通过fork系统调用创建子进程，创建的子进程会复制父进程的文件描述符，这样两个进程就可以通过各自的fd写入和读取同一个管道文件实现跨进程通信了。 管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是： 父进程关闭读取的fd[0]，只保留写入的fd[1]； 子进程关闭写入的fd[1]，只保留读取的fd[0]； 在shell里面执行A | B命令的时候，A进程和B进程都是shell创建出来的子进程，A和B之间不存在父子关系，它俩的父进程都是shell。 当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。 在Linux中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个file结构指向同一个临时的VFS索引节点，而这个VFS索引节点又指向一个物理页面而实现的。 管道是个环形缓冲区，对环形缓冲区的维护，主要是协调好数据读写的两个指针，以及生产者、消费者的休眠时机。环形缓冲区中一个指针用于读数据，另一个用于写数据。当缓冲区已满时，生产者要睡眠，并在睡眠前唤醒消费者，当缓冲区为空时，消费者要睡眠，并在睡眠前唤醒生产者。当缓冲区满或空时，使一方休眠，这是保证数据不丢失的方法。管道其实就是典型的生产者和消费者问题。 管道写函数通过将字节复制到VFS索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，内核必须利用一定的机制同步对管道的访问，为此，内核使用了锁、等待队列和信号。 当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的file结构。file结构中指定了用来进行管道专门写操作的函数pipe_write地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查VFS索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作： 内存中有足够的空间可容纳所有要写入的数据； 内存没有被读程序锁定。 如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在VFS索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。 管道的读取过程和写入过程类似，通过read系统调用转调用管道专用读操作函数pipe_read。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。 可以说管道适用于具有亲缘关系的进程间通信。无论是命名管道还是匿名管道，进程写入的数据都是缓存在内核的内存缓冲区中，读取的时候自然也是从内核的内存缓冲区中读取，因此需要在用户态和内核态之间转换。因此，管道的通信方式是低效率的，不适合进程间频繁地、大块地交换数据。 消息队列消息队列的通信模式比如说，A进程要给B进程发送消息，A进程把数据放在对应的消息队列后就可以正常返回了，B进程需要的时候再去读取数据就可以了。同理，B进程要给A进程发送消息也是如此。 消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。 消息队列生命周期根随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。发送者和接收者通过消息队列通信时，无需同时运行，例如，发送进程可以打开一个队列，写入消息，然后结束工作，接收进程在发送者结束之后启动，仍然可以访问队列并（根据消息编号）获取消息。中间的一段时间内消息由内核维护。 消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，每个消息都至少分配一个内存页，同时所有队列所包含的全部消息体的总长度也是有上限。在Linux内核中，会有两个宏定义MSGMAX和MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。 消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时或者另一进程读取内核中的消息数据时，会发生从内核缓冲区拷贝数据到用户缓冲区的过程。 消息队列的实现： 消息队列使用名为msg_queue的结构体： 123456789101112131415struct msg_queue&#123; struct kern_ipc_perm q_perm; time_t q_stime; // 上一次调用 sgsnd 送消息的时 time_t q_rtime; // 上一次调用 msgrcv 接收消息的时间 time_t q_ctime; // 上一次修改的时间 unsigned long q_cbytes; /*队列上当前字节数目*/ unsigned long q_qnum; /*队列中的消息数目*/ unsigned long q_qbytes; /*队列上最大字节数目*/ pid_t q_lspid; /*上一次调用 msgsnd 的 pid */ pid_t q_lrpid; /*上一次接收消息的 pid */ struct list_head q_messages; // 消息体链表 struct list_head q_receivers; // 睡眠的接收者链表 struct list_head q_senders; // 睡眠的发送者链表&#125;; q_messages中的各个消息都封装在msg_msg结构体中： 1234567891011121314struct msg_msg&#123; struct list_head m_list; long m_type; // 消息类型 int m_ts; /*消息正文长度*/ struct msg_msgseg* next;// 如果保存的消息超过一个内存页的长度 /*接下来是实际的消息*/&#125;;struct msg_msgseg&#123; struct msg_msgseg* next; /*接下来是消息的下一部分*/&#125;； 消息正文紧接着该数据结构的实例之后存储。使用next，可以使消息分布到任意数目的页上。在通过消息队列通信时，发送进程和接收进程都可以进入睡眠：如果消息队列已经达到最大容量，则发送者在试图写入消息时会进入睡眠；如果队列中没有消息，那么接收者在试图获取消息时会进入睡眠。 睡眠的发送者放置在msg_queue的q_senders链表中，睡眠的接收者放置在q_receivers链表中，链表元素使用下列数据结构： 123456789101112131415struct msg_sender&#123; struct list_head list; struct task_struct* tsk; // 指向休眠进程的进程描述符&#125;;struct msg_receiver&#123; struct list_head r_list; struct task_struct* r_tsk; // 指向休眠进程的进程描述符 int r_mode; long r_msgtype; long r_maxsize; struct msg_msg *volatile r_msg;&#125;; 共享内存操作系统内存管理采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程A和进程B的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。 共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。 但是共享内存通信方式带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。 共享内存的实现： 同样，在smd_ids全局变量的entries数组中保存了kern_ipc_perm和shmid_kernel的组合，以便管理IPC对象的访问权限。对每个共享内存对象都创建一个伪文件，通过shm_file连接到shmid_kernel的实例。内核使用shm_file-&gt;f_mapping指针访问地址空间对象（struct address_space），用于创建匿名映射。还需要设置所涉及各进程的页表，使得各个进程都能够访问与该IPC对象相关的内存区域。 信号量为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。 信号量其实是一个整型的计数器，程序对其访问都是原子操作，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。 信号量表示资源的数量，控制信号量的方式有两种原子操作： 一个是P操作，这个操作会把信号量减去-1，相减后如果信号量&lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量&gt;= 0，则表明还有资源可使用，进程可正常继续执行。 另一个是V操作，这个操作会把信号量加上1，相加后如果信号量&lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量&gt; 0，则表明当前没有阻塞中的进程； P操作是用在进入共享资源之前，V操作是用在离开共享资源之后，这两个操作是必须成对出现的。 信号量初始化为1，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。信号初始化为0，就代表着是同步信号量，它可以保证进程A应在进程B之前执行。 信号量的实现： sem_queue是一个数据结构，用于将信号量与睡眠进程关联起来，该进程想要执行信号量操作，但目前不允许执行。换句话说，信号量的待决操作列表中，每一项都是该数据结构的实例。 123456789101112131415// sem.hstruct sem_queue&#123; struct sem_queue* next; /*队列中下一项*/ struct sem_queue* prev; /*队列中的前一项，对于第一项有 *(q-&gt;prev) == q*/ struct task_struct* sleeper; /*睡眠的进程*/ struct sem_undo* undo; /*用于撤销的结构*/ int pid; /*请求信号量操作的进程 ID*/ int status; /*操作的完成状态*/ struct sem_array* sma ;/*操作的信号量数组*/ int id; /*内部信号量 ID*/ struct sembuf* sops; /*待决操作数组*/ int nsops; /*操作数目*/ int alter; /*操作是否改变了数组?*/&#125;; 对每个信号量，都有一个队列管理与信号量相关的所有睡眠进程。该队列并未使用内核的标准设施实现（即struct list_head），而是通过next和prev指针手工实现的。 sleeper是一个指针，指向等待执行信号量操作进程的task_struct实例。 pid指定了等待进程的PID。 id保存了标识该信号量的ID。 sops是一个指针，指向保存待决信号量操作的数组。操作数目（即，数组的长度）在nsops中定义。 alter表明操作是否修改信号量的值（例如，状态查询不改变值）。 sma保存了一个指针，指向用于管理信号量状态的数据结构的实例。 123456789101112// sem.hstruct sem_array&#123; struct kern_ipc_perm sem_perm; /*权限，参见ipc.h*/ time_t sem_otime; /*最后一次信号量操作的时间*/ time_t sem_ctime; /*最后一次修改的时间*/ struct sem *sem_base; /*指向数组中第一个信号量的指针*/ struct sem_queue *sem_pending; /*需要处理的待决操作*/ struct sem_queue* sem_pending_last; /*上一个待决操作*/ struct sem_undo *undo; /*该数组上的撤销请求*/ unsigned long sem_nsems; /*数组中信号量的数目*/&#125;; 系统中的每个信号量集合，都对应于该数据结构的一个实例。该实例用于管理集合中的所有信号量（这个信号量集合指的是，每个进程操作信号量时，信号量都有一个值，将这些值组合在这个集合中，由下面要介绍的sem_base指向的数组表示）。 信号量访问权限保存在我们熟悉的kern_ipc_perm类型的sem_perm成员中。 sem_nsems指定了一个用户信号量集合中信号量的数目。 sem_base是一个数组，每个数组项描述了集合中的一个信号量。其中保存了当前的信号量值和上一次访问它的进程的PID。 12345struct sem&#123; int semval; // 当前值 int sempid; // 上一次操作进程的 pid&#125;; sem_otime指定了上一次访问信号量的时间。sem_ctime指定了上次修改信号量值的时间。 sem_pending指向待决信号量操作的链表。该链表由sem_queue实例组成。sem_pending_last用于快速访问该链表的最后一个元素，而sem_pending指向链表的起始。 从当前命名空间获得sem_ids实例开始，内核通过ipcs_idr找到ID到指针的映射，在其中查找所需的kern_ipc_perm实例。kern_ipc_perm项可以转换为sem_array的实例。信号量的当前状态需要通过与另外两个结构的联系获取。 待决操作通过sem_queue实例的链表管理。等待操作执行的睡眠进程，也可以通过该链表确定。 struct sem实例的数组用于保存集合中各个信号量的值。 kern_ipc_perm是用来管理IPC对象的数据结构的第一个成员，不止对信号量是这样，消息队列和共享内存对象也是如此。这使得内核可以使用同样的代码检查所有3种对象的访问权限。放在第一个位置还方便转换为sem_array。 每个sem_queue成员包含了一个指针sops，指向sembuf实例的数组，sembuf详细描述了在信号量上将要执行的操作。使用sembuf实例的数组，可以使用一个semctl调用，用于在信号量集合的各个信号量上执行操作。 1234567// sem.hstruct sembuf&#123; unsigned short sem_num; // 信号量在数组中的索引 short sem_op; // 信号量操作 short semflg; // 操作标志&#125;; 它不仅保存了信号量在信号量集合struct sem[]中的索引（sem_num），还有所要进行的操作（sem_op）和一些操作标志（sem_flg）。 信号上面说的进程间通信，都是常规状态下的工作模式。对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。在Linux操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过kill -l命令，查看所有的信号： 1234567891011121314$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX 运行在shell终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如 Ctrl + C产生SIGINT信号，表示终止该进程； Ctrl + Z产生SIGTSTP信号，表示停止该进程，但还未结束； 如果进程在后台运行，可以通过kill命令的方式给进程发送信号，但前提需要知道运行中的进程PID号，例如： 1$kill -9 1050 表示给PID为1050的进程发送SIGKILL信号，用来立即结束该进程。 所以，信号事件的来源主要有硬件来源（如键盘Cltr + C）和软件来源（如kill命令）。 信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。 执行默认操作。Linux对每种信号都规定了默认操作，例如，上面列表中的SIGTERM信号，就是终止进程的意思。Core的意思是Core Dump，也即终止进程后，通过Core Dump将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。 捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。 忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即SIGKILL和SEGSTOP，它们用于在任何时候中断或结束某一进程。 本地套接字我们先来看看创建socket的系统调用： 1int socket(int domain, int type, int protocal) 三个参数分别代表： domain参数用来指定协议族，比如AF_INET用于IPV4、AF_INET6用于IPV6、AF_LOCAL/AF_UNIX用于本机； type参数用来指定通信特性，比如SOCK_STREAM表示的是字节流，对应TCP、SOCK_DGRAM表示的是数据报，对应UDP、SOCK_RAW表示的是原始套接字； protocal参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol目前一般写成0即可； 根据创建socket类型的不同，通信的方式也就不同： 实现TCP字节流通信：socket类型是AF_INET和SOCK_STREAM； 实现UDP数据报通信：socket类型是AF_INET和SOCK_DGRAM； 实现本地进程间通信：「本地字节流socket」类型是AF_LOCAL和SOCK_STREAM，「本地数据报socket」类型是AF_LOCAL和SOCK_DGRAM。另外，AF_UNIX和AF_LOCAL是等价的。 本地字节流socket和本地数据报socket在bind的时候，不像TCP和UDP要绑定IP地址和端口，而是绑定一个本地文件，这也是它们之间的最大区别。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"leetcode刷题系列之队列和栈","date":"2021-03-18T13:35:42.000Z","path":"fhQPnKWa9qDDelG3/","text":"这篇文章是leetcode刷题系列的第5部分——队列和栈。这里把有代表性的题目发出来，共计22道。主要涉及BFS算法、DFS算法、单调栈以及单调队列技巧的应用。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！ 1660. Correct a Binary Tree 你有一棵二叉树，这棵二叉树有个小问题，其中有且只有一个无效节点，它的右子节点错误地指向了与其在同一层且在其右侧的一个其他节点。 给定一棵这样的问题二叉树的根节点root，将该无效节点及其所有子节点移除（不移除被错误指向的节点），然后返回新二叉树的根结点。 示例: 123输入: root &#x3D; [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode &#x3D; 7, toNode &#x3D; 4输出: [8,3,1,null,null,9,4,null,null,5,6]解释: 值为 7 的节点是无效的，所以移除这个节点及其子节点 2。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 借助层序遍历的思想// 如果遍历到某一个节点, 发现其右孩子已经访问过了// 就说明当前节点就是无效节点// 但此时需要记录已经访问过的节点// 如果要把此无效节点删除, 还要知道当前节点的父节点// 因此, 使用一个哈希表记录所有访问过的节点以及这些节点的父节点// 哈希表的映射有点特殊, 因为我们想达到这样的效果 mapping[node] == node's parent// 因此, 每次访问一个节点 node 时// 以 node 为值, 分别以其左右孩子(如果存在的话)为键加入哈希表TreeNode* correctBinaryTree(TreeNode* root)&#123; // 队列仅仅用于完成层序遍历 queue&lt;TreeNode*&gt; q; // 当前节点和其父亲的映射的哈希表 unordered_map&lt;TreeNode*, TreeNode*&gt; mapping; if(root) q.push(root); // 标记是否找到了无效节点, 可用于提前结束遍历 bool flag = false; while(!q.empty() &amp;&amp; !flag) &#123; int sz = q.size(); for(int i = 0; i &lt; sz; i++) &#123; TreeNode* node = q.front(); q.pop(); // 以上都是标准的层序遍历迭代实现的固定框架 // 如果当前节点的右孩子已经遍历过了 // 说明找到无效节点 if(mapping.count(node-&gt;right)) &#123; if(mapping[node]-&gt;left == node) // 如果当前节点是其父节点的左孩子 mapping[node]-&gt;left = nullptr; else // 否则是右孩子 mapping[node]-&gt;right = nullptr; flag = true; break; &#125; else &#123; // 否则继续遍历就是了 if(node-&gt;left) &#123; mapping[node-&gt;left] = node; q.push(node-&gt;left); &#125; if(node-&gt;right) &#123; mapping[node-&gt;right] = node; q.push(node-&gt;right); &#125; &#125; &#125; &#125; return root;&#125; 394. Decode String 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的encoded_string正好重复k次。注意k保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数k ，例如不会出现像3a或2[4]的输入。 Constraints: 1 &lt;= s.size() &lt;= 30 s consists of lowercase English letters, digits, and square brackets &#39;[]&#39;. s is guaranteed to be a valid input. All the integers in s are in the range [1, 300]. Example 1: 12Input: s &#x3D; &quot;3[a]2[bc]&quot;Output: &quot;aaabcbc&quot; Example 2: 12Input: s &#x3D; &quot;2[abc]3[cd]ef&quot;Output: &quot;abcabccdcdcdef&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void repeatString(string&amp; str, int count)&#123; string s = str; while(--count) str = s + str;&#125;string decodeString(string str)&#123; unordered_set&lt;string&gt; isdigits&#123;\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"&#125;; stack&lt;string&gt; s; for(char c : str) &#123; if(c == ']') &#123; string substr; while(!s.empty() &amp;&amp; s.top() != \"[\") &#123; substr = s.top() + substr; s.pop(); &#125; s.pop(); // pop 掉相匹配的那个 '[' // 获取 [] 前面的那个数字, 注意可能是多位数 string numstr; while (!s.empty() &amp;&amp; isdigits.count(s.top())) &#123; numstr = s.top() + numstr; s.pop(); &#125; // 将 [] 中的字串重复指定次 repeatString(substr, stoi(numstr)); // 新串再次入栈 s.push(substr); &#125; else s.push(string(1, c)); &#125; // 这时从栈底到栈顶的所有串连在一起其实就是答案了 // 但是要转为 string 返回 string res; while(!s.empty()) &#123; res = s.top() + res; s.pop(); &#125; return res;&#125; 752. Open the Lock 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;。每个拨轮可以自由旋转：例如把&#39;9&#39;变为&#39;0&#39;，&#39;0&#39;变为&#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为&#39;0000&#39; ，一个代表四个拨轮的数字的字符串。 列表deadends包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串target代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回-1。 Example 1: 123456Input: deadends &#x3D; [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target &#x3D; &quot;0202&quot;Output: 6Explanation:A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;. Example 2: 12345Input: deadends &#x3D; [&quot;8888&quot;], target &#x3D; &quot;0009&quot;Output: 1Explanation:We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// 宽度优先遍历 BFS 通常用来解决最小(距离)、最短(路径)、最少(步数)等问题// 先给出 BFS 算法框架// 计算从 [开始状态] 到 [目标状态]的最近距离int BFS(STATE startState, STATE targetState)&#123; queue&lt;STATE&gt; q; // 核心数据结构 unordered_map&lt;STATE&gt; visited; // 避免走回头路 q.push(startState); // 将起点加入队列 visited.insert(startState); int step = 0; // 记录扩散的步数 while(!q.empty()) &#123; int sz = q.size(); /* 将当前队列中的所有状态分别向其所有相邻状态转换 */ for (int i = 0; i &lt; sz; i++) &#123; STATE curState = q.front(); q.pop(); // 下面代码是需要你根据实际问题的逻辑做调整的 /***************************************/ /* 划重点: 这里判断是否到达终点 */ if (curState is targetState) return step; /* 将 cur 的所有相邻状态加入队列 */ for (STATE state : all adjacent states of curState ) &#123; if (state not in visited) &#123; q.push(state); visited.insert(state); &#125; &#125; /***************************************/ &#125; /* 划重点: 更新步数在这里 */ step++; &#125; return step;&#125;// 对于我们这题打开密码锁的问题// 就是穷举所有的密码组合, 直到到达目标密码// 密码锁初始值(开始状态)为 \"0000\", 一共四个位置, 每个位置可以向上或向下拨动, 也就是有 8 个相邻状态int openLock(vector&lt;string&gt;&amp; deadends, string target)&#123; queue&lt;string&gt; q; unordered_set&lt;string&gt; visited; unordered_set&lt;string&gt; deads; // 将死亡密码加入哈希集合 // 其实这里是可以直接用 visited, 就是说直接把死亡密码看作已经被访问过了, 一样的 for(auto elem : deadends) deads.insert(elem); q.push(\"0000\"); visited.insert(\"0000\"); int step = 0; while(!q.empty()) &#123; int qSize = q.size(); for(int i = 0; i &lt; qSize; i++) &#123; // 从队列中取出一个状态访问 string curLock = q.front(); q.pop(); // 如果当前状态在死亡状态里面 // 说明我们不能够到达这个状态 // 因此也就不可能从这个状态向其它相邻状态转换 // 继续取出队列中的下一个状态 if(deads.count(curLock)) continue; // 如果当前状态是目标状态了 if(curLock == target) return step; // 否则, 向相邻的 8 个状态转换 for(int j = 0; j &lt; 4; j++) &#123; // 将第 j 个字符向上拨动 string upRotate = rotate(curLock, j, 1); if(!visited.count(upRotate)) &#123; q.push(upRotate); visited.insert(upRotate); &#125; // 将第 j 个字符向下拨动 string downRotate = rotate(curLock, j, 0); if(!visited.count(downRotate)) &#123; q.push(downRotate); visited.insert(downRotate); &#125; &#125; &#125; step++; &#125; return -1;&#125;// direction 为 1 向上拨动, 为 0 则向下拨动string rotate(string theLock, int position, bool direction)&#123; if(direction) &#123; if(theLock[position] == '9') &#123; theLock[position] = '0'; return theLock; &#125; theLock[position]++; return theLock; &#125; else &#123; if(theLock[position] == '0') &#123; theLock[position] = '9'; return theLock; &#125; theLock[position]--; return theLock; &#125;&#125; 37. Sudoku Solver 编写一个程序，通过填充空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字1-9在每一行只能出现一次。 数字1-9在每一列只能出现一次。 数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。空白格用&#39;.&#39;表示。 一个数独 红色为答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 这是深度优先搜索算法应用的典型题目// void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board)&#123; dfs(board, 0, 0);&#125;bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col)&#123; // 如果当前行填写完了, 就到下一行 if(col == board.size()) return dfs(board, row + 1, 0); // 如果最后一行也填完了, 就说明找到了数独的一个解 if(row == board.size()) return true; // 如果当前格子中已经有数了就跳过这个格子 if(board[row][col] != '.') return dfs(board, row, col + 1); // 针对当前格子 // 从数字 1 到 9 依次尝试 for(char c = '1'; c &lt;= '9'; c++) &#123; // 如果当前格子放置这个数字不符合那 3 条规则就跳过 if(!isValid(board, row, col, c)) continue; // 做选择 board[row][col] = c; // 这里的 if 语句可以在找到一组解的时候立即返回 // 不至于找到所有可能的解 if(dfs(board, row, col + 1)) return true; // 撤销选择 board[row][col] = '.'; &#125; return false;&#125;bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, char c)&#123; for(int i = 0; i &lt; board.size(); i++) &#123; // 当前行不能有数字重复 if(board[row][i] == c) return false; // 当前列不能有数字重复 if(board[i][col] == c) return false; // 当前格子所在的九宫格不能有数字重复 // 这特么还真不好写, 看不懂就背下吧 if(board[(row / 3) * 3 + i / 3][(col / 3) * 3 + i % 3] == c) return false; &#125; return true;&#125; 279. Perfect Squares 给定正整数n，找到若干个完全平方数（比如1, 4, 9, 16, ...）使得它们的和等于n。你需要让组成和的完全平方数的个数最少。 给你一个整数n ，返回和为n的完全平方数的最少数量。 Example 1: 123Input: n &#x3D; 12Output: 3Explanation: 12 &#x3D; 4 + 4 + 4. Example 2: 123Input: n &#x3D; 13Output: 2Explanation: 13 &#x3D; 4 + 9. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// DP 递推式: numSquares(n) = min(numSquares(n - k)) + 1// 有点 找零钱 那题的那味儿int numSquares(int n)&#123; vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] = 0; vector&lt;int&gt; squares; // 先计算出所有符合条件的完全平方数 for(int i = 1; i * i &lt;= n; i++) squares.push_back(i * i); for(int i = 1; i &lt;= n; i++) &#123; for(int square : squares) &#123; if(i - square &lt; 0) break; dp[i] = min(dp[i], dp[i - square]); &#125; dp[i]++; &#125; return dp[n];&#125;// 穷举所有完全平方数相加的组合, 直到一组的和等于目标数// 因为要找用到的 [最少的] 完全平方数, 所以使用 BFS// 第 1 轮: 搜索所有 1 位数字判断是否满足// 将 0 + (1, 2, 4, 9, ...) 的数字依次放进队列中// 第 2 轮: 搜索所有 2 位数字的和并判断是否满足// 将 1 + (1, 2, 4, 9, ...) 的数字依次放进队列中// 将 2 + (1, 2, 4, 0, ...) 的数字依次放进队列中// ...// 第 3 轮: 搜索所有 3 位数字和并判断是否满足// ...// 你会发现我们穷举的时候遇到了大量同样的数字组合, 因此使用一个哈希集合来跳过它们int numSquares(int n)&#123; queue&lt;int&gt; q; unordered_set&lt;int&gt; visited; q.push(0); int step = 0; while(!q.empty()) &#123; int sz = q.size(); for(int i = 0; i &lt; sz; i++) &#123; int cur = q.front(); q.pop(); if(cur == n) return step; // 直到完全平方数大于目标数 // 这里的循环相当于是找当前值的所有可能的邻居 for(int j = 1; j * j &lt;= n; j++) &#123; int temp = cur + j * j; // 如果完全平方数的和还小于目标数 // 或者这个和没有被访问, 才加入队列 if(temp &lt;= n &amp;&amp; !visited.count(temp)) &#123; q.push(temp); visited.insert(temp); &#125; &#125; &#125; step++; &#125; return -1;&#125; 155. Min Stack 设计一个支持push，pop，top操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素x推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 1234567891011121314151617181920212223242526272829303132333435class MinStack&#123;public: /** initialize your data structure here. */ MinStack() : _minVal(INT_MIN) &#123;&#125; void push(int x) &#123; if(x &lt; _minVal || _data.empty()) _minVal = x; _data.push_back(x); &#125; void pop() &#123; if(_data.empty()) return; if(_data.back() == _minVal) _minVal = *min_element(_data.begin(), _data.end() - 1); _data.pop_back(); &#125; int top() &#123; return _data.back(); &#125; int getMin() &#123; return _minVal; &#125;private: vector&lt;int&gt; _data; int _minVal;&#125;; 739. Daily Temperatures 请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用0来代替。 例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是[1, 1, 4, 2, 1, 1, 0, 0]。 123456789101112131415161718192021222324252627// 这题本质上就是找到当前元素的下一个比它大的元素// 然后两者的索引相减即可// 像这样和下一个更大元素有关的问题都需要使用一种单调栈的技巧// 就是说维护一个栈, 使其中的元素保持单调的次序// 下面的代码就是单调栈的模板// 这里维护着从栈底到栈顶递减的次序vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T)&#123; // 存放答案的数组 vector&lt;int&gt; res(T.size()); stack&lt;int&gt; s; // 倒着遍历入栈, 因此也就是正着出栈 for(int i = T.size() - 1; i &gt;= 0; i--) &#123; // 如果当前元素比栈首元素大 // 那么栈的首元素出栈让出位子 // 直到首元素比当前元素大了才把当前元素压入栈 // 注意这里栈内放的是索引 while(!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) s.pop(); // 更新数组中第 i 个元素的下一个更大的元素 // 就在栈首 res[i] = s.empty() ? 0 : (s.top() - i); s.push(i); &#125; return res;&#125; 496. Next Greater Element I 给你两个没有重复元素的数组nums1和nums2，其中nums1是nums2的子集。 请你找出nums1中每个元素在nums2中的下一个比其大的值。 nums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出-1 。 Example: 123456Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2]Output: [-1,3,-1]Explanation:For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.For number 1 in the first array, the next greater number for it in the second array is 3.For number 2 in the first array, there is no next greater number for it in the second array, so output -1. 1234567891011121314151617181920// 直接套用单调栈的模板vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; // 这里用哈希表来存放答案 // 记录着 nums2 数组中的每个元素与其下一个更大的元素之间的映射 unordered_map&lt;int, int&gt; mapping; stack&lt;int&gt; s; for(int i = nums2.size() - 1; i &gt;= 0; i--) &#123; while(!s.empty() &amp;&amp; s.top() &lt;= nums2[i]) s.pop(); mapping[nums2[i]] = s.empty() ? -1 : s.top(); s.push(nums2[i]); &#125; vector&lt;int&gt; res(nums1.size()); // 直接从哈希表中获取 nums1 数组中元素的下一个更大元素即可 for(int i = 0; i &lt; nums1.size(); i++) res[i] = mapping[nums1[i]]; return res;&#125; 503. Next Greater Element II 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字x的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出-1。 Example: 123&gt;Input: [1,2,1]&gt;Output: [2,-1,2]&gt;Explanation: The first 1&#39;s next greater number is 2; The number 2 can&#39;t find next greater number; The second 1&#39;s next greater number needs to search circularly, which is also 2. 1234567891011121314151617181920212223// 这里和 I 题的区别是, 数组可以循环// 也就是说从当前位置一直向后看去, 直到找到下一个更大元素为止// 如果找到了尾元素则从首元素开始继续找// 可以看作在原始数组后面又接了一段原始数组(见上图)// 你当然可以申请一段两倍的数组空间来这放元素// 但是, 下面来学习一个循环遍历数组的技巧// 先直接套用单调栈的模板// 其中改动的地方就是能够循环遍历数组的技巧vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums)&#123; vector&lt;int&gt; res(nums.size()); stack&lt;int&gt; s; int n = nums.size(); for(int i = 2 * n - 1; i &gt;= 0; i--) &#123; while(!s.empty() &amp;&amp; s.top() &lt;= nums[i % n]) s.pop(); res[i % n] = s.empty() ? -1 : s.top(); s.push(nums[i % n]); &#125; return res;&#125; 556. Next Greater Element III 给你一个正整数n，请你找出符合条件的最小整数，其由重新排列n中存在的每位数字组成，并且其值大于n。如果不存在这样的正整数，则返回-1。 Example 1: 12Input: n &#x3D; 320241Output: 320412 Example 2: 12Input: n &#x3D; 321Output: -1 12345678910111213141516171819202122232425262728293031323334353637// 首先要想到的是先把数字转成字符串, 方便处理// 然后再试想一下, 影响数值前后发生大小变化的决定因素什么// 不知道你脑子里有没有蹦出 [逆序对] 三个字// 注意我这里的 [逆序对] 是指, 原本降序排列的数, 其中相邻的一对数字是升序// 如果你想到了这个, 那问题就很简单了// 对于数字其中的一个逆序对// 如果你把这两个数字交换, 值是不是就变大了？// 但这题要找变大之后的数中最小的数// 那就只需要对最后边的一个逆序对操作嘛// 但是还是不能简单的将逆序对的数字交换// 需要将逆序对的前一个元素和它后面的最后一个比它大的数交换才行// 交换完之后还要将逆序对后面的所有元素进行一次反转// 因为此时后面的那些元素必定是降序排列的, 反转之后值会进一步变小// 说起来太抽象了, 下面直接看代码int nextGreaterElement(int n)&#123; string s(to_string(n)); // 从后往前走 // 定位到第一个逆序对, pivot 指向逆序对的第一个元素 int pivot = s.size() - 2; for(; pivot &gt;= 0; pivot--) if(s[pivot] &lt; s[pivot + 1]) break; // 如果没有逆序对, 说明不可能组合成比原来大的数 if(pivot == -1) return -1; // 从后往前走, 定位到第一个比 pivot 指向元素大的元素 int larger = s.size() - 1; for(; larger &gt; pivot; larger--) if(s[pivot] &lt; s[larger]) break; // 交换二者 swap(s[pivot], s[larger]); // 这时候 pivot 之后的所有元素肯定是降序排列的 // 反转它们, 以求数值最小 reverse(s.begin() + pivot + 1, s.end()); // 如果这个数比 int 类型数值范围, 就不符合题目要求了 if(stol(s) &gt; INT_MAX) return -1; return stoi(s);&#125; 133. Clone Graph 给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。 图中的每个节点都包含它的值val（int）和其邻居的列表list[Node]。 1234567891011// Definition for a Node.struct Node&#123; int val; vector&lt;Node *&gt; neighbors; Node(int _val) &#123; val = _val; neighbors = vector&lt;Node *&gt;(); &#125;&#125;; Example: 1234567Input: adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]Output: [[2,4],[1,3],[2,4],[1,3]]Explanation: There are 4 nodes in the graph.1st node (val &#x3D; 1)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).2nd node (val &#x3D; 2)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).3rd node (val &#x3D; 3)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).4th node (val &#x3D; 4)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3). 1234567891011121314151617181920212223242526272829// 直接深度优先搜索即可// 只是需要使用一个哈希表来记录已经 new 过的节点// 哈希表中记录的是原节点和拷贝节点之间的映射// 下次通过某节点的邻居遍历到相同的节点直接从哈希表中取就可以了Node* cloneGraph(Node* node)&#123; if(!node) return nullptr; unordered_map&lt;Node*, Node*&gt; visited; return dfs(node, visited);&#125;Node* dfs(Node* node, unordered_map&lt;Node*, Node*&gt;&amp; visited)&#123; // 如果这个节点已经 被克隆过了 // 直接从哈希表中返回其映射 if(visited.count(node)) return visited[node]; // 克隆当前节点 Node* res = new Node(node-&gt;val); // 记录映射 visited[node] = res; // 深度遍历其所有邻居 vector&lt;Node*&gt; neighbors = node-&gt;neighbors; for(int i = 0; i &lt; neighbors.size(); i++) // 将其一一添加进拷贝节点的邻居中 res-&gt;neighbors.push_back(dfs(neighbors[i], visited)); return res;&#125; 494. Target Sum 给定一个非负整数数组，a1, a2, ..., an和一个目标数S。现在你有两个符号+和-。对于数组中的任意一个整数，你都可以从+或-中选择一个符号添加在前面。 返回可以使最终数组和为目标数S的所有添加符号的方法数。 Example: 1234567891011Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 &#x3D; 3+1-1+1+1+1 &#x3D; 3+1+1-1+1+1 &#x3D; 3+1+1+1-1+1 &#x3D; 3+1+1+1+1-1 &#x3D; 3There are 5 ways to assign symbols to make the sum of nums be target 3. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 先上暴力搜索 (dfs) 穷举所有添加方法的结果// 时间复杂度为 O(2^n), n 为数组长度// 空间复杂度为 O(n) 递归调用栈的空间int count = 0;int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)&#123; dfs(nums, 0, S); return count;&#125;// 注意这里用到的一个技巧是// 等式左边的数相加或相减起来 = S, 等价于 S + 等式左边的那些数相加或相减 = 0// 它们的个数肯定相等嘛void dfs(vector&lt;int&gt;&amp; nums, int pos, long S)&#123; if(pos == nums.size()) &#123; if(S == 0) count++; return; &#125; // S += nums[pos]; // 做选择 // dfs(nums, pos + 1, S); // S -= nums[pos]; // 撤销选择 dfs(nums, pos + 1, S + nums[pos]); // 函数进入自动做选择, 返回自动撤销选择 // S -= nums[pos]; // 做选择 // dfs(nums, pos + 1, S); // S += nums[pos]; // 撤销选择 dfs(nums, pos + 1, S - nums[pos]); // 函数进入自动做选择, 返回自动撤销选择&#125;// 我们从上面可以注意到递归过程中出现了许多的重复计算// 比如, nums[pos] == 0 的时候, dfs(num, pos + 1, S) 要计算 2 次// 除了这种特殊情况还有许多// 这里我们就使用备忘录来消除重叠子问题unordered_map&lt;string, int&gt; memo;int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S)&#123; return dfs(nums, 0, S);&#125;// 需要修改一下递归函数的定义// int dfs(vector&lt;int&gt;&amp; nums, pos, int S)// 表示在 pos 位置加正负号使其和等于 S 有多少种方法// 这样递推式就是 dfs(.., pos, S) = // dfs(.., pos + 1, S + nums[pos]) /* pos 位置加正号的话 */// + dfs(.., pos + 1, S - nums[pos]) /* pos 位置加负号的话 */int dfs(vector&lt;int&gt;&amp; nums, int pos, int S)&#123; if(pos == nums.size()) &#123; if(S == 0) return 1; return 0; &#125; // 需要将这两个参数转为字符串作为哈希表的键 // 把 [状态] 转化为字符串作为键是一种小技巧 string key = to_string(pos) + \",\" + to_string(S); if(memo.count(key)) return memo[key]; int res = dfs(nums, pos + 1, S + nums[pos]) + dfs(nums, pos + 1, S - nums[pos]); memo[key] = res; return res;&#125;// 从上面使用的优化方法来看// 似乎有 [动态规划] 的影子// 现在让我们再转化一下思路 232. Implement Queue using Stacks 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作： 实现MyQueue类： void push(int x)：将元素x推到队列的末尾； int pop()：从队列的开头移除并返回元素； int peek()：返回队列开头的元素； bool empty()：如果队列为空，返回true；否则，返回false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 如上图, 将两个栈这样放class MyQueue&#123;public: /* Initialize your data structure here. */ MyQueue() &#123;&#125; /* Push element x to the back of queue. */ void push(int x) &#123; // 入栈的时候直接放进右边的栈即可 _back.push(x); &#125; /* Removes the element from in front of queue and returns that element. */ int pop() &#123; // 出栈的时候从左边出 // 如果为空, 需要把右边栈的元素搬过来 if(_front.empty()) moveData(); // 搬过来之后直接 pop 左边的栈即可 int res = _front.top(); _front.pop(); return res; &#125; /* Get the front element. */ int peek() &#123; // 取的时候和 pop 的情况一样 if(_front.empty()) moveData(); // 只是不出栈, 只取元素 return _front.top(); &#125; /* Returns whether the queue is empty. */ bool empty() &#123; return _front.empty() &amp;&amp; _back.empty(); &#125; private: stack&lt;int&gt; _front; stack&lt;int&gt; _back; void moveData() &#123; // 搬移数据就是简单的将右边栈出栈 // 左边栈接收元素压入栈 while(!_back.empty()) &#123; _front.push(_back.top()); _back.pop(); &#125; &#125;&#125;; 225. Implement Stack using Queues 请你仅使用两个队列实现一个后入先出的栈，并支持普通队列的全部四种操作。 实现MyStack类： void push(int x)：将元素x压入栈顶； int pop()：移除并返回栈顶元素； int top()：返回栈顶元素； bool empty()：如果栈是空的，返回true；否则，返回false。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 队列实现栈// 入栈操作很简单, 调用队列的 push 即可// 出栈麻烦点, 因为队列只能从对头出列, 对头相当于栈的栈底// 但我们是想 pop 掉队尾元素// 这时很暴力, 直接把队列中除了队尾之外的所有元素依次出队并依次入队即可// 这时对头就是原队尾元素了, 再出队就行// 获取栈顶元素的话, 为了实现 O(1) 复杂度// 使用一个变量实时记录队尾 (栈顶) 元素class MyStack&#123;public: /* Initialize your data structure here. */ MyStack() &#123;&#125; /* Push element x onto stack. */ void push(int x) &#123; // 入队的时候要更新栈顶变量 _top = x; _queue.push(x); &#125; /* Removes the element on top of the stack and returns that element. */ int pop() &#123; int sz = _queue.size(); while(sz-- &gt; 1) &#123; _top = _queue.front(); _queue.pop(); _queue.push(_top); &#125; int res = _queue.front(); _queue.pop(); return res; &#125; /* Get the top element. */ int top() &#123; return _top; &#125; /* Returns whether the stack is empty. */ bool empty() &#123; return _queue.empty(); &#125;private: queue&lt;int&gt; _queue; int _top;&#125;; 200. Number of Islands 给定一个m x n字符栅格网格，该栅格网格表示&#39;1&#39;（土地）和&#39;0&#39;（水）的地图，请返回岛的数量。 一个岛屿被水包围，是通过水平或垂直连接相邻的土地而形成的。 您可以假设网格的所有四个边缘都被水包围。 Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] is &#39;0&#39; or &#39;1&#39; Example 1: 1234567Input: grid &#x3D; [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]Output: 1 Example 2: 1234567Input: grid &#x3D; [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]Output: 3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 思想是// 1. 依次遍历网格中的每一个字符// 2. 如果当前字符是 '1' 说明踏上了一座岛, 进行下一步, 如果为 '0'，回到步骤 1// 3. 然后骚操作来了, 将当前字符赋值为 '0'// 4. 然后遍历当前字符的上下左右四个邻居// 5. 每到一个邻居重复对当前字符的操作// 6. 直到某一个邻居 (可以是邻居的邻居) 的四个邻居都为'0'// 7. 说明这座岛的每一个陆地都走过了, 此时岛数量 +1// 8. 接下来再到下一个字符, 回到步骤 1// 遍历邻居的时候有两种方法, dfs 和 bfs// dfsint numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid)&#123; int count = 0; for(int i = 0; i &lt; grid.size(); i++) &#123; for(int j = 0; j &lt; grid[0].size(); j++) &#123; if(grid[i][j] == '1') &#123; // 踏上了一座岛 count++; // 递归函数的目的把这座岛的所有陆地变成水 (淹没) dfs(grid, i, j); &#125; &#125; &#125; return count;&#125;void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c)&#123; if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size() || grid[r][c] != '1') return; // 淹没陆地 grid[r][c] = '0'; // 判断左邻居 dfs(grid, r - 1, c); // 判断右邻居 dfs(grid, r + 1, c); // 判断上邻居 dfs(grid, r, c - 1); // 判断下邻居 dfs(grid, r, c + 1);&#125;// bfs 借助队列的迭代实现int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid)&#123; if(grid.empty()) return 0; // 队列中保存的是当前陆地的坐标 queue&lt;pair&lt;int, int&gt;&gt; q; int count = 0; for(int i = 0; i &lt; grid.size(); i++) &#123; for(int j = 0; j &lt; grid[0].size(); j++) &#123; if(grid[i][j] == '1') &#123; // 踏上了一座岛 count++; q.push(&#123;i, j&#125;); // while 循环的目的是把这座岛的所有陆地变成水 (淹没) while(!q.empty()) &#123; int r = q.front().first; int c = q.front().second; q.pop(); if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size() || grid[r][c] != '1') continue; // 淹没陆地 grid[r][c] = '0'; // 判断左邻居 q.push(&#123;r - 1, c&#125;); // 判断右邻居 q.push(&#123;r + 1, c&#125;); // 判断上邻居 q.push(&#123;r, c - 1&#125;); // 判断下邻居 q.push(&#123;r, c + 1&#125;); &#125; &#125; &#125; &#125; return count;&#125; 694. Number of Distinct Islands 给定一个非空01二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的1组成，你可以认为网格的四周被海水包围。 请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合。 示例 1： 1234511000110000001100011给定上图，返回结果 1 。 示例 2： 1234511011100000000111011给定上图，返回结果 3 。 注意： 11 1 和 1 11 是不同的岛屿，因为我们不考虑旋转、翻转操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344int x = 0, y = 0;int numDistinctIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; set&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; setting; for(int i = 0; i &lt; grid.size(); i++) &#123; for(int j = 0; j &lt; grid[0].size(); j++) &#123; if(grid[i][j] == 1) &#123; // 踏上了一座岛 // isLand 用于记录这座岛的所有陆地坐标 // 实际记录的是相对陆地坐标, 即其他陆地相对于左上角的那块陆地 vector&lt;pair&lt;int, int&gt;&gt; isLand; // 更新当前岛屿的相对坐标 x = i; y = j; // 递归函数的目的把这座岛的所有陆地变成水 (淹没) dfs(grid, isLand, i, j); // set 有自动排序和去重的功能 setting.insert(isLand); &#125; &#125; &#125; return setting.size();&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;pair&lt;int, int&gt;&gt;&amp; isLand, int r, int c)&#123; if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size() || grid[r][c] != 1) return; isLand.push_back(&#123;r - x, c - y&#125;); // 淹没陆地 grid[r][c] = 0; // 判断左邻居 dfs(grid, isLand, r - 1, c); // 判断右邻居 dfs(grid, isLand, r + 1, c); // 判断上邻居 dfs(grid, isLand, r, c - 1); // 判断下邻居 dfs(grid, isLand, r, c + 1);&#125; 1254. Number of Closed Islands 有一个二维矩阵grid，每个位置要么是陆地（记号为0）要么是水域（记号为1）。 我们从一块陆地出发，每次可以往上下左右4个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。 如果一座岛屿完全由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。 请返回封闭岛屿的数目。 Example 1: 1234Input: grid &#x3D; [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]Output: 2Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s). Example 2: 12Input: grid &#x3D; [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]Output: 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 注意这题 1 代表水域而 0 代表陆地// 和岛屿数量 I 题的区别在于边界上的岛屿不算岛屿// 所以如果搜索出来的岛屿在边界上就不更新岛屿数bool flag; // 是否是封闭岛的标志int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; int rowLength = grid.size(); int colLength = grid[0].size(); int count = 0; for(int i = 0; i &lt; rowLength; i++) &#123; for(int j = 0; j &lt; colLength; j++) &#123; if(grid[i][j] == 0) &#123; // 踏上了一座岛 // 看它是否是边界岛 flag = true; // 递归函数的目的把这座岛的所有陆地变成水 (淹没) dfs(grid, i, j); if(flag) count++; &#125; &#125; &#125; return count;&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r, int c)&#123; if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size()) &#123; // 能到达边界, 说明不是封闭岛 flag = false; return; &#125; if(grid[r][c] != 0) return; // 淹没陆地 grid[r][c] = 1; // 判断左邻居 dfs(grid, r - 1, c); // 判断右邻居 dfs(grid, r + 1, c); // 判断上邻居 dfs(grid, r, c - 1); // 判断下邻居 dfs(grid, r, c + 1);&#125; 695. Max Area of Island 给定一个包含了一些0和1的非 空二维数组grid。 一个岛屿是由一些相邻的1(代表土地) 构成的组合，这里的「相邻」要求两个1必须在水平或者竖直方向上相邻。你可以假设grid的四个边缘都被0（代表水）包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0 ) Example 1: 12345678910[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]Given the above grid, return &#96;6&#96;. Note the answer is not 11, because the island must be connected 4-directionally. Example 2: 123[[0,0,0,0,0,0,0,0]]Given the above grid, return &#96;0&#96;. 1234567891011121314151617181920212223242526272829303132333435363738// dfsint area; // 用于记录每个岛的面积int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; int res = 0; for(int i = 0; i &lt; grid.size(); i++) &#123; for(int j = 0; j &lt; grid[0].size(); j++) &#123; if(grid[i][j] == 1) &#123; // 踏上了一座岛就把先前岛屿面积清零 area = 0; // 递归函数的目的把这座岛的所有陆地变成水 (淹没) dfs(grid, i, j); res = max(res, area); &#125; &#125; &#125; return res;&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r, int c)&#123; if(r &lt; 0 || c &lt; 0 || r == grid.size() || c == grid[0].size() || grid[r][c] != 1) return; // 淹没陆地 grid[r][c] = 0; area++; // 判断左邻居 dfs(grid, r - 1, c); // 判断右邻居 dfs(grid, r + 1, c); // 判断上邻居 dfs(grid, r, c - 1); // 判断下邻居 dfs(grid, r, c + 1);&#125; 733. Flood Fill 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在0到65535之间。 给你一个坐标(sr, sc)表示图像渲染开始的像素值（行 ，列）和一个新的颜色值newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 Example: 123456789Input: image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image (with position (sr, sc) &#x3D; (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connectedto the starting pixel. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 和前面那个岛屿数量 I 的题思路差不多// DFSvector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor)&#123; if(image[sr][sc] != newColor) dfs(image, sr, sc, image[sr][sc], newColor); return image;&#125;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int r, int c, int srcColor, int newColor)&#123; if(r &lt; 0 || c &lt; 0 || r == image.size() || c == image[0].size() || image[r][c] != srcColor) return; image[r][c] = newColor; dfs(image, r + 1, c, srcColor, newColor); dfs(image, r - 1, c, srcColor, newColor); dfs(image, r, c + 1, srcColor, newColor); dfs(image, r, c - 1, srcColor, newColor);&#125;// BFSvector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor)&#123; if(image[sr][sc] == newColor) return image; int srcColor = image[sr][sc]; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;sr, sc&#125;); while(!q.empty()) &#123; int sz = q.size(); for(int i = 0; i &lt; sz; i++) &#123; int r = q.front().first; int c = q.front().second; q.pop(); if(r &lt; 0 || c &lt; 0 || r == image.size() || c == image[0].size() || image[r][c] != srcColor) continue; image[r][c] = newColor; q.push(&#123;r + 1, c&#125;); q.push(&#123;r - 1, c&#125;); q.push(&#123;r, c + 1&#125;); q.push(&#123;r, c - 1&#125;); &#125; &#125; return image;&#125; 542. 01 Matrix 给定一个由0和1组成的矩阵，找出每个元素到最近的0的距离。 两个相邻元素间的距离为1。矩阵中的元素只在四个方向上相邻：上、下、左、右。 Example 1: 123456789&gt;Input:&gt;[[0,0,0],&gt;[0,1,0],&gt;[0,0,0]]&gt;Output:&gt;[[0,0,0],&gt;[0,1,0],&gt;[0,0,0]] Example 2: 123456789&gt;Input:&gt;[[0,0,0],&gt;[0,1,0],&gt;[1,1,1]]&gt;Output:&gt;[[0,0,0],&gt;[0,1,0],&gt;[1,2,1]] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 因为要寻找 [最近] 距离, 所以显然使用 BFSvector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)&#123; int rSize = matrix.size(); int cSize = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; res(rSize, vector&lt;int&gt;(cSize)); queue&lt;pair&lt;int, int&gt;&gt; q; int step = 0; // 因为要对矩阵中的所有元素进行寻找最近的 0 // 所以外面的两层循环实际上是处理这个问题的 // 如果只需要对一个元素进行寻找就不需要这两层循环, 和传统的 BFS 模板一样 for(int i = 0; i &lt; rSize; i++) &#123; for(int j = 0; j &lt; cSize; j++) &#123; step = 0; q.push(&#123;i, j&#125;); while(!q.empty()) &#123; int sz = q.size(); while(sz--) &#123; // 从当前位置出发, 遍历其所有邻居 int r = q.front().first; int c = q.front().second; q.pop(); // 如果 走到了 0, 那么它离 0 的最近距离就是已经走的 step if(matrix[r][c] == 0) &#123; res[i][j] = step; // 更新完 step 之后还要将队列清空方便对下一位置进行搜索时使用 while(!q.empty()) q.pop(); break; &#125; // 将其上下左右四个邻居入栈等待搜索 if(r + 1 &lt; rSize) q.push(&#123;r + 1, c&#125;); if(r - 1 &gt;= 0) q.push(&#123;r - 1, c&#125;); if(c + 1 &lt; cSize) mq.push(&#123;r, c + 1&#125;); if(c - 1 &gt;= 0) q.push(&#123;r, c - 1&#125;); &#125; step++; &#125; &#125; &#125; return res;&#125; 841. Keys and Rooms 有N个房间，开始时你位于0号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间i都有一个钥匙列表rooms[i]，每个钥匙rooms[i][j]由[0,1，...，N-1]中的一个整数表示，其中N = rooms.length。 钥匙rooms[i][j] = v可以打开编号为v的房间。 最初，除0号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回true，否则返回false。 Note: 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 The number of keys in all rooms combined is at most 3000. Example 1: 1234567Input: [[1],[2],[3],[]]Output: trueExplanation: We start in room 0, and pick up key 1.We then go to room 1, and pick up key 2.We then go to room 2, and pick up key 3.We then go to room 3. Since we were able to go to every room, we return true. Example 2: 123Input: [[1,3],[3,0,1],[2],[0]]Output: falseExplanation: We can&#39;t enter the room with number 2. 123456789101112131415161718192021222324252627282930// 因为最多就 1000 个房间// 需要对已经访问过的房间进行标记// 所以这里我们使用一个 bitsetbool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms)&#123; // 所有房间初始化全未被访问 bitset&lt;1000&gt; bits; // 从 0 号房间开始 return dfs(rooms, 0, bits);&#125;// 因为我们是想要搜索到一种可能满足的访问次序就可以// 所以这里的 dfs 函数有 bool 返回值来提前结束搜索bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; rooms, int room, bitset&lt;1000&gt;&amp; bits)&#123; // 访问当前房间, 标记为已访问 bits.set(room); // 如果访问的房间总数等于所有房间数 if(bits.count() == rooms.size()) return true; // 否则, 从当前房间获取其它房间钥匙, 依次进行访问 vector&lt;int&gt; curRoom = rooms[room]; for(int key : curRoom) &#123; // 如果这把钥匙对应的房间已经被访问过, 就不过去了 if(bits.test(key)) continue; // 否则去访问 if(dfs(rooms, key, bits)) return true; &#125; return false;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"操作系统之malloc底层原理","date":"2021-03-15T13:35:42.000Z","path":"wF5qv4uNKgDG1SUa/","text":"先来了解一些背景知识。 进程地址空间的组成： 内核空间：这块区域包含两种数据，一种是对每个进程都一样的数据，如共享的内核代码和全局数据结构。另一种是每个进程都不一样的数据，如页表、内核在进程上下文中执行代码时使用的栈，以及记录该进程虚拟地址空间当前组织状态的各种数据结构。 BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。是可读写的。在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了）。 数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。 堆（heap）是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free函数释放内存时，被释放的内存从堆中被释放（堆被缩减） 。 栈（stack）又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数块中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 内存映射区：这块虚拟内存区域被映射到任何需要的对象身上，如共享库文件、磁盘上的普通文件和将要介绍的通过malloc分配的大块内存区域（大于128K）。 注意这些区域实际上存在于进程的虚拟地址空间上，一开始并没有被装载到物理内存上，比如说bss段，理论上是被初始化为零值，但并不是说在物理内存区域的对应段被填入零值，实际上，是将其映射到了零页，等到CPU向这块区域内写数据时，通过引发缺页故障的形式，才被装载到物理内存，分配到初始化为零的页（所谓的写时复制）。 操作系统提供的两个系统调用函数： 1234#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void* sbrk(intptr_t incr);void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset); sbrk函数的作用是移动brk指针扩展heap的上界。函数的参数指示brk指针移动的大小，返回申请之前的brk地址。注意申请的内存地址中的值是随机的，即不要求为零。 mmap函数第一种用法是映射磁盘文件到内存中；而malloc使用的mmap函数的第二种用法，即匿名映射，匿名映射不映射磁盘文件，而是向映射区申请一块全零页内存，相应的虚拟页面是被初始化为零的。 如上面的进程虚拟内存布局图所示，mmap对应Memory Mapping Segment，brk对应Heap。start_brk是堆段的开始位置，brk(program break)则是堆段的结束位置。 下面开始介绍malloc的实现原理。 那么，既然brk/mmap提供了内存分配的功能，直接使用brk/mmap进行内存管理不是更简单吗，为什么需要malloc呢？ 我们知道，系统调用本身会产生软中断，导致程序从用户态陷入内核态，比较消耗资源。试想，如果频繁分配回收小块内存区，那么将有很大的性能耗费在系统调用中。因此，为了减少系统调用带来的性能损耗，malloc采用了内存池的设计，增加了一个代理层，每次内存分配，都优先从内存池中寻找，如果内存池中无法提供，再向操作系统申请。 当申请小于128K内存时，malloc使用sbrk分配内存，当申请大于128K内存时，使用mmap函数申请内存。 下面主要讨论对于小块内存的申请malloc所采用的内存池设计方案。分配器不但要管理已分配的内存块，还需要管理空闲的内存块。malloc利用chunk结构体来管理这些内存块，内存池就是由许多不同大小的chunk链表组成的。 内存池保存在bins这个长128的数组中，每个元素都是一个双向链表。其中： bins[0]目前没有使用。 bins[1]的链表称为unsorted_list，用于维护free释放的chunk。 bins[2, 63)的区间称为small_bins，用于维护＜512字节的内存块，其中每个元素对应的链表中的chunk大小相同，均为index*8。 bins[64,127)称为large_bins，用于维护&gt;512字节的内存块，每个元素对应的链表中的chunk大小不同，index越大，链表中chunk的内存大小相差越大，例如: 下标为64的chunk大小介于[512, 512+64)，下标为95的chunk大小介于[2k+1, 2k+512)。同一条链表上的chunk，按照从小到大的顺序排列。 结构体malloc_chunk来描述这些块： 123456789101112struct malloc_chunk&#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; glibc在内存池中查找合适的chunk时，采用了最佳适应的伙伴算法。举例如下： 如果分配内存&lt; 512字节，则通过内存大小定位到smallbins对应的index上。 如果smallbins[index]为空，进入步骤3 如果smallbins[index]非空，直接返回第一个chunk 如果分配内存&gt; 512字节，则定位到largebins对应的index上。 如果largebins[index]为空，进入步骤3 如果largebins[index]非空，扫描链表，找到第一个大小最合适的chunk，如size=12.5K，则使用chunk B，剩下的0.5k放入unsorted_list中 遍历unsorted_list，查找合适size的chunk，如果找到则返回；否则，将这些chunk都归类放到smallbins和largebins里面。 index++从更大的链表中查找，直到找到合适大小的chunk为止，找到后将chunk拆分，并将剩余的加入到unsorted_list中。 如果还没有找到，那么使用top chunk。 top chunk 如下图示: top chunk是堆顶的chunk，堆顶指针brk位于top chunk的顶部。移动brk指针，即可扩充top chunk的大小。 free释放内存时，有两种情况： chunk和top chunk相邻，则和top chunk合并。 chunk和top chunk不相邻，则直接插入到unsorted_list中。 参考链接： glibc内存管理那些事儿 - 简书 Understanding glibc malloc – sploitF-U-N 自己实现一个简单的malloc可参考 malloc-tutorial/malloc.c at master · danluu/malloc-tutorial [译] 写一个简单的内存分配器（替换glibc中的malloc函数） | yoko blog [译] malloc中的系统调用brk和mmap | yoko blog。 [malloc的底层实现（ptmalloc）_牛客博客","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统之内存管理","date":"2021-03-12T13:35:42.000Z","path":"CB6w5vAiSmICT1OK/","text":"操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做内存管理。 加载和链接 地址绑定时间 功能 程序设计时 程序员直接在程序中确定所有实际的物理地址 编译或汇编时 程序包含符号地址访问，由编译器在加载程序时把它们转换为实际的绝对地址 加载时 编译器或汇编器产生相对地址，加载器在加载程序时把它们转换为实际的绝对地址 运行时 被加载的程序保持相对地址，处理器硬件在执行时把它们动态的转换为绝对地址 链接时间 功能 程序设计时 不允许外部程序或数据访问。程序员必须把所有引用到的子程序源代码放入程序中 编译或汇编时 汇编器必须取到每个引用的子程序的源代码，并把它们作为一个部件来进行汇编 加载模块产生时 所有目标模块都使用相对地址汇编。这些模块被链接在一起，所有访问都相对于最后加载的模块的地点重新声明 加载时 直到加载模块被加载到内存时才解析外部访问，此时被访问的动态链接模块附加到加载模块后，整个软件包被加载到内存或虚存 运行时 直到处理器执行外部调用时才解析外部访问，此时该进程被中断，需要的模块被链接到调用程序中 加载创建活动进程的第一步是把程序装入内存，并创建一个进程映像。应用程序由许多已编译过或汇编过的模块组成，这些模块以目标代码的形式存在，并被链接起来以解析模块间的任何访问和对库例程的访问。库例程可以合并到程序中，或作为操作系统在运行时提供的共享访问代码。 加载器把加载的模块放置在内存中从x开始的位置。一般而言，可以采用三种方法: 绝对加载 绝对加载器要求给定加载模块总被加载到内存中的同一位置。因此，在提供给加载器的加载模块中，所有的地址访问必须是确定的，或者说是绝对的内存地址。给程序中的内存访问指定具体的地址值既可以由程序员完成，也可以在编译时或汇编时完成， 这种方法存在许多缺点：首先，程序员必须知道在内存中放置模块时预定的分配策略；其次，如果在程序的模块体中进行了任何涉及插入或删除的修改，则所有地址都需要更改。 因此，更可取的方法是允许用符号表示程序中的内存访问，然后在编译或汇编时解析这些符号引用。对指令或数据项的引用最初被表示成一个符号。在准备输入到一个绝对加载器的模块时，汇编器或编译器将把所有这些引用转换为具体地址。 可重定位加载 在加载之前就把内存访问绑定到具体的地址的缺点是，会使得加载模块只能放置到内存中的一个区域。但是，当多个程序共享内存时，不可能事先确定哪块区域用于加载哪个特定的模块，最好是在加载时确定。因此，需要一个可分配到内存中任何地方的加载模块。 为满足这个新需求，汇编器或编译器不产生实际的内存地址（绝对地址），而是使用相对于某些已知点的地址，如相对于程序的起点。加载模块中的所有其他内存访问都用与该模块起点的相对值来表示。 既然所有内存访问都以相对形式表示，那么加载器就可以很容易地把模块放置在期望的位置。如果该模块要加载到从x位置开始的地方，则当加载器把该模块加载到内存中时，只需简单地给每个内存访问都加上x。为完成这一任务，加载模块必须包含一些需要告诉加载器的信息，如地址访问在哪里、如何解释它们（通常相对于程序的起点）。由编译器或汇编器准备这些信息，通常称这些信息为重定位地址库。 动态运行时加载 动态运行时加载可重定位加载器非常普遍，且相对于绝对加载器具有明显的优点。但是，在多道程序设计环境中，即使不依赖于虚存，可重定位的加载方案仍是不够的。由于需要把进程换入或换出内存来增大处理器的利用率，而为最大程度地利用内存，又希望能在不同的时刻把一个进程映像换回到不同的位置，因此，程序被加载后，可能被换出到磁盘，然后又被换回到内存中不同的位置。如果在开始加载时，内存访问就被绑足到绝对地址，那么前面提到的情况是不可能实现的。 一种替代方案是在运行时真正在使用某个绝对地址时再计算它。为达到这一目的，加载模块被加载到内存中时，其所有内存访问都以相对形式表示，一条指令只有在真正被执行时才计算其绝对地址。为确保该功能不会降低性能，这些工作必须由特殊的处理器硬件完成，而不用软件实现。 动态地址计算提供了很大的灵活性。一个程序可以加载到内存中的任何区域，程序的执行可以中断，程序还可换出内存，以后再换回到不同的位置。 链接链接器的功能是把一组目标模块作为输入，产生一个包含完整程序和数据模块的加载模块，并传递给加载器。在每个目标模块中，可能有到其他模块的地址访问，每个这样的访问可以在未链接的目标模块中用符号表示。链接器会创建一个单独的加载模块，它把所有目标模块逐个链接起来。每个模块内的引用必须从符号地址转换为对整个加载模块中的一个位置的引用。 产生可重定位加载模块的链接器通常称为链接编辑程序。地址链接的性质取决于链接发生时要创建的加载模块的类型。通常情况下需要可重定位的加载模块，然后链接按以下方式完成：同时创建每个已编译或汇编的目标模块及相对于该目标模块开始处的引用。所有这些模块，连同相对于该加载模块起点的所有引用，一起放进一个可重定位的加载模块中。该模块可以作为可重定位加载或动态运行时加载的输入。 像加载一样，可以推迟某些链接功能。动态链接是指把某些外部模块的链接推迟到创建加载模块之后。因此，加载模块包含到其他程序的未解析的引用，这些引用可以在加载时或运行时解析。 加载时的动态链接分为如下步骤： 待加载的加载模块（应用模块）读入内存。 应用模块中到一个外部模块（目标模块）的任何引用都将导致加载程序查找目标模块，加载它，并把这些引用修改为相对于应用程序模块开始处的相对地址。 该方法与静态加载相比，有以下优点： 能更容易地并入已改变或已升级的目标模块，如操作系统工具，或某些其他的通用例程。而对于静态链接，这类支持模块的变化需要重新链接全部应用程序模块。 在动态链接文件中的目标代码可以很方便的进行共享。因为操作系统加载并链接了该代码，所以可以识别出有多个应用程序使用相同的目标代码。操作系统可以使用此信息，然后只加载目标代码的一个副本，并把这个被加载的目标副本链接到所有使用该目标代码的应用程序，而不是为每个应用程序都分别加载一个副本。 使用运行时动态链接时，某些链接工作被推迟到执行时。这样一些对目标模块的外部引用保留在被加载的程序中，当调用的模块不存在时，操作系统定位该模块，加载它，并把它链接到调用模块中。这些模块一般是共享的。在 Windows环境下，这些模块称为动态链接库（DLL）。也就是说，如果一个进程已使用动态链接共享模块，该模块就位于内存中，新的进程就可以简单地链接上已加载好的模块。 内存管理的需求操作系统将内存分为两部分：一部分供操作系统使用（驻留内核进程和重要的数据结构等），另一部分供用户进程使用，必须将内存进一步的细分给不同的用户进程以满足多个进程的需求。操作系统完成这一“细分”的任务的过程就叫做内存管理。 术语 解释 页框 内存中固定长度的块 页 固定长度的数据块。一般和页框的长度相等，数据页可临时复制到内存的页框中 段 变长的数据块。整个段可以临时复制到内存中的一个可用区域中，或者将一个段划分为许多页，然后将每页单独复制到内存中（分段和分页相结合） 内存管理的需求如下： 重定位 可用的有限内存空间通常被多个进程共享。程序换出到磁盘后，下次换入内存时并不一定被放回原来的区域。也就是说我们需要把进程重定位到不同的内存区域。同时，我们必须允许程序通过交换技术在内存中移动，所以处理器硬件和操作系统软件必须能够以某种方式将程序代码中写死的内存访问地址转换为实际的物理内存地址。 首次加载一个进程时，重定位将代码中的相对内存访问被绝对内存地址代替，这个绝对地址由进程被加载到的基地址确定。 一个进程在其生命周期中可能占据不同的分区。首次创建一个进程映像时，它被装入内存中的某个分区。以后，该进程可能被换出，当它再次被换入时，可能被指定到与上一次不同的分区中。 进程被换入或在内存中移动时，指令和数据单元的位置会发生改变。为解决这个问题，需要区分几种地址类型。逻辑地址是指与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须把它转换为物理地址。相对地址是逻辑地址的一个特例，它是相对于某些已知点（通常是程序的开始处）的存储单元。物理地址或绝对地址是数据在内存中的实际位置。 进程处于运行态时，有一个特殊处理器寄存器（称为基址寄存器），其内容是程序在内存中的起始地址。还有一个界限寄存器指明程序的终止位置。当程序被装入内存或当该进程的映像被换入时，必须设置这两个寄存器。在进程的执行过程中会遇到相对地址，包括指令寄存器的内容、跳转或调用指令中的指令地址，以及加载和存储指令中的数据地址。每个这样的相对地址都经过处理器的两步操作。首先，基址寄存器中的值加上相对地址产生一个绝对地址；然后，将得到的结果与界限寄存器的值进行比较，如果这个地址在界限范围内，则继续该指令的执行；否则，向操作系统发出一个中断信号，操作系统必须以某种方式对这个错误做出响应。 保护 一个进程的内存空间不能被其它进程未经授权的访问，满足重定位的需求增大了满足保护需求的难度。由于程序在内存中的位置通常会变化，因此，不可能通过在编译时检查绝对地址来保护。必须在运行时检查进程的所有内存访问，以确保它们只访问分配给自己的内存空间。 注意，内存保护必须由硬件（处理器）而非软件（操作系统）来满足。 共享 例如，多个进程在执行同一个程序时，允许每个进程访问该程序的同一个副本，以节省内存空间。这意味着操作系统允许进程对共享内存区域的受控访问。 逻辑组织 计算机系统中的内存总是被组织成线性(或一维）的地址空间，且地址空间由一系列字节或字组成。然而，大多数程序被组织成模块，某些模块是不可修改的（只读、只执行），某些模块包含可以修改的数据。若操作系统和计算机硬件能够有效地处理以某种模块形式组织的用户程序与数据，则会带来很多好处： 可以独立地编写和编译模块，系统在运行时解析从一个模块到其他模块的所有引用。 通过适度的额外开销，可以为不同的模块提供不同的保护级别。 可以引入某种机制，使得模块可被多个进程共享。 最易于满足这些需求的工具是分段。 物理组织 计算机存储器至少要组织成两级，即内存和外存。内存提供快速的访问，成本也相对较高。此外，内存是易失性的，即它不能提供永久性存储。外存比内存慢而且便宜，且通常是非易失性的。因此，大容量的外存可用于长期存储程序和数据，而较小的内存则用于保存当前使用的程序和数据。 在两级存储器间移动信息的任务应由系统负责。这一任务恰好是存储管理的本质。 固定分区和动态分区内存管理的主要操作是处理器把程序装入内存中执行。虚存基于分页和分段两种技术。 内存管理技术 说明 固定分区 在系统生成阶段，内存被划分成许多静态分区。进程可装入大于等于自身大小的分区中 动态分区 分区是动态创建的，因而每个进程可装入与自身大小正好相等的分区中 简单分页 内存被划分成许多大小相等的页框；每个进程被划分成许多大小与页框相等的页；要装入一个进程,需要把进程包含的所有页都装入内存内不一定连续的某些页框中 简单分段 每个进程被划分成许多段；要装入一个进程，需要把进程包含的所有段都装入内存内不一定连续的某些动态分区中 虚存分页 除了不需要装入一个进程的所有页外，与简单分页一样；非驻留页在以后需要时自动调入内存 虚存分段 除了不需要装入一个进程的所有段外，与简单分段一样；非驻留段在以后需要时自动调入内存 固定分区 使用大小相等的分区： 程序可能太大而不能放到一个分区中，此时必须使用覆盖技术。 内存的利用率很低。会产生大量内部碎片。 使用大小不等的分区可缓解这两个问题。 对于大小相等的分区，放置算法将进程放入内存的哪个分区都没有关系。 对于大小不等的分区，放置算法将每个进程分配到能够容纳它的最小分区中。每个分区需要维护一个调度队列，用于保存从这个分区换出的进程。 动态分区 对于动态分区，分区长度和数量是可变的。进程装入内存时，系统会给它分配一块与其所需容量完全相等的内存空间。动态分区方法最初不错，但它最终在内存中形成了许多小空洞。随着时间的推移，内存中形成了越来越多的外部碎片，内存的利用率随之下降。 放置算法把一个进程装入或换入内存时，如果内存中有多个足够大的空闲块，那么操作系统必须确定要为此进程分配哪个空闲块。可供考虑的放置算法有三种：最佳适配、首次适配和下次适配。首次适配算法是最简单，最好和最快的。 置换算法使得操作系统将一个阻塞的进程换出内存，给新进程或处于就绪-挂起态的进程让出空间。因此,操作系统必须选择要替换哪个进程。 伙伴系统 简单分页大小不等的固定分区和大小可变的分区技术在内存的使用上都是低效的，前者会产生内部碎片，后者会产生外部碎片。但是，如果内存被划分成大小固定、相等的块，且块相对比较小，每个进程也被分成同样大小的小块，那么进程中称为页的块可以分配到内存中称为页框的可用块。使用分页技术时，每个进程在内存中浪费的空间，仅是进程最后一页的一小部分形成的内部碎片，没有任何外部碎片。 在某个给定时刻，内存中的某些页框正被使用，某些页框是空闲的，操作系统维护空闲页框的列表。 这时仅有一个简单的基址寄存器是不够的，操作系统需要为每个进程维护一个页表。页表给出了该进程的每页所对应页框的位置。在程序中，每个逻辑地址包括一个页号和在该页中的偏移量。在简单分区的情况下，逻辑地址是一个字相对于程序开始处的位置，处理器把它转换为一个物理地址。在分页中，逻辑地址到物理地址的转换仍然由处理器硬件完成，且处理器必须知道如何访问当前进程的页表。给出逻辑地址（页号，偏移量）后，处理器使用页表产生物理地址（页框号，偏移量）。 进程的每页在页表中都有一项，因此页表很容易按页号对进程的所有页进行索引（从0页开始）。每个页表项包含内存中用于保存相应页的页框的页框号。此外，操作系统为当前内存中未被占用、可供使用的所有页框维护一个空闲页框列表。 总之，采用简单的分页技术，内存可分成许多大小相等且很小的页框，每个进程可划分成同样大小的页；较小的进程需要较少的页，较大的进程需要较多的页；装入一个进程时，其所有页都装入可用页框中，并建立一个页表。 简单分段把程序和与其相关的数据划分到几个段中。并不要求所有程序的所有段的长度都相等。和分页一样，采用分段技术时的逻辑地址也由两部分组成：段号和偏移量。 一般情况下，程序员或编译器会把程序和数据指定到不同的段。为了实现模块化程序设计的目的，程序或数据可能会进一步分成多个段。 采用大小不等的段的另一个结果是，逻辑地址和物理地址间不再是简单的对应关系。类似于分页，在简单的分段方案中，每个进程都有一个段表，系统也会维护一个内存中的空闲块列表。每个段表项必须给出相应段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效地址。当进程进入运行状态时，系统会把其段表的地址装载到一个寄存器中，由内存管理硬件来使用这个寄存器。 总之，采用简单的分段技术，进程可划分为许多段，段的大小无须相等；调入一个进程时，其所有段都装入内存的可用区域，并建立一个段表。 虚拟内存概念 术语 解释 虚拟内存 被定义成一个连续完整的地址空间，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换 虚拟地址 在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主内的一部分那样 虚拟地址空间 分配给进程的虚拟存储 地址空间 用于某进程的内存地址范围 实地址 内存中存储位置的地址 分页和分段的两个特点： 进程中的所有内存访问都是逻辑地址，这些逻辑地址会在运行时动态的转换为物理地址。这意味着一个进程可被换入和换出内存，进程可在执行过程中占据不同时刻内存中的不同区域。 一个进程可被划分为许多块（页和段），在执行过程中，这些快不需要连续的位于内存中。 假设需要把一个新进程放入内存，此时操作系统仅读取包含程序开始处的一个或几个块。进程执行的任何时候都在内存的部分称为进程的常驻集。进程执行时，只要所有内存访问都是访问常驻集中的单元，执行就可以顺利进行；使用段表或页表，处理器总可以确定是否如此。 处理器需要访问一个不在内存中的逻辑地址时，会产生一个中断，这表明出现了内存访问故障（缺页故障）。操作系统会把被中断的进程置于阻塞态。要继续执行这个进程，操作系统必须把包含引发访问故障的逻辑地址的进程块（所在的页）读入内存。为此，操作系统产生一个磁盘IO读请求。产生I/O请求后，在执行磁盘IO期间，操作系统可以调度另一个进程运行。需要的块读入内存后，产生一个I/O中断，控制权交回给操作系统，而操作系统则把由于缺少该块而被阻塞的进程置为就绪态。 在内存中保留多个进程。 由于对任何特定的进程都仅装入它的某些块，因此有足够的空间来放置更多的进程。这样，在任何时刻这些进程中至少有一个处于就绪态，于是处理器得到了更有效的利用。 进程可以比内存的全部空间还大。 操作系统在需要时会自动地把进程块装入内存。 由于进程只能在内存中执行，因此这个存储器称为实存储器，简称实存。但程序员或用户感觉到的是一个更大的内存，且通常分配在磁盘上，这称为虚拟内存，简称虚存。虚存支持更有效的系统并发度，并能解除用户与内存之间没有必要的紧密约束。 考虑一个由很长的程序和多个数据数组组成的大进程。在任何一段很短的时间内，执行可能会局限在很小的一段程序中（如一个子程序），且可能仅会访问一个或两个数据数组。因此，若在程序被挂起或被换出前仅使用了一部分进程块，则为该进程给内存装入太多的块显然会带来巨大的浪费。仅装入这一小部分块可更好地使用内存。然后，若程序转移到或访问到不在内存中的某个块中的指令或数据，就会引发一个错误，告诉操作系统读取需要的块。 当操作系统读取一块时，它必须把另一块换出。如果一块正好在将要用到之前换出，操作系统就不得不很快地把它取回。这类操作通常被称为系统抖动。 局部性原理表明虚拟内存方案是可行的。要使虚存比较实用并且有效，需要两方面的因素： 首先，必须有对所采用分页或分段方案的硬件支持； 其次，操作系统必须有管理页或段在内存和辅助存储器之间移动的软件。 虚拟分页每个进程都有自己的页表，当它的所有页都装入内存时，将创建页表并装入内存。页表项（Page Table Entry，PTE）包含有与内存中的页框相对应的页框号。由于一个进程可能只有一些页在内存中，因而每个页表项需要有一位P来表示它所对应的页当前是否在内存中。若这一位表示该页在内存中，则这个页表项还包括该页的页框号。 页表项中所需要的另一个控制位是修改位M，它表示相应页的内容从上次装入内存到现在是否已改变。若未改变，则在需要把该页换出时，无须用页框中的内容更新该页。页表项还须提供其他一些控制位，例如，保护位和共享位。 页表结构从内存中读取一个字的基本机制包括使用页表从虚拟地址到物理地址的转换。虚拟地址又称为逻辑地址，它由页号和偏移量组成，而物理地址由页框号和偏移量组成。由于页表的长度可基于进程的长度而变化，因而不能期望在寄存器中保存它，它须在内存中且可以访问。当某个特定的进程正运行时，一个寄存器保存该进程页表的起始地址。虚拟地址的页号用于检索页表、查找相应的页框号，并与虚拟地址的偏移量结合起来形成需要的实地址。一般来说，页号域长于页框号域（n &gt; m）。 每个进程可以占据大量的虚存空间，因而一个进程会有大量的页表项，这会导致保存页表的内存空间太大。大多数虚拟内存方案都在虚存而非实存中保存页表。这意味着页表和其他页一样都服从分页管理。一个进程正在运行时，它的页表至少有一部分须在内存中，这一部分包括正在运行的页的页表项。一些处理器使用两级方案来组织大型页表。在这类方案中有一个页目录，其中的每项指向一个页表。 假设采用字节级的寻址，页尺寸为4KB(2^12^)，则4GB(2^32^)虚拟地址空间由2^20^页组成。若这些页中的每页都由一个4字节的页表项映射，则可创建由2^20^个页表项组成的一个页表，这时需要4MB(2^22^)的内存空间。这个由2^10^页组成的巨大用户页表可以保留在虚存中，并由一个包括2^10^个页表项的根页表映射，根页表占据的内存为4KB(2^12^)。 转换检测缓冲区TLB原则上，每次虚存访问都可能会引起两次物理内存访问：一次取相应的页表项，另一次取需要的数据（进程页）。因此，虚拟内存方案都为页表项使用了一个特殊的高速缓存，通常称为转换检测缓冲区（Translation Lookaside Buffer，TLB）。TLB中包含有最近用过的页号和完整的页表项。给定一个虚拟地址，处理器首先检查TLB，若需要的页表项在其中（TLB命中），则检索页框号并形成实地址。若未找到需要的页表项（TLB未命中）,则处理器用页号检索进程页表，并检查相应的页表项。若“存在位”已置位，则该页在内存中，处理器从页表项中检索页框号以形成实地址。处理器同时更新TLB，使其包含这个新页表项。最后，若“存在位”未置位，则表示需要的页不在内存中，这时会产生一次内存访问故障，称为缺页（page fault）故障。此时离开硬件作用范围，调用操作系统，由操作系统负责装入所需要的页，并更新页表。 页尺寸对缺页中断发生概率的影响使得这些问题变得更为复杂。一般而言，基于局部性原理，如果页尺寸非常小，那么每个进程在内存中就有较多数量的页。一段时间后，内存中的页都包含有最近访问的部分，因此缺页率较低。当页尺寸增加时，每页包含的单元和任何一个最近访问过的单元越来越远。因此局部性原理的影响被削弱，缺页率开始增长。 更为复杂的是，缺页率还取决于分配给一个进程的页框的数量。对固定的页尺寸，当内存中的页数量增加时，缺页率会下降。因此，软件策略（分配给每个进程的内存总量）影响着硬件设计决策（页尺寸)。 虚拟分段和段页式分段允许程序员把内存视为由多个地址空间或段组成，段的大小不等，并且是动态的。内存访问以段号和偏移量的形式组成地址。其优点： 允许程序独立地改变或重新编译，而不要求整个程序集重新链接和重新加载。同样，这也是使用多个段实现的。 有助于进程间的共享。程序员可以在段中放置一个实用工具程序或一个有用的数据表，供其他进程访问。 有助于保护。由于一个段可被构造成包含一个明确定义的程序或数据集，因而程序员或系统管理员可以更方便地指定访问权限。 从内存中读一个字的基本机制，涉及使用段表来将段号和偏移量组成的虚拟地址（或逻辑地址）转换为物理地址。根据进程的大小，段表长度可变，无法在寄存器中保存，因此访问段表时它必须在内存中。当某个特定的进程正在运行时，有一个寄存器为该进程保存段表的起始地址。虚拟地址中的段号用于检索这个表，并查找该段起点的相应内存地址。这个地址加上虚拟地址中的偏移量部分，就形成了需要的实地址。 段页式系统 在段页式系统中，用户的地址空间被程序员划分为许多段。每段依次划分为许多固定大小的页，页的长度等于内存中的页框大小。若某段的长度小于一页，则该段只占据一页。从程序员的角度看，逻辑地址仍然由段号和段偏移量组成：从系统的角度看，段偏移量可视为指定段中的一个页号和页偏移量。 每个进程都使用一个段表和一些页表，且每个进程段使用一个页表。某个特定的进程运行时，使用一个寄存器记录该进程段表的起始地址。对每个虚拟地址，处理器使用段号部分来检索进程段表以寻找该段的页表。然后虚拟地址的页号部分用于检索页表并查找相应的页框号。这种方式结合虚拟地址的偏移部分，就形成了需要的实地址。 分段有助于实现保护与共享机制。实际上，操作系统要求的保护和共享功能通常在段一级处理。由于每个段表项包括一个长度和一个基地址，因而程序不会不经意地访问超出该段的内存单元。为实现共享，一个段可能会在多个进程的段表中引用。 操作系统软件的支持这里主要涉及的是操作系统为虚存方案提供的算法。在段页式虚存系统中，操作系统所面临的内存管理问题大多数都与分页有关。 在各种情况下，最重要的都是与性能相关的问题：由于缺页中断会带来巨大的软件开销，所以希望使缺页中断发生的频率最小。这类开销至少包括决定置换哪个或哪些驻留页，以及交换这些页所需要的IO操作。此外，在这个页IO操作的过程中，操作系统还须调度另一个进程运行，即导致一次进程切换。因此，希望能通过适当的安排，使得在一个进程正在执行时，访问一个未命中的页中的字的概率最小。 读取策略和清除策略读取策略 当一个进程首次启动时，会在一段时间出现大量的缺页故障；取入越来越多的页后，局部性原理表明大多数将来访问的页都是最近读取的页。因此，在一段时间后错误会逐渐减少，缺页率会降到很低。 读取策略决定某页何时取入内存，常用的两种方法是请求分页和预先分页。 对于请求分页，只有当访问到某页中的一个单元时才将该页取入内存。对于预先分页，读取的页并不是缺页中断请求的页。若一个进程的页连续存储在辅存中，则一次读取许多连续的页要比隔一段时间读取一页有效。 进程首先启动时或者发生缺页中断时，都可采用预先分配策略。 某个进程被换出内存并置于挂起态时，它的所有驻留页都会被换出。当该进程被唤醒时，所有以前在内存中的页都会被重新读回内存。 清除策略 与读取策略相反，清除策略用于确定何时将已修改的一页写回辅存。通常有两种选择：请求式清除和预约式清除。 对于请求式清除，只有当一页被选择用于置换时才被写回辅存；而预约式清除策略则将这些已修改的多页在需要使用它们所占据的页框之前成批写回辅存。 一种较好的方法是结合下一节介绍的页缓冲技术，这种技术允许采用下面的策略：只清除可用于置换的页。通过页缓冲，被置换页可放置在两个链表中：修改链表和未修改链表。修改链表中的页可以周期性地成批写出，并移到未修改链表中。未修改链表中的一页要么因为被访问到而被回收，要么在其页框分配给另一页时被淘汰。 放置策略放置策略决定一个进程块驻留在实存中的什么位置。在段页式系统中，此策略无关紧要，因为地址转换硬件和内存访问硬件能以相同的效率为任何页框组合执行相应的功能。 置换策略和页缓冲置换策略决定在必须读取一个新页时，应该置换内存中的哪一页。需要明确三个问题： 给每个活动进程分配多少页框。 计划被置换的页集局限于那些产生缺页故障的进程，还是局限于所有页框都在内存中的进程。 上面两个问题属于驻留集管理。置换策略专指第三个问题。 在计划被置换的页集，选择换出哪一页。 所有置换策略的目标都是移出最近最不可能访问的页。根据局部性原理，最近的访问历史和最近将要访问的模式间有很大的相关性。因此，大多数策略都基于过去的行为来预测将来的行为。 页框锁定 内存中的某些页框可能是被锁定的。被锁定的页框中的页不能被置换。操作系统内核和重要的控制结构就需要保存在被锁定的页框中。锁定是通过给每个页框关联一个“锁定”位实现的，这一位可以包含在页框表和当前页表中。 基本算法 最近最少使用（LRU，Least Recently Used） 该策略选择置换内存中最长时间未被引用的页。根据局部性原理，这也是最近最不可能访问到的页。 这种方法的问题是比较难以实现。一种实现方法是给每页添加一个最后一次访问的时间戳，并在每次访问内存时更新这个时间戳。另一种方法是维护一个关于访问页的栈，但开销同样很大。 先进先出（FIFO，First In First Out） FIFO 策略把分配给进程的页框视为一个循环缓冲区，并按循环方式移动页。它需要的只是一个指针，该指针在进程的页框中循环。 这种方法所隐含的逻辑是置换驻留在内存中时间最长的页：很久以前取入内存的页，现在可能不会再用到。这一推断通常是错误的，因为经常会出现一部分程序或数据在整个程序的生命周期中使用频率都很高的情况，若使用 FIFO算法，则这些页需要被反复地换入和换出。 时钟（Clock） 页缓冲（Page Cache） 页缓冲能够提高分页的性能并允许使用较简单的页面置换策略。 使用页缓冲的置换算法不丢弃置换出的页。若该页未被修改，则将它分配到空闲页链表中；若已被修改，则分配到修改页链表中。注意，该页在内存中并不会物理性移动，移动的只是该页所对应的页表项，移动后的页表项放置在空闲页链表中或修改页链表中。 空闲页链表中包含有可被置换页的一系列页框，需要从磁盘中读取一页到内存中时，都将其放到空闲页链表头节点所指向的页框中，随后将头节点移除。注意，系统记录的被置换的页并不是链表头节点所指向的页。 比如说，头节点当前指向内存中的页a，系统通过置换策略决定出要用磁盘中的页b置换内存中的页c。实际执行的操作是，将页b放置在页a中，如果页c未被修改，就将其加入到空闲页链表尾部，如果页c已被修改，就将其加入到修改页链表中。 这一骚操作的一个重要特点是，被置换的页仍然留在内存中。因此，若进程访问该页，则可迅速返回该进程的驻留集，且代价很小。实际上，空闲页链表和修改页链表充当着页的高速缓存的角色。 修改页链表还有另外―种很有用的功能：已修改的页按簇写回，而不是一次只写一页，因此大大减少了I/O操作的数量，进而减少了磁盘访问时间。 Page Cache和块缓冲（Buffer Cache）的区别 首先要明确一点，cache是位于内存中的，是为了提高磁盘设备的IO性能。程序读磁盘设备中的数据时，首先把需要访问的数据页及其相邻页面统一读到内存（预读取策略），然后从内存中读取数据。程序向磁盘设备中的文件写数据时，先将数据写入内存，然后再将内存中的脏数据页定时统一的刷新到磁盘中。 这个用作磁盘数据缓存的内存就是所谓的Buffer Cache。主要是针对写数据场景的性能优化。也就是说Buffer Cache是作为磁盘数据读写而存在的。 然而，文件系统层为了提高文件读写的性能，也提供了文件系统级别的Page Cache。更多的是针对读数据场景的性能优化。也就是说Page Cache是作为文件读写而存在的。 其实针对的都是磁盘中的数据，有两个缓存显得没有必要了，因此，现有的linux系统版本已经将二者合并了，统称为Page Cache。其是通过radix树（基数树）数据结构实现的。 驻留集管理驻留集是指一个进程被读取到内存中的页集。 分配给一个进程的内存越少，在任何时候驻留在内存中的进程数就越多。这增加了操作系统至少找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间。 若一个进程在内存中的页数较少，尽管有局部性原理，缺页率仍相对较高。 然而，给进程分配的内存空间大到一定程度时，由于局部性原理，缺页率也不会有明显的降低。 固定分配策略为一个进程分配固定数量的页框，以供执行时使用。这个数量由进程创建时确定。对于这种策略，一旦在进程的执行过程中发生缺页中断，该进程的一页就必须被它所需要的页面置换。 可变分配策略允许分配给一个进程的页框在该进程的生命周期中不断地发生变化。其大小可根据当前进程的缺页率大小来实时调整。理论上，若一个进程的缺页率一直比较高，则表明在该进程中局部性原理表现较弱，应给它多分配一些页框以减小缺页率；而若一个进程的缺页率特别低，则表明从局部性的角度看该进程的表现非常好，可在不明显增大缺页率的前提下减少分配给它的页框。 置换范围 局部置换策略在产生这次缺页的进程的驻留页中选择，而全局置换策略则把内存中所有未被锁定的页都作为置换的候选页，而不管它们属于哪个进程。 Linux内存管理 虚存寻址 Linux使用三级页表结构（最新版本已经使用四级页表了），它由下面几种类型的表组成（每个表的大小都是一页）： 顶级页表是页全局目录（PGD），它包含了一个pgd_t类型数组，多数体系结构中pgd_t类型等同于无符号长整型类型。PGD中的表项指向二级页目录中的表项：PMD。每个活动进程的页目录都必须在内存中。 二级页表是中间页目录（PMD），它是个pmd_t类型数组，其中的表项指向PTE中的表项。页中间目录可能跨越多个页。页中间目录中的每项指向页表中的一页。 最后一级的页表简称页表，其中包含了pte_t类型的页表项，该页表项指向物理页面。页表也可跨越多个页。每个页表项指向该进程的一个虚拟页。 页面分配 页面分配为提升向内存中读入和从内存中写出页的效率，Linux定义了一种机制，用于把连续的页映射到连续的页框中。基于这一目的，它使用了伙伴系统。内核维护一系列大小固定的连续页框组，一组可以包含1、2、4、8、16、32个页框。当一页在内存中被分配或被解除分配时，可用的页框组使用伙伴算法来分裂或合并。 Linux引入了一种新的分割LRU算法。 新算法给每个页表项添加了两个有效位：PG_active和PG_referenced。Linux的所有物理内存均基于它们的地址分配到两块“区域”，“激活”和“非激活”两个链表通过内存管理器来进行各区域的页面回收。内核驻留进程kswapd在后台周期性地执行各区域的页面回收，它扫描那些与系统页框对应的页表项。对于所有标记为访问过的页表项，启用PG_referenced有效位。处理器首次访问一个页面时，会启用这个标志位。kswapd每次迭代时，都会检查页表项中的页面访问过标志位是否被启用。kswapd在每次读取页面访问有效位后即将其清除。具体步骤如下： 访问非激活链表中的一页时，PG_referenced有效位启用。 页面下次被访问时，PG_active被置位，并将其移动到激活链表。也就是说，页面经访问两次后被声明为激活。更准确地讲，两次不同扫描的访问才使得一个页面变为激活状态。 若第二次访问并未很快发生，则重置PG_referenced。 同样，激活的页面在两次超时之后也需要移动到非激活链表中。 非激活链表中的页面然后可通过LRU算法被置换。 页（page）内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字，但是，内存管理单元（MMU，管理内存并把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理。正因为如此，MMU以页大小为单位来管理系统中的页表。从虚拟内存的角度来看，页就是最小单位。 内核用struct page结构来表示系统中的每一个物理页，该结构位于&lt;linux/mm_types.h&gt;： 1234567891011struct page&#123; unsigned long flags; atomic_t _count; atomic_t _mapcount; unsigned long private; struct address_space *mapping; pgoff_t index; struct list_head lru; void virtual;&#125; flag域用来存放页的状态。这些状态包括页是不是脏的，是不是被锁定在内存中等。这些标志被定义在&lt;linux/page-flags.h&gt;中。 count域存放页的引用计数——也就是这一页被引用了多少次。当计数值变为-1时，就说明当前内核并没有引用这一页，于是，在新的分配中就可以使用它。内核代码不应当直接检查该域，而是调用page_count()函数进行检查，该函数唯一的参数就是page结构。当页空闲时，尽管该结构内部的_count值是负的，但是对page_count()函数而言，返回0表示页空闲，返回一个正整数表示页在使用。一个页可以由页缓存使用（这时，mapping域指向和这个页关联的addresss_space对象），或者作为私有数据（由private指向），或者作为进程页表中的映射。 virtual域是页的虚拟地址。通常情况下，它就是页在虚拟内存中的地址。 必须要理解的一点是page结构与物理页相关，而并非与虚拟页相关。因此，该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，它们也可能并不再和同一个page结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关的物理页中存放的东西。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。 内核用这一结构来管理系统中所有的页，系统中的每个物理页都要分配一个这样的结构体。因为内核需要知道一个页是否空闲（也就是页有没有被分配）。如果页已经被分配，内核还需要知道谁拥有这个页。拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或页高速缓存（Page Cache）等。 区（zone）有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区。内核使用区对具有相似特性的页进行分组。 Linux主要使用了三种区: ZONE_DMA：这个区包含的页能用来执行DMA操作。 ZONE_NORMAL：这个区包含的都是能正常映射的页。 ZONE_HIGHEM：这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间。 这些区在&lt;linux/mmzone.h&gt;中定义。 区的实际使用和分布是与体系结构相关的。例如，某些体系结构在内存的任何地址上执行DMA都没有问题。在这些体系结构中，ZONE_DMA为空，ZONE_NORMAL就可以直接用于分配。与此相反，在x86体系结构上，ISA设备就不能在整个32位的地址空间中执行DMA，因为ISA设备只能访问物理内存的前16MB。因此，ZONE_DMA在x86上包含的页都在0-16MB的内存范围里。 Linux把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。例如，ZONE_DMA内存池让内核有能力为DMA分配所需的内存。如果需要这样的内存，那么，内核就可以从ZONE_DMA中按照请求的数目取出页。 有些64位的体系结构，如Intel的x86-64体系结构可以映射和处理64位的内存空间，所以x86-64没有ZONE_HIGHMEM区，所有的物理内存都处于ZONE_DMA和ZONE_NORMAL区。 注意，区的划分没有任何物理意义，这只不过是内核为了管理页而采取的一种逻辑上的分组。 每个区都用struct zone表示，在&lt;linux/mmzone.h&gt;中定义。 这个结构体很大，但是，系统中只有三个区，因此，也只有三个这样的结构。 lock域是一个自旋锁，它防止该结构被并发访问。注意，这个域只保护结构，而不保护驻留在这个区中的所有页。没有特定的锁来保护单个页。watermark数组持有该区的最小值、最低和最高水位值。内核使用水位为每个内存区设置合适的内存消耗基准。该水位随空闲内存的多少而变化。name域是一个以NULL结束的字符串表示这个区的名字。内核启动期间初始化这个值，其代码位于mm/page_alloc.c中。分别为“DMA“，“Normal”和“HighMem”。 获得与释放页 内核接口 解释 struct page* alloc_pages(gfp_t gfp_mask, unsigned int order) 该函数分配2^order^ (1 &lt;&lt; order）个连续的物理页，并返回一个指针，该指针指向第一个页的page结构体，如果出错，就返回NULL。 void free_pages(unsigned long addr, unsigned int order) 释放页，释放页时要谨慎，只能释放属于你的页。传递了错误的struct page或地址，用了错误的order值，这些都可能导致系统崩溃。 void kmalloc(size_t size, gfp_t flags) 这个函数返回一个指向以字节为单位内存块的指针。所分配的内存区在物理上是连续的。出错，返回NULL。它确保页在物理地址上是连续的。 void kfree(const void *ptr) 释放由kmalloc()分配出来的内存块。如果释放的内存不是由kmalloc()分配的，或者释放的内存早就被释放了，调用这个函数就会导致严重的后果。调用kfree(NULL)是安全的。 void* vmalloc(unsigned long size) 分配的内存虚拟地址是连续的，而物理地址则无须连续。它通过分配非连续的物理内存块，再“修正”页表，把内存映射到逻辑地址空间的连续区域中。 void vfree(const void* addr) 要释放通过vmalloc()获得的内存。 大多数情况下，只有硬件设备需要得到物理地址连续的内存。在很多体系结构上，硬件设备存在于内存管理单元以外，它根本不理解什么是虚拟地址。因此，硬件设备用到的任何内存区都必须是物理上连续的块，而不仅仅是虚拟地址连续上的块。而仅供软件使用的内存块（例如与进程相关的缓冲区）就可以使用只有虚拟地址连续的内存块。对内核而言，所有内存看起来都是逻辑上连续的。 进程地址空间内核除了管理本身的内存外，还必须管理用户空间中进程的内存。我们称这个内存为进程地址空间，也就是系统中每个用户空间进程所看到的内存。Linux系统中的所有进程之间以虚拟方式共享内存。对一个进程而言，它好像都可以访问整个系统的所有物理内存。即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。 进程地址空间由进程可寻址的虚拟内存组成，内核允许进程使用这种虚拟内存中的地址。每个进程都有一个32位或64位的平坦地址空间。术语“平坦”指的是地址空间范围是一个独立的连续区间。一个进程的地址空间与另一个进程的地址空间即使有相同的内存地址，实际上也彼此互不相干。这样的进程也就是Linux中所谓的线程。 内存地址是一个给定的值，它要在地址空间范围之内，比如4021F000。这个值表示的是进程32位地址空间中的一个特定的字节。尽管一个进程可以寻址4GB的虚拟内存（在32位的地址空间中)，但这并不代表它就有权访问所有的虚拟地址。在地址空间中，我们更为关心的是一些虚拟内存的地址区间，比如08048000 - 0804C000，它们可被进程访问。这些可被访问的合法地址空间称为内存区域。通过内核，进程可以给自己的地址空间动态地添加或减少内存区域。 进程只能访问有效内存区域内的内存地址。每个内存区域也具有相关权限如对相关进程有可读、可写、可执行属性。如果一个进程访问了不在有效范围中的内存区域，或以不正确的方式访向了有效地址，那么内核就会终止该进程，并返回“段错误”信息。 内存描述符Linux内核使用内存描述符来表示进程的地址空间，该描述符表示着进程所有地址空间的信息。内存描述符由mm_struct结构体表示，下面给出内存描述符结构中各个域的描述，请大家结合前面的进程内存段布局图一起看： 12345678910111213141516171819202122232425262728293031323334struct mm_struct&#123; struct vm_area_struct *mmap; /* 内存区域组织成链表 */ struct rb_root mm_rb; /* 内存区域组织成红黑树 */ struct vm_area_struct *mmap_cache; /* 最近使用的内存区域 */ unsigned long free_area_cache; /* 地址空间第一个空洞 */ pgd_t *pgd; /* 页全局目录 */ atomic_t mm_users; /* 使用地址空间的用户数 */ atomic_t mm_count; /* 主使用计数器 */ int map_count; /* 内存区域的个数 */ struct rw_semaphore mmap_sem; /* 内存区域的信号量 */ spinlock_t page_table_lock; /* 页表锁 */ struct list_head mmlist; /* 所有 mm_struct 形成的链表 */ unsigned long rss; /* 所分配的物理页 */ unsigned long total_vm; /* 全部页面数目 */ unsigned long locked_vm; /* 上锁的页面数据 */ unsigned long pinned_vm; /* Refcount permanently increased */ unsigned long shared_vm; /* 共享页面数目 Shared pages (files) */ unsigned long exec_vm; /* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */ unsigned long stack_vm; /* 栈区页面数目 VM_GROWSUP/DOWN */ unsigned long def_flags; /* 代码段、数据段 起始地址和结束地址 */ unsigned long start_code, end_code, start_data, end_data; unsigned long start_brk, brk, start_stack; /* 堆区起始地址和结束地址, 进程栈区的起始地址 */ /* 命令行参数 和 环境变量的 起始地址和结束地址 */ unsigned long arg_start, arg_end, env_start, env_end; /* Architecture-specific MM context */ mm_context_t context; /* 体系结构特殊数据 */ /* Must use atomic bitops to access the bits */ unsigned long flags; /* 状态标志位 */ /* Coredumping and NUMA and HugePage 相关结构体 */ ...&#125;; mm_count代表了对mm_strcut本身的引用，而mm_users代表对mm_struct相关资源的引用，分了两个层次。mm_count类似于以进程为单位。 mm_users类似于以线程为单位。内核线程在运行时会借用其他进程的mm_struct，这样的线程叫anonymous users，因为他们不关心mm_struct指向的用户空间，也不会去访问这个用户空间，他们只是临时借用（比如说当进程执行系统调用陷入到内核中，内核会借用该进程的地址空间）。mm_count记录这样的进程数。mm_users是对mm_struct所指向的用户空间进行共享的所有进程的计数。也就是说，会有多个进程共享同一个用户空间， 这些进程也就是所谓的线程。 mmap和mm_rb这两个不同数据结构体描述的对象是相同的：该地址空间中的全部内存区域。但是前者以链表形式存放而后者以红黑树的形式存放。mmap结构体作为链表，利于简单、高效地遍历所有元素；而mm_rb结构体作为红黑树，更适合搜索定位指定元素。 所有的mm_struct结构体都通过自身的mmlist域连接在一个双向链表中，该链表的首元素是init_mm内存描述符，它代表init进程的地址空间。另外要注意，操作该链表的时候需要使用mmlist_lock锁来防止并发访问，该锁定义在文件kernel/fork.c中。 每个进程都有自己的页表（当然，线程会共享页表）。内存描述符的pgd域指向的就是进程的页全局目录。 内存描述符的分配与撤销在进程的进程描述符（即task_struct结构体）中，mm域存放着该进程使用的内存描述符，所以current-&gt;mm便指向当前进程的内存描述符。fork()函数利用copy_mm()函数复制父进程的内存描述符，也就是current-&gt;mm域给其子进程，而子进程中的mm_struct结构体实际是通过文件kernel/fork.c中的allocate_mm()宏从mm_cachep slab缓存中分配得到的。通常，每个进程都有唯一的mm_struct结构体，即唯一的进程地址空间。 如果父进程希望和其子进程共享地址空间，可以在调用clone()时，设置CLONE_VM标志。我们把这样的进程称作线程。当CLONE_VM被指定后，内核就不再需要调用allocate_mm()函数了，而仅仅需要调用copy_mm()函数中将mm域指向其父进程的内存描述符就可以了： 123456if(clone_flags &amp; CLONE_vM)&#123; // current 是父进程而 tsk 在 fork(）执行期间是子进程 atomic_inc(&amp;current-&gt;mm-&gt;mm_users); tsk-&gt;mm = current-&gt;mm;&#125; 当进程退出时，内核会调用定义在kernel/exit.c中的exit_mm()函数，该函数执行一些常规的撤销工作，同时更新一些统计量。其中，该函数会调用mmput()函数减少内存描述符中的mm_users用户计数，如果用户计数降到零，将调用mmdrop()函数，减少mm_count使用计数。如果mm_count也等于零了，说明该内存描述符不再有任何使用者了，那么调用free_mm()宏通过kmem_cache_free()函数将mm_struct结构体归还到mm_cachep slab缓存中。 内核线程没有进程地址空间，也没有相关的内存描述符。所以内核线程对应的进程描述符中mm域为空。事实上，这也正是内核线程的真实含义——它们没有用户上下文。当一个进程被调度时，该进程的mm域指向的地址空间被装载到内存，进程描述符中的active_mm域会被更新，指向新的地址空间。内核线程没有地址空间，所以mm域为NULL。于是，当一个内核线程被调度时，内核发现它的mm域为NULL，就会保留前一个进程的地址空间，随后内核更新内核线程对应的进程描述符中的active_mm域，使其指向前一个进程的内存描述符。 所以在需要时，内核线程便可以使用前一个进程的页表。因为内核线程不访问用户空间的内存，所以它们仅仅使用地址空间中和内核内存相关的信息，这些信息的含义和普通进程完全相同（要知道用户进程的地址空间是包含分配给内核的那1G的空间的，只不过是不允许访问而已，所以内核线程借用前一个进程的地址空间是用来访问属于内核的那1G空间的）。 虚拟内存区域每个和进程相关的内存区域都对应于一个vm_area_struct结构体。vm_area_struct结构体描述了指定地址空间内连续区间上的一个独立内存范围。内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都拥有一致的属性，比如访问权限等，另外，相应的操作也都一致。按照这样的方式，每一个VMA就可以代表不同类型的内存区域（比如内存映射文件或者进程用户空间栈），下面给出该结构定义和各个域的描述： 1234567891011121314151617181920212223242526272829struct vm_area_struct&#123; struct mm_struct *vm_mm; // 相关的 mm_struct 结构体 unsigned long vm_start; // 区间的首地址 unsigned long vm_end; // 区间的尾地址 struct vm_area_struct *vm_next; // VMA 链表 pgprot_t vm_page_prot; // 访问控制权限 unsigned long vm_flags; //标志 struct rb_node vm_rb; //树上该 VMA 的节点 union &#123; // 或者是关联于 address_space-&gt;i_mmap 字段 // 或者是关联于 address_space-&gt;i_mmap_nonlinear 字段 struct &#123; struct list_head list; void *parent; struct vm_area_truct head; &#125; vm_set; struct prio_tree_node prio_tree_node; &#125; shared; struct list_head anon_vma_node; // anon_vma 项 struct anon_vma *anon_vma; //匿名VMA对象 struct vm_operations_struct vin_ops; // 相关的操作表 unsigned 1ong vm_pgoff; // 文件中的偏移量 struct file *vm_file; // 被映射的文件（如果存在) void *vm_private_data; // 私有数据&#125;; 每个内存描述符都对应于进程地址空间中的唯一区间。vm_start域指向区间的首地址（最低地址），vm_end域指向区间的尾地址（最高地址）之后的第一个字节。注意，在同一个地址空间内的不同内存区间不能重叠。 vm_mm域指向和VMA相关的mm_struct结构体，注意，每个VMA对其相关的mm_struct结构体来说都是唯一的，所以即使两个独立的进程将同一个文件映射到各自的地址空间，它们分别都会有一个vm_area_struct结构体来标志自己的内存区域；反过来，如果两个线程共享一个地址空间，那么它们也同时共享其中的所有vm_area_struct结构体。 上文讨论过，可以通过内存描述符中的mmap和mm_rb域之一访问内存区域。mmap域使用单独链表连接所有的内存区域对象。每一个vm_area_struet结构体通过自身的vm_next域被连入链表，所有的区域按地址增长的方向排序，mmap域指向链表中第一个内存区域，链中最后一个结构体指针指向空。mm_rb域使用红黑树连接所有的内存区域对象。mm_rb域指向红黑树的根节点，地址空间中每一个vm_area_struct结构体通过自身的vm_rb域连接到树中。 创建和删除地址空间内核使用do_mmap()函数创建一个新的线性地址区间。如果创建的地址区间和一个已存在的地址区间相邻，并且它们具有相同的访问权限的话，两个区间将合并为一个。映射时，从vm_area_cachep长字节（slab）缓存中分配一个vm_area_struct结构体，并且使用vma_link()函数将新分配的内存区域添加到地址空间的内存区域链表和红黑树中，随后还要更新内存描述符中的total_vm域，然后才返回新分配的地址区间的初始地址。 do_mmap()函数定义在文件&lt;linux/mm.h&gt;中。 123unsigned long do_mmap(struct file *file, unsigned long addr, unsigned long len, unsigned long prot, unsigned long flag, unsigned long offset); 该函数映射由file指定的文件，具体映射的是文件中从偏移offset处开始，长度为len字节的范围内的数据。如果file参数是NULL并且offset参数也是0，那么就代表这次映射没有和文件相关，该情况称作匿名映射（anonymous mapping）。如果指定了文件名和偏移量，那么该映射称为文件映射（file-backed mapping）。 addr是可选参数，它指定搜索空闲区域的起始位置。prot参数指定内存区域中页面的访问权限。访问权限标志定义在文件&lt;asm/mman.h&gt;中。 在用户空间可以通过mmap()系统调用获取内核函数do_mmap()的功能。mmap()系统调用 1void* mmap2(void* start, size_t length, int prot, int flags, int fd, off_t pgoff); 由于该系统调用是mmap()调用的第二种变种，所以起名为mmap2()。最原始的mmap()调用中最后一个参数是字节偏移量，而目前这个mmap2()使用页面偏移作最后一个参数。使用页面偏移量可以映射更大的文件和更大的偏移位置。原始的mmap()调用由POSIX定义，仍然在C库中作为mmap()方法使用，但是内核中已经没有对应的实现了，而实现的是新方法mmap2()。虽然C库仍然可以使用原始版本的映射方法，但是它其实还是基于函数mmap2进行的，对原始mmap()方法的调用是通过将字节偏移转化为页面偏移，从而转化为对mmap2()函数的调用来实现的。 do_mummap()函数从特定的进程地址空间中删除指定地址区间，该函数定义在文件&lt;linux/mm.h&gt;中： 1int do_mummap(struct mm_struct *mm , unsigned long start, size_t len); 第一个参数指定要删除区域所在的地址空间，删除从地址start开始，长度为len字节的地址区间。如果成功，返回零。否则，返回负的错误码。 系统调用munmap()给用户空间程序提供了一种从自身地址空间中删除指定地址区间的方法，它和系统调用mmap()的作用相反，该系统调用定义在文件mm/mmap.c中，它是对do_mummap()函数的一个简单的封装。 1int munmap(void *start, size_t length); 进程用户栈、线程栈、进程内核栈、中断栈进程用户栈 进程栈是属于用户态栈，和进程虚拟地址空间 (Virtual Address Space) 密切相关。那我们先了解下什么是虚拟地址空间：在32位机器下，虚拟地址空间大小为4G。这些虚拟地址通过页表 (Page Table) 映射到物理内存，页表由操作系统维护，并被处理器的内存管理单元 (MMU) 硬件引用。每个进程都拥有一套属于它自己的页表，因此对于每个进程而言都好像独享了整个虚拟地址空间。 Linux内核将这4G字节的空间分为两部分，将最高的1G字节（0xC0000000- 0xFFFFFFFF）供内核使用，称为内核空间。而将较低的3G字节（0x00000000 - 0xBFFFFFFF）供各个进程使用，称为用户空间。每个进程可以通过系统调用陷入内核态，因此内核空间是由所有进程共享的。虽然说内核和用户态进程占用了这么大地址空间，但是并不意味它们使用了这么多物理内存，仅表示它可以支配这么大的地址空间。它们是根据需要，将物理内存映射到虚拟地址空间中使用。 Linux对进程地址空间有个标准布局，地址空间中由各个不同的内存段组成 (Memory Segment)，主要的内存段如下： 程序段 (Text Segment)：可执行文件代码的内存映射。 数据段 (Data Segment)：可执行文件的已初始化全局变量的内存映射。 BSS段 (BSS Segment)：未初始化的全局变量或者静态变量（映射到零页）。 堆区 (Heap) : 存储动态内存分配，匿名的内存映射（malloc分配的内存区域）。 栈区 (Stack) : 进程用户空间栈，由编译器自动分配释放，存放函数的参数值、局部变量的值等。 映射段（Memory Mapping Segment）：任何内存映射文件，如每一个诸如C库或动态连接程序等共享库的代码段、数据段和BSS也会被载入进程的地址空间。 可执行文件的BSS段未存储在磁盘上，内核将零页面映射到BSS范围。 因为在创建新进程时预期BSS段将被初始化为零，并且仅在可执行文件中存储一堆零浪费了空间，所以可执行文件仅指示BSS段应从何处开始以及应该从多大。 当内核从可执行文件构建新进程时，它将为BSS范围创建到零页面的映射，该页面是全零的静态（虚拟）页面。该映射设置有写时复制功能，因此，新进程首次向其中一个BSS页进行写入时，在允许写入完成之前，静态零页的实际副本将分配到另一个内存页中。 这样做有如下几点好处： 节省了可执行文件中的空间。 避免了实际分配可能永远不会被该进程触及的BSS页面，从而节省了内存使用量。 同时仍然提供了确保每个进程中的BSS段看起来都是零初始化的保证。 而上面进程虚拟地址空间中的栈区，正指的是我们所说的进程栈。进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，Linux内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制RLIMIT_STACK（一般为8M），我们可以通过ulimit来查看或更改RLIMIT_STACK的值。 如何确认进程栈的大小 我们要知道栈的大小，那必须得知道栈的起始地址和结束地址。栈起始地址获取很简单，只需要嵌入汇编指令获取栈指针esp寄存器的值即可。栈结束地址的获取有点麻烦，我们需要先利用递归函数把栈搞溢出了，然后再GDB中把栈溢出的时候把栈指针esp寄存器的值打印出来即可。代码如下： 123456789101112131415161718192021222324252627/* file name: stacksize.c */void *orig_stack_pointer;void blow_stack() &#123; blow_stack(); &#125;int main()&#123; __asm__(\"movl %esp, orig_stack_pointer\"); blow_stack(); return 0;&#125;$ g++ -g stacksize.c -o ./stacksize$ gdb ./stacksize(gdb) rStarting program: /home/home/misc-code/setrlimitProgram received signal SIGSEGV, Segmentation fault.blow_stack () at setrlimit.c:44 blow_stack();(gdb) print (void *)$esp$1 = (void *) 0xffffffffff7ff000(gdb) print (void *)orig_stack_pointer$2 = (void *) 0xffffc800(gdb) print 0xffffc800-0xff7ff000$3 = 8378368 // Current Process Stack Size is 8M 进程栈的动态增长实现 进程在运行的过程中，通过不断向栈区压入数据，当超出栈区容量时，就会耗尽栈所对应的内存区域，这将触发一个 缺页异常 (page fault）。通过异常陷入内核态后，异常会被内核的expand_stack()函数处理，进而调用 acct_stack_growth()来检查是否还有合适的地方用于栈的增长。 如果栈的大小低于RLIMIT_STACK（通常为8MB），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情，这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会发生栈溢出（stack overflow），进程将会收到内核发出的段错误（segmentation fault）信号。 动态栈增长是唯一一种访问未映射内存区域而被允许的情形，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。 线程栈 从Linux内核的角度来说，其实它并没有线程的概念。Linux把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了task_struct中。线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和Linux中所谓线程的唯一区别。线程创建的时候，加上了CLONE_VM标记，这样 线程的内存描述符 将直接指向父进程的内存描述符。 虽然线程的地址空间和进程一样，但是对待其地址空间的栈stack还是有些区别的。对于Linux进程或者说主线程，其stack是在fork的时候生成的，实际上就是复制了父亲的stack空间地址，然后写时拷贝 (cow) 以及动态增长。然而对于主线程生成的子线程而言，其stack将不再是这样的了，而是事先固定下来的，使用mmap系统调用，它不带有VM_STACK_FLAGS标记。 这个可以从glibc的nptl/allocatestack.c中的allocate_stack()函数中看到： 1mem = mmap (NULL, size, prot, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0); 由于线程的mm-&gt;start_stack栈地址和所属进程相同，所以线程栈的起始地址并没有存放在task_struct中，应该是使用pthread_attr_t中的stackaddr来初始化task_struct-&gt;thread-&gt;sp（sp指向struct pt_regs对象，该结构体用于保存用户进程或者线程的寄存器现场）。这些都不重要，重要的是，线程栈不能动态增长，一旦用尽就没了，这是和生成进程的fork不同的地方。由于线程栈是从进程的地址空间中map出来的一块内存区域，原则上是线程私有的。 进程内核栈 在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作进程内核栈。进程内核栈在进程创建的时候，通过slab分配器从thread_info_cache缓存池中分配出来，其大小为THREAD_SIZE，一般来说是一个页大小4K： 12345union thread_union&#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE / sizeof(long)];&#125;; thread_union进程内核栈和task_struct进程描述符有着紧密的联系。由于内核经常要访问task_struct，高效获取当前进程的描述符是一件非常重要的事情。因此内核将进程内核栈的头部一段空间，用于存放thread_info结构体，而此结构体中则记录了对应进程的描述符，两者关系如下图： 有了上述关联结构后，内核可以先获取到栈顶指针esp，然后通过esp来获取thread_info。这里有一个小技巧，直接将esp的地址与上~(THREAD_SIZE - 1)后即可直接获得thread_info的地址。由于thread_union结构体是从thread_info_cache的Slab缓存池中申请出来的，而thread_info_cache在kmem_cache_create创建的时候，保证了地址是THREAD_SIZE对齐的。因此只需要对栈指针进行THREAD_SIZE对齐，即可获得thread_union的地址。成功获取到thread_info后，直接取出它的task成员就成功得到了task_struct。其实上面这段描述，也就是current宏的实现方法： 123456789register unsigned long current_stack_pointer asm (\"sp\");static inline struct thread_info *current_thread_info(void)&#123; return (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE - 1));&#125;#define get_current() (current_thread_info()-&gt;task)#define current get_current() 中断栈 进程陷入内核态的时候，需要内核栈来支持内核函数调用。中断也是如此，当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关。 x86上中断栈就是独立于内核栈的；独立的中断栈所在内存空间的分配发生在arch/x86/kernel/irq_32.c的irq_ctx_init()函数中（如果是多处理器系统，那么每个处理器都会有一个独立的中断栈），函数使用__alloc_pages在低端内存区分配2个物理页面，也就是8KB大小的空间。有趣的是，这个函数还会为softirq分配一个同样大小的独立堆栈。如此说来，softirq将不会在hardirq的中断栈上执行，而是在自己的上下文中执行。 为什么需要单独的进程内核栈？ （为什么需要单独的线程栈？进程和线程是否共享一个内核栈？） 所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程A陷入内核态执行的时候，需要等待读取网卡的数据，主动调用schedule()让出CPU；此时调度器唤醒了另一个进程B，碰巧进程B也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程B进入内核态的时候产生的压栈操作，必然会破坏掉进程A已有的内核栈数据；一但进程A的内核栈数据被破坏，很可能导致进程A的内核态无法正确返回到对应的用户态了。 **这三个问题很好理解，只要可被调度执行的对象之间共用一个栈（无论进程栈，内核栈还是线程栈），那必然会有出错的机会，所以不能共用。进程和同一个进程的线程都是可被调度执行的对象！","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统之并发与同步","date":"2021-03-06T13:35:42.000Z","path":"29s2fW7i8PsxWCiK/","text":"并发的概念在单处理器多道程序设计系统中，进程会被交替地执行，因而表现出一种并发执行的外部特征。支持并发进程的基本需求是加强互斥的能力。也就是说，当一个进程被授予互斥能力时，那么在其活动期间，它具有排斥所有其他进程的能力。 并发包括很多设计问题，其中有进程间通信、资源共享与竞争（如内存、文件、I/O访问)、多个进程活动的同步以及给进程分配处理器时间等。并发问题源于多道程序设计系统的一个基本特性：进程的相对执行速度不可预测，它取决于其他进程的活动、操作系统处理中断的方式以及操作系统的调度策略。 术语 解释 临界区 一段代码，在这段代码中进程将访问共享资源，当另外一个进程已在这段代码中运行时，这个进程就不能在这段代码中执行 死锁 两个或两个以上的进程因每个进程都在等待其他进程做完某些事情而不能继续执行的情形 互斥 当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源的情形 竞争条件 多个线程或进程在读写一个共享数据时，结果依赖于它们执行的相对时间的情形 饥饿 一个可运行进程尽管能继续执行，但被调度程序无限期地忽视，而不能被调度执行的情形 原子操作 保证指令序列要么作为一个组来执行，要么都不执行 如果需要保护共享的全局变量（以及其他共享的全局资源），唯一的办法是控制访问该变量的代码。 原子性和顺序性 原子性确保指令执行期间不被打断，要么全部执行完，要么根本不执行。另一方面，顺序性确保即使两条或多条指令出现在独立的执行线程中，甚至独立的处理器上，它们本该的执行顺序却依然要保持。顺序性通过屏障（barrier）指令来实施。 进程交互的分类 进程之间互相不知道对方的存在，它们表现出竞争关系 进程间接知道对方的存在，但它们共享某些对象，表现出通过共享合作的关系 进程直接知道对方的存在，可以通过进程ID互相传递消息进行通信，表现出通过通信合作的关系 竞争进程面临三个控制问题： 互斥 假设两个或更多的进程需要访问一个不可共享的资源，如打印机。在执行过程中，每个进程都给该IO设备发命令，接收状态信息，发送数据和接收数据。我们把这类资源称为临界资源，使用临界资源的那部分程序称为程序的临界区。一次只允许有一个程序在临界区中，这一点非常重要。 为了实现互斥则产生了下面两个问题： 死锁 考虑两个进程P1和P2，以及两个资源R1和R2，假设每个进程为执行部分功能都需要访问这两个资源，那么就有可能出现下列情况：操作系统把R1分配给P2，把R2分配给P1，每个进程都在等待另一个资源，且在获得其他资源并完成功能前，谁都不会释放自己已拥有的资源，此时这两个进程就会发生死锁。 饥饿 假设有三个进程（P1、P2和P3），每个进程都周期性地访问资源R。假设操作系统把访问权轮流授予P1和P3，那么即使没有死锁，P2也可能被无限地拒绝访间资源。 合作进程和竞争进程的唯一区别是可以按两种不同的模式（读和写）访问数据项，并且只有写操作必须保证互斥。除了面临上面三个问题外，还有一个新的要求：数据一致性。 若使用临界区来保护数据的一致性，则没有确定的资源或变量可作为参数。此时，可以把参数视为一个在并发进程间共享的标识符，用于标识必须互斥的临界区。 互斥的要求以及实现 必须强制实施互斥：在与相同资源或共享对象的临界区有关的所有进程中，一次只允许一个进程进入临界区。 没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入。 一个进程驻留在临界区中的时间必须是有限的。 硬件支持的实现 禁用中断 为保证互斥，只需保证一个进程不被中断即可，这种能力可通过系统内核为启用和禁用中断定义的原语来提供。但代价非常高。 专用机器指令 在硬件级别上，对存储单元的访问排斥对相同单元的其他访问。因此，处理器的设计者人员提出了一些机器指令，用于保证两个动作的原子性。 软件支持的实现 并发机制 解释 信号量 用于进程间传递信号的一个整数值。在信号量上只可进行三种操作，即初始化、递减和递增，它们都是原子操作。递减操作用于阻塞一个进程，递增操作用于解除一个进程的阻塞 二元信号量 只取0值和1值的信号量 互斥量 类似于二元信号量。关键区别在于为其加锁（设定值为0）的进程和为其解锁（设定值为1）的进程必须为同一个进程，一般被用在构造临界区上 条件变量 一种数据类型，用于阻塞进程或线程，直到特定的条件为真 自旋锁 一种互斥机制，进程在一个无条件循环中执行，等待锁变量的值可用 信号量Linux中的信号量是一种睡眠锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放）后，处于等待队列中的那个任务将被唤醒。 我们可以从信号量的睡眠特性得出一些有意思的结论： 由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况。 相反，锁被短时间持有时，使用信号量就不太适宜了。因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁被占用的全部时间还要长。 面于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下文中是不能进行调度的。 你可以在持有信号量时去睡眠，因为当其他进程试图获得同一信号量时不会因此而死锁（因为该进程也只是去睡眠而已，而你最终会继续执行的）。 为达到预期效果，可把信号量视为一个值为整数的变量，整数值上定义了三个操作： 一个信号量可以初始化成非负数。 semWait操作使信号量减1。若值变成负数，则阻塞执行semWait的进程，否则进程继续执行。 semSignal操作使信号量加1。被semWait操作阻塞的进程之一（可能没有被阻塞的）解除阻塞。 12345678910111213141516171819202122232425262728293031// 使用 比较和交换指令 实现的信号量原语struct semaphore&#123; int count; bool flag; queueType queue;&#125;;void semwait(semaphore s)&#123; while(compare_and_swap(s.flag, 0, 1) == 1); s.count--; if(s.count &lt; 0) &#123; /* 把当前进程插入队列 */; /* 阻塞当前进程 */; &#125; s.flag = 0;&#125;void semSignal(semaphore s)&#123; while(compare_and_swap(s.flag, 0, 1) == 1); s.count++; if(s.count &lt;= O) &#123; /* 把进程 P 从队列中移除 */; /* 把进程卫插入就绪队列 */; &#125; s.flag = 0;&#125; s.count ≥ 0：s.count是可执行semwait(s)而不被阻塞的进程数。这种情形允许信号量支持同步与互斥。 s.count &lt; 0：s.count的大小是阻塞在s.queue队列中的进程数。 二元信号量 二元信号量可以初始化为0或1。 semWaitB操作检查信号的值。若值为0，则进程执行semwaitB就会受阻。若值为1，则将值改为0，并继续执行该进程。 semSignalB操作检查是否有任何进程在该信号上受阻。若有进程受阻，则通过semWaitB操作受阻的进程会被唤醒：若没有进程受阻，则值设置为1。 123456789101112131415161718192021222324252627struct binary_semaphore&#123; enum &#123;zero, one&#125; value; qrueueType queue;&#125;;void semwaitB(binary semaphore s)&#123; if(s.value = one) s.value = zero; else &#123; /* 把当前进程插入队列 */; /* 阻塞当前进程 */; &#125;&#125;void semSignalB(semaphore s)&#123; if(s.queue is empty()) s.value =one; else &#123; /* 把进程 P 从等待队列中移除 */; /* 把进程卫插入就绪队列 */; &#125;&#125; 不论是计数信号量还是二元信号量，都需要使用队列来保存于信号量上等待的进程。这就产生了一个问题，进程按什么顺序从队列中移出？最公平的策略是先进先出，被阻塞时间最久的进程最先从队列释放。采用这一策略定义的信号量称为强信号量，而没有规定进程从队列中移出顺序的信号量称为弱信号量。 强信号量保证不会饥饿，而弱信号量则无法保证。 自旋锁自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个被已经持有（即所谓的争用）的自旋锁，那么该线程就会一直进行忙循环一旋转，等待锁重新可用。要是锁未被争用，请求锁的执行线程便能立刻得到它，继续执行。在任意时间，自旋锁都可以防止多于一个的执行线程同时进入临界区。 自旋锁是不可递归的（不可重入的）。 自旋锁可以使用在中断处理程序中（此处不能使用信号量，因为它们会导致睡眠）。在中断处理程序中使用自旋锁时，一定要在获取锁之前，首先禁止本地中断（在当前处理器上的中断请求），否则，中断处理程序就会打断正持有锁的内核代码，有可能会试图去争用这个已经被持有的自旋锁。这样一来，中断处理程序就会自旋，等待该锁重新可用，但是锁的持有者在这个中断处理程序执行完毕前不可能运行。这正是我们在前面的内容中提到的双重请求死锁。注意，需要关闭的只是当前处理器上的中断。如果中断发生在不同的处理器上，即使中断处理程序在同一锁上自旋，也不会妨碍锁的持有者（在不同处理器上）最终释放锁。 互斥量mutex 任何时刻中只有一个任务可以持有mutex，也就是说，mutex的使用计数永远是1。 给mutex上锁者必须负责给其再解锁——你不能在一个上下文中锁定一个mutex，而在另一个上下文中给它解锁。这个限制使得mutex不适合内核同用户空间复杂的同步场景。最常使用的方式是：在同一上下文中上锁和解锁。 递归地上锁和解锁是不允许的。也就是说，你不能递归地持有同一个锁，同样你也不能再去解锁一个已经被解开的mutex。 当持有一个mutex时，进程不可以退出。 mutex只能通过官方API管理，不可被拷贝、赋值、重复初始化。 除非mutex的某个约束妨碍你使用，否则相比信号量要优先使用mutex。在中断上下文中只能使用自旋锁，而在任务睡眠时只能使用mutex。 死锁原理死锁定义为一组相互竞争系统资源或进行通信的进程间的“永久”阻塞。当一组进程中的每个进程都在等待某个事件（典型情况下是等待释放所请求的资源），而仅有这组进程中被阻塞的其他进程才可触发该事件时，就称这组进程发生了死锁。 资源通常分为两类：可重用资源和可消耗资源。可重用资源是指一次仅供一个进程安全使用且不因使用而耗尽的资源。可重用资源的例子包括处理器、I/O通道、内存和外存、设备，以及诸如文件、数据库和信号量之类的数据结构。可消耗资源是指可被创建（生产）和销毁（消耗）的资源。存在。可消耗资源的例子有中断、信号、消息和I/O缓冲区中的信息。 产生死锁有三个必要条件： 互斥。一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。 占有且等待。当一个进程等待其他进程时，继续占有已分配的资源。 不可抢占。不能强行抢占进程已占有的资源。 要产生死锁，还需要第四个条件： 循环等待。存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。 第四个条件实际上是前三个条件的潜在结果，即假设前三个条件存在，那么可能发生的系列事件会导致不可解的循环等待。这个不可解的循环等待实际上就是死锁的定义。循环等待之所以不可解，是因为有前面三个条件的存在。因此，这四个条件一起构成 了死锁的充分必要条件。 死锁预防死锁预防方法分为两类。一类是间接死锁预防方法，即防止前面列出的三个必要条件中的任何一个条件的发生；另一类是直接死锁预防方法，即防止循环等待的发生。 互斥 不可能禁止。如果需要对资源进行互斥访问，那么操作系统就必须支持互斥。 占有且等待 为预防占有且等待的条件，可以要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足。 不可抢占 预防不可抢占的方法有几种。首先，占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放其最初占有的资源，必要时可再次申请这些资源和其他资源。其次，一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不同的条件下，后一种方案才能预防死锁。 此外，只有在资源状态可以很容易地保存和恢复的情况下（如CPU上下文），这种方法才是实用的。 循环等待 循环等待条件可通过定义资源类型的线性顺序来预防。若一个进程已分配了R类型的资源，则其接下来请求的资源只能是那些排在R类型之后的资源。 死锁避免在死锁避免中，是否允许当前的资源分配请求是通过判断该请求是否可能导致死锁来决定的。因此，死锁避免需要知道未来进程资源请求的情况。 进程启动拒绝。若一个进程的请求会导致死锁，则不启动该进程。 资源分配拒绝，又称银行家算法。若一个进程增加的资源请求会导致死锁，则不允许这一资源分配。 死锁避免的优点是，无须死锁预防中的抢占和回滚进程， 死锁检测对于死锁检测来说，只要有可能，就会给进程分配其所请求的资源。操作系统周期性地执行一个算法来检测前面的循环等待条件。算法的策略是查找一个进程，使得可用资源能满足该进程的资源请求，然后假设同意这些资源，让该进程运行直到结束，再释放它的所有资源。然后，算法再寻找另一个可以满足资源请求的进程。 死锁恢复： 取消所有的死锁进程。这是操作系统中最常采用的方法。 连续取消死锁进程直到不再存在死锁。所选取消进程的顺序应基于某种最小代价原则。每次取消后，必须重新调用检测算法，以测试是否仍存在死锁。 连续抢占资源直到不再存在死锁。 对于内存资源来说，基于抢占的死锁预防是最适合的策略。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统之进程与线程管理","date":"2021-03-01T13:35:42.000Z","path":"DRLdCV5y4mc6kSqv/","text":"任务、线程、进程三者关系 任务是一个抽象的概念，即指软件完成的一个活动；而线程则是完成任务所需的动作；进程则指的是完成此动作所需资源的统称；关于三者的关系，有一个形象的比喻： 任务 = 送货 线程 = 开送货车 系统调度 = 决定合适开哪部送货车 进程 = 道路 + 加油站 + 送货车 + 修车厂 进程进程的概念操作系统为进程提供两种虚拟机制。虚拟处理器让进程觉得自己在独享CPU。虚拟内存让进程在分配和管理内存的时候觉得自己拥有全部内存资源。 进程就是处于执行期的程序和一组相关的系统资源的总称。这些资源包括，打开的文件描述符、挂起的信号、内核内部数据、处理器状态、映射了的内存地址空间、所有执行的线程以及存放全局变量的数据段。它的两个基本元素就是程序代码（可能被执行相同程序的其他进程共享）和与代码相关联的数据集。 进程最少必须包括一个或一组被执行的程序，而与这些程序相关联的是局部变量、全局变量和任何已定义常量的数据单元。因此，一个进程至少应有足够的内存空间来保存其程序和数据；此外，程序的执行通常涉及用于跟踪过程调用和过程间参数传递的栈帧。最后，还有与每个进程相关的许多属性，以便操作系统控制该进程。通常，属性集称为进程描述符。程序、数据、栈帧和属性的集合称为进程映像。下图表示了进程映像在虚存中的结构。 进程描述符从linux内核的观点看，进程又被称为任务，内核将所有进程组织在叫做任务队列的一个双向循环链表中。链表中的每一项是类型为task_struct的结构体（定义在&lt;linux/sched.h&gt;文件中），称为进程描述符或进程控制块，它被用来定义和描述一个完整的进程。 进程描述符包含有一个具体进程的所有信息，主要包括： 进程标识信息 标识符：与进程相关的唯一标识符，用来区分其他进程。每个进程都有唯一的一个进程标识符PID，以及用户标识符UID和组标识符GID。组标识符用于给一组进程指定资源访问特权。 进程状态信息 程序计数器：程序中即将执行的下一条指令的地址。 栈指针：用于指向保存参数和过程调用或系统调用的地址的栈帧的栈顶指针。 上下文数据：进程执行时处理器的寄存器组中的数据。包括控制，状态寄存器等。 进程控制信息 状态：表示进程的执行状态，有执行态、就绪态、停止态、阻塞态和僵死态。 调度信息：Linux调度进程所需要的信息。一个进程可能是普通的或实时的，并具有优先级。实时进程在普通进程前调度，且在每类中使用相关的优先级。一个计数器会记录允许进程执行的时间量。 等待事件信息：进程继续执行前等待的事件标识。 地址空间信息：包括程序代码和进程相关数据的指针，以及与其他进程共享内存块的指针。 时间和计时器：包括进程创建的时刻和进程所消耗的处理器时间总量。一个进程可能还有一个或多个间隔计时器，进程通过系统调用来定义间隔计时器，计时器期满时，会给进程发送一个信号。计时器可以只用一次或周期性地使用。 链接：每个进程都有一个到其父进程的链接及到其兄弟进程（与它有相同的父进程）的链接，以及到其所有子进程的链接。 文件系统：包括指向被该进程打开的任何文件的指针和指向该进程当前目录与根目录的指针。 Linux通过slab分配器动态地给task_struct的结构体分配内存空间，这样能达到对象复用（通过预先分配和重复使用task_struct，可以避免动态分配和释放带来的资源消耗）和缓存着色的目的。除此之外，还需要在内核栈的栈底创建一个类型为thread_info的结构体（定义在&lt;asm/thread_info.h&gt;文件中），结构中的task域存放有指向该任务的task_struct的指针。 对于Linux系统，进程描述符中的state域描述了当前进程的状态，也就是其行为特征，共分为5种： TASK_RUNNING 表示进程是可执行的；要么是在运行队列中等待被调度执行（就绪态），要么是正在执行（运行态）。 TASK_INIERRUPTIBLE 进程正在被阻塞（阻塞态），等待某些条件的满足。一旦条件满足或者接收到信号而提前被唤醒，会从当前状态转为TASK_RUNNING状态（就绪态）。 TASK_UNINIERRUPTIBLE 和TASK_INIERRUPTIBLE状态相同，除了不响应任何信号。也就是执行ps命令后看到进程被标记为D状态的进程，不能通过发送SIGKILL信号杀死处于此状态的进程。比如内核态进程在等待某项资源，这时候是不允许被打断的，否则可能导致系统进入未知状态，或者引发严重的系统异常，所以对于这种操作，定义D状态进行保护。使其在完成本次操作之前，不可以被任何异步状态打断。 _TASK_TRACED 表示此进程正在被其它进程跟踪，例如通过ptrace对调试程序进行跟踪。 _TASK_STOPPED 进程处于终止状态（停止态）。并且只能由来自另一个进程的主动动作恢复，例如，在调试期间收到任何信号都会使进程进入此状态。 僵死态 进程已被终止，但由于某些原因，在进程表中仍然有其task_struct。 可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行（用户态）。当一个程序调执行了系统调用或者触发了某个异常，它就陷入了内核空间（内核态）。此时，我们称内核“代表进程执行”并处于进程上下文中。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复到用户空间继续执行。 系统调用，异常处理程序和中断处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行——对内核的所有访问都必须通过这些接口。 在Linux系统中，所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本并执行其他的相关程序，最终完成系统启动的整个过程。 进程创建进程的创建将一个新进程添加到正被管理的进程集时，操作系统需要建立用于管理该进程的数据结构，并在内存中给它分配地址空间，这些行为构成了一个新进程的创建过程， 操作系统会按照如下步骤操作： 为新进程分配一个唯一的进程描述符。此时，主进程表中会添加一个新表项，每个进程一个表项。 为进程分配空间。包括进程映像中的所有元素。 初始化进程控制块（进程描述符）。 设置正确的链接。即将其放入适当的任务队列中。 创建或扩充其它数据结构。例如，操作系统可因编制账单和/或评估性能，为每个进程维护一个记账文件。 Linux中的进程创建分为两步，首先，fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID、PPID（子进程将其设置为被拷贝进程的PID）和某些资源和统计量（例如，挂起的信号，它没有必要被继承）。然后，在需要时，通过exec()函数族读取可执行文件并将其载入地址空间开始作为一个全新的进程运行。 fork()使用写时拷贝（copy-on-write）页实现。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。 fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。如果进程创建后马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据。 fork()通过clone()系统调用实现。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。fork()和_clone()库函数都根据各自需要的参数标志去调用clone()，然后由clone()去调用do_fork()。 do_fork完成了创建中的大部分工作，它的定义在kernel/fork.c文件中。该函数调用copy_process()函数，然后让进程开始运行。copy _process()函数完成如下工作： 调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同的。 检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制。 子进程着手使自己与父进程区别开来。进程描述符内的许多成员都要被清零或设为初始值。那些不是继承而来的进程描述符成员，主要是统计信息（文件引用计数等）。task_struct中的大多数数据都依然未被修改。 子进程的状态被设置为TASK_UNINTERRUPTIBLE，以保证它不会投入运行。 copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERPRIV标志被清0。表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。 调用alloc_pid()为新进程分配一个有效的PID。 根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。在一般情况下，这些资源会被给定进程的所有线程共享。 最后，copy_process()做扫尾工作并返回一个指向子进程的指针。 再回到do_fork()函数，如果copy_process()函数成功返回，新创建的子进程被唤醒并让其投入运行。内核有意选择子进程首先执行。因为一般子进程都会马上调用exec()函数族，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。 进程终结 原因 说明 正常完成 进程自行执行一个操作系统服务调用，表示它已经结束运行 超出时限 进程运行时间超过规定的时限 无可用内存 系统无法满足进程需要的内存空间 保护错误 进程试图使用不允许使用的资源或文件，如往只读文件中写或试图访问不允许访问的内存单元 I/O失败 在输入或输出期间发生错误，如找不到文件或某些无效操作 父进程终止 当一个父进程终止时，操作系统可能会自动终止该进程的所有子进程 父进程请求 父进程通常具有终止其任何子进程的权力 进程的终结发生在调用exit()系统调用时，exit()又调用了do_exit()（定义在&lt;kernel/exit.c&gt;文件中）： 将tast_struct中的标志成员设置为PF_EXITING。 调用del_timer_sync()删除任一内核定时器。根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。 然后调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（也就是说，这个地址空间没有被共享)，就彻底释放它们。 接下来调用sem__exit()函数。如果进程排队等候IPC信号，它则离开队列。 调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为零，那么就代表没有进程在使用相应的资源，此时可以释放。 接着把存放在task_struct的exit_code成员中的任务退出代码置为由exit()提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。退出代码存放在这里供父进程随时检索。 调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者为init进程，并把进程状态（存放在task_struct结构的exit_state中）设成EXIT_ZOMBIE。 如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白地耗费内存。一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。 do_exit()调用schedule()切换到新的进程。因为处于EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程所执行的最后一段代码。do_exit()永不返回。 至此，与进程相关联的所有资源都被释放掉了，还占用的所有内存就是内核栈、thread_info结构和tast_struct结构。此时进程存在的唯一目的就是向它的父进程提供信息。 这意味着，进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得已终结的子进程的信息后，通知内核它并不关注那些信息后，子进程的task_struct结构才被释放。 wait()这一族函数都是通过唯一（但是很复杂）的一个系统调用wait4()来实现的。它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的PID。此外，调用该函数时提供的指针会包含子函数退出时的退出代码。 当最终需要释放进程描述符时，release_task()会被调用，用以完成以下工作： 它调用__exit_signal()，该函数调用_unhash process()，后者又调用detach_pid()从pidhash上删除该进程，同时也要从任务列表中删除该进程。 _exit_signal()释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。 如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么release_task()就要通知僵死的领头进程的父进程。 release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放tast_struct所占的slab高速缓存。 至此，进程描述符和所有进程独享的资源就全部释放掉了。 进程切换进程间切换进程切换可在操作系统从当前正在运行进程中获得控制权的任何时刻（即，当执行进程从用户态转移到内核态之后）发生。 机制 原因 用途 中断 来自当前执行指令的外部 对异步外部事件的反应，如完成一次I/O操作 异常（陷阱） 与当前执行指令有关 处理一个错误或异常事件，如非法的内存或文件访问 系统调用 显示请求 调用系统函数，使用系统调用会将用户进程设为阻塞态 涉及状态变化的完整的进程切换步骤如下： 保存处理器的上下文，包括程序计数器和其他寄存器。 更新当前处于运行态进程的进程控制块，包括把进程的状态改变为另一状态（就绪态、阻塞态、退出态）。还须更新其他相关的字段，包括退出运行态的原因和记账信息。 把该进程的进程控制块移到相应的任务队列（就绪、阻塞） 选择另一个进程执行，详见进程调度。 更新所选进程的进程控制块，包括把进程的状态改为运行态。 更新内存管理数据结构。是否需要更新取决于管理地址转换的方式，详见内存管理。 载入程序计数器和其他寄存器先前的值，将处理器的上下文恢复为所选进程上次退出运行态时的上下文。 与模式切换（指用户态和内核态间切换）的区别在于，模式切换可在不改变当前运行态进程的状态下出现（即不涉及状态变化），此时保存上下文并之后恢复上下文仅需很少的开销。 线程间切换在Linux系统中，当Linux内核执行从一个进程到另一个进程的切换时，会检查当前进程的页目录地址是否与将被调度的进程的相同。若相同，则它们共享同一个地址空间（即同一个进程中的不同线程），所以此时上下文切换仅是从代码的处跳转到代码的另一处。 进程切换分两步： 切换页目录以使用新的地址空间。 切换内核栈和硬件上下文。 对于Linux来说，线程和进程的最大区别就在于地址空间。对于线程切换，第1步是不需要做的，第2步是进程和线程切换都要做的。 所以明显是进程切换代价大。 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理器的页表缓冲（TLB）会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。 线程和线程在Linux中的实现进程是资源分配的最小单元，享有资源所有权，线程是调度执行的具体对象，享有被调度执行权。 线程是在进程中活动的可被内核调度的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。同一个进程中的所有线程可以共享虚拟内存，但拥有独立的虚拟处理器。进程中的所有线程共享该进程的状态和资源，所有线程都驻留在同一块地址空间中，并可访问相同的数据。 Linux实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的task_struct，所以在内核中，它看起来就像是一个普通的进程，只是线程和其他一些进程共享某些资源，如地址空间。 也就是说，组成一个用户级进程的多个用户级线程被映射到共享同一个组ID的多个Linux内核级进程上。因此，这些进程可以共享文件和内存等资源，使得同一个组中的进程调度切换时不需要切换上下文。 线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源： 1clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0); 上面的代码产生的结果和调用fork()差不多，只是父子俩共享地址空间CLONE_VM、文件系统资源CLONE_FS、文件描述符CLONE_FILES和信号处理程序CLONE_SIGHAND。新建的进程和它的父进程就是所谓的线程，但它们都具有各自的用户栈，因为clone()系统调用会为每个进程创建独立的栈空间。 对比一下，一个普通的fork()的实现是： 1clone(SIGCHLD, 0); 这些clone()用到的参数标志以及它们的作用，这些是在&lt;linux/sched.h&gt;中定义的。 内核线程（进程）内核经常需要在后台执行一些操作。这种任务可以通过内核线程（独立运行在内核空间的标准进程，内核线程也只能由其他内核线程创建）完成。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL）。它们只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。 守护线程（进程）Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd等。 守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。 一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。 首先我们要了解一些基本概念： 进程组 ： 每个进程也属于一个进程组 每个进程主都有一个进程组号，该号等于该进程组组长的PID号 . 一个进程只能为它自己或子进程设置进程组ID号 会话：会话（session）是一个或多个进程组的集合。 setsid()函数可以建立一个会话： 如果，调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。 此进程变成该对话期的首进程； 此进程变成一个新进程组的组长进程； 此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误； 为了保证这一点，我们先调用fork()然后父进程exit()，此时只有子进程在运行。 现在我们来给出创建守护进程所需步骤： 编写守护进程的一般步骤步骤： 在父进程中执行fork并让父进程exit退出； 在子进程中调用setsid函数创建新的会话； 在子进程中调用chdir函数，让根目录/成为子进程的工作目录； 在子进程中调用umask函数，设置进程的umask为0； 在子进程中关闭任何不需要的文件描述符。 一些说明： 在后台运行 为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。 脱离控制终端，登录会话和进程组 有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。 控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长，当进程是会话组长时setsid()调用失败。 但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。 禁止进程重新打开控制终端 现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过再次fork()使进程不再成为会话组长来禁止进程重新打开控制终端。 关闭打开的文件描述符 进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。 改变当前工作目录 进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录。 重设文件创建掩码 进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);。 处理SIGCHLD信号 处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN：signal(SIGCHLD, SIG_IGN);。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://yuanlehome.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"重要知识点详细解读之memcpy、memset、strcpy、strcmp、strlen、string的实现","date":"2021-02-21T13:35:42.000Z","path":"fKh6HJGjVNfldP4P/","text":"memcpy memset strcpy strcmp strlen 自己动手实现一个string类 memcpy、memset实现memcpy实现 此实现并没有考虑dst和src的内存重叠问题 123456789101112131415// 使用 const 修饰 srcvoid* memcpy(void* dst, const void* src, size_t n)&#123; // 验证 dst 和 src 的合法性 assert(dst != NULL); assert(src != NULL); void* ret = dst; while(n--) &#123; *(char*)dst = *(char*)src; dst = (char*)dst + 1; src = (char*)src + 1; &#125; return ret;&#125; memset实现1234567891011void* memset(void* dst, int ch, size_t n)&#123; assert(dst != NULL); void* ret = dst; while(n--) &#123; *(char*)dst = (char)ch; dst = (char*)dst + 1; &#125; return ret; // 返回原 dst 指针&#125; strcpy、strcmp、strlen实现strcpy实现 此实现并没有考虑dst和src的内存重叠问题 12345678910// 使用 const 修饰 srcchar* strcpy(char* dst, const char* src)&#123; // 验证 dst 和 src 的合法性 assert(dst != NULL); assert(src != NULL); char* ret = dst; while((*dst++ = *src++) != '\\0'); return ret; // 返回原 dst 指针&#125; strcmp实现12345678910111213141516171819202122// 注意将两个指针都用 const 修饰int strcmp(const char* rhs, const char* lhs)&#123; // 判空测试 assert(rhs != NULL); assert(lhs != NULL); // 注意这里必须是 unsigned char // 表示的范围为 0 ~ 255 // 如果是 char 的话, 范围是 -128 ~ 127, 这个范围用来比较字符串是不对的 unsigned char c1, c2; while(1) &#123; c1 = *rhs++; c2 = *lhs++; if(c1 != c2) return c1 &lt; c2 ? -1 : 1; if(c1 == 0) bresk; &#125; return 0;&#125; strlen实现1234567size_t strlen(const char* str)&#123; if(str == NULL) return 0; const char* pc = str; while(*pc++ != '\\0'); return pc - str - 1;&#125; 关于标准库中的实现：通过减少数据从内存存取到寄存器的次数来提高效率，使用的手段是先字节对齐，然后每次读取一个4/8字节的多字节数据，对多字节数据遍历是否存在\\0。 自己动手实现一个string类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;cstring&gt;class String&#123;private: char *_data; size_t _size; void init(const char *c_str) &#123; _data = new char[_size + 1]; strcpy(_data, c_str); &#125;public: String() : _data(nullptr), _size(0) &#123;&#125; String(const char *c_str) : _size(strlen(c_str)) &#123; if (c_str) init(c_str); else _data = nullptr; &#125; String(const String &amp;str) : _size(str._size) &#123; if (str._data) init(str._data); else _data = nullptr; &#125; String(String &amp;&amp;str) noexcept : _data(str._data), _size(str._size) &#123; str._data = nullptr; str._size = 0; &#125; ~String() &#123; if (_data) delete _data; &#125; String &amp;operator=(const char *c_str) &#123; // 使用 copy and swap 技术, 可以处理自我赋值情况 String temp(c_str); swap(temp); return *this; &#125; String &amp;operator=(const String &amp;str) &#123; return *this = str._data; &#125; String &amp;operator=(String &amp;&amp;str) noexcept &#123; // 检测自我赋值情况 if(this == &amp;str) return *this; if (_data) delete _data; _data = nullptr; _size = 0; swap(str); return *this; &#125; size_t size() const &#123; return _size; &#125; char *c_str() &#123; return _data; &#125; const char *c_str() const &#123; return _data; &#125; void swap(String &amp;str) &#123; using std::swap; swap(_data, str._data); swap(_size, str._size); &#125; bool operator==(const char *c_str) &#123; if (strcmp(_data, c_str) == 0) return true; return false; &#125; bool operator==(const String &amp;str) &#123; return *this == str._data; &#125; char &amp;operator[](size_t i) &#123; return _data[i]; &#125; const char &amp;operator[](size_t i) const &#123; return _data[i]; &#125;&#125;;std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const String str)&#123; return os &lt;&lt; str.c_str();&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"重要知识点详细解读之const关键字的实现","date":"2021-02-18T13:35:42.000Z","path":"cZUstnNRSXkgncRt/","text":"编译器是如何实现const关键字功能的const用于声明变量const定义的变量只有类型为整数或枚举，且以常量表达式初始化时，在其它地方使用该变量的地方才会被以常量替换。其他情况下它只是一个const限定的变量。但它们都分配了内存地址，把它们统称为常量。 修饰全局变量 123456789101112131415struct Point&#123; int x; int y;&#125;;// 全局const Point p&#123;1, 2&#125;;void func()&#123; Point *pp = (Point *)&amp;p; pp-&gt;x = 3; // error! // Exception has occurred. Segmentation fault&#125; 未被const修饰的全局变量默认为extern，不需要extern显式声明即可以在其它文件中访问！而全局const常量需要显式声明extern，并且需要做初始化，才能在其它文件中访问！因为常量在定义后就不能被修改，所以定义时必须初始化。 虽然可以编译通过（骗过了编译器）。但上述全局const修饰的变量p会被编译器存放在ELF文件的.rodata分区（只读），程序默认不拥有写权限，故运行时不可更改。 接下来，控制变量p的const功能就交给操作系统中内存分页机制了。操作系统会将.rodata所在的内存页的权限标记为只读。每当程序访问内存时，CPU都会检查内存地址对应的权限。如果权限不符，那么CPU就会产生中断并调用操作系统所设置的中断处理例程。在这个例子中，当CPU发现程序想要写一块只读内存时，就会产生中断。而Linux设置的默认动作是终止程序，并打印 “Segmentation fault (core dumped)”。 修饰局部变量 这时只是编译器负责检查你有没有显式的通过p来修改const修饰的变量p的值。但是你可以通过其它技巧骗过编译器来修改。比如： 12345678// 局部void func()&#123; const Point p&#123;1, 2&#125;; p.x = 3; // error! Point *pp = (Point *)&amp;p; pp-&gt;x = 3; // correct!&#125; 编译器的实现为，函数内变量放在函数的栈帧里的，程序拥有对这个存储区自由读写的权限。 修饰类的成员变量 编译器的实现和前面说的修饰函数内局部变量一样。但类中的const成员变量必须通过初始化列表进行初始化。 12345678910111213struct Point&#123; const int x; int y; Point(int x_, int y_) : x(x_), y(y_) &#123;&#125;&#125;;void func()&#123; const Point p(1, 2); // p 对象中 x = 1, y = 2 int *pi = (int *)&amp;p; *pi = 3; // // p 对象中 x = 3, y = 2&#125; 通过指针竟然可以修改类对象内声明为const的对象。细思极恐,，这其实就是指针的被广为诟病的地方了。 修饰函数形参 value with const 12void func(const int val); // 传递过来的参数不可变void func(int *const p); // 指针本身不可变 编译器的实现跟前面讨论的修饰函数内局部变量一样。 reference or pointer with const 12void strcpy(char *dst, const char *src); // 参数指针所指内容为常量不可变void func(const A &amp;a) // 参数为引用, 为了增加效率同时防止修改 修饰函数返回类型 value with const 1const Point func1(); // 无意义, 因为参数返回本身就是赋值给其他的变量！ reference or pointer with const 12const Point* func2(); // 指针指向内容不可变const Point&amp; func2(); // 引用的内容不可变 const用于声明函数 修饰类的成员函数 被const修饰的类对象，只能访问类中const成员函数。 12345678910struct Point&#123; const int x; int y; Point(int x_, int y_) : x(x_), y(y_) &#123;&#125; int getX() const &#123; return x; &#125;&#125;; 编译器会将被const修饰的成员函数getX()转化为： 12345678910111213// 转化为下面这样// 前面的那个 const_ 才是 const 修饰起到的作用, 后面的本身就有int getX(const_ Point* const this)&#123; return this-&gt;x;&#125;// 这样的调用Point p(1, 2);p.getX();// 转化为下面这样getX(&amp;p); 也就是说，const修饰类成员函数时，修饰的只是传进来的this指针而已。 const char* str、char* str、char str[]、const char str[]的区别12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* 注意, 下面的讨论都是把此定义放在 全局 */// 编译器都会将常量 \"hello\" 存放在只读数据段// 而且这和前面是否使用 const 修饰没关系// 程序持有的只是一个指针变量而已// 所以, 通过指针修改这个串 \"hello\", 都会报错的const char* str = \"hello\";// 或char* str = \"hello\";// 但如果这样定义// 此时定义的是数组变量, 有 const 的话会放在只读数据段const char str[] = \"hello\";// 没有 const 的话就会放在可写段char str[] = \"hello\";/////////////////////////////////////////const char *s1 = \"hello\";char *s2 = \"world\";char s3[] = \"dfasd\";const char s4[] = \"asdfasdf\";void func()&#123; *s1 = 'e'; // error char *ps1 = (char *)s1; *ps1 = 'd'; // error *s2 = 'e'; // error *s3 = 'e'; // correct *s4 = 'r'; // error char *ps4 = (char *)s4; *ps4 = 'd'; // error&#125;/* 注意, 下面的讨论都是把此定义放在 局部 */// 和定义在全局相同// 编译器都会将常量 \"hello\" 存放在只读数据段// 而且这和前面是否使用 const 修饰没关系// 程序持有的只是一个指针变量而已// 所以, 通过指针修改这个串 \"hello\", 都会报错的const char* str = \"hello\";// 或char* str = \"hello\";// 但如果这样定义// 此时定义的是数组变量, 有 const 的话 只会放在函数的栈帧上// 编译器会负责检查, 不允许你显示修改 str 数组// 可以通过前面介绍的 trick 骗过编译器来修改const char str[] = \"hello\";// 没有 const 的话, 放在函数的栈帧上, 访问就随意啦char str[] = \"hello\";/////////////////////////////////////////void func()&#123; const char *s1 = \"hello\"; char *s2 = \"world\"; char s3[] = \"dfasd\"; const char s4[] = \"asdfasdf\"; *s1 = 'e'; // error char *ps1 = (char *)s1; *ps1 = 'd'; // error *s2 = 'e'; // error *s3 = 'e'; // correct *s4 = 'r'; // error char *ps4 = (char *)s4; *ps4 = 'd'; // correct&#125; 编译器是如何实现强制类型转换的关于强制类型转换的分类和使用参考《Effective C++》条款27。 进行强制类型转换后，内存空间里面原变量的内容是不会发生改变的，改变的是运算时产生的临时数据对象的类型，是你去读取这个内存空间时的解析方法。 从编译原理的角度去看，C++编译器会维护一份程序中所有变量的名称和其类型之间的一个映射表。通过变量名称去操作内存空间时，会查看这个映射表，获取变量所属的类型之后再决定操作的内存范围。当使用强制类型转换时，会首先改变这个临时数据对象的类型，再去操作内存。","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"重要知识点详细解读之智能指针","date":"2021-02-15T13:35:42.000Z","path":"DVejmy5owOXx5WKk/","text":"关于智能指针的demo，参见C++ primer 12.1。 什么是智能指针智能指针是使用RAII手法对裸指针进行的一个面向对象封装，即在构造函数中初始化资源地址，在析构函数中释放资源。智能指针保证当资源应当被释放的时候一定会释放它，这是利用了栈上的对象出作用域时自动析构这个特点。 为什么引入智能指针用以弥补裸指针的不足： ​ 1）使用裸指针分配内存后，没有对指针释放资源会导致内存泄漏； ​ 2）多个裸指针指向同一资源时，多次释放资源时，对空悬指针进行释放会导致不可预知的错误。 如何知道是否存在内存泄漏在不借助其他检测工具的情况下，可以通过观察，即程序长时间运行后内存占用率一直不断的缓慢的上升，而实际上在你的逻辑中并没有这么多的内存需求。 如何定位到内存泄漏点 review代码，找到new和delete关键字的位置，先看看内存的申请和释放是否是成对的来进行初步的判断； 对于函数中申请的临时空间，认真检查是否存在提前跳出函数的地方而导致没有释放内存。 智能指针有哪些智能指针分为不带引用计数的scoped_ptr和unique_ptr，带引用计数的shared_ptr和weak_ptr。 这些智能指针分别是如何实现的scoped_ptr私有化了拷贝构造函数和赋值操作运算符，资源的所有权无法进行转移，也无法在容器中使用，这种方式杜绝了浅拷贝的发生。 unique_ptr删除了拷贝构造函数和赋值函数，因此不支持普通的拷贝或赋值操作。但引入了移动构造函数和移动赋值运算符。所以它们保证了有唯一的智能指针持有此资源。unique_ptr还提供了reset重置资源，swap交换资源等函数，也经常会使用到。 shared_ptr称为强智能指针，它的资源引用计数器在内存的heap堆上（这保证了，每个智能指针的引用计数变量会动态的变化）。通常用于管理对象的生命周期。只要有一个指向对象的shared_ptr存在，该对象就不会被析构。 weak_ptr被称为弱智能指针，其对资源的引用不会引起资源的引用计数的变化，通常作为观察者，用于判断资源是否存在，并根据不同情况做出相应的操作。比如使用weak_ptr对资源进行弱引用，当调用weak_ptr的lock()方法时，若返回nullptr，则说明资源已经不存在，放弃对资源继续操作。否则，将返回一个shared_ptr对象，可以继续操作资源。另外，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。 当需要多个智能指针指向同一个资源时，使用带引用计数的智能指针。每增加一个智能指针指向同一资源，资源引用计数加1，反之减1。当引用计数为0时，由最后一个指向资源的智能指针将资源进行释放。 如何避免循环引用12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class B; // 前置声明类Bclass A&#123;public: A() &#123; cout &lt;&lt; \"A()\" &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A()\" &lt;&lt; endl; &#125; shared_ptr&lt;B&gt; _ptrb; // 指向B对象的智能指针&#125;;class B&#123;public: B() &#123; cout &lt;&lt; \"B()\" &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; \"~B()\" &lt;&lt; endl; &#125; shared_ptr&lt;A&gt; _ptra; // 指向A对象的智能指针&#125;;int main()&#123; shared_ptr&lt;A&gt; ptra(new A()); // ptra指向A对象，A的引用计数为1 shared_ptr&lt;B&gt; ptrb(new B()); // ptrb指向B对象，B的引用计数为1 ptra-&gt;_ptrb = ptrb; // A对象的成员变量_ptrb也指向B对象，B的引用计数为2 ptrb-&gt;_ptra = ptra; // B对象的成员变量_ptra也指向A对象，A的引用计数为2 cout &lt;&lt; ptra.use_count() &lt;&lt; endl; // 打印A的引用计数结果:2 cout &lt;&lt; ptrb.use_count() &lt;&lt; endl; // 打印B的引用计数结果:2 /* 出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和 B对象的引用计数从2减到1，达不到释放A和B的条件（释放的条件是 A和B的引用计数为0），因此造成两个new出来的A和B对象无法释放， 导致内存泄露，这个问题就是“强智能指针的交叉引用(循环引用)问题” */ return 0;&#125; 解决办法，这也是强弱智能指针的一个重要应用规则：定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class B; // 前置声明类 Bclass A&#123;public: A() &#123; cout &lt;&lt; \"A()\" &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A()\" &lt;&lt; endl; &#125; weak_ptr&lt;B&gt; _ptrb; // 指向 B 对象的弱智能指针。引用对象时，用弱智能指针&#125;;class B&#123;public: B() &#123; cout &lt;&lt; \"B()\" &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; \"~B()\" &lt;&lt; endl; &#125; weak_ptr&lt;A&gt; _ptra; // 指向 A 对象的弱智能指针。引用对象时，用弱智能指针&#125;;int main()&#123; // 定义对象时，用强智能指针 shared_ptr&lt;A&gt; ptra(new A()); // ptra 指向 A 对象，A 的引用计数为 1 shared_ptr&lt;B&gt; ptrb(new B()); // ptrb 指向B 对象，B 的引用计数为 1 // A 对象的成员变量 ptrb 也指向 B 对象，B 的引用计数为 1，因为是弱智能指针，引用计数没有改变 ptra-&gt;_ptrb = ptrb; // B 对象的成员变量 ptra 也指向 A 对象，A 的引用计数为 1，因为是弱智能指针，引用计数没有改变 ptrb-&gt;_ptra = ptra; cout &lt;&lt; ptra.use_count() &lt;&lt; endl; // 打印结果: 1 cout &lt;&lt; ptrb.use_count() &lt;&lt; endl; // 打印结果: 1 /* 出 main 函数作用域，ptra 和 ptrb 两个局部对象析构，分别给 A 对象和 B 对象的引用计数从 1 减到 0，达到释放 A 和 B 的条件，因此 new 出来的 A 和 B 对象 被析构掉，解决了“强智能指针的交叉引用(循环引用)问题” */ return 0;&#125; 什么情况下需要自定义deleter在管理的裸指针不是new出来的裸指针时需要自定义删除器，比如管理的指针为文件指针或由malloc获得的指针等。 enable_shared_from_this机制当class Widget被share_ptr管理，且在Widget的成员函数里需要把当前类对象的智能指针作为参数传给其他函数时，就需要传递一个指向自身的share_ptr。 而当使用shared_ptr管理同一资源，调用shared_ptr的构造函数和拷贝构造函数是不一样的（构造函数新创建一份堆上的引用计数资源，拷贝构造函数修改原来堆上的引用计数资源），它们虽然使得不同shared_ptr指向同一资源，但管理引用计数资源的方式却不一样。这就造成了不能直接传递shared_ptr&lt;Widget&gt;(this)。因为这样会造成2个非共享的share_ptr指向同一个对象，引用计数资源相互独立导致对象被析构2次。 12345678910111213141516171819202122#include &lt;memory&gt;#include &lt;iostream&gt; class Widget&#123;public: std::shared_ptr&lt;Widget&gt; getptr() &#123; return std::shared_ptr&lt;Widget&gt;(this); &#125; ~Widget() &#123; std::cout &lt;&lt; \"Widget::~Widget() called\" &lt;&lt; std::endl; &#125;&#125;; int main()&#123; // 错误的示例, 每个 shared_ptr 都认为自己是对象仅有的所有者 std::shared_ptr&lt;Widget&gt; p1(new Widget; std::shared_ptr&lt;Widget&gt; p2 = p1-&gt;getptr(); // 打印 p1 和 p2 的引用计数 std::cout &lt;&lt; \"p1.use_count() = \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; // 输出为 1 std::cout &lt;&lt; \"p2.use_count() = \" &lt;&lt; p2.use_count() &lt;&lt; std::endl; // 输出为 1&#125; // Widget 对象将会被删除两次 12345678910111213141516171819202122#include &lt;memory&gt;#include &lt;iostream&gt; struct Widget : public std::enable_shared_from_this&lt;Widget&gt; // 注意：继承&#123;public: std::shared_ptr&lt;Widget&gt; getptr() &#123; return shared_from_this(); &#125; ~Widget() &#123; std::cout &lt;&lt; \"Widget::~Widget() called\" &lt;&lt; std::endl; &#125;&#125;; int main()&#123; std::shared_ptr&lt;Widget&gt; p1(new Widget; std::shared_ptr&lt;Widget&gt; p2 = p1-&gt;getptr(); // 打印 p1 和 p2 的引用计数 std::cout &lt;&lt; \"p1.use_count() = \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; // 输出为 2 std::cout &lt;&lt; \"p2.use_count() = \" &lt;&lt; p2.use_count() &lt;&lt; std::endl; // 输出为 2&#125; // // Widget 对象只会被删除一次 实际使用场景：在异步调用中，存在一个保活机制，异步函数执行的时间点我们是无法确定的，然而异步函数可能会使用到异步调用之前就存在的变量。为了保证该变量在异步函数执期间一直有效，我们可以传递一个指向自身的share_ptr给异步函数，这样在异步函数执行期间share_ptr所管理的对象就不会析构，所使用的变量也会一直有效了（保活）。 enable_shared_from_this是如何实现的enable_shared_from_this类中包含一个作为观察者的成员变量，如下： 1234567891011121314151617181920212223template&lt;class T&gt;class enable_shared_from_this&#123;public: ... SetSharedPtr(shared_ptr&lt;T&gt;* sp) &#123; if(weak_this_.expired()) wp = sp; // 标准库中并没有把 sp 直接赋值给 wp，而是使用了 shared_ptr 的别名构造函数 &#125; __shared_ptr&lt;_Tp, _Lp&gt; shared_from_this() &#123; return __shared_ptr&lt;_Tp, _Lp&gt;(this-&gt;_M_weak_this); &#125; __shared_ptr&lt;const _Tp, _Lp&gt; shared_from_this() const &#123; return __shared_ptr&lt;const _Tp, _Lp&gt;(this-&gt;_M_weak_this); &#125;private: mutable weak_ptr&lt;_Tp&gt; _M_weak_this; // 使用 weak_ptr 的目的正是为了避免循环引用!&#125;; 当一个类继承了enable_shared_from_this类，就继承了_M_weak_this这个成员变量。 使用shared_ptr&lt;Widget&gt;(new Widget())第一次构造智能指针对象时，就会初始化一个作为观察者的弱智能指针_M_weak_this指向Widget对象资源。 12345678910111213141516171819class shared_ptr&lt;T&gt;&#123;public: explicit shared_ptr&lt;T&gt;(T* w) &#123; SetSharedPtr(this, w); &#125; void SetSharedPtr(shared_ptr&lt;T&gt;* sp, enable_shared_from_this&lt;T&gt;* w) &#123; w-&gt;SetSharedPtr(sp); &#125; // 此重载函数的作用是为了处理 Widget 并没有继承 enable_shared_from_this 的情况 void SetSharedPtr(...) &#123; // 什么也不做 &#125;&#125;; 通过shared_from_this()方法代替shared_ptr的普通构造函数来返回一个shared_ptr对象，从而避免产生额外的引用计数资源对象。在shared_from_this()函数中，是通过_M_weak_this来构造并返回一个shared_ptr对象的。 智能指针源码分析unique_ptr的声明包含两个模板参数，第一个参数_Tp显然就是原生指针的类型。第二个模板参数_Dp是一个deleter，默认值为default_delete&lt;_Tp&gt;。default_delete是一个针对delete operator的函数对象。 unique_ptr内部用tuple&lt;pointer, _Dp&gt; _M_t;变量保存数据，相当于原生指针和deleter对象组成的一个pair。 定义了构造函数和移动构造函数和移动赋值运算符，但是删除了拷贝构造函数和拷贝赋值运算符。 unqiue_ptr还定义了两个很重要的函数：reset(pointer)和release()。reset(pointer)的功能是用一个新指针替换原来的指针，而release()则是是放弃原生指针的所有权。 到目前为止，unique_ptr还不像个指针，因为还缺少两个方法：operator*和operator-&gt;。 下面是unique_ptr的源码，有删减，但大体上不变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169template &lt;typename _Tp&gt;struct default_delete&#123; /// Default constructor constexpr default_delete() noexcept = default; void operator()(_Tp *__ptr) const &#123; delete __ptr; &#125;&#125;;template &lt;typename _Tp, typename _Dp&gt;class __uniq_ptr_impl&#123; template &lt;typename _Up, typename _Ep, typename = void&gt; struct _Ptr &#123; using type = _Up *; &#125;; template &lt;typename _Up, typename _Ep&gt; struct _Ptr&lt;_Up, _Ep, __void_t&lt;typename remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt; &#123; using type = typename remove_reference&lt;_Ep&gt;::type::pointer; &#125;;public: using pointer = typename _Ptr&lt;_Tp, _Dp&gt;::type; __uniq_ptr_impl() = default; __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125; template &lt;typename _Del&gt; __uniq_ptr_impl(pointer __p, _Del &amp;&amp;__d) : _M_t(__p, std::forward&lt;_Del&gt;(__d)) &#123;&#125; pointer &amp;_M_ptr() &#123; return std::get&lt;0&gt;(_M_t); &#125; pointer _M_ptr() const &#123; return std::get&lt;0&gt;(_M_t); &#125; _Dp &amp;_M_deleter() &#123; return std::get&lt;1&gt;(_M_t); &#125; const _Dp &amp;_M_deleter() const &#123; return std::get&lt;1&gt;(_M_t); &#125;private: tuple&lt;pointer, _Dp&gt; _M_t;&#125;;template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt;class unique_ptr&#123; __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t;public: using pointer = typename __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer; using element_type = _Tp; using deleter_type = _Dp; // Constructors. /// Default constructor, creates a unique_ptr that owns nothing. template &lt;typename _Up = _Dp, typename = _DeleterConstraint&lt;_Up&gt;&gt; constexpr unique_ptr() noexcept : _M_t() &#123; &#125; template &lt;typename _Up = _Dp, typename = _DeleterConstraint&lt;_Up&gt;&gt; explicit unique_ptr(pointer __p) noexcept : _M_t(__p) &#123; &#125; unique_ptr(pointer __p, typename remove_reference&lt;deleter_type&gt;::type &amp;&amp;__d) noexcept : _M_t(std::move(__p), std::move(__d)) &#123; &#125; // Move constructors. /// Move constructor. unique_ptr(unique_ptr &amp;&amp;__u) noexcept : _M_t(__u.release(), std::forward&lt;deleter_type&gt;(__u.get_deleter())) &#123;&#125; /// Destructor, invokes the deleter if the stored pointer is not null. ~unique_ptr() noexcept &#123; auto &amp;__ptr = _M_t._M_ptr(); if (__ptr != nullptr) get_deleter()(__ptr); __ptr = pointer(); &#125; // Assignment. unique_ptr &amp;operator=(unique_ptr &amp;&amp;__u) noexcept &#123; reset(__u.release()); get_deleter() = std::forward&lt;deleter_type&gt;(__u.get_deleter()); return *this; &#125; /// Reset the %unique_ptr to empty, invoking the deleter if necessary. unique_ptr &amp;operator=(nullptr_t) noexcept &#123; reset(); return *this; &#125; // Observers. /// Dereference the stored pointer. typename add_lvalue_reference&lt;element_type&gt;::type operator*() const &#123; return *get(); &#125; /// Return the stored pointer. pointer operator-&gt;() const noexcept &#123; return get(); &#125; /// Return the stored pointer. pointer get() const noexcept &#123; return _M_t._M_ptr(); &#125; /// Return a reference to the stored deleter. deleter_type &amp;get_deleter() noexcept &#123; return _M_t._M_deleter(); &#125; /// Return a reference to the stored deleter. const deleter_type &amp;get_deleter() const noexcept &#123; return _M_t._M_deleter(); &#125; /// Return @c true if the stored pointer is not null. explicit operator bool() const noexcept &#123; return get() == pointer() ? false : true; &#125; /// Release ownership of any stored pointer. pointer release() noexcept &#123; pointer __p = get(); _M_t._M_ptr() = pointer(); return __p; &#125; void reset(pointer __p = pointer()) noexcept &#123; using std::swap; swap(_M_t._M_ptr(), __p); if (__p != pointer()) get_deleter()(__p); &#125; /// Exchange the pointer and deleter with another object. void swap(unique_ptr &amp;__u) noexcept &#123; using std::swap; swap(_M_t, __u._M_t); &#125; // Disable copy from lvalue. unique_ptr(const unique_ptr &amp;) = delete; unique_ptr &amp;operator=(const unique_ptr &amp;) = delete;&#125;; 下面是shared_ptr的类图。 如图，shared_ptr类几乎什么都没有做，它是继承了__shared_ptr，__shared_ptr内部有一个类型为__shared_count类型的成员，__shared_count内部有类型为_Sp_counted_base*的成员。 _Sp_counted_base才是整个shared_ptr功能的核心，通过_Sp_counted_base控制引用计数来管理指向的内存，由图可见_Sp_counted_base内部不持有指向内存的指针，这里__shared_count内部的_Sp_counted_base*成员其实指向的是一个继承自_Sp_counted_base的_Sp_counted_ptr类型的派生类对象，_Sp_counted_ptr类型内部持有指向内存的指针M_ptr，这样__shared_count内部就既可以控制引用计数，又可以在最后根据指向对象的指针释放托管内存。 注意的是：为什么_Sp_counted_ptr和__shared_ptr内部都有指向对象的指针。实际上它们可以是不同的类型（只要它们之间存在隐式转换），这是shared_ptr的一大功能： 无需虚析构。假设Bar是Foo的基类，但是Bar和Foo都没有虚析构。 12345678// _Sp_counted_ptr._M_ptr 和 __shared_ptr._M_ptr 的类型都是 Foo*shared_ptr&lt;Foo&gt; sp1(new Foo);// 可以赋值, __shared_ptr._M_ptr 自动向上转型 up-cast// _Sp_counted_ptr._M_ptr 类型不变shared_ptr&lt;Bar&gt; sp2 = sp1;sp1.reset(); // 这时 Foo 对象的引用计数降为 1 此后sp2仍然能安全地管理Foo对象的生命期，并安全完整地释放Foo，因为其_Sp_counted_ptr._M_ptr记住了Foo的实际类型。 shared_ptr&lt;void&gt;可以指向并安全地管理（析构或防止析构）任何对象。 12345678// _Sp_counted_ptr._M_ptr 和 __shared_ptr._M_ptr 的类型都是 Foo*shared_ptr&lt;Foo&gt; sp1(new Foo);// 可以赋值, __shared_ptr._M_ptr 中的 Foo* 类型向 void* 自动转型// _Sp_counted_ptr._M_ptr 类型不变shared_ptr&lt;void&gt; sp2 = sp1;sp1.reset(); // 这时 Foo 对象的引用计数降为 1 此后sp2仍然能安全地管理Foo对象的生命期，并安全完整地释放Foo，不会出现delete void*的情况，因为delete的是_Sp_counted_ptr._M_ptr而不是__shared_ptr._M_ptr。 多继承。假设Bar是Foo的多个基类之一，那么： 1234567shared_ptr&lt;Foo&gt; sp1(new Foo);// 这时 sp1._M_ptr 和 sp2._M_ptr 可能指向不同的地址// 因为 Bar subobject 在 Foo object 中的 offset 可能不为 0shared_ptr&lt;Bar&gt; sp2 = sp1;sp1.reset(); // 此时 Foo 对象的引用计数降为 1 但是sp2仍然能安全地管理Foo对象的生命期，并安全完整地释放Foo，因为delete的不是Bar*，而是原来的 Foo*。换句话说，sp1._M_ptr和sp2._M_ptr可能具有不同的值（当然它们的类型也不同）。 这里称_M_pi为管理对象，它内部的_M_ptr为托管对象，管理同一块托管对象的多个shared_ptr内部共用一个管理对象,，这里的多个shared_ptr可能是通过第一个shared_ptr拷贝或者移动而来，管理对象内部有两个成员变量_M_use_count和_M_weak_count。 _M_use_count表示托管对象的引用计数，控制托管对象什么时候析构和释放，当引用计数为0时调用托管对象的析构函数且释放内存。 _M_weak_count表示管理对象的引用计数，它的初始值比_M_use_count大1，管理对象也是一个内存指针，这块指针是初始化第一个shared_ptr时new出来的，到最后也需要delete，所以使用_M_weak_count来控制管理对象什么时候析构，当weak_ptr析构时时，管理对象的引用计数_M_weak_count就会减1，当_M_weak_count为0时，管理对象_M_pi就会析构且释放内存。 _M_use_count是如何加减的 Muse_count表示托管对象的引用计数，即当shared_ptr拷贝时会增加，当shared_ptr析构时会减少，看精简代码： 12345678910111213141516template &lt;typename _Yp&gt;__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r, element_type* __p) noexcept : _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws&#123;&#125;__shared_count(const __shared_count&amp; __r) noexcept : _M_pi(__r._M_pi)&#123; if (_M_pi != 0) _M_pi-&gt;_M_add_ref_copy();&#125;template &lt;&gt;inline void _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy()&#123; ++_M_use_count;&#125; shared_ptr拷贝时，内部__shared_count类型的_M_refcount会进行拷贝，__shared_count的拷贝构造函数会调用_M_add_ref_copy()方法，_M_add_ref_copy()方法中会将_M_use_count加1。 这里再看下shared_ptr的赋值构造函数： 1234567891011121314151617181920212223242526template &lt;typename _Yp&gt;_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt; operator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept&#123; this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(__r); return *this;&#125;template &lt;typename _Yp&gt;_Assignable&lt;_Yp&gt; operator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept&#123; _M_ptr = __r._M_ptr; _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw return *this;&#125;__shared_count&amp; operator=(const __shared_count&amp; __r) noexcept&#123; _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi; if (__tmp != _M_pi) &#123; if (__tmp != 0) __tmp-&gt;_M_add_ref_copy(); if (_M_pi != 0) _M_pi-&gt;_M_release(); _M_pi = __tmp; &#125; return *this;&#125; 从代码中可见，shared_ptr的operator=会调用__shared_ptr的operator=进而调用__shared_count的operator=，从这里可以看出管理同一块托管对象的shared_ptr共用的同一个管理对象的指针。 _M_use_count是如何减为0的，可以猜想到shared_ptr析构时会调用__shared_count的析构函数，看精简代码： 12345678910111213141516~__shared_count() noexcept&#123; if (_M_pi != nullptr) _M_pi-&gt;_M_release();&#125;template &lt;&gt;inline void _Sp_counted_base&lt;_S_single&gt;::_M_release() noexcept&#123; if (--_M_use_count == 0) &#123; _M_dispose(); if (--_M_weak_count == 0) _M_destroy(); &#125;&#125;virtual void _M_dispose() noexcept &#123; delete _M_ptr; &#125; 在shared_ptr生命周期结束析构时会将引用计数减1，如果引用引用计数为0，会调用_M_dispose()函数进而释放托管对象内存。 _M_weak_count是如何加减的 上面的代码中可以看见_M_weak_count为0时，会调用_M_destroy()函数，这里看看_M_weak_count是如何加减的。管理对象初始化时_M_weak_count的初始值为1 1_Sp_counted_base() noexcept : _M_use_count(1), _M_weak_count(1) &#123;&#125; 注意当shared_ptr拷贝或者移动时_M_weak_count是不会增加的，它表示的是管理对象的计数，只有当__M_use_count为0时_M_weak_count才会减1，除此之外_M_weak_count的数值是由weak_ptr控制的。 由上面类图可以看见weak_ptr内部其实和shared_ptr内部持有的是同一个管理对象指针，即_Sp_counted_base的指针，当weak_ptr拷贝析构时候，_Sp_counted_base内部的_M_weak_count会相应加减。 1234567891011121314151617181920212223__weak_count(const __weak_count&amp; __r) noexcept : _M_pi(__r._M_pi)&#123; if (_M_pi != nullptr) _M_pi-&gt;_M_weak_add_ref();&#125;template &lt;&gt;inline void _Sp_counted_base&lt;_S_single&gt;::_M_weak_add_ref() noexcept&#123; ++_M_weak_count;&#125;~__weak_count() noexcept&#123; if (_M_pi != nullptr) _M_pi-&gt;_M_weak_release();&#125;template &lt;&gt;inline void _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() noexcept&#123; if (--_M_weak_count == 0) _M_destroy();&#125;virtual void _M_destroy() noexcept &#123; delete this; &#125; 从代码中可以看出，weak_ptr拷贝时_M_weak_count加1，析构时_M_weak_count减1，当_M_weak_count为0时，表示不再需要管理对象来控制托管对象，调用_M_destroy()的delete this来释放管理对象内存。 weak_ptr的expired()和lock()做了什么 1234bool expired() const noexcept&#123; return _M_refcount._M_get_use_count() == 0;&#125; weak_ptr的expired()函数只是看了托管对象的引用计数是否为0，为0返回true。 12345678910__shared_ptr&lt;_Tp, _Lp&gt; lock() const noexcept&#123; return __shared_ptr&lt;element_type, _Lp&gt;(*this, std::nothrow);&#125;__shared_ptr(const __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, std::nothrow_t) : _M_refcount(__r._M_refcount, std::nothrow)&#123; _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;&#125; weak_ptr的lock()函数是打算返回一个shared_ptr对象来延长托管对象的生命周期，这里返回后需要判断返回值是否为nullptr。 shared_from_this()是如何实现的 精简代码如下： 1234567891011121314class enable_shared_from_this&#123; __shared_ptr&lt;_Tp, _Lp&gt; shared_from_this() &#123; return __shared_ptr&lt;_Tp, _Lp&gt;(this-&gt;_M_weak_this); &#125; __shared_ptr&lt;const _Tp, _Lp&gt; shared_from_this() const &#123; return __shared_ptr&lt;const _Tp, _Lp&gt;(this-&gt;_M_weak_this); &#125; mutable weak_ptr&lt;_Tp&gt; _M_weak_this;&#125;; 使用shared_from_this()的类需要继承enable_shared_from_this类，enable_shared_from_this类中持有一个类型为weak_ptr的成员_M_weak_this，调用shared_from_this()就是将内部持有的weak_ptr转成了shared_ptr。 为什么建议使用make_shared()函数我们已经看到了，shared_ptr内部维护了两个指针，如果你直接调用构造函数，就想这样： 12class Foo;auto sp = shared_ptr&lt;Widget&gt;(new Foo()); 这里实际分配了两次内存，第一次是调用new Foo()的时候，第二次则是在shared_ptr构造函数的内部构造_Sp_counted_base的时候。分配内存是很昂贵的操作，所以标准库提供了make_shared()函数，让你一次分配全部所需的内存： 12345678template&lt;typename _Tp, _Lock_policy _Lp, typename... _Args&gt;inline __shared_ptr&lt;_Tp, _Lp&gt;__make_shared(_Args&amp;&amp;... __args)&#123; typedef typename std::remove_const&lt;_Tp&gt;::type _Tp_nc; return std::__allocate_shared&lt;_Tp, _Lp&gt; (std::allocator&lt;_Tp_nc&gt;(), std::forward&lt;_Args&gt;(__args)...);&#125; 现在用make_shared()的话，可以一次分配一块足够大的内存，供Foo和_Sp_counted_base对象容身。 智能指针的线程安全性分析 同一个的shared_ptr对象可以被多个线程同时读取（只读） 对同一个对象的并发读，显然是线程安全的。 不同的shared_ptr对象可以被多个线程同时读写 如果这不同的shared_ptr对象管理的是不同的对象资源，显然并发读写是线程安全的。 若它们指向的是同一个对象，这需要它们共同维护一份在堆上的引用计数资源。而shared_ptr对象对于这份引用计数资源的读写使用了原子性操作，因此，也是线程安全的。 容易出现问题的是，从shared_ptr构造weak_ptr或者从weak_ptr构造shared_ptr的情况。 从shared_ptr构造weak_ptr 由于weak_ptr的构造过程中并不涉及引用计数资源的改变（实际上不改变的是shared_ptr对象计数变量_M_use_count_，只是改变了weak_ptr对象计数变量_M_weak_count），和前面的分析一样，使用了原子操作，也是线程安全的。 从weak_ptr构造shared_ptr 而这一过程，会改变引用计数资源（增加shared_ptr对象计数变量_M_use_count），但是实际上也实现了线程安全的修改。可以去参考源码的实现。 同一个shared_ptr对象不可以被多个线程同时读写（有写） shared_ptr&lt;Foo&gt;包含两个成员，一个是指向Foo的指针_M_ptr，另一个是_Sp_counted_base*指针，指向堆上的_Sp_counted_base对象。因为这两个数据成员读写操作不是原子化，所以使用多个线程读写同一个shared_ptr对象需要加锁，也就是说不是线程安全的。 自己动手实现一个基本的shared_ptr123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309#include &lt;iostream&gt;#include &lt;functional&gt;template &lt;class T&gt;class Deleter&#123;public: using DefaultFunc = std::function&lt;void(T *)&gt;; Deleter() : func_(std::bind(&amp;Deleter::defaultFunc, this, std::placeholders::_1)) &#123; std::cout &lt;&lt; \"Deleter::Deleter()\" &lt;&lt; std::endl; &#125; template &lt;class D&gt; Deleter(D func) : func_(func) &#123; std::cout &lt;&lt; \"Deleter::Deleter(D func)\" &lt;&lt; std::endl; &#125; void operator()(T *p) &#123; func_(p); &#125;private: DefaultFunc func_; void defaultFunc(T *p) &#123; std::cout &lt;&lt; \"Deleter::defaultFunc\" &lt;&lt; std::endl; delete p; &#125;&#125;;template &lt;class T&gt;class Ref_count_base&#123;private: T *ptr_; int count_; Deleter&lt;T&gt; deleter_;public: Ref_count_base(T *p) : ptr_(p), count_(1) &#123; std::cout &lt;&lt; \"Ref_count_base::Ref_count_base(T *p)\" &lt;&lt; std::endl; &#125; template &lt;class D&gt; Ref_count_base(T *p, D deleter) : ptr_(p), count_(1), deleter_(deleter) &#123; std::cout &lt;&lt; \"Ref_count_base::Ref_count_base(T *p, D deleter)\" &lt;&lt; std::endl; &#125; ~Ref_count_base() &#123; std::cout &lt;&lt; \"Ref_count_base::~Ref_count_base()\" &lt;&lt; std::endl; deleter_(ptr_); &#125; int increase() &#123; return count_++; &#125; int reduce() &#123; return --count_; &#125; int getCount() &#123; return count_; &#125;&#125;;template &lt;class T&gt;class Shared_ptr&#123;private: T *ptr_; Ref_count_base&lt;T&gt; *ref_count_;public: Shared_ptr() : ptr_(nullptr), ref_count_(nullptr) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr()\" &lt;&lt; std::endl; &#125; explicit Shared_ptr(std::nullptr_t) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr(std::nullptr_t)\" &lt;&lt; std::endl; Shared_ptr&lt;T&gt; temp; swap(temp); &#125; explicit Shared_ptr(T *p) : ptr_(p), ref_count_(new Ref_count_base&lt;T&gt;(p)) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr(T *p)\" &lt;&lt; std::endl; &#125; template &lt;class D&gt; explicit Shared_ptr(T *p, D deleter) : ptr_(p), ref_count_(new Ref_count_base&lt;T&gt;(p, deleter)) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr(T *p, D deleter)\" &lt;&lt; std::endl; &#125; ~Shared_ptr() &#123; std::cout &lt;&lt; \"Shared_ptr::~Shared_ptr()\" &lt;&lt; std::endl; if (ref_count_ &amp;&amp; ref_count_-&gt;reduce() == 0) delete ref_count_; &#125; Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp) : ptr_(sp.ptr_), ref_count_(sp.ref_count_) &#123; std::cout &lt;&lt; \"Shared_ptr::Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp)\" &lt;&lt; std::endl; if (ref_count_) ref_count_-&gt;increase(); &#125; Shared_ptr &amp;operator=(const Shared_ptr&lt;T&gt; &amp;sp) &#123; std::cout &lt;&lt; \"Shared_ptr::operator=(const Shared_ptr&lt;T&gt; &amp;sp)\" &lt;&lt; std::endl; Shared_ptr&lt;T&gt; temp(sp); swap(temp); return *this; &#125; Shared_ptr &amp;operator=(std::nullptr_t) &#123; std::cout &lt;&lt; \"Shared_ptr::operator=(std::nullptr_t)\" &lt;&lt; std::endl; Shared_ptr&lt;T&gt; temp; swap(temp); return *this; &#125; T &amp;operator*() &#123; if (ptr_) return *ptr_; &#125; T *operator-&gt;() &#123; if (ptr_) return ptr_; &#125; T &amp;operator[](ptrdiff_t i) &#123; return ptr_[i]; &#125; bool operator==(Shared_ptr&lt;T&gt; &amp;rhs) const &#123; return ptr_ == rhs.ptr_; &#125; operator bool() const &#123; return ptr_ != nullptr; &#125; T *get() const &#123; return ptr_; &#125; int use_count() const &#123; if (ref_count_) return ref_count_-&gt;getCount(); return 0; &#125; void swap(Shared_ptr&lt;T&gt; &amp;sp) &#123; std::cout &lt;&lt; \"Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)\" &lt;&lt; std::endl; using std::swap; swap(ptr_, sp.ptr_); swap(ref_count_, sp.ref_count_); &#125;&#125;;template &lt;class T&gt;void swap(Shared_ptr&lt;T&gt; &amp;lhs, Shared_ptr&lt;T&gt; &amp;rhs)&#123; lhs.swap(rhs);&#125;/* 以下是测试代码 *//* 以下是测试代码 *//* 以下是测试代码 */class Point&#123;public: explicit Point(int i = 0) : val(i) &#123; std::cout &lt;&lt; \"Point(int i = 0)\" &lt;&lt; std::endl; &#125; ~Point() &#123; std::cout &lt;&lt; \"~Point()\" &lt;&lt; std::endl; &#125; Point &amp;operator=(int i) &#123; std::cout &lt;&lt; \"Point::operator=(int i)\" &lt;&lt; std::endl; val = i; return *this; &#125; int getVal() const &#123; return val; &#125;private: int val;&#125;;class myDeleter1&#123;public: void operator()(Point *p) &#123; delete[] p; &#125;&#125;;void myDeleter2(Point *p)&#123; std::cout &lt;&lt; \"myDeleter2(Point *p)\" &lt;&lt; std::endl; delete[] p;&#125;auto myDeleter3 = [](Point *p) &#123; delete[] p; &#125;;int main()&#123; Shared_ptr&lt;Point&gt; p1(new Point[2], myDeleter3); std::cout &lt;&lt; p1[0].getVal() &lt;&lt; std::endl; p1[0] = 10; std::cout &lt;&lt; p1[0].getVal() &lt;&lt; std::endl; std::cout &lt;&lt; \"p1.use_count: \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; Shared_ptr&lt;Point&gt; p2 = p1; Shared_ptr&lt;Point&gt; p3; p3 = p2; std::cout &lt;&lt; \"p1.use_count: \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"p2.use_count: \" &lt;&lt; p2.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"p3.use_count: \" &lt;&lt; p3.use_count() &lt;&lt; std::endl; if (p1 == p2) std::cout &lt;&lt; \"p1 == p2\" &lt;&lt; std::endl; else std::cout &lt;&lt; \"p1 != p2\" &lt;&lt; std::endl; if (p1) std::cout &lt;&lt; \"p1 为真\" &lt;&lt; std::endl; p1 = nullptr; if (!p1) std::cout &lt;&lt; \"p1 为假\" &lt;&lt; std::endl; std::cout &lt;&lt; \"p1.use_count: \" &lt;&lt; p1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"p2.use_count: \" &lt;&lt; p2.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"p3.use_count: \" &lt;&lt; p3.use_count() &lt;&lt; std::endl; return 0;&#125;// 运行结果为Point::Point(int i = 0)Point::Point(int i = 0)Deleter::Deleter(D func)Ref_count_base::Ref_count_base(T *p, D deleter)Shared_ptr::Shared_ptr(T *p, D deleter)0Point::operator=(int i)10p1.use_count: 1Shared_ptr::Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::Shared_ptr()Shared_ptr::operator=(const Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::Shared_ptr(const Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::~Shared_ptr()p1.use_count: 3p2.use_count: 3p3.use_count: 3p1 == p2p1 为真Shared_ptr::operator=(std::nullptr_t)Shared_ptr::Shared_ptr()Shared_ptr::swap(Shared_ptr&lt;T&gt; &amp;sp)Shared_ptr::~Shared_ptr()p1 为假p1.use_count: 0p2.use_count: 2p3.use_count: 2Shared_ptr::~Shared_ptr()Shared_ptr::~Shared_ptr()Ref_count_base::~Ref_count_base()Point::~Point()Point::~Point()Shared_ptr::~Shared_ptr() 智能指针使用注意事项 尽量用make_shared/make_unique std::shared_ptr在实现的时候使用的ref count技术，因此内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行std::shared_ptr&lt;Widget&gt; p2(new Widget)的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而std::make_shared&lt;Widget&gt;()则是只执行一次内存申请，将数据和控制块的申请放到一起。 不要使用相同的内置指针来初始化（或者reset）多个智能指针 不要delete get()返回的指针 不要用get()初始化或reset另一个智能指针 智能指针管理的资源它只会默认删除new分配的内存，如果不是new分配的则要传递给其一个删除器 以下代码试图将malloc产生的动态内存交给shared_ptr管理，显然是有问题的，所以我们需要自定义删除器传递给shared_ptr。 12345678910// 错误的&#123; int* pi = (int*)malloc(4 * sizeof(int)); shared_ptr&lt;int&gt; sp(pi);&#125;// 正确的&#123; int* pi = (int*)malloc(4 * sizeof(int)); shared_ptr&lt;int&gt; sp(pi， [](int* p)&#123; free(p); &#125;);&#125; 不要把一个原生指针给多个shared_ptr或者多个unique_ptr管理 在使用原生指针对智能指针初始化的时候，智能指针对象都视原生指针为自己管理的资源。换句话意思就说：初始化多个智能指针之后，这些智能指针都担负起释放内存的作用。那么就会导致该原生指针会被释放多次！！ 1234// p1, p2 析构的时候都会释放 ptr, 同一内存被释放多次!int* ptr = new int;shared_ptr&lt;int&gt; p1(ptr);shared_ptr&lt;int&gt; p2(ptr);","tags":[{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"智能指针","slug":"智能指针","permalink":"https://yuanlehome.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"}]},{"title":"重要知识点详细解读之排序算法实现及效率分析","date":"2021-02-13T13:35:42.000Z","path":"cuQpjpPOQ0qnpSE2/","text":"快速排序 归并排序 计数排序 堆排序 排序算法实现及效率分析 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 洗牌算法void shuffle(vector&lt;int&gt; &amp;nums)&#123; int n = nums.size(); for (int i = 0 ; i &lt; n; i++) &#123; int j = rand() % ((n - 1) - i + 1) + i; // 返回 [i, n - 1] 内的随机数 swap(nums[i], nums[j]); &#125;&#125;/* 左闭右闭区间, 以首元素作为轴点 */// 版本一, 数据结构视频 9.1.5 节// int partition(std::vector&lt;int&gt; &amp;nums, int lo, int hi)// &#123;// // 随机置乱数组// shuffle(nums.begin(), nums.end(), default_random_engine(time(nullptr)));// int pivot = nums[lo];// while (lo &lt; hi)// &#123;// while (lo &lt; hi &amp;&amp; (pivot &lt;= nums[hi])) hi--;// nums[lo] = nums[hi]; // while (lo &lt; hi &amp;&amp; (nums[lo] &lt;= pivot)) lo++;// nums[hi] = nums[lo];// &#125;// nums[lo] = pivot;// return lo;// &#125;// 版本二, 算法 4 书籍int partition(std::vector&lt;int&gt; &amp;nums, int lo, int hi)&#123; // 随机置乱数组 shuffle(nums.begin(), nums.end(), default_random_engine(time(nullptr))); int i = lo; int j = hi + 1; while (1) &#123; while (nums[++i] &lt; nums[lo]) if (i == hi) break; while (nums[lo] &lt; nums[--j]) if (j == lo) break; if (j &lt;= i) break; std::swap(nums[i], nums[j]); &#125; std::swap(nums[lo], nums[j]); return j;&#125;// 版本三, 数据结构视频 9.3.4 节int partition(std::vector&lt;int&gt; &amp;nums, int lo, int hi)&#123; // 随机置乱数组 shuffle(nums.begin(), nums.end(), default_random_engine(time(nullptr))); int i = lo; int j = lo; while (++j &lt;= hi) if (nums[j] &lt; nums[lo]) std::swap(nums[++i], nums[j]); std::swap(nums[lo], nums[i]); return i;&#125;// 左闭右闭区间void quickSort(std::vector&lt;int&gt; &amp;nums, int lo, int hi)&#123; if (lo &gt;= hi) return; int pivot = partition(nums, lo, hi); quickSort(nums, lo, pivot - 1); quickSort(nums, pivot + 1, hi);&#125;void quickSort(std::vector&lt;int&gt; &amp;nums)&#123; quickSort(nums, 0, nums.size() - 1);&#125; 归并排序（Top-down Approach）12345678910111213141516171819202122232425262728293031323334353637383940414243// 注意以下的 vector 参数传的都是引用// 左闭右闭区间// [lo, mi] 和 [mi + 1, hi] 分别是有序的void merge(vector&lt;int&gt; &amp;nums, int lo, int mi, int hi)&#123; // 辅助空间, 存储 [mi + 1, hi] 元素 vector&lt;int&gt; helper(nums.begin() + mi + 1, nums.begin() + hi + 1); // 对两个数组中的元素, 依次从后向前比较 // 从后向前放置元素, 先放较大者 int i = mi; int j = helper.size() - 1; int k = hi; // 注意 i 的终止条件 while (i &gt;= lo &amp;&amp; j &gt;= 0) // 注意, 这里如果是 &gt;= 就不稳定了 if (nums[i] &gt; helper[j]) nums[k--] = nums[i--]; else nums[k--] = helper[j--]; while (j &gt;= 0) nums[k--] = helper[j--];&#125;// 左闭右闭区间void mergeSort(vector&lt;int&gt; &amp;nums, int lo, int hi)&#123; // 单元素自动有序 if (hi - lo &lt; 1) return; int mi = lo + (hi - lo) / 2; mergeSort(nums, lo, mi); mergeSort(nums, mi + 1, hi); merge(nums, lo, mi, hi);&#125;// 左闭右闭区间void mergeSort(vector&lt;int&gt; &amp;nums)&#123; // 排序 [0, nums.size()) 之间的元素 mergeSort(nums, 0, nums.size() - 1);&#125; 归并排序（Bottom-up Approach）12345678910111213141516171819202122232425262728293031323334353637// 左闭右闭区间// [lo, mi] 和 [mi + 1, hi] 分别是有序的void merge(vector&lt;int&gt; &amp;nums, int lo, int mi, int hi)&#123; // 辅助空间, 存储 [mi + 1, hi] 元素 vector&lt;int&gt; helper(nums.begin() + mi + 1, nums.begin() + hi + 1); // 对两个数组中的元素, 依次从后向前比较 // 从后向前放置元素, 先放较大者 int i = mi; int j = helper.size() - 1; int k = hi; // 注意 i 的终止条件 while (i &gt;= lo &amp;&amp; j &gt;= 0) if (nums[i] &gt; helper[j]) nums[k--] = nums[i--]; else nums[k--] = helper[j--]; while (j &gt;= 0) nums[k--] = helper[j--];&#125;void mergeSort(vector&lt;int&gt;&amp; nums)&#123; int sz = nums.size(); // 中间节点相对于起点的位置是 1 个 step // 终点相对于起点是 2 个 step // step 从 1 开始直到等于数组的长度 sz for(int step = 1; step &lt;= sz; step *= 2) // 注意, 这里 lo 从 0 开始直到等于 sz - 1 for(int lo = 0; lo &lt; sz; lo += 2 * step) // 因为 merge 函数实现的原因, 都是闭区间, 而且 [lo, mi] 和 [mi + 1, hi] 分别是有序的 // 所以这里求出的 mi 和 hi 都需要减 1 merge(nums, lo, min(lo + step - 1, sz - 1), min(lo + 2 * step - 1, sz - 1)); return nums;&#125; 计数排序 计数排序要求待排序的n个元素的大小在[0, k]之间，并且k与n在一个数量级上，即k = O(n)，此时使用计数排序可以把时间复杂度降到O(n)上； 计数排序不是基于比较的排序算法，它基于计数策略； 写计数排序算法时，应该把它写成稳定排序的； 计数排序还是原址排序，但需要借助额外的内存空间； 123456789101112131415161718192021222324252627282930313233// 找出待排序的数组中最大的元素 maxVal 和最小元素 minVal// 统计数组中每个值为 val 的元素出现的次数, 存入数组 count 的第 val - minVal 项// 对所有的计数累加, 从 count 中的第一个元素开始, 每一项和前一项相加// 反向填充目标数组: 将每个元素 val 放在新数组的第 count(val - minVal) 项// 每放一个元素就将 count(val - minVal) 减去 1void CountSort(vector&lt;int&gt; &amp;nums)&#123; int minVal = *min_element(nums.begin(), nums.end()); int maxVal = *max_element(nums.begin(), nums.end()); int valRange = maxVal - minVal; // 注意: 这个数组的大小为 valRange + 1, 用于统计 [0, valRange]范围内的元素 vector&lt;int&gt; count(valRange + 1, 0); // 统计待排序数组中每一个元素的个数 for (auto x : nums) count[x - minVal]++; // 此处计算待排序数组中小于等于第i个元素的个数 for (int i = 1; i &lt;= valRange; ++i) count[i] += count[i - 1]; // 把待排序的数组放到输出数组中, 为了保持排序的稳定性, 从后向前添加元素 vector&lt;int&gt; backup(nums); for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; int index = count[backup[i] - minVal] - 1; nums[index] = backup[i]; // 因为可能有重复的元素, 所以要减 1, 为下一个重复的元素计算正确的下标 count[backup[i] - minVal]--; &#125;&#125; 堆排序秩为i的元素，其父节点若存在，其秩必为(i - 1) / 2；其左孩子若存在，其秩必为2 * i + 1；其右孩子若存在，其秩必为左孩子秩加1。 下滤：将首元素依次和其孩子中较大者交换。上滤：将末元素依次和其父亲交换。时间复杂度均为O(logn)。 批量建堆：可以是所有的内部节点，自右往左依次下滤（复杂度正比于所有下滤节点的高度），或者是末元素依次上滤（复杂度是正比于所有上滤节点的深度），相比之下，前者的时间复杂度为O(n)，后者时间复杂度为O(nlogn)。第一个内部节点其实就是末元素的父亲，之后的内部节点依次递减即可。 堆排序：先执行批量建堆操作，时间复杂度为O(n)，然后进行n次取最大值操作，时间复杂度为O(nlogn)。具体实现可以是建完堆后，反复进行将首元素和未排序的末元素交换，然后对首元素进行下滤的操作。总体时间复杂度为O(n) + O(nlogn) = O(nlogn)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define P(i) ((i - 1) / 2)#define LC(i) ((2 * i) + 1)#define RC(i) (LC(i) + 1)// 下滤操作, 复杂度正比于完全二叉树的高度为 log(n)// 参数 len 代表 [有效堆] 数组的长度, 可用于验证待下滤元素 i 的左右孩子节点的合法性void downFilter(vector&lt;int&gt; &amp;nums, int i, int len)&#123; int val = nums[i]; // 先保存待下滤的值, i 就可代表洞号 int rc = RC(i); // 待下滤元素的右孩子 // 如果右孩子存在 while (rc &lt; len) &#123; // 如果右子节点的值小于左子节点 if (nums[rc] &lt;= nums[rc - 1]) rc--; // 此时, rc 指向孩子节点中较大的那一个 // 如果待下滤的值比孩子中较大的还大, 就不需要下滤了 if (nums[rc] &lt;= val) &#123; nums[i] = val; return; &#125; nums[i] = nums[rc]; i = rc; // 产生新的洞号 rc = RC(i); // 获得新洞号的右孩子 &#125; // 右孩子不存在, 但如果左孩子存在且其值大于待下滤的值 if (rc - 1 &lt; len &amp;&amp; nums[rc - 1] &gt; val) &#123; nums[i] = nums[rc - 1]; i = rc - 1; &#125; // 如果左右孩子都不存在了 nums[i] = val;&#125;void heapSort(vector&lt;int&gt; &amp;nums)&#123; int sz = nums.size(); int i = P(sz - 1); // 获取末元素的父亲, 也就是最后一个内部节点 // 建堆操作, 复杂度为 O(n) while (i &gt;= 0) downFilter(nums, i--, sz); // 从最后一个内部节点自后向前 依次下滤 // 外层循环 n 加内层的 log(n) 下滤, 因此堆排序复杂度为 nlog(n) // 此时最大元素是首元素 for (int i = sz - 1; i &gt; 0; i--) &#123; std::swap(nums[0], nums[i]); // 首尾交换, 末元素就位 downFilter(nums, 0, i); // 将新首元素下滤 // 依次缩短未排序数组的长度 &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"重要知识点详细解读之右值与移动语义","date":"2021-02-10T13:35:42.000Z","path":"63ixVU2ANYIUKUrm/","text":"解释右值引用和左值引用的区别 移动构造函数和移动赋值运算符 理解std::move和std::forward 解释右值引用和左值引用的区别所谓右值引用就是必须绑定到右值的引用，通过&amp;&amp;获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。左值引用，不能绑定到要转换的表达式、字面常量或返回右值的表达式。而右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。 返回左值的表达式包括返回左值引用的函数及赋值、下标、解引用和前置递增/递减运算符，返回右值的表达式包括返回非引用类型的函数及算术、关系、位和后置递增/递减运算符。可以看到，左值的特点是有持久的状态，而右值则是短暂的。 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。 函数参数和其它任何变量一样，都是左值表达式。 移动构造函数和移动赋值运算符参见C++ primer 13.6。 与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcept。 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。 移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。 类似拷贝构造函数和拷贝赋值运算符，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。如果有类成员是const的或是引用，则类的移动赋值运算符被定义为删除的。 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数：移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝（即，通过拷贝构造函数来“移动”）。 拷贝并交换赋值运算符和移动操作HasPtr类定义了一个拷贝并交换赋值运算符，如果为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符： 12345678910111213141516171819class HasPtr&#123;public: // 添加的移动构造函数 HasPtr(HasPtr &amp;&amp;p) noexcept : ps(p.ps), i(p.i) &#123; p.ps = 0; &#125; // 赋值运算符既是移动赋值运算符, 也是拷贝赋值运算符 HasPtr&amp; operator=(HasPtr&amp; rhs) &#123; HasPtr temp(rhs); // copy and swap(*this, temp); // swap return *this; &#125; // 其他成员的定义 ...&#125;; 在这个版本中，我们为类添加了一个移动构造函数，它接管了给定实参的值。构造函数体将给定的HasPtr的指针置为0，从而确保销毁移后源对象是安全的。此函数不会抛出异常，因此我们将其标记为noexcept。现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。假定hp和hp2都是HasPtr对象： 12hp = hp2; // hp2 是一个左值; hp2 通过拷贝构造函数来拷贝hp = std::move(hp2); // 移动构造函数移动 hp2 在第一个赋值中，右侧运算对象是一个左值，因此移动构造函数是不可行的。rhs将使用拷贝构造函数来初始化。拷贝构造函数将分配一个新string，并拷贝hp2指向的string。在第二个赋值中，我们调用std::move将一个右值引用绑定到hp2上。在此情况下，拷贝构造函数和移动构造函数都是可行的。但是，由于实参是一个右值引用，移动构造函数是精确匹配的。移动构造函数从hp2拷贝指针，而不会分配任何内存。不管使用的是拷贝构造函数还是移动构造函数，赋值运算符的函数体都swap两个运算对象的状态。交换HasPtr会交换两个对象的指针成员。在swap之后，rhs中的指针将指向原来左侧运算对象所拥有的string。当rhs离开其作用域时，这个string将被销毁。 理解std::move和std::forward参见C++ primer 16.2.6 &amp; 16.2.7。 调用std::move就意味着承诺：除了对移后源赋值或销毁外，我们将不再使用它。 标准库中std::move的实现123456template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)&#123; // 从一个左值 static_cast 到一个右值引用是允许的 return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);&#125; 其中，remove_reference模板有一个模板类型参数和一个名为type的（public）类型成员。如果我们用一个引用类型实例化remove_reference，则type将表示被引用的类型。例如，如果我们实例化remove_reference&lt;string&amp;&gt;，则type成员将是string。更一般的，给定一个迭代器beg： 1remove_reference&lt;decltype(*beg)&gt;::type 将获得beg引用的元素的类型：decltype(*beg)返回元素类型的引用类型。remove_reference::type脱去引用，剩下元素类型本身。 std::move是如何工作的123string s1(\"hi!\"), s2;s2 = std::move(string(\"bye!\")); // 正确: 从一个右值移动数据s2 = std::move(s1); // 正确: 但在赋值之后, s1的值是不确定的 在第一个赋值中，传递给move的实参是string的构造函数的右值结果——string(&quot;bye!&quot;)。因此，在std::move(string(&quot;bye!&quot;))中： 推断出的T的类型为string； 因此，remove_reference用string进行实例化； remove_reference&lt;string&gt;的type成员是string； move的返回类型是string&amp;&amp;； move的函数参数t的类型为string&amp;&amp;。 因此，这个调用实例化move&lt;string&gt;，即函数 1string&amp;&amp; move(string&amp;&amp; t) 函数体返回static_cast&lt;string&amp;&amp;&gt;(t)。t的类型已经是string&amp;&amp;，于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用。 现在考虑第二个赋值，它调用了std::move。在此调用中，传递给move的实参是一个左值。这样： 推断出的T的类型为string&amp;； 因此，remove_reference用string&amp;进行实例化； remove_reference&lt;string&amp;&gt;的type成员是string； move的返回类型仍是string&amp;&amp;； move的函数参数t实例化为string&amp;&amp; &amp;，会折叠为string&amp;。 因此，这个调用实例化move&lt;string&amp;&gt;，即 1string&amp;&amp; move(string&amp; t) 这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回static_cast&lt;string&amp;&amp;&gt;(t)。在此情况下，t的类型为string&amp;，static_cast将其转换为string&amp;&amp;。 标准库中std::forward的实现1234567891011template &lt;class T&gt;T&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp; t)&#123; return static_cast&lt;T&amp;&amp;&gt;(t);&#125;template &lt;class T&gt;T&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp;&amp; t)&#123; return static_cast&lt;T&amp;&amp;&gt;(t);&#125; std::forward&lt;T&gt;的返回类型是T&amp;&amp;。通常情况下，使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值/右值以及const属性： 12345template&lt;typename T&gt;void func(T&amp;&amp; t)&#123; // 在这里使用 std::forward&lt;T&gt;(t)&#125; 如果实参t是一个右值，则T被推断为一个普通（非引用）类型，std::forward&lt;T&gt;将返回T&amp;&amp;。如果实参是一个左值，则通过引用折叠，T被推断为一个左值引用类型。在此情况下，std::forward&lt;T&gt;返回类型是一个指向左值引用类型的右值引用T&amp;&amp; &amp;，再次引用折叠，将返回一个左值引用类型T&amp;。 注意：不能使用一个左值实例化一个右值引用类型的函数参数。函数参数和其它任何变量一样，在函数体内都是左值表达式。","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"重要知识点","slug":"重要知识点","permalink":"https://yuanlehome.github.io/tags/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"leetcode刷题系列之二叉树","date":"2021-02-08T13:35:42.000Z","path":"B90hHtDrYEYJD3xv/","text":"这篇文章是leetcode刷题系列的第4部分——二叉树。这里把有代表性的题目发出来，共计36道。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！ 114. Binary Tree Preorder Traversal 二叉树的前序遍历。 123456789101112131415161718// 迭代实现vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; nodes; nodes.push(root); while(!nodes.empty()) &#123; TreeNode* node = nodes.top(); nodes.pop(); while(node) &#123; res.push_back(node-&gt;val); if(node-&gt;right) &#123; nodes.push(node-&gt;right); &#125; node = node-&gt;left; &#125; &#125; return res;&#125; 94. Binary Tree Inorder Traversal 二叉树的中序遍历。 12345678910111213141516171819// 正中序遍历, 即左-中-右vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; res; while(1) &#123; while(root) &#123; nodes.push(root); root = root-&gt;left; &#125; if(nodes.empty()) &#123; break; &#125; root = nodes.top(); nodes.pop(); res.push_back(root-&gt;val); root = root-&gt;right; &#125; return res;&#125; 123456789101112131415161718192021// 逆中序遍历, 即右-中-左vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; res; while(1) &#123; while(root) &#123; nodes.push(root); // 右子树依次入栈 root = root-&gt;right; &#125; if(nodes.empty()) &#123; break; &#125; root = nodes.top(); nodes.pop(); res.push_back(root-&gt;val); // 这里去左子树 root = root-&gt;left; &#125; return res;&#125; 145. Binary Tree Postorder Traversal 二叉树的后序遍历。 1234567891011121314151617181920212223242526272829303132// 此解法借鉴中序遍历的思路vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; res; TreeNode* preVisited = nullptr; while(1) &#123; while(root) &#123; nodes.push(root); root = root-&gt;left; &#125; if(nodes.empty()) &#123; break; &#125; root = nodes.top(); // 如果待访问节点没有右孩子或者右孩子刚才访问过 if(root-&gt;right == nullptr || root-&gt;right == preVisited) &#123; // 就访问 preVisited = root; res.push_back(root-&gt;val); nodes.pop(); // 这是为了跳过下次的 while(root) 循环 root = nullptr; // 下一个待访问节点一定是刚刚访问节点的父节点 &#125; // 如果待访问节点有右孩子并且右孩子上次没有访问过 else &#123; // 就去访问右孩子 root = root-&gt;right; &#125; &#125; return res;&#125; 123456789101112131415161718192021// 此解法借鉴前序遍历的思路vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; res; nodes.push(root); while(!nodes.empty()) &#123; TreeNode* node = nodes.top(); nodes.pop(); while(node) &#123; res.push_back(node-&gt;val); // 和前序遍历相反的顺序访问左右子树 if(node-&gt;left) &#123; nodes.push(node-&gt;left); &#125; node = node-&gt;right; &#125; &#125; // 最后, 逆序输出就和后序遍历一样 reverse(res.begin(), res.end()); return res;&#125; 102. Binary Tree Level Order Traversal 二叉树的层序遍历。 12345678910111213141516171819202122232425// 使用队列迭代实现vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; nodes; if(root) &#123; nodes.push(root); &#125; while(!nodes.empty()) &#123; int n = nodes.size(); vector&lt;int&gt; subVector(n); for(int i = 0; i &lt; n; i++) &#123; root = nodes.front(); nodes.pop(); subVector[i] = root-&gt;val; if(root-&gt;left) &#123; nodes.push(root-&gt;left); &#125; if(root-&gt;right) &#123; nodes.push(root-&gt;right); &#125; &#125; res.push_back(subVector); &#125; return res;&#125; 12345678910111213141516171819// 借助前序遍历的思想, 递归实现vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; // 每次递归的时候提供被遍历节点的层级信息 auto preOrder = [&amp;](auto&amp;&amp; preOrder, TreeNode* root, size_t level) &#123; if(root == nullptr) &#123; return; &#125; level++; if(res.size() &lt; level) &#123; res.resize(level); &#125; res[level - 1].push_back(root-&gt;val); preOrder(preOrder, root-&gt;left, level); preOrder(preOrder, root-&gt;right, level); &#125;; preOrder(preOrder, root, 0); return res;&#125; 104. Maximum Depth of Binary Tree 给定二叉树的根，返回其最大深度。二叉树的最大深度是指沿着从根节点到最远的叶节点的最长路径的节点数。 Example: 12Input: root &#x3D; [3,9,20,null,null,15,7]Output: 3 1234567// 自底向上递归int maxDepth(TreeNode* root) &#123; if(!root) &#123; return 0; &#125; return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));&#125; 123456789101112131415// 自上到下递归int maxDepth(TreeNode* root) &#123; int res = 0; // 每次递归时传递被访问节点的深度信息 function&lt;void(TreeNode*, int)&gt; helper = [&amp;](TreeNode* root, int depth) &#123; if(!root) &#123; return; &#125; res = max(res, depth); helper(root-&gt;left, 1 + depth); helper(root-&gt;right, 1 + depth); &#125;; helper(root, 1); return res;&#125; 111. Minimum Depth of Binary Tree 给定二叉树的根，返回其最小深度。二叉树的最小深度是指沿着从根节点到最近的叶节点的最短路径的节点数。 123456789101112131415// 递归解法int minDepth(TreeNode* root) &#123; if(!root) &#123; return 0; &#125; int leftMinDepth = minDepth(root-&gt;left); int rightMinDepth = minDepth(root-&gt;right); if(leftMinDepth == 0) &#123; return 1 + rightMinDepth; &#125; if(rightMinDepth == 0) &#123; return 1 + leftMinDepth; &#125; return 1 + min(leftMinDepth, rightMinDepth);&#125; 1234567891011121314151617181920212223242526// BFS 迭代解法int minDepth(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; if(root) &#123; q.push(root); &#125; int step = 0; while(!q.empty()) &#123; int sz = q.size(); while(sz-- &gt; 0) &#123; TreeNode* node = q.front(); q.pop(); if(!node-&gt;left &amp;&amp; !node-&gt;right) &#123; return step + 1; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); &#125; &#125; step++; &#125; return step;&#125; 112. Path Sum 给定二叉树的根和一个整数targetSum，如果树具有从根到叶的路径，则沿路径的所有值加起来等于targetSum，则返回true。 Example: 12Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22Output: true 12345678910111213141516// 自顶向下递归bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) &#123; return false; &#125; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; return sum == root-&gt;val; &#125; if(hasPathSum(root-&gt;left, sum - root-&gt;val)) &#123; return true; &#125; if(hasPathSum(root-&gt;right, sum - root-&gt;val)) &#123; return true; &#125; return false;&#125; 113. Path Sum II 给定二叉树的根和一个整数targetSum，返回所有从根到叶的路径，其中每个路径的和等于targetSum。 Constraints: The number of nodes in the tree is in the range[0, 5000]. -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 Example: 12Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22Output: [[5,4,11,2],[5,8,4,5]] 1234567891011121314151617181920212223// 前序遍历vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; target; function&lt;void((TreeNode*, int))&gt; dfs = [&amp;](TreeNode* root, int sum) &#123; if(!root) &#123; return; &#125; sum -= root-&gt;val; target.push_back(root-&gt;val); // 如果是叶子节点 if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0) &#123; res.push_back(target); &#125; dfs(root-&gt;left, sum); // target.pop_back(); // target.push_back(root-&gt;val); dfs(root-&gt;right, sum); target.pop_back(); &#125;; dfs(root, sum); return res;&#125; 437. Path Sum III 你将获得一棵二叉树，其中每个节点都包含一个整数值。查找路径中节点值总和为给定值的路径数。 该路径无需在根或叶处开始或结束，但必须向下（仅从父节点到子节点移动）。 Example: 123456789101112131415root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8 10 &#x2F; \\ 5 -3 &#x2F; \\ \\ 3 2 11&#x2F; \\ \\3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 123456789101112131415161718192021222324252627// recursiveint pathSum(TreeNode* root, int sum) &#123; if(!root) &#123; return 0; &#125; // 等于以从 root 开始的子路径 + ... return rootPathSum(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);&#125;// dfs 求解以从 root 开始的子路径int rootPathSum(TreeNode* root, int targetSum) &#123; int res = 0; function&lt;void(TreeNode*, int)&gt; dfs = [&amp;](TreeNode* root, int curSum) &#123; if(root) &#123; curSum += root-&gt;val; // 和上一题 II 不同了 // 不必等到是叶子节点 // 只要中间有满足的, 直接增加计数 if(targetSum == curSum) &#123; res++; &#125; dfs(root-&gt;left, curSum); dfs(root-&gt;right, curSum); &#125; &#125;; dfs(root, 0); return res;&#125; 123456789101112131415161718192021222324// 上面纯递归的方法相当于暴力搜索, 时间复杂度为 O(n2)// 不仅数组中可以用到前缀和, 这里也可以用到, 时间复杂度可以优化到 O(n)int pathSum(TreeNode* root, int sum) &#123; int count = 0; unordered_map&lt;int, int&gt; mapping; // &lt;前缀和, 出现的次数&gt; // base case mapping[0] = 1; function&lt;void(TreeNode*, int)&gt; dfs = [&amp;](TreeNode* root, int curSum) &#123; if(root) &#123; curSum += root-&gt;val; if(mapping.count(curSum - sum)) &#123; count += mapping[curSum - sum]; &#125; mapping[curSum]++; dfs(root-&gt;left, curSum); // mapping[curSum]--; // mapping[curSum]++; dfs(root-&gt;right, curSum); mapping[curSum]--; &#125; &#125;; dfs(root, 0); return count;&#125; 666. Path Sum IV 对于一棵深度小于5的树，可以用一组三位十进制整数来表示。 对于每个整数： 百位上的数字表示这个节点的深度D，1 &lt;= D &lt;= 4。十位上的数字表示这个节点在当前层所在的位置P，1 &lt;= P &lt;= 8。位置编号与一棵满二叉树的位置编号相同。个位上的数字表示这个节点的权值V，0 &lt;= V &lt;= 9。给定一个包含三位整数的升序数组，表示一棵深度小于5的二叉树，请你返回从根到所有叶子结点的路径之和。 示例 1： 123456789输入: [113, 215, 221]输出: 12解释: 这棵树形状如下: 3&#x2F; \\5 1路径和 &#x3D; (3 + 5) + (3 + 1) &#x3D; 12. 示例 2： 123456789输入: [113, 221]输出: 4解释: 这棵树形状如下: 3 \\ 1路径和 &#x3D; (3 + 1) &#x3D; 4. 12345678910111213141516171819202122232425262728293031323334// 类似于堆排序中将完全二叉树存储在一个向量的思路// 借助一个哈希表来记录二叉树的每个节点在向量中的索引和其权重的映射// 每个节点的索引可通过其深度和位置计算出来// 公式为 i = 2 ^ (depth - 1) + position - 1// 比如, 根节点 112, depth = 1, position = 1, i = 2 ^ (1 - 1) + 1 - 1 = 1// 某节点 346, depth = 3, position = 4, i = 2 ^ (3 - 1) + 4 - 1 = 7// 这样表示之后, 索引为 i 的节点// 其左孩子索引为 2 * i, 右孩子索引为 2 * i + 1int pathSum(vector&lt;int&gt;&amp; nums) &#123; int res = 0; unordered_map&lt;int, int&gt; mapping; for(int num : nums) &#123; int depth = num / 100; int position = num % 100 / 10; int weight = num % 10; mapping[pow(2, depth - 1) + position - 1] = weight; &#125; function&lt;void(int, int)&gt; dfs = [&amp;](int i, int sum) &#123; if(mapping.count(i) == 0) &#123; return; &#125; sum += mapping[i]; // 到达叶子节点 if(mapping.count(2 * i) == 0 &amp;&amp; mapping.count(2 * i + 1) == 0) &#123; res += sum; &#125; // 去左子树 dfs(2 * i, sum); // 去右子树 dfs(2 * i + 1, sum); &#125;; dfs(1, 0); return res;&#125; 129. Sum Root to Leaf Numbers 你将获得只包含0到9的数字的二叉树的根。树中的每条从根到叶的路径都代表一个数字。 例如，从根到叶的路径1 -&gt; 2 -&gt; 3表示数字123。返回所有从根到叶的数字的总和。 Constraints: The number of nodes in the tree is in the range[1, 1000]. 0 &lt;= Node.val &lt;= 9. The depth of the tree will not exceed 10. Example: 1234567Input: root &#x3D; [4,9,0,5,1]Output: 1026Explanation:The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.The root-to-leaf path 4-&gt;0 represents the number 40.Therefore, sum &#x3D; 495 + 491 + 40 &#x3D; 1026. 12345678910111213141516int sumNumbers(TreeNode* root) &#123; int res = 0; auto dfs = [&amp;](auto&amp;&amp; dfs, auto* root, int num) &#123; if(!root) &#123; return; &#125; num = num * 10 + root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; res += num; &#125; dfs(dfs, root-&gt;left, num); dfs(dfs, root-&gt;right, num); &#125;; dfs(dfs, root, 0); return res;&#125; 124. Binary Tree Maximum Path Sum 二叉树中的路径是节点序列，其中序列中的每对相邻节点都有一条连接它们的边。 一个节点最多只能出现在序列中一次。 请注意，该路径不需要通过根。路径的路径总和是路径中节点值的总和。 给定二叉树的根，返回任何路径的最大路径总和。 Constraints: The number of nodes in the tree is in the range[1, 3 * 104]. -1000 &lt;= Node.val &lt;= 1000. Example: 123Input: root &#x3D; [-10,9,20,null,null,15,7]Output: 42Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42. 12345678910111213141516171819202122// 后序遍历思想int maxPathSum(TreeNode* root) &#123; int res = INT_MIN; // 递归函数的定义是返回 [以 root 为首节点] 的最大路径和 auto dfs = [&amp;](auto&amp;&amp; dfs, auto* root) &#123; if(!root) &#123; return 0; &#125; // 如果以 left 或 right 为首节点的路径和为负数 // 就不加上它 // 这样就能保证返回的值是以 root 为首节点的最大路径和 // 就是说将 root 单节点看作一条路径 int leftMaxSum = max(0, dfs(dfs, root-&gt;left)); int rightMaxSum = max(0, dfs(dfs, root-&gt;right)); // 计算 [经过] root 的最大路径和 // 这样, 通过递归的过程, 保证会分别计算经过每一个节点的最大路径和 res = max(res, leftMaxSum + root-&gt;val + rightMaxSum); return root-&gt;val + max(leftMaxSum, rightMaxSum); &#125;; dfs(dfs, root); return res;&#125; 105. Construct Binary Tree from Preorder and Inorder Traversal 给定两个整数数组preorder和inorder，其中preorder是二叉树的前序遍历，而inorder是同一树的中序遍历，构造并返回二叉树。 12345678910111213141516171819202122232425// 首先要知道前序遍历的首元素就是树的根// 其在中序遍历的位置的左边所有元素构成左子树, 右边所有元素构成右子树TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int n = inorder.size(); auto build = [&amp;](auto&amp;&amp; build, int preStart, int inStart, int inEnd) &#123; if(inStart &gt; inEnd) &#123; return (TreeNode*)nullptr; &#125; int rootVal = preorder[preStart]; TreeNode* root = new TreeNode(rootVal); // 定位 rootVal 在中序遍历中的位置 int index = inStart; for(; index &lt;= inEnd; index++) &#123; if(inorder[index] == rootVal) &#123; break; &#125; &#125; // 计算左子树节点数量 int leftSize = index - inStart; root-&gt;left = build(build, preStart + 1, inStart, index - 1); root-&gt;right = build(build, preStart + leftSize + 1, index + 1, inEnd); return root; &#125;; return build(build, 0, 0, n - 1);&#125; 1234567891011121314151617181920212223242526// 可以使用一个哈希表存储节点值在中序遍历数组中的索引TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int n = inorder.size(); unordered_map&lt;int, int&gt; mapping; for(int i = 0; i &lt; n; i++) &#123; mapping[inorder[i]] = i; &#125; auto build = [&amp;](auto&amp;&amp; build, int rootIndex, int inStart, int inEnd) &#123; if(inStart &gt; inEnd) &#123; return (TreeNode*)nullptr; &#125; int rootVal = preorder[rootIndex]; int index = mapping[rootVal]; int leftSize = index - inStart; TreeNode* root = new TreeNode(rootVal); // 左子树的根节点在当前根节点位置 + 1 的位置 root-&gt;left = build(build, rootIndex + 1, inStart, index - 1); // 右子树的根节点在当前根节点位置 + 左子树长度 + 1 的位置 root-&gt;right = build(build, rootIndex + leftSize + 1, index + 1, inEnd); return root; &#125;; // 因为每次我们只是需要得到节点值在中序遍历数组中的索引 // 现在我们已经预存储了节点值到索引的映射, 参数中就不需要中序遍历数组了 // 并且左右树根节点的值在前序遍历数组中的位置可以通过当前根节点的位置和左子树的长度来确定 return build(build, 0, 0, n - 1);&#125; 106. Construct Binary Tree from Inorder and Postorder Traversal 给定两个整数数组postorder和inorder，其中postorder是二叉树的后序遍历，而inorder是同一树的中序遍历，构造并返回二叉树。 123456789101112131415161718192021222324252627282930313233// 首先要知道后序遍历的尾元素就是树的根// 其在中序遍历的位置的左边所有元素构成左子树// 右边所有元素构成右子树TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int n = inorder.size(); auto build = [&amp;](auto&amp;&amp; build, int rootIndex, int inStart, int inEnd) &#123; if(inStart &gt; inEnd) &#123; return (TreeNode*)nullptr; &#125; // 后序遍历尾元素就是根 int rootVal = postorder[rootIndex]; TreeNode* root = new TreeNode(rootVal); // 定位根在中序遍历中的位置 // 一定存在 // 这里有一个特殊情况 inStart == inEnd // 出现这种情况 index 应该等于 inStart == inEnd // 递归基可以处理 int index = inStart; for(; index &lt;= inEnd; index++) &#123; if(inorder[index] == rootVal) &#123; break; &#125; &#125; // 计算右子树的节点数 int rightSize = inEnd - index; // 左子树的根节点在当前根节点位置 - 右子树长度 - 1 的位置 root-&gt;left = build(build, rootIndex - rightSize - 1, inStart, index - 1); // 右子树的根节点在当前根节点位置 - 1 的位置 root-&gt;right = build(build, rootIndex - 1, index + 1, inEnd); return root; &#125;; return build(build, n - 1, 0, n - 1);&#125; 123456789101112131415161718192021222324252627// 可以使用一个哈希表存储节点值在中序遍历数组中的索引TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int n = inorder.size(); unordered_map&lt;int, int&gt; mapping; for(int i = 0; i &lt; inorder.size(); i++) &#123; mapping[inorder[i]] = i; &#125; auto build = [&amp;](auto&amp;&amp; build, int rootIndex, int inStart, int inEnd) &#123; if(inStart &gt; inEnd) &#123; return (TreeNode*)nullptr; &#125; int rootVal = postorder[rootIndex]; int index = mapping[rootVal]; int rightSize = inEnd - index; TreeNode* root = new TreeNode(rootVal); // 左子树的根节点在当前根节点位置 - 右子树长度 - 1 的位置 root-&gt;left = build(build, rootIndex - rightSize - 1, inStart, index - 1); // 右子树的根节点在当前根节点位置 - 1 的位置 root-&gt;right = build(build, rootIndex - 1, index + 1, inEnd); return root; &#125;; // 因为每次我们只是需要得到节点值在中序遍历数组中的索引 // 现在我们已经预存储了节点值到索引的映射, 参数中就不需要中序遍历数组了 // 左右树根节点的值在前序遍历数组中的位置可以通过当前根节点的位置和右子树的长度来确定 return build(build, n - 1, 0, n - 1);&#125; 889. Construct Binary Tree from Preorder and Postorder Traversal 返回与给定的前序和后序遍历匹配的任意二叉树。二叉树中的值是不同的正整数。 12345678910111213141516171819202122232425262728293031323334353637383940// 虽然有些情况不能确定一棵唯一的二叉树// 但我们决定左右子树的规则固定即可// 首先注意到前序遍历的首元素为树的根// 首元素的下一个元素可能为其左子树的根, 也可能为其右子树的根// 但我们始终把它认定为左子树的根// 接下来就是在后序遍历中定位到 前序遍历首元素的下一个元素 的位置// 这个位置左边的就是左子树所有元素 (包括这个位置上的元素, 实际上它是左子树的根)// 右边的就是右子树所有元素 (除了末元素, 因为它是当前树的根啊)TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post)&#123; int n = pre.size(); function&lt;TreeNode*(int, int, int, int)&gt; construct = [&amp;](int preStart, int preEnd, int postStart, int postEnd) &#123; if(preStart &gt; preEnd) &#123; return (TreeNode*)nullptr; &#125; int rootVal = pre[preStart]; TreeNode* root = new TreeNode(rootVal); // 这个条件判断非常重要 // 如果 preStart == preEnd // 下面的 index 就会因为找不到而很大 为 postEnd // 导致错误地计算出很大的 leftSize // 这种情况递归基处理不了 if(preStart == preEnd) &#123; return root; &#125; // 定位到左子树的根在后序遍历中的位置 // 此时保证至少会有该元素, 也就是说 pre[preStart + 1] 在后序遍历中一定存在 int index = postStart; for(; index &lt; postEnd; index++) &#123; if(post[index] == pre[preStart + 1]) &#123; break; &#125; &#125; int leftSize = index - postStart + 1; root-&gt;left = construct(preStart + 1, preStart + leftSize, postStart, index); root-&gt;right = construct(preStart + leftSize + 1, preEnd, index + 1, postEnd - 1); return root; &#125;; return construct(0, n - 1, 0, n - 1);&#125; 1008. Construct Binary Search Tree from Preorder Traversal 给定一个整数已排序数组，该数组表示二叉搜索树的前序遍历结果，请构造该BST树并返回其根。 可以确保始终可以找到满足测试用例要求的BST。 Constraints: 1 &lt;= preorder.length &lt;= 100. 1 &lt;= preorder[i] &lt;= 108. All the values of preorder are unique. Example: 12Input: preorder &#x3D; [8,5,1,7,10,12]Output: [8,5,10,1,7,null,12] 1234567891011121314151617181920212223242526272829303132// 首先可以确定前序遍历的首元素为树的根// 其左子树的所有元素都小于首元素// 其右子树的所有元素都大于首元素// 所以, 我们接下来只要确定数组中第一个大于首元素的值的位置// 就能够直到左子树和右子树的元素范围TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder)&#123; int n = preorder.size(); function&lt;TreeNode*(int, int)&gt; build = [&amp;](int preStart, int preEnd) &#123; if(preStart &gt; preEnd) &#123; return (TreeNode*)nullptr; &#125; // 根为首元素 int rootVal = preorder[preStart]; TreeNode* root = new TreeNode(rootVal); // 找到第一个大于首元素的位置 int index = preStart + 1; for(; index &lt;= preEnd; index++) &#123; if(preorder[index] &gt; rootVal) &#123; break; &#125; &#125; // 到这里, 有两种情况 // 1. 左子树为空, 此时 index 应该为 prepreStart + 1 // 2. 右子树为空, 此时 index 应该为 preEnd + 1 // 无论哪一种情况, 递归进去之后, 递归基都可以处理 root-&gt;left = build(preStart + 1, index - 1); root-&gt;right = build(index, preEnd); return root; &#125;; return build(0, n - 1);&#125; 117. Populating Next Right Pointers in Each Node II - LeetCode 填充二叉树的每个节点下一个指针以指向其下一个右节点。 如果没有下一个右节点，则下一个指针应设置为NULL。 最初，所有下一个指针都设置为NULL。 12345678910111213141516171819202122232425262728293031/*struct Node &#123; int val; Node *left; Node *right; Node *next;&#125;;*/// 使用辅助节点的迭代式解法Node* connect(Node* root) &#123; Node helper; Node* cur = root; while(cur) &#123; Node* last = &amp;helper; while(cur) &#123; if(cur-&gt;left) &#123; last-&gt;next = cur-&gt;left; last = last-&gt;next; &#125; if(cur-&gt;right) &#123; last-&gt;next = cur-&gt;right; last = last-&gt;next; &#125; cur = cur-&gt;next; &#125; cur = helper.next; helper.next = nullptr; &#125; return root;&#125; 12345678910111213141516171819202122// 使用队列的迭代式解法(层序遍历)Node* connect(Node* root) &#123; Node* cur = root; queue&lt;Node*&gt; nodes; if(cur) &#123; nodes.push(cur); &#125; while(!nodes.empty()) &#123; for(int sz = nodes.size(); sz &gt; 0; sz--) &#123; cur = nodes.front(); nodes.pop(); cur-&gt;next = sz &gt; 1 ? nodes.front() : nullptr; if(cur-&gt;left) &#123; nodes.push(cur-&gt;left); &#125; if(cur-&gt;right) &#123; nodes.push(cur-&gt;right); &#125; &#125; &#125; return root;&#125; 如果给定的二叉树是棵完美二叉树：116. Populating Next Right Pointers in Each Node 123456789101112131415161718// 针对完美二叉树的递归式解法Node* connect(Node* root) &#123; if(!root) &#123; return nullptr; &#125; // 递归函数的定义就是将 p 和 q 两节点相连 function&lt;void(Node*, Node*)&gt; helper = [&amp;](Node* p, Node* q) &#123; if(!p || !q) &#123; return; &#125; p-&gt;next = q; helper(p-&gt;left, p-&gt;right); helper(q-&gt;left, q-&gt;right); helper(p-&gt;right, q-&gt;left); &#125;; helper(root-&gt;left, root-&gt;right); return root;&#125; 98. Validate Binary Search Tree 给定二叉树的根，确定它是否是有效的二叉搜索树。 123456789101112131415161718bool isValidBST(TreeNode* root) &#123; // 必须将对上层节点的约束传递给下层节点 // 限定以 root 为根的子树节点必须满足 min-&gt;val &lt; root.val &lt; max-&gt;val function&lt;bool(TreeNode*, TreeNode*, TreeNode*)&gt; helper = [&amp;](TreeNode* root, TreeNode* min, TreeNode* max) &#123; if(!root) &#123; return true; &#125; if(min &amp;&amp; root-&gt;val &lt;= min-&gt;val) &#123; return false; &#125; if(max &amp;&amp; root-&gt;val &gt;= max-&gt;val) &#123; return false; &#125; // 这时 left 节点的最大就是 root, right 节点的最小值就是 root return helper(root-&gt;left, min, root) &amp;&amp; helper(root-&gt;right, root, max); &#125;; return helper(root, nullptr, nullptr);&#125; 1373. Maximum Sum BST in Binary Tree 给定二叉树的根，找出所有是BST的子树，分别计算这些子树的所有节点值的和， 返回其中的最大值。 二叉搜索树的定义如下： 任意节点的左子树中的键值都小于此节点的键值。任意节点的右子树中的键值都大于此节点的键值。任意节点的左子树和右子树都是二叉搜索树。 Example 1: 123Input: root &#x3D; [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]Output: 20Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3. Example 2: 123Input: root &#x3D; [4,3,null,1,2]Output: 2Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2. 123456789101112131415161718192021222324252627282930313233343536373839int maxSumBST(TreeNode* root) &#123; int res = 0; // 递归函数返回值依次是 // 1. 以 root 为根的 BST 子树节点值的总和, 如果其不是 BST, 此值为 0 // 2. 以 root 为根的树中节点的最小值, 如果其不是 BST, 此值为 INT_MIN // 3. 以 root 为根的树中节点的最大值, 如果其不是 BST, 此值为 INT_MAX auto postOrder = [&amp;res](auto&amp; postOrder, TreeNode* root) &#123; if(!root) &#123; return make_tuple(0, INT_MAX, INT_MIN); &#125; auto [leftSum, leftMinVal, leftMaxVal] = postOrder(postOrder, root-&gt;left); auto [rightSum, rightMinVal, rightMaxVal] = postOrder(postOrder, root-&gt;right); // 如果当前节点的左子树中节点的最大值比当前节点还大 // 或者当前节点的右子树中节点的最小值比当前节点还小 // 以当前节点为根的子树就不是 BST // 因此总和为 0 // 最小值为 INT_MIN 以致于右子树中包含此树的树也被认定为非 BST // 最大值为 INT_MAX 以致于左子树中包含此树的树也被认定为非 BST if(leftMaxVal &gt;= root-&gt;val || rightMinVal &lt;= root-&gt;val) &#123; return make_tuple(0, INT_MIN, INT_MAX); &#125; // 此时, 以当前节点为根的子树是 BST // 计算此树的总和并更新最大值 int sum = leftSum + root-&gt;val + rightSum; res = max(res, sum); // 最后还要返回以当前节点为根的子树的信息 // 其总和就为 sum // 1. 当前节点有可能是叶子节点或者只有一颗子树 // 所以最小值为当前节点的值和左子树中最小的值相比取小者 // 最大值为当前节点的值和右子树中最大的值相比取大者 // 因为 if(!root) return &#123;0, INT_MAX, INT_MIN&#125;; 语句 // 保证了左子树中最小的值为 INT_MAX, 右子树中最大的值为 INT_MIN // 所以比较的结果肯定是 root-&gt;val // 2. 当前节点有两棵子树, 那么比较的结果肯定不是 root-&gt;val (这是 BST 的规则!) return make_tuple(sum, min(root-&gt;val, leftMinVal), max(root-&gt;val, rightMaxVal)); &#125;; postOrder(postOrder, root); return res;&#125; 123456789101112131415161718192021// make_tuple(isBST, sumOfBST, minVal, maxVal)int maxSumBST(TreeNode* root) &#123; int res = 0; auto post = [&amp;](auto&amp;&amp; post, auto&amp;&amp; root) &#123; if(root == nullptr) &#123; // 空树也是 BST return make_tuple(true, 0, INT_MAX, INT_MIN); &#125; auto&amp;&amp; [l_isBST, l_sumOfBST, l_minVal, l_maxVal] = post(post, root-&gt;left); auto&amp;&amp; [r_isBST, r_sumOfBST, r_minVal, r_maxVal] = post(post, root-&gt;right); if(!l_isBST || !r_isBST || root-&gt;val &lt;= l_maxVal || root-&gt;val &gt;= r_minVal) &#123; // 不是 BST 的话, 其他值都无所谓了 return make_tuple(false, 0, 0, 0); &#125; int sum = l_sumOfBST + root-&gt;val + r_sumOfBST; res = max(res, sum); return make_tuple(true, sum, min(root-&gt;val, l_minVal), max(root-&gt;val, r_maxVal)); &#125;; post(post, root); return res;&#125; 297. Serialize and Deserialize Binary Tree 序列化是将数据结构或对象转换为位序列的过程，以便可以将其存储在文件或内存缓冲区中，或者通过网络连接链接进行传输，以便稍后在相同或另一台计算机环境中进行重构。 设计一种用于对二叉树进行序列化和反序列化的算法。 序列化和反序列化算法的工作方式没有任何限制。 你只需要确保可以将二叉树序列化为字符串，并且可以将该字符串反序列化为原始树结构。 12345678910111213141516171819202122232425262728293031323334353637383940class Codec &#123;public: // 前序遍历解法 string serialize(TreeNode* root) &#123; string res; serialize(root, res); return res; &#125; TreeNode* deserialize(string data) &#123; stringstream ss(data); return deserialize(ss); &#125; private: void serialize(TreeNode* root, string&amp; res) &#123; if(!root) &#123; res += \"# \"; return; &#125; res += to_string(root-&gt;val) + \" \"; serialize(root-&gt;left, res); serialize(root-&gt;right, res); &#125; TreeNode* deserialize(stringstream&amp; ss) &#123; if(!ss) &#123; return nullptr; &#125; string temp; ss &gt;&gt; temp; if(temp == \"#\") &#123; return nullptr; &#125; TreeNode* root = new TreeNode(stoi(temp)); root-&gt;left = deserialize(ss); root-&gt;right = deserialize(ss); return root; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Codec &#123;public: // 后序遍历解法 string serialize(TreeNode* root) &#123; string res; serialize(root, res); return res; &#125; TreeNode* deserialize(string data) &#123; stringstream ss(data); vector&lt;string&gt; encoded; string s; while(getline(ss, s, ' ')) &#123; encoded.push_back(s); &#125; return deserialize(encoded); &#125; private: void serialize(TreeNode* root, string&amp; res) &#123; if(!root) &#123; res += \"# \"; return; &#125; serialize(root-&gt;left, res); serialize(root-&gt;right, res); res += to_string(root-&gt;val) + \" \"; &#125; TreeNode* deserialize(vector&lt;string&gt;&amp; encoded) &#123; if(encoded.empty()) &#123; return nullptr; &#125; string s = encoded.back(); encoded.pop_back(); if(s == \"#\") &#123; return nullptr; &#125; TreeNode* root = new TreeNode(stoi(s)); // 后序遍历需要先构造右孩子, 再构造左孩子 root-&gt;right = deserialize(encoded); root-&gt;left = deserialize(encoded); return root; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Codec &#123;public: // 层序遍历解法 string serialize(TreeNode* root) &#123; string encoded; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; auto node = q.front(); q.pop(); if(node) &#123; encoded += to_string(node-&gt;val) + \" \"; q.push(node-&gt;left); q.push(node-&gt;right); &#125; else &#123; encoded += \"# \"; &#125; &#125; return encoded; &#125; TreeNode* deserialize(string data) &#123; stringstream ss(data); string nodeVal; ss &gt;&gt; nodeVal; if(nodeVal == \"#\") &#123; return nullptr; &#125; TreeNode* root = new TreeNode(stoi(nodeVal)); queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode* root = q.front(); q.pop(); if(ss &gt;&gt; nodeVal) &#123; if(nodeVal != \"#\") &#123; root-&gt;left = new TreeNode(stoi(nodeVal)); q.push(root-&gt;left); &#125; &#125; if(ss &gt;&gt; nodeVal) &#123; if(nodeVal != \"#\") &#123; root-&gt;right = new TreeNode(stoi(nodeVal)); q.push(root-&gt;right); &#125; &#125; &#125; return root; &#125;&#125;; 653. Two Sum IV - Input is a BST 给定一个二叉搜索树和一个目标数，如果BST中存在两个元素的总和等于给定的目标数，则返回true。 Example: 12Input: root &#x3D; [5,3,6,2,4,null,7], k &#x3D; 9Output: true 12345678910111213141516// 方法 1 基本思想都是借助 BST 的中序遍历结果是升序排列的, 然后借助双指针搜索即可// 方法 2 无论使用什么遍历 (递归或迭代), 都借助哈希表在遍历的过程中记录已经出现的值bool findTarget(TreeNode* root, int k) &#123; unordered_set&lt;int&gt; setting; auto helper = [&amp;](auto&amp;&amp; helper, auto root) &#123; if(!root) &#123; return false; &#125; if(setting.count(k - root-&gt;val)) &#123; return true; &#125; setting.insert(root-&gt;val); return helper(helper, root-&gt;left) || helper(helper, root-&gt;right); &#125;; return helper(helper, root);&#125; 114. Flatten Binary Tree to Linked List 给定二叉树的根，将树展平为“链表”：“链表”应使用相同的TreeNode类，其中右子指针指向列表中的下一个节点，而左子指针始终为null。 “链表”的顺序应与二叉树的前序遍历顺序相同。 1234567891011121314151617181920212223// 递归思想: 相信递归函数的定义并毫不怀疑的去调用它!// 此例中, void flatten(TreeNode* root) 函数的定义就是将 root 平展// 只需要注意递归基的处理就可以了void flatten(TreeNode* root) &#123; if(root) &#123; flatten(root-&gt;left); flatten(root-&gt;right); // 此时左右两棵子树都已经 flatten 完毕了 TreeNode* temp = root-&gt;right; // 备份右子树 root-&gt;right = nullptr; // 1. 将右孩子指针指向左子树, 随后左孩子指针置空 if(root-&gt;left) &#123; root-&gt;right = root-&gt;left; root-&gt;left = nullptr; &#125; // 2. 沿着新右指针一直往前走, 定位到尾节点 while(root &amp;&amp; root-&gt;right) &#123; root = root-&gt;right; &#125; // 3. 将尾节点指向右子树 root-&gt;right = temp; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 1 / \\ 2 5 / \\ \\3 4 6// 将 1 的左子树插入到右子树的地方 1 \\ 2 5 / \\ \\ 3 4 6// 将原来的右子树接到左子树的最右边节点 1 \\ 2 / \\ 3 4 \\ 5 \\ 6// 将 2 的左子树插入到右子树的地方 1 \\ 2 \\ 3 4 \\ 5 \\ 6// 将原来的右子树接到左子树的最右边节点 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6*/void flatten(TreeNode* root) &#123; auto cur = root; while(cur) &#123; if(cur-&gt;left) &#123; auto pre = cur-&gt;left; while(pre-&gt;right) &#123; pre = pre-&gt;right; &#125; // 将原来的右子树接到左子树的最右边节点 pre-&gt;right = cur-&gt;right; // 将左子树插入到右子树的地方 cur-&gt;right = cur-&gt;left; cur-&gt;left = nullptr; &#125; // 考虑下一个节点 cur = cur-&gt;right; &#125;&#125; 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree 给定一个原始树和一个克隆树，克隆树是原始树的副本。并给出对原始树中某目标节点的引用。 返回对克隆树中相同节点的引用。 请注意，不允许您更改两个树或目标节点中的任何一个，并且答案必须是对克隆树中节点的引用。 注意：你的解答要适用于在树上允许有重复的值的情况。 123456789101112131415161718// 树上允许有重复的值意味着不能通过比较节点的值来返回目标节点// 题目已经给出保证 original cloned target 都不为 null// 直接对两棵树同步遍历TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) &#123; if(!original) &#123; return nullptr; &#125; if(original == target) &#123; return cloned; &#125; // 先在左子树中找 TreeNode* found = getTargetCopy(original-&gt;left, cloned-&gt;left, target); // 没找到再去右子树中找 if(!found) &#123; found = getTargetCopy(original-&gt;right, cloned-&gt;right, target); &#125; return found;&#125; 99. Recover Binary Search Tree 给定一个二叉搜索树的根节点，恰好树中的两个节点错误地交换了。 在不更改其结构的前提下，恢复这棵二叉搜索树。 Example 1 Example 2 Example 1: 123Input: root &#x3D; [1,3,null,null,2]Output: [3,1,null,null,2]Explanation: 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid. Example 2: 123Input: root &#x3D; [3,1,4,null,null,2]Output: [2,1,4,null,null,3]Explanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid. 注意：使用O(n)空间复杂度的解决方案非常简单。 你能设计一个O(1)空间解决方案吗？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 首先要知道, BST 的中序遍历是有序的// 然后注意到, 如果树中有两个节点被交换了// 在中序遍历序列中必然会出现逆序对 (可能一对, 也可能两对)// 一对的情况是被交换的两个节点在中序遍历序列中相邻// 此时我们有两个指针来分别定位这一逆序对的两个节点// 交换它们的值即可// 被交换的两个节点不相邻就会出现两对逆序对的情况// 此时, 有一个指针定位前一个逆序对的第一个节点// 另一个指针定位后一个逆序对的第二个节点// 交换它们的值即可// 从这题要学会如何跟踪遍历过程中当前节点的前一个节点的技术void recoverTree(TreeNode* root) &#123; // 定位逆序对的第一个节点 TreeNode* first = nullptr; // 定位逆序对的第二个节点 TreeNode* second = nullptr; // 始终指向当前访问节点的前一个节点 TreeNode* pre = nullptr; auto inorder = [&amp;](auto&amp;&amp; inorder, auto* cur) &#123; if(cur == nullptr) &#123; return; &#125; inorder(inorder, cur-&gt;left); if(pre &amp;&amp; pre-&gt;val &gt; cur-&gt;val) &#123; // 如果为空, 说明遇到的是第一个逆序对 // 当前节点是逆序对的第二个节点 // 第一个节点由 pre 指出, 更新 first // 如果不为空, 说明遇到的是第二个逆序对 // 就不更新 first, 因为我们定位第二个逆序对的第一个节点没有用 if(first == nullptr) &#123; first = pre; &#125; // 无论是第几个逆序对 // second 都指向逆序对的第二个节点 second = cur; &#125; // 持续跟踪前一个节点 pre = cur; inorder(inorder, cur-&gt;right); &#125;; inorder(inorder, root); swap(first-&gt;val, second-&gt;val);&#125; 687. Longest Univalue Path 给定二叉树的根，返回最长路径的长度，其中路径中的每个节点都具有相同的值。 此路径可能会也可能不会通过根。 两个节点之间的路径长度由它们之间的边数表示。 Example 1: 12Input: root &#x3D; [1,4,5,4,4,5]Output: 2 Example 2: 12Input: root &#x3D; [5,4,5,1,1,5]Output: 2 1234567891011121314151617181920212223242526272829int longestUnivaluePath(TreeNode* root) &#123; int maxPath = 0; // 该递归函数的定义就是返回以 root 为起点的符合条件的路径的最大长度 auto post = [&amp;](auto&amp;&amp; post, auto cur) -&gt; int &#123; if(cur == nullptr) &#123; return 0; &#125; int leftMax = post(post, cur-&gt;left); int rightMax = post(post, cur-&gt;right); int LeftMaxFromRoot = 0; int rightMaxFromRoot = 0; // 如果当前节点的值与其左孩子的值相等 // 那么它就可以和其左孩子的路径连在一块, 路径长度 +1 if(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val == cur-&gt;val) &#123; LeftMaxFromRoot = leftMax + 1; &#125; // 如果当前节点的值与其右孩子的值相等 // 那么它就可以和其右孩子的路径连在一块, 路径长度 +1 if(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val == cur-&gt;val) &#123; rightMaxFromRoot = rightMax + 1; &#125; // 注意这两条路径是不一样的 maxPath = max(maxPath, LeftMaxFromRoot + rightMaxFromRoot); // 而以 root 为起点的符合条件的路径的最大长度为这两条路径的较大者 return max(LeftMaxFromRoot, rightMaxFromRoot); &#125;; post(post, root); return maxPath;&#125; 654. Maximum Binary Tree 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 Constraints: All integers in nums are unique. Example: 12Input: nums &#x3D; [3,2,1,6,0,5]Output: [6,3,5,null,2,0,null,null,1] 123456789101112131415161718192021222324252627282930313233343536373839404142TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums)&#123; return construct(nums, 0, nums.size() - 1);&#125;// 构造闭区间 [lo, hi] 内的元素TreeNode* construct(vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; // base case if(lo &gt; hi) return nullptr; // 找到最大值 int maxIndex = findMax(nums, lo, hi); /* 另外, 装逼的话, 获取数组中最大元素的索引可以这样写 int maxIndex = distance(nums.begin(), max_element(nums.begin() + lo, nums.begin() + hi + 1)); */ // 以最大值为根节点 TreeNode* root = new TreeNode(nums[maxIndex]); // 左子树为最大值左边的 root-&gt;left = construct(nums, lo, maxIndex - 1); // 右子树为最大值右边的 root-&gt;right = construct(nums, maxIndex + 1, hi); return root;&#125;int findMax(vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; int maxVal = INT_MIN; int index; for(int i = lo; i &lt;= hi; i++) &#123; if(nums[i] &gt; maxVal) &#123; index = i; maxVal = nums[i]; &#125; &#125; return index;&#125; 998. Maximum Binary Tree II 最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。 给出最大树的根节点root。 就像之前的654. Maximum Binary Tree问题那样，给定的树是从列表A递归地使用下述Construct(A)例程构造的： 如果A为空，返回null否则，令A[i]作为A的最大元素。创建一个值为A[i]的根节点rootroot的左子树将被构建为Construct([A[0], A[1], ..., A[i-1]])root的右子树将被构建为Construct([A[i+1], A[i+2], ..., A[A.length - 1]])返回root请注意，我们这里没有直接给定A，只有一个根节点root = Construct(A). 假设B是A的副本，并在末尾附加值val。题目数据保证B中的值是不同的。返回Construct(B)。 Example 1: 123Input: root &#x3D; [4,1,3,null,null,2], val &#x3D; 5Output: [5,4,null,1,3,null,null,2]Explanation: A &#x3D; [1,4,2,3], B &#x3D; [1,4,2,3,5] Example 2: 123Input: root &#x3D; [5,2,4,null,1], val &#x3D; 3Output: [5,2,4,null,1,null,3]Explanation: A &#x3D; [2,1,5,4], B &#x3D; [2,1,5,4,3] Example 3: 123Input: root &#x3D; [5,2,3,null,1], val &#x3D; 4Output: [5,2,4,null,1,3]Explanation: A &#x3D; [2,1,5,3], B &#x3D; [2,1,5,3,4] 1234567891011121314151617// 先要明确一点, 最大二叉树指的是在构造的时候最大值左边的为左子树, 右边的为右子树// 因为是放在数组右边的, 所以新节点必然在右子树中TreeNode* insertIntoMaxTree(TreeNode* root, int val)&#123; // 如果比人家右子树中的所有节点都小 // 只能作为叶子节点了 if(!root) return new TreeNode(val); // 如果目标值当前节点的值大 // 说明以当前节点为根的子树要成为我的左子树才行 // 因为我是放在最右边的, 你在我左边我还比你大 if(val &gt; root-&gt;val) return new TreeNode(val, root, nullptr); // 否则, 就要向右边搜索位置 // 因为你在原来最大值的右边 root-&gt;right = insertIntoMaxTree(root-&gt;right, val); return root;&#125; 508. Most Frequent Subtree Sum 给定一棵树的根，要求你找到最频繁的子树总和。 节点的子树总和定义为由以该节点为根的子树（包括节点本身）形成的所有节点值的总和。 那么，最频繁的子树总和的值是多少？如果有平局，则以任意顺序返回具有最高频率的所有值。 Examples 1Input: 123 5 &#x2F; \\2 -3 return [2, -3, 4], since all the values happen only once, return all of them in any order. Examples 2Input: 123 5 &#x2F; \\2 -5 return [2], since 2 happens twice, however -5 only occur once. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 思想就是先通过递归获得所有子树的和// 递归的过程中记录下来每一个确定的和出现的次数// 这需要一个哈希表来记录 sum --&gt; preq 的映射// 但是问题来了, 之后我们要获取出现次数最多的, 也就是值(频率)最大的键// 并且频率还有可能相同而出现重复// 第一种方法是 auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);// 注意, cmp 需要定制 auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)// &#123; return a.second &lt; b.second; &#125;;// 这种方法效率有点低, 有多少个重复的 freq, 我们就需要遍历哈希表多少次// 最坏情况下，时间复杂度为 O(n2)// 第二种方法是再使用一个 multimap 来 [逆映射] 原 unordered_map 中的键值对// for(auto elem : mapping)// mappingSwap.insert(&#123;elem.second, elem.first&#125;);// 需要注意的是, 使用有序可重复哈希表, 将原来的键变成值, 值变成键// 然后通过逆迭代器直接获得最大键元素 (在红黑树的最右下边嘛)// 最坏时间复杂度将为 O(n) 啦// 第一种方法// vector&lt;int&gt; findFrequentTreeSum(TreeNode* root)// &#123;// unordered_map&lt;int, int&gt; mapping;// subTreeSum(root, mapping);// auto cmp = [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b)// &#123; return a.second &lt; b.second; &#125;;// vector&lt;int&gt; res;// int preFreq = 0;// while(1)// &#123;// if(mapping.empty()) break;// auto maxFreqSum = *max_element(mapping.begin(), mapping.end(), cmp);// if(!res.empty() &amp;&amp; maxFreqSum.second != preFreq)// break;// preFreq = maxFreqSum.second;// res.push_back(maxFreqSum.first);// mapping.erase(maxFreqSum.first);// &#125;// return res;// &#125;// 第二种方法vector&lt;int&gt; findFrequentTreeSum(TreeNode* root)&#123; unordered_map&lt;int, int&gt; mapping; multimap&lt;int, int&gt; mappingSwap; subTreeSum(root, mapping); for(auto elem : mapping) mappingSwap.insert(&#123;elem.second, elem.first&#125;); vector&lt;int&gt; res; if(mappingSwap.empty()) return res; int preFreq = mappingSwap.rbegin()-&gt;first; for(auto it = mappingSwap.rbegin(); it != mappingSwap.rend(); it++) &#123; if(it-&gt;first != preFreq) break; res.push_back(it-&gt;second); &#125; return res;&#125;int subTreeSum(TreeNode* root, unordered_map&lt;int, int&gt;&amp; mapping)&#123; if(!root) return 0; int leftSum = subTreeSum(root-&gt;left, mapping); int rightSum = subTreeSum(root-&gt;right, mapping); int rootSum = leftSum + rightSum + root-&gt;val; mapping[rootSum]++; return rootSum;&#125; 236. Lowest Common Ancestor of a Binary Tree 给定一棵二叉树，找到树中两个给定节点的最低公共祖先（LCA）。一个节点的祖先可以是它自己。 Constraints: 所有Node.val互不相同 p != q p 和 q均存在于给定的二叉树中。 123456789101112131415161718192021222324// 接下来的几道题全是最低公共祖先的问题// 这题的限制是给定的两个节点都存在树中// 基本思想就是借助递归, 时刻牢记递归函数的定义, 并且毫不怀疑的使用它// 这题中, lowestCommonAncestor 函数的定义就是, 接受一个根节点和两个在树中的其它节点// 返回它们的 LCA// 所以, 利用后序遍历, 先分别在当前节点的左右子树中找给定两个节点的 LCA// 根据返回值判断寻找情况TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)&#123; // 如果当前节点为空, 肯定找不到 LCA 了 if(!root) return nullptr; // left 为左子树中的寻找情况 TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); // right 为右子树中的寻找情况 TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); // 注意, 如果当前节点属于这两个节点之一 // 意味着 当前节点就是它们的最低公共祖先啦 if(root == p || root == q) return root; // 如果在左子树中和右子树中都找到了一个 LCA // 同样的, 说明当前节点就是它们的 LCA if(left &amp;&amp; right) return root; // 否则, 返回在 以当前节点为根的子树 中给定节点的 LCA return left ? left : right;&#125; 1644. Lowest Common Ancestor of a Binary Tree II 给定一棵二叉树的根节点root，返回给定节点p和q的最近公共祖先（LCA）节点。如果p或q之一不存在于该二叉树中，返回null。 Constraints: 所有Node.val互不相同 p != q 1234567891011121314151617181920212223242526272829303132333435363738// 这题和 I 题不同之处在于// 给定的两个节点可能不在树中// 所以, 这里我们使用两个 flag// 在后序遍历的同时, 标志给定的两个节点是否在树中// 其余的逻辑和 I 题一样bool pIsInTree = false;bool qIsInTree = false;TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)&#123; TreeNode* res = nullptr; // 辅助递归函数返回 LCA res = helper(root, p, q); // 如果有任何一个节点不在树中, 返回 null if(!pIsInTree || !qIsInTree) return nullptr; return res;&#125;TreeNode* helper(TreeNode* root, TreeNode* p, TreeNode* q)&#123; if(!root) return nullptr; TreeNode* left = helper(root-&gt;left, p, q); TreeNode* right = helper(root-&gt;right, p, q); // 将上题中的 if(root == p || root == q) return root; 分开写就行了 if(root == p) &#123; pIsInTree = true; return root; &#125; if(root == q) &#123; qIsInTree = true; return root; &#125; if(left &amp;&amp; right) return root; return left ? left : right;&#125; 1650. Lowest Common Ancestor of a Binary Tree III 给定一棵二叉树中的两个节点p和q，返回它们的最近公共祖先节点（LCA）。 每个节点都包含其父节点的引用（指针）。Node的定义如下： 1234567struct Node&#123; int val; Node* left; Node* right; Node* parent;&#125; Constraints: 所有Node.val互不相同 p != q p 和 q均存在于给定的二叉树中。 123456789101112131415161718192021222324252627// 这题中的树的节点都有指向父亲的指针, 而且还说给定的两个节点还肯定存在// 那就更简单了, 直接分别从给定的两个节点逐层向上找// 借助一个哈希集合, 第一个节点向上找的过程中, 经过的每一个父节点都放进一个集合内// 等第二个节点向上找的时候, 如果遇到已经在哈希集合中的父节点 (首个遇到的)// 那就说明这个节点就是它们的 LCA 啦// 和查找链表的交叉点的思路一样Node* lowestCommonAncestor(Node* p, Node* q)&#123; unordered_set&lt;Node*&gt; setting; // p 先向上, 同样的自己也可以是自己的祖先 while(p) &#123; // 所以自己也得放进集合 setting.insert(p); p = p-&gt;parent; &#125; while(q) &#123; // 已经在集合中了, 就是它! if(setting.count(q)) return q; setting.insert(q); q = q-&gt;parent; &#125; return nullptr;&#125; 1676. Lowest Common Ancestor of a Binary Tree IV 给定一棵二叉树的根节点root和TreeNode类对象的数组（列表）nodes，返回nodes中所有节点的最近公共祖先（LCA）。数组（列表）中所有节点都存在于该二叉树中，且二叉树中所有节点的值都是互不相同的。 Constraints: 所有的Node.val都是互不相同的。 所有的nodes[i]都存在于该树中。 所有的nodes[i]都是互不相同的。 示例 1: 123输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [4,7]输出: 2解释: 节点 4 和 7 的最近公共祖先是 2。 示例 2: 123输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], nodes &#x3D; [7,6,2,4]输出: 5解释: 节点 7、6、2 和 4 的最近公共祖先节点是 5。 12345678910111213141516171819202122232425// 这一题, 我笑了// I 题是找两个节点的 LCA// 这题找多个节点的, 思路完全一样TreeNode* lowestCommonAncestor(TreeNode* root, vector&lt;TreeNode*&gt;&amp; nodes)&#123; // 先将 nodes 中的节点们都放进一个哈希集合中 unordered_set&lt;TreeNode*&gt; setting; for(auto node : nodes) setting.insert(node); return dfs(root, setting);&#125;TreeNode* dfs(TreeNode* root, unordered_set&lt;TreeNode*&gt;&amp; setting)&#123; if(!root) return nullptr; TreeNode* left = dfs(root-&gt;left, setting); TreeNode* right = dfs(root-&gt;right, setting); // 将 I 题中的 if(root == p || root == q) return root; 换个写法就行了 if(setting.count(root)) return root; if(left &amp;&amp; right) return root; return left ? left : right;&#125; 235. Lowest Common Ancestor of a Binary Search Tree 给定一个二叉搜索树，找到该树中两个指定节点的最近公共祖先。 1234567891011TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)&#123; if(p == root || q == root) return root; if(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); else if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); return root;&#125; 101. Symmetric Tree 给定二叉树，请检查其是否是其自身的镜像（即围绕其中心对称）。 Example: 12Input: root &#x3D; [1,2,2,3,4,4,3]Output: true 12345678910111213141516171819bool isSymmetric(TreeNode* root)&#123; if(!root) return true; return helper(root-&gt;left, root-&gt;right);&#125;// 左右子树同步遍历bool helper(TreeNode* p, TreeNode* q)&#123; // 如果都为空, 显然对称 if(!p &amp;&amp; !q) return true; // 此时两者必有不为 null 的 // 就判断是否有为 null 的 if(!p || !q) return false; // 此时两者都不为 null // 就判断它们的值是否相等 if(p-&gt;val != q-&gt;val) return false; return helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left);&#125; 1372. Longest ZigZag Path in a Binary Tree 给你一棵以root为根的二叉树，二叉树中的交错路径定义如下： 选择二叉树中任意节点和一个方向（左或者右）。如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。改变前进方向：左变右或者右变左。重复第二步和第三步，直到你在树中无法继续移动。交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为0）。 请你返回给定树中最长交错路径的长度。 Example 1 Example 2 Example 1: 123Input: root &#x3D; [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]Output: 3Explanation: Longest ZigZag path in blue nodes (right -&gt; left -&gt; right). Example 2: 123Input: root &#x3D; [1,1,1,null,1,null,null,1,1,null,1]Output: 4Explanation: Longest ZigZag path in blue nodes (left -&gt; right -&gt; left -&gt; right). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 递归形式 1// 0 表示方向向左// 1 表示方向向右int res = 0;int longestZigZag(TreeNode* root)&#123; helper(root-&gt;left, 0, 1); helper(root-&gt;right, 1, 1); return res;&#125;void helper(TreeNode* node, bool dir, int depth)&#123; if(!node) return; res = max(res, depth); if(dir) &#123; // 如果当前节点是从右方向过来的 // 之后就要转去左方向 helper(node-&gt;left, 0, depth + 1); // 同时还可以接着去右方向 // 只不过深度要重新计算 helper(node-&gt;right, 1, 1); &#125; else &#123; // 如果当前节点是从左方向过来的 // 之后就要转去右方向 helper(node-&gt;right, 1, depth + 1); // 同时还可以接着去左方向 // 只不过深度要重新计算 helper(node-&gt;left, 0, 1); &#125;&#125;// 递归形式 2int res = 0;int helper(TreeNode* root, bool dir)&#123; if(!root) return 0; int tmp_L = 1 + helper(root-&gt;left, 0); int tmp_R = 1 + helper(root-&gt;right, 1); res = max(res, tmp_L); res = max(res, tmp_R); return dir ? tmp_L : tmp_R;&#125;int longestZigZag(TreeNode* root)&#123; helper(root, 0); // helper(root, 1); return res - 1;&#125; 173. Binary Search Tree Iterator 实现一个二叉搜索树迭代器类BSTIterator，表示一个按中序遍历二叉搜索树（BST）的迭代器： BSTIterator(TreeNode* root)初始化BSTIterator类的一个对象。BST的根节点root会作为构造函数的一部分给出。指针应初始化为一个不存在于BST中的数字，且该数字小于BST中的任何元素。 bool hasNext()如果向指针右侧遍历存在数字，则返回true；否则返回false。 int next()将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于BST中的数字，所以对next()的首次调用将返回BST中的最小元素。 你可以假设next()调用总是有效的，也就是说，当调用next()时，BST的中序遍历中至少存在一个下一个数字。 12345678910111213141516171819202122232425262728293031323334// 这题考察二叉树的中序遍历的迭代实现// 只不过把循环分摊在每次调用 next 函数里class BSTIterator&#123;public: BSTIterator(TreeNode* root) : _pointer(root) &#123;&#125; // 这段和是中序遍历的迭代式写法 while(1) 循环体里的代码完全一样 int next() &#123; while(_pointer) &#123; _stack.push(_pointer); _pointer = _pointer-&gt;left; &#125; _pointer = _stack.top(); int val = _pointer-&gt;val; _stack.pop(); _pointer = _pointer-&gt;right; return val; &#125; bool hasNext() &#123; // 只有当 _pointer 为空并且 _stack 也为空的情况下 // 才没有下一个节点 return _pointer || !_stack.empty(); &#125;private: TreeNode* _pointer; stack&lt;TreeNode*&gt; _stack;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"leetcode刷题系列之链表","date":"2021-01-08T13:35:42.000Z","path":"S07PSuYxoZ6CPova/","text":"这篇文章是leetcode刷题系列的第2部分——链表，链表的大部分题目难度都不大。leetcode上链表部分的题目也就40道左右，基本上都做了，这里就把有代表性的题目发出来，共计24道。每道题都给出了注释，有的题目还给出了另一种思路和解法。 接下来这几个月，计划完成的leetcode刷题系列其组织如下： 1. 数组 2. 链表 3. 字符串 4. 二叉树 5. 队列和栈 6. 动态规划 7. 数据结构设计 预计涉及题目至少300道！ 206. Reverse Linked List 给定一个单链表的头节点，反转链表，然后返回反转后的链表头节点。 12345678910111213141516171819202122232425// 迭代解法ListNode* reverseList(ListNode* head) &#123; ListNode* p = nullptr; ListNode* q = p; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p;&#125;// 递归解法ListNode* reverseList(ListNode* head) &#123; if(!head || !head-&gt;next) &#123; return head; &#125; ListNode* q = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return q;&#125; 92. Reverse Linked List II 给定一个单链表的头以及left和right两个整数，其中left &lt;= right，将链表中从left位置到right位置的节点反转，返回反转后的链表。 1234567891011121314151617181920212223242526272829303132// 头插法// 鲁棒性编码，如果输入无效参数，函数返回空指针// 输入有效则返回反转后链表的头节点ListNode *reverseBetween(ListNode *head, int left, int right) &#123; if(head == nullptr || left &lt; 1 || left &gt; right) &#123; return nullptr; &#125; ListNode helper(0, head); ListNode* preTheLeft = &amp;helper; for(int i = 0; i &lt; left - 1; i++) &#123; if(preTheLeft-&gt;next) &#123; preTheLeft = preTheLeft-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; ListNode* preToInsert = preTheLeft-&gt;next; ListNode* ToInsert = nullptr; for(int i = 0; i &lt; right - left; i++) &#123; if(preToInsert-&gt;next) &#123; ToInsert = preToInsert-&gt;next; &#125; else &#123; return nullptr; &#125; preToInsert-&gt;next = ToInsert-&gt;next; ToInsert-&gt;next = preTheLeft-&gt;next; preTheLeft-&gt;next = ToInsert; &#125; return helper.next;&#125; 12345678910111213141516171819202122232425262728293031/* 纯递归解法 */// 反转整个链表ListNode* reverseList(ListNode* head) &#123; if(!head || !head-&gt;next) &#123; return head; &#125; ListNode* q = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return q;&#125;// 反转前 n 个节点ListNode* reverseN(ListNode* head, int n) &#123; ListNode* p = head; while(--n &gt; 0) &#123; p = p-&gt;next; &#125; ListNode* q = p-&gt;next; p-&gt;next = nullptr; p = reverseList(head); head-&gt;next = q; return p;&#125;ListNode* reverseBetween(ListNode* head, int left, int right) &#123; if(left == 1) &#123; return reverseN(head, right); &#125; head-&gt;next = reverseBetween(head-&gt;next, left - 1, right - 1); return head;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/* 纯迭代解法 */// 反转整个链表ListNode* reverseList(ListNode* head) &#123; ListNode* p = nullptr; ListNode* q = p; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p;&#125;// 反转前 n 个节点ListNode* reverseN(ListNode* head, int n) &#123; ListNode* p = head; while(--n &gt; 0) &#123; p = p-&gt;next; &#125; ListNode* q = p-&gt;next; p-&gt;next = nullptr; ListNode* r = reverseList(head); head-&gt;next = q; return r;&#125;ListNode* reverseBetween(ListNode* head, int left, int right) &#123; if(left == 1) &#123; return reverseN(head, right); &#125; // 计算反转的实际节点数 int n = right - left + 1; ListNode* preLeft = head; left--; while(--left &gt; 0) &#123; preLeft = preLeft-&gt;next; &#125; // preLeft 现在指向第 left 个节点的前一个节点 preLeft-&gt;next = reverseN(preLeft-&gt;next, n); return head;&#125; 25. Reverse Nodes in k-Group 给你一个链表，每k个节点一组进行翻转，请你返回翻转后的链表。k是一个正整数，它的值小于或等于链表的长度。如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺序。 进阶：你可以设计一个只使用常数额外空间的算法来解决此问题吗？不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 Example 1 Example 2 12345678910111213141516171819202122232425262728293031323334353637383940ListNode* reverseKGroup(ListNode* head, int k) &#123; if(head == nullptr || k &lt;= 1) &#123; return head; &#125; ListNode helper(0, head); // last 始终指向新链表的末尾节点, 方便后续链表接在其后面 // last-&gt;next 就一直指向正在反转的局部链表 ListNode* last = &amp;helper; // cur 用于遍历每一个节点 ListNode* cur = last; // 反转整个链表 auto reverseList = [](ListNode* head) &#123; ListNode* reversedHead = nullptr; ListNode* needToReverse = nullptr; while(head) &#123; needToReverse = head-&gt;next; head-&gt;next = reversedHead; reversedHead = head; head = needToReverse; &#125; return reversedHead; &#125;; while(1) &#123; for(int i = 0; i &lt; k &amp;&amp; cur; i++) &#123; cur = cur-&gt;next; &#125; if(cur == nullptr) &#123; break; &#125; // nextToReverse 始终指向后面待反转的链表的头节点 ListNode* nextToReverse = cur-&gt;next; cur-&gt;next = nullptr; cur = last-&gt;next; last-&gt;next = reverseList(last-&gt;next); cur-&gt;next = nextToReverse; last = cur; &#125; return helper.next;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061struct Node &#123; Node* next; int val; Node(int _val, Node* _next) : val(_val), next(_next) &#123;&#125;&#125;;Node* reverseKGroup(Node* head, int k) &#123; if(head == nullptr) &#123; return head; &#125; Node helper(0, head); Node* last = &amp;helper; Node* curNode = last; auto reverse = [](Node* head) &#123; Node* p = nullptr; Node* q = nullptr; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p; &#125;; while(1) &#123; for(int i = 0; i &lt; k; i++) &#123; if(curNode-&gt;next) &#123; curNode = curNode-&gt;next; &#125; else &#123; last-&gt;next = reverse(last-&gt;next); curNode = nullptr; break; &#125; &#125; if(curNode == nullptr) &#123; break; &#125; Node* temp = curNode-&gt;next; curNode-&gt;next = nullptr; curNode = last-&gt;next; last-&gt;next = reverse(last-&gt;next); curNode-&gt;next = temp; last = curNode; &#125; return helper.next;&#125;int main() &#123; Node head(0, nullptr); Node* last = &amp;head; for(int i = 1; i &lt;= 8; i++) &#123; last-&gt;next = new Node(i, nullptr); last = last-&gt;next; &#125; Node* newHead = reverseKGroup(head.next, 3); for(auto* it = newHead; it; it = it-&gt;next) &#123; cout &lt;&lt; it-&gt;val &lt;&lt; \" \"; &#125;&#125; 382. Linked List Random Node 给定一个单链表，从链表随机返回一个节点的值。 每个节点必须具有相同的被选择概率。 如果链表很大并且你不知道其长度怎么办？你能在不使用额外空间的情况下有效解决此问题吗？ 如果随机返回k个节点的值呢？ 水塘抽样算法：遇到第i个元素时，应该有1/i的概率选择该元素，1 - 1/i的概率保持原有的选择。 证明：假设总共有n个元素，我们要的随机性无非就是每个元素被选择的概率都是1/n ，那么对于第i个元素，它被选择的概率就是： 同理，如果要随机选择k个数，只要在第i个元素处以k/i的概率选择该元素，以1 - k/i的概率保持原有选择即可。 证明：略。 1234567891011121314/* Returns a random node's value. */int getRandom(ListNode* head) &#123; int res = 0, i = 0; while(head) &#123; i++; int j = rand() % i; // j 等于 0 的概率就为 1/i if(j == 0) &#123; res = head-&gt;val; &#125; head = head-&gt;next; &#125; return res;&#125; 1234567891011121314151617181920/* Returns k random node's value. */vector&lt;int&gt; getRandom(ListNode* head, int k) &#123; vector&lt;int&gt; res(k, 0); // 前 k 个值默认先选上 for(int i = 0; i &lt; k &amp;&amp; head; i++) &#123; res[i] = head-&gt;val; head = head-&gt;next; &#125; int i = k; while(head) &#123; i++; int j = rand() % i; // j 小于 k 的概率就为 k/i if(j &lt; k) &#123; res[j] = head-&gt;val; &#125; head = head-&gt;next; &#125; return res;&#125; 2. Add Two Numbers 给定两个表示两个非负整数的非空链表。 这些数字以相反的顺序存储，即低位数在前，并且它们的每个节点都包含一个数字。 将两个数字相加并返回总和作为链接列表。 123456789101112131415161718192021222324ListNode* addTwoNumbers(ListNode* p, ListNode* q) &#123; ListNode head; ListNode* last = &amp;head; int sum = 0, carry = 0; while(p || q) &#123; if(p) &#123; sum += p-&gt;val; p = p-&gt;next; &#125; if(q) &#123; sum += q-&gt;val; q = q-&gt;next; &#125; sum += carry; last-&gt;next = new ListNode(sum % 10); last = last-&gt;next; carry = sum / 10; sum = 0; &#125; if(carry &gt; 0) &#123; last-&gt;next = new ListNode(carry); &#125; return head.next;&#125; 445. Add Two Numbers II 给定两个表示两个非负整数的非空链表。 高位数字在前，并且它们的每个节点都包含一个数字。 将两个数字相加，然后将其作为链表返回。 如果无法修改输入列表怎么办？ 换句话说，不允许反转列表。 Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 12345678910111213141516171819202122232425262728293031323334// 借助栈后进先出的特性即可// 只不过插入新节点的时候注意插在头部// 另外将外面的两个 while 循环拿进去, 减少重复代码, 更优美ListNode* addTwoNumbers(ListNode* p, ListNode* q) &#123; stack&lt;ListNode*&gt; pStack, qStack; while(p) &#123; pStack.push(p); p = p-&gt;next; &#125; while(q) &#123; qStack.push(q); q = q-&gt;next; &#125; ListNode* head = nullptr; int carry = 0; while(!pStack.empty() || !qStack.empty()) &#123; int sum = 0; if(!pStack.empty()) &#123; sum += pStack.top()-&gt;val; pStack.pop(); &#125; if(!qStack.empty()) &#123; sum += qStack.top()-&gt;val; qStack.pop(); &#125; sum += carry; head = new ListNode(sum % 10, head); carry = sum / 10; &#125; if(carry &gt; 0) &#123; head = new ListNode(carry, head); &#125; return head;&#125; 1721. Swapping Nodes in a Linked List 给定一个链表的头以及一个整数k。将从头开始第k个节点的值与从结尾开始第k个节点的值交换，返回链表的头。 Input: head = [1, 2, 3, 4, 5], k = 2Output: [1, 4, 3, 2, 5] 123456789101112131415161718// 左右双指针的解法ListNode* swapNodes(ListNode* head, int k) &#123; ListNode* left = nullptr; ListNode* p = head; while(--k &gt; 0) &#123; p = p-&gt;next; &#125; left = p; // 此时 left 指向从左边数第 k 个节点 ListNode* right = head; while(p-&gt;next) &#123; right = right-&gt;next; p = p-&gt;next; &#125; // 此时 right 指向从右边数第 k 个节点 swap(left-&gt;val, right-&gt;val); return head;&#125; 109. Convert Sorted List to Binary Search Tree 给定一个单链表的头，其中元素按升序排序，请将其转换为高度平衡的BST。结果不唯一。 在此处，高度平衡的二叉树定义为这样一棵二叉树，其中每个节点的两个子树的深度相差不超过1。 12345678910111213141516171819202122232425262728293031// 基本思想是将链表的左半部分节点作为 BST 的左子树, 右半部分节点作为 BST 的右子树,// 然后进行递归调用就可以了, 每次只需要处理中间节点即可// 这样可保证 BST 是高度平衡的// 同样的, 如果给的是有序数组, 也可以利用将中间元素构造成根节点的递归思路// 分治的思路, 所以时间复杂度为 O(nlogn), 递推式为 T(n) = T(n/2) + O(n)// 递归过程中空间复杂度取决于树的最大深度为 O(logn)TreeNode* sortedListToBST(ListNode* head) &#123; if(!head) &#123; return nullptr; &#125; if(!head-&gt;next) &#123; return new TreeNode(head-&gt;val); &#125; // 先定位到链表的中间节点 ListNode* slow = head; ListNode* fast = head; ListNode* preSlow = head; while(fast &amp;&amp; fast-&gt;next) &#123; preSlow = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; // 此时 slow 指向中间节点, preSlow 指向其前一节点 // 将左半部分子链表分离 preSlow-&gt;next = nullptr; // 将中间节点构建成 BST 的根节点 TreeNode* root = new TreeNode(slow-&gt;val); root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(slow-&gt;next); return root;&#125; 123456789101112131415161718192021// 上一方法时间复杂度的瓶颈在于寻找中间节点// 由于构造出来的二叉搜索树的中序遍历结果就是给定的链表// 因此, 我们假想二叉搜索树已经存在了// 对此二叉搜索树进行中序遍历, 遍历的同时更新树中的节点TreeNode* sortedListToBST(ListNode* head) &#123; int size = 0; for(ListNode* temp = head; temp; temp = temp-&gt;next, size++); auto inOrder = [&amp;](auto&amp;&amp; inOrder, int left, int right) &#123; if(left &gt; right) &#123; return (TreeNode*)nullptr; &#125; int mid = left + (right - left) / 2; TreeNode* root = new TreeNode; root-&gt;left = inOrder(inOrder, left, mid - 1); root-&gt;val = head-&gt;val; head = head-&gt;next; root-&gt;right = inOrder(inOrder, mid + 1, right); return root; &#125;; return inOrder(inOrder, 0, size - 1);&#125; 141. Linked List Cycle 给定链表的头节点，确定链表中是否有环。如果链表中有一个循环，则返回true。 否则，返回false。 12345678910111213141516// 快慢指针bool hasCycle(ListNode* head) &#123; ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; // 慢指针每次走一步 slow = slow-&gt;next; // 快指针每次走两步 fast = fast-&gt;next-&gt;next; // 如果相遇就有环 if(slow == fast) &#123; return true; &#125; &#125; return false;&#125; 142. Linked List Cycle II 给定一个链表头节点，返回环开始的节点。 如果没有环，则返回null。 第一次相遇时，假设慢指针slow走了k步，那么快指针fast一定走了2k步： fast一定比slow多走了k步，这多走的k步其实就是fast指针在环里转圈圈，所以k的值就是环长度的「整数倍」。设相遇点距环的起点的距离为m，那么环的起点距头结点head的距离为k - m，也就是说如果从head前进k - m步就能到达环起点。 巧的是，如果从相遇点继续前进k - m步，也恰好到达环起点。你甭管fast在环里到底转了几圈，反正走k步可以到相遇点，那走k - m步一定就是走到环起点了： 123456789101112131415161718192021ListNode* detectCycle(ListNode* head) &#123; ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast) &#123; break; &#125; &#125; // 如果不是因为相遇才出循环的 if(fast == nullptr || fast-&gt;next == nullptr) &#123; return nullptr; &#125; slow = head; while(slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow;&#125; 876. Middle of the Linked List 给定一个链表头节点，返回链表的中间节点。 可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。当链表的长度是奇数时，slow恰巧停在中点位置；如果长度是偶数，slow最终的位置是中间偏右。 链表的归并排序：对于链表，合并两个有序链表是很简单的，难点就在于二分。但是现在知道了找到链表的中点的方法，就能实现链表的二分了。 123456789101112// 版本一// 节点个数为偶数时, 返回指向中间两个节点的第二个节点// 为奇数时返回指向中间的节点ListNode* middleNode(ListNode* head) &#123; ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125; 123456789101112// 版本二, 在写链表的归并排序时, 要用这个版本!// 节点个数为偶数时, 返回指向中间两个节点的第一个节点// 为奇数时返回指向中间的节点的前一个节点ListNode* middleNode(ListNode* head) &#123; ListNode* slow = nullptr; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow ? slow-&gt;next : head; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125; 19. Remove Nth Node From End of List 给定一个链表，删除链表的倒数第n个节点，并且返回链表的头结点。 Example: 12&gt;Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2&gt;Output: [1,2,3,5] 12345678910111213141516ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* slow = head; ListNode* fast = head; while(n-- &gt; 0 &amp;&amp; fast) &#123; fast = fast-&gt;next; &#125; if(!fast) &#123; return head-&gt;next; &#125; while(fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return head;&#125; 160. Intersection of Two Linked Lists 给定两个单链列表headA和headB的头，返回两个列表相交的节点。 如果两个链接列表完全没有交集，则返回null。 例如，以下两个链接列表开始在节点c1处相交： 1234567891011121314151617181920212223242526272829303132333435// 先制造出一个环来, 再借助返回环起点的思路ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123; if(!headA || !headB) &#123; return nullptr; &#125; ListNode* p = headA; while(p-&gt;next) &#123; p = p-&gt;next; &#125; // 将 A 链表的首尾相连成环 p-&gt;next = headA; ListNode* slow = headB; ListNode* fast = headB; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow == fast) &#123; break; &#125; &#125; // 如果没有相遇, 说明原先不存在交点 if(!fast || !fast-&gt;next) &#123; // 恢复链表 A p-&gt;next = nullptr; return nullptr; &#125; slow = headB; while(slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; // 最后别忘了恢复链表 A p-&gt;next = nullptr; return slow;&#125; 123456789// 很秀的思路ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *A = headA, *B = headB; while(A != B) &#123; A = A ? A-&gt;next : headB; B = B ? B-&gt;next : headA; &#125; return A;&#125; 328. Odd Even Linked List 给定一个单链列表的头，将所有具有奇数索引的节点组合在一起，然后再加上具有偶数索引的节点，然后返回重新排序的列表。 第一个节点被认为是奇数，第二个节点被认为是偶数，依此类推。请注意，偶数和奇数组中的相对顺序应保持输入中的原样。 Could you solve it in O(1) space complexity and O(nodes) time complexity? 12345678910111213141516ListNode* oddEvenList(ListNode* head) &#123; if(head == nullptr) &#123; return head; &#125; ListNode* oddLast = head; ListNode* evenHead = head-&gt;next; ListNode* evenLast = evenHead; while(evenLast &amp;&amp; evenLast-&gt;next) &#123; oddLast-&gt;next = evenLast-&gt;next; oddLast = oddLast-&gt;next; evenLast-&gt;next = oddLast-&gt;next; evenLast = evenLast-&gt;next; &#125; oddLast-&gt;next = eHead; return head;&#125; 234. Palindrome Linked List 给定一个单链表的头节点，如果它是回文链表，则返回true。例如，下面这个就为回文链表： 123456789101112131415161718// 链表的后序遍历结合左右指针// 利用系统栈来后进先出节点bool isPalindrome(ListNode* left)&#123; bool res = true; function&lt;void(ListNode*)&gt; traverse = [&amp;](ListNode* right) &#123; if(right == nullptr) &#123; return; &#125; traverse(right-&gt;next); res = res &amp;&amp; (left-&gt;val == right-&gt;val); // 左指针前进 left = left-&gt;next; // 结束一个递归实例后, 右指针会自动后退 &#125;; traverse(left); return res;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 找到链表的中间节点// 再将后半部分链表反转, 判断bool isPalindrome(ListNode* head) &#123; // 零个或一个节点的链表默认是回文链表 if(head == nullptr || head-&gt;next == nullptr) &#123; return true; &#125; // 当链表长度为偶数时, 返回指向中间两个节点的前一个节点 // 当链表长度为奇数时, 返回指向中间节点的前一个节点 auto getPreMid = [](ListNode* head) &#123; ListNode* slow = nullptr; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow ? slow-&gt;next : head; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125;; // 迭代式反转链表 auto reverseList = [](ListNode* head) &#123; ListNode* p = nullptr; ListNode* q = head; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q;; &#125; return p; &#125;; ListNode* preMid = getPreMid(head); ListNode* headRight = preMid-&gt;next; preMid-&gt;next = nullptr; headRight = reverseList(headRight); ListNode* curNode = headRight; bool res = true; while(curNode &amp;&amp; head) &#123; if(curNode-&gt;val != head-&gt;val) &#123; res = false; break; &#125; curNode = curNode-&gt;next; head = head-&gt;next; &#125; preMid-&gt;next = reverseList(headRight); return res;&#125; 21. Merge Two Sorted Lists 合并两个有序的链表，并将合并结果作为有序链表返回。 12345678910111213141516171819// 迭代解法ListNode* mergeTwoLists(ListNode* p, ListNode* q) &#123; // 辅助节点 ListNode head; ListNode* last = &amp;head; while(p &amp;&amp; q) &#123; if(p-&gt;val &lt;= q-&gt;val) &#123; last-&gt;next = p; p = p-&gt;next; &#125; else &#123; last-&gt;next = q; q = q-&gt;next; &#125; last = last-&gt;next; &#125; last-&gt;next = p ? p : q; return head.next;&#125; 12345678910111213141516171819// 递归解法ListNode* mergeTwoLists(ListNode* p, ListNode* q) &#123; if(!p) &#123; return q; &#125; if(!q) &#123; return p; &#125; ListNode* head = nullptr; if(p-&gt;val &lt;= q-&gt;val) &#123; head = p; p-&gt;next = mergeTwoLists(p-&gt;next, q); &#125; else &#123; head = q; q-&gt;next = mergeTwoLists(p, q-&gt;next); &#125; return head;&#125; 23. Merge k Sorted Lists 给定一个由k个链表头节点所组成的数组，每个链表以升序排列。将所有链表合并为一个排序的链表，然后将其返回。 Example 1: 12345678910Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]Explanation: The linked-lists are:[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]merging them into one sorted list:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 1234567891011121314151617181920212223242526272829// 将这 k 个头节点交给优先级队列管理// 优先级队列采用最小堆, 以节点内的值为排序对象// 这样每次 pop 的时候保证总是全局所有节点中最小的节点出队ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; // C++ 中提供的 priority_queue 默认采用最大堆, 这里需要定制成最小堆 auto cmp = [](ListNode* a, ListNode* b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq(cmp); // 所有头节点移交给 priority_queue 管理 for(int i = 0; i &lt; lists.size(); i++) &#123; if(lists[i]) &#123; pq.push(lists[i]); &#125; &#125; // 辅助节点 ListNode head; ListNode* p = &amp;head; while(!pq.empty()) &#123; // 每次将全局最小节点入链出队 p-&gt;next = pq.top(); pq.pop(); p = p-&gt;next; // 放进去的将是最近入链出队的节点的下一个节点 // 这样才能保证在队列中的是全局最小的 k 个节点 if(p-&gt;next) &#123; pq.push(p-&gt;next); &#125; &#125; return head.next;&#125; 430. Flatten a Multilevel Doubly Linked List 给定一个双向链表，该链表除了拥有指向下一个节点和上一个节点的指针外，还具有一个孩子指针，该孩子指针可能指向也可能不指向单独的双向链接列表。 这些子链表可能有一个或多个自己的子链表，依此类推，以产生一个多级数据结构，如下面的示例所示： 展平链表，以便所有节点都出现在单级双链表中。 返回链表的头。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*// Definition for a Node.class Node &#123; int val; Node* prev; Node* next; Node* child; Node() &#123;&#125; Node(int _val, Node* _prev, Node* _next, Node* _child) &#123; val = _val; prev = _prev; next = _next; child = _child; &#125;&#125;;*/// 将题目中的孩子节点看做左孩子, 下一节点看作右孩子Node* flatten(Node* p) &#123; if(!p) &#123; return p; &#125; // 辅助节点 Node head(0, nullptr, nullptr, nullptr); Node* last = &amp;head; stack&lt;Node*&gt; s; s.push(p); while(!s.empty()) &#123; Node* cur = s.top(); s.pop(); last-&gt;next = cur; cur-&gt;prev = last; if(cur-&gt;next) &#123; s.push(cur-&gt;next); &#125; if(cur-&gt;child) &#123; s.push(cur-&gt;child); cur-&gt;child = nullptr; &#125; last = last-&gt;next; &#125; head.next-&gt;prev = nullptr; return head.next;&#125; 61. Rotate List 给定一个单链表的头节点，将链表向右旋转k个位置。 Example 1: 12Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2Output: [4,5,1,2,3] Example 2: 12Input: head &#x3D; [0,1,2], k &#x3D; 4Output: [2,0,1] Example 1 Example 2 12345678910111213141516171819202122232425262728293031323334// 首先要注意到:// 1. 旋转了几次, 就会有末尾的几个节点整体次序不变的被平移到前面// 2. 如果旋转了链表长度的倍数次, 链表将恢复原样ListNode* rotateRight(ListNode* head, int k) &#123; if(!head || k == 0) &#123; return head; &#125; ListNode* last = head; // 获取链表的长度, 并将 last 定位至尾节点 int size = 1; while(last-&gt;next) &#123; last = last-&gt;next; size++; &#125; // 计算实际旋转的次数 k = k % size; // 如果待旋转次数为链表长度的倍数, 不需要旋转 if(k == 0) &#123; return head; &#125; // 计算新的头节点为第几个节点 k = size - k; // 将 q 定位到新的头节点的前一个节点 ListNode* preNewHead = head; while(--k &gt; 0) &#123; preNewHead = preNewHead-&gt;next; &#125; // start 为新的头节点 ListNode* newHead = preNewHead-&gt;next; // 前后接在一块即可 preNewHead-&gt;next = nullptr; last-&gt;next = head; return newHead;&#125; 138. Copy List with Random Pointer 给你一个长度为n的链表，每个节点包含一个额外增加的随机指针random，该指针可以指向链表中的任何节点或空节点。 构造这个链表的深拷贝。 深拷贝应该正好由n个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的next指针和random指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。 例如，如果原链表中有X和Y两个节点，其中X.random --&gt; Y。那么在复制链表中对应的两个节点x和y，同样有x.random --&gt; y。 返回复制链表的头节点。 用一个由n个节点组成的链表来表示输入/输出中的链表。每个节点用一个[val, random_index]表示： val：一个表示Node.val的整数。 random_index：随机指针指向的节点索引（范围从0到n - 1）；如果不指向任何节点，则为null。 你的代码只接受原链表的头节点head作为传入参数。 123456789101112// Definition for a Node.class Node &#123;public: int val; Node *next; Node *random; Node(int _val) &#123; val = _val; next = NULL; random = NULL; &#125; &#125;; Example 1: 12 Input: head &#x3D; [[3,null],[3,0],[3,null]]&gt;Output: [[3,null],[3,0],[3,null]] Example 2: 12 Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]&gt;Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] 12345678910111213141516171819202122232425262728293031323334353637383940// 直接从头节点通过 next 指针, 向后一个一个遍历就可以了// 先拷贝当前节点, 在判断当前节点的 random 指针是否为空// 如果为空, 直接跳到下一个节点就可以了// 如果不为空, 那就将 random 节点 new 一份// 注意当前节点的 random 节点可能已经遍历过或者啊还没有遍历// 1. 如果已经遍历过, 此时只需要将当前节点的拷贝节点的 random 指向它就可以了// 那么我们怎么获取已经遍历过的节点的拷贝节点的指针呢？// 2. 如果没有被遍历过, 直接 new 出来, 再将当前节点的拷贝节点的 random 指向它就行// 但是, 下次通过 next 指针遍历到它的时候, 不能再 new 了, 因为它已经存在了// 解决这个问题的方法就是借助哈希表在遍历的过程中记录当前节点和其拷贝节点之间的映射// 这样在每次遍历新节点的时候先判断是否已经被 new 出来过了// 下面直接看代码吧, 有详细注释Node* copyRandomList(Node* head) &#123; // 记录节点与其拷贝节点之间的映射 unordered_map&lt;Node*, Node*&gt; mapping; // 辅助节点, 方便插入新节点和最后返回 Node helper(0); // last 之后一直指向新链表的尾节点 Node* last = &amp;helper; while(head) &#123; if(mapping.count(head) == 0) &#123; // 如果没有, 需要重新 new 一个 mapping[head] = new Node(head-&gt;val); &#125; last-&gt;next = mapping[head]; // 如果当前节点指向了一个随机节点 // 就要为它的拷贝节点也要指向一个随机节点 if(head-&gt;random) &#123; // 如果这个随机节点没有 new 过 if(mapping.count(head-&gt;random) == 0) &#123; mapping[head-&gt;random] = new Node(head-&gt;random-&gt;val); &#125; last-&gt;next-&gt;random = mapping[head-&gt;random]; &#125; // 新旧链表当前节点指针同步前进一步 head = head-&gt;next; last = last-&gt;next; &#125; return helper.next;&#125; 123456789101112131415161718192021222324// 这种解法也是建立映射, 但思路有点差别, 这里用两次 O(n) 遍历// 第一次遍历建立所有节点到其拷贝节点的映射, 第一次遍历完所有节点都被 new 过了// 第二次遍历将拷贝节点的 next 指针和 random 指针安置妥当Node* copyRandomList(Node* head) &#123; if(!head) &#123; return nullptr; &#125; // 建立 “原节点 -&gt; 新节点” 的映射 unordered_map&lt;Node*, Node*&gt; mapping; Node* cur = head; while(cur) &#123; mapping[cur] = new Node(cur-&gt;val); cur = cur-&gt;next; &#125; cur = head; // 构建新链表的 next 和 random 指向 while(cur) &#123; mapping[cur]-&gt;next = mapping[cur-&gt;next]; mapping[cur]-&gt;random = mapping[cur-&gt;random]; cur = cur-&gt;next; &#125; // 返回新链表的头节点 return mapping[head];&#125; 1019. Next Greater Node In Linked List 给出一个以头节点head作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。 每个节点都可能有下一个更大值（next larger value）：对于node_i，如果其next_larger(node_i)是node_j.val，那么就有j &gt; i且node_j.val &gt; node_i.val，而j是可能的选项中最小的那个。如果不存在这样的j，那么下一个更大值为0。 Example 1: 12Input: [2,1,5]Output: [5,5,0] Example 2: 12Input: [2,7,4,3,5]Output: [7,0,5,5,0] 1234567891011121314151617181920212223242526272829// 像这种下一个最大元素之类的问题, 一定用的是单调栈的技巧// 有几道数组的题目是找下一个最大元素// 这里给换成了链表了, 换汤不换药// 这里主要学习的技术是链表的后序遍历// 对的, 链表就是一种特殊的二叉树嘛// 链表的后序遍历就是从后向前访问节点// 你当然可以用栈来完成// 这里用递归完成vector&lt;int&gt; nextLargerNodes(ListNode* head) &#123; vector&lt;int&gt; res; stack&lt;int&gt; s; function&lt;void(ListNode*)&gt; traverse = [&amp;](ListNode* head) &#123; if(head) &#123; // 先不访问节点, 递归去下一个节点 traverse(head-&gt;next); // 后序遍历代码 // 下面代码都是是固定的单调栈算法的模板 while(!s.empty() &amp;&amp; s.top() &lt;= head-&gt;val) &#123; s.pop(); &#125; res.push_back(s.empty() ? 0 : s.top()); s.push(head-&gt;val); &#125; &#125;; traverse(head); // 最后需要反转一下 reverse(res.begin(), res.end()); return res;&#125; 148. Sort List 链表的排序。这里分别给出归并排序的递归版、迭代版以及快速排序版本。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 归并排序, 递归解法// T: O(nlogn), S: O(logn)ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) &#123; return head; &#125; ListNode* mid = getMid(head); ListNode* head1 = mid-&gt;next; mid-&gt;next = nullptr; return merge(sortList(head), sortList(head1));&#125;// // 这里的 bug 是如果链表的长度为 2// // 永远返回的是指向第 2 个元素的指针// // 对这个链表的归并排序将永远循环下去!// // tmd 卡了我半天, 艹!// ListNode* getMid(ListNode* head)// &#123;// ListNode* slow = head;// ListNode* fast = head;// while(fast &amp;&amp; fast-&gt;next)// &#123;// slow = slow-&gt;next;// fast = fast-&gt;next-&gt;next;// &#125;// return slow;// &#125;// 这是修正后的版本ListNode* getMid(ListNode* head) &#123; ListNode* slow = nullptr; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow ? slow-&gt;next : head; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125;ListNode* merge(ListNode* p, ListNode* q) &#123; ListNode helper; ListNode* last = &amp;helper; while(p &amp;&amp; q) &#123; if(p-&gt;val &lt; q-&gt;val) &#123; last-&gt;next = p; p = p-&gt;next; &#125; else &#123; last-&gt;next = q; q = q-&gt;next; &#125; last = last-&gt;next; &#125; last-&gt;next = p ? p : q; return helper.next;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 归并排序, 迭代解法// T: O(nlogn), S: O(1)// nextSublist 始终指向后续待归并的链表的头节点ListNode* nextSublist = nullptr;// tail 始终指向已经归并好的局部子链表的尾节点ListNode* tail = nullptr;ListNode* sortList(ListNode* head) &#123; int size = 0; for(ListNode* temp = head; temp; temp = temp-&gt;next) &#123; size++; &#125; // 辅助头节点 ListNode helper; helper.next = head; // 从长度为 1 开始, 每次成倍增长地归并子链表 for(int i = 1; i &lt; size; i *= 2) &#123; ListNode* start = &amp;helper; nextSublist = helper.next; while(nextSublist) &#123; // 划出 i 个有序节点组成一个链表 ListNode* list1 = split(nextSublist, i); // 再划出 i 个有序节点组成一个链表 ListNode* list2 = split(nextSublist, i); // 将这划分出来的两个相邻有序链表合并 start-&gt;next = merge(list1, list2); start = tail; &#125; &#125; return helper.next;&#125;// 从 head 链表前面划出 size 长度的子链表出来ListNode* split(ListNode* head, int size) &#123; if(!head) &#123; return head; &#125; ListNode* p = head; while(--size &gt; 0 &amp;&amp; p) &#123; p = p-&gt;next; &#125; if(p) &#123; // 这里说明 size 小于 head 链表的长度 // 现在 p 指向被划出来链表的尾节点 nextSublist = p-&gt;next; p-&gt;next = nullptr; &#125; else &#123; // 如果 size 大于 head 链表的长度 // 说明已经有序了 nextSublist = nullptr; &#125; return head;&#125;// 合并两个有序链表, 和递归版本的没区别// 主要是要更新 tail 指针ListNode* merge(ListNode* p, ListNode* q) &#123; ListNode helper; ListNode* last = &amp;helper; while(p &amp;&amp; q) &#123; if(p-&gt;val &lt; q-&gt;val) &#123; last-&gt;next = p; p = p-&gt;next; &#125; else &#123; last-&gt;next = q; q = q-&gt;next; &#125; last = last-&gt;next; &#125; last-&gt;next = p ? p : q; // 更新 tail 指针, 使其指向这被合并完成的有序链表的尾节点 while(last-&gt;next) &#123; last = last-&gt;next; &#125; tail = last; return helper.next;&#125; 123456789101112131415161718192021222324252627282930313233343536373839// 快速排序版本, 最坏时间复杂度为 O(n2), 超时!ListNode* sortList(ListNode* head) &#123; // 接收一个左闭右开区间 [left, right) auto qs = [&amp;] (auto&amp;&amp; qs, ListNode* left, ListNode* right) &#123; if(left == right || left-&gt;next == right) &#123; return left; &#125; // 取首节点元素为基准值 // 凡小于此值的节点以头插法插入到左边 // 凡大于此值的节点以尾插法插入到右边 ListNode* pivot = left; ListNode* cur = left-&gt;next; ListNode* tail = pivot; while(cur != right) &#123; ListNode* temp = cur-&gt;next; if(cur-&gt;val &lt; pivot-&gt;val) &#123; // 头插法 cur-&gt;next = left; left = cur; &#125; else &#123; // 尾插法 tail-&gt;next = cur; tail = cur; &#125; cur = temp; &#125; // 这行很重要, tail 一直指向右边链表的尾节点 // 要把开区间的之后的节点们接到它后面 tail-&gt;next = right; // 此时, head 指向新链表的头节点 // p 指向新链表的基准节点, 以基准节点作为右边链表的开区间尾元素进行下一次递归调用 ListNode* newHead = qs(qs, left, pivot); // 跳过已经归位的基准节点 pivot-&gt;next = qs(qs, pivot-&gt;next, right); return newHead; &#125;; return qs(qs, head, nullptr);&#125; 143. 重排链表 - 力扣（LeetCode） 给定一个单链表L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为：L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 Constraints: The number of nodes in the list is in the range [1, 5*10^4]. 1 &lt;= Node.val &lt;= 1000 Example 1: 12Input: head &#x3D; [1,2,3,4,5]Output: [1,5,2,4,3] Example 2: 12Input: head &#x3D; [1,2,3,4]Output: [1,4,2,3] 12345678910111213141516171819202122232425// 双端队列解法// 时间和空间复杂度均为 O(n)void reorderList(ListNode* head) &#123; deque&lt;ListNode*&gt; dq; while(head) &#123; dq.push_back(head); head = head-&gt;next; &#125; ListNode helper; ListNode* last = &amp;helper; while(dq.size() &gt; 1) &#123; last-&gt;next = dq.front(); dq.pop_front(); last = last-&gt;next; last-&gt;next = dq.back(); dq.pop_back(); last = last-&gt;next; &#125; if(!dq.empty()) &#123; last-&gt;next = dq.front(); last = last-&gt;next; &#125; last-&gt;next = nullptr; head = helper.next;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1. 找到链表中点// 2. 反转后半部分链表// 3. 合并两部分链表void reorderList(ListNode* head) &#123; if(head) &#123; ListNode* mid = middleNode(head); ListNode* q = mid-&gt;next; mid-&gt;next = nullptr; q = reverseList(q); mergeList(head, q); &#125;&#125;// 节点个数为偶数时, 返回指向中间两个节点的第二个节点// 为奇数时返回指向中间的节点ListNode* middleNode(ListNode* head) &#123; ListNode* slow = head; ListNode* fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow;&#125;ListNode* reverseList(ListNode* head) &#123; ListNode* p = nullptr; ListNode* q = nullptr; while(head) &#123; q = head-&gt;next; head-&gt;next = p; p = head; head = q; &#125; return p;&#125;void mergeList(ListNode* p, ListNode* q) &#123; ListNode* p_next = nullptr; ListNode* q_next = nullptr; while(p &amp;&amp; q) &#123; p_next = p-&gt;next; q_next = q-&gt;next; p-&gt;next = q; p = p_next; q-&gt;next = p; q = q_next; &#125;&#125; 2.24 82. Remove Duplicates from Sorted List II 存在一个按升序排列的链表，给你这个链表的头节点head，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中没有重复出现的数字。 返回同样按升序排列的结果链表。 Example 1: 12&gt;Input: head &#x3D; [1,2,3,3,4,4,5]&gt;Output: [1,2,5] Example 2: 12&gt;Input: head &#x3D; [1,1,1,2,3]&gt;Output: [2,3] 1234567891011121314151617181920ListNode* deleteDuplicates(ListNode* head) &#123; if(head == nullptr) &#123; return head; &#125; ListNode helper(0, head); ListNode* last = &amp;helper; while(last-&gt;next) &#123; ListNode* temp = last-&gt;next-&gt;next; while(temp &amp;&amp; temp-&gt;val == last-&gt;next-&gt;val) &#123; temp = temp-&gt;next; &#125; if(temp == last-&gt;next-&gt;next) &#123; last = last-&gt;next; &#125; else &#123; last-&gt;next = temp; &#125; &#125; return helper.next;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://yuanlehome.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://yuanlehome.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"认识C++内存管理的工具 （三）","date":"2020-07-18T13:35:42.000Z","path":"gMOP9F0b8zMZULMj/","text":"13. 重载类本身的operator new/delete1234567891011121314151617181920212223242526272829303132333435363738394041using namespace std;struct A&#123; A() &#123; cout &lt;&lt; \"A() : this:\" &lt;&lt; this &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A(): this: \" &lt;&lt; this &lt;&lt; endl; &#125; // 这个函数写不写 static 都会被编译器做成 static static void* operator new(size_t len) &#123; return malloc(len); &#125; static void operator delete(void* ptr, size_t len) &#123; return free(ptr); &#125;&#125;;int main()&#123; // 调用 A::operator new 版本 A* a = new A(); // 调用全局的 operator new, 如果想调用 A 的版本, 则需显式调用 A::operator new() void* b = operator new(sizeof(A)); A* c = ::new A(); // 调用全局的 operator new void* d = ::new A(); // 调用全局的 operator new delete a; // 先调用 A 的析构函数, 再调用 A 的 operator delete delete b; // 直接调用了全局的 operator delete ::delete c; ::delete d;&#125; 14. 本质就是重载newnew是关键字，编译器看到new，会转换成operator new的调用。 15. 重载new()/delete() 16. 关于多参new对应的delete 上面重载了参数不一的operator new()，那是不是要重载对应的operator delete()呢？ 理论上delete的工作只是为了释放内存，所以只需要一个指针就可以了，但C++在语法上支持多参的delete重载，但delete的调用格式只有delete ptr，所以关于重载的delete版本什么时候被调用，并不是用户手动调用，而是对应版本的Ctor发生异常后，会由crt来调用对应的delete。 17. basic_string使用new(extra)扩充申请量 18. new_handler","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"C++内存管理","slug":"C-内存管理","permalink":"https://yuanlehome.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"认识C++内存管理的工具 （二）","date":"2020-07-08T13:35:42.000Z","path":"vgFO35JETZ2jRu74/","text":"7. 构造和析构的直接调用方式通过指针不可以直接调用构造函数，但可以直接调用析构函数。可以通过placement new来直接调用构造函数。 123456789101112131415161718192021struct A&#123; int a; int b; A(int _a, int _b) : a(_a), b(_b) &#123;&#125;&#125;;int main()&#123; A* tmp_a = new A(2, 8); // tmp-&gt;A::A(2, 8); // error! cannot call constructor 'A::A' directly tmp_a-&gt;~A(); // 可以的 // 虽然调用了析构函数, 但事实上 tmp_a 的空间并没有释放 // 因为没有 free 掉, 那块内存还在, 值没有被重写 // 所以可以访问 通过 tmp_a 访问原对象的值 // 如果是 delete tmp_a; 就不能访问 // 因为 delete 调用完析构函数之后, 还调用了 free 函数释放那块内存 cout &lt;&lt; tmp_a-&gt;a &lt;&lt; endl; // 所有这里访问的值看似没有变化&#125; 8. array new/deletenew []/delete[]本质调用malloc/free。malloc/free细节： 除了分配给定的内存之外，还会有cookie——用来记录分配数组的长度，查看cookie中的长度，然后调用适当次数的析构函数 所谓内存泄漏 对于一个new []，需要有相应的delete []，本质上cookie记录了free本身需要释放的内存大小，泄露则发生在调用的析构函数次数上：如果对象含有指针的data member，指向堆上的内存，则意味着析构函数是nontrival，需要再析构函数中释放指针指向的内存，反之则是trival的，而析构函数的调用次数，则会影响指针指向的内存部分的泄露。 9. placement new标准不允许直接用指针调用构造函数，但给出了另一种调用语法，可以在现有的对象的内存中调用构造函数，它不会分配新的内存。这也是没有对应的placement delete的原因。 10. C++程序分配内存的途径 从图中可以看出，当出现new Foo(x)后，编译器会检查Foo这个类有没有实现operator new(size_t)的static函数，如果有就会调用Foo这个版本的operator new，如果没有就调用全局的::operator new，delete也是如此。 所以可以为一个类单独实现operator new和operator delete。也可以重载全局的operator new/delete，但很少这么做，因为全局的版本是照顾所有的类。 11. 探究operator new12345678910111213int main()&#123; A* a = new A(); new (a) A(27, 224); void* b = ::operator new(sizeof(A)); cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; a-&gt;a &lt;&lt; endl; cout &lt;&lt; a-&gt;b &lt;&lt; endl;&#125;// 汇编代码如下: 12. 重载::operator new/delete上面说了，重载全局的operator new/delete影响深远，谨慎使用。但可以重载，方法是在非namespace中声明和全局版本相同的函数签名。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using namespace std;struct A&#123; int a; int b; A() &#123; cout &lt;&lt; \"A() : this:\" &lt;&lt; this &lt;&lt; endl; &#125; A(int _a, int _b) : a(_a), b(_b) &#123; cout &lt;&lt; \"A(int,int): this: \" &lt;&lt; this &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A(): this: \" &lt;&lt; this &lt;&lt; endl; &#125;&#125;;// 以下 4 个函数就在当前的文件中声明定义inline void* operator new(size_t len)&#123; return malloc(len); &#125;inline void* operator new[](size_t len)&#123; return malloc(len);&#125;inline void operator delete(void* ptr)&#123; return free(ptr);&#125;inline void operator delete[](void* ptr)&#123; return free(ptr);&#125;int main()&#123; A* a = new A(); // 调用到上面自定义的 operator new void* b = ::operator new(sizeof(A)); // 虽然指定的是 ::operator new, 但还是调用到上面自定义的版本 // 对于 a 是正确的释放, 先调用 A 的析构函数, 再调用上面的 operator delete delete a; // 对于 b, 释放的操作应该显示调用 operator delete // 这里用 delete 后, 并没有调用 A 的析构函数, 而是直接调用了 operator delete // 可见编译器对于 delete void* 的时候, 是直接转换为 opreator delete delete b;&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"C++内存管理","slug":"C-内存管理","permalink":"https://yuanlehome.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"认识C++内存管理的工具 （一）","date":"2020-06-28T13:35:42.000Z","path":"kZo0999uFp6r1QI2/","text":"1. 内存管理函数的层次从下图中可以看到，C++程序员处于的位置是最上层的Applications，用的最多的是new，new[]，如果用容器，则内存基本不用管理。其次也可以调用malloc。至于最底层的操作系统级别的API，没有可移植性。它们之间的调用关系如上图的箭头所示。 2. Memory primitives分类 分配 释放 所属 可否重载 malloc free C函数 否 new delete C++表达式 否 ::operator new() ::operator delete() C++函数 可 allocator&lt;T&gt;::allocate() allocator&lt;T&gt;::deallocate() STL分配器 可以自己设计搭配容器 123456789101112131415161718void primitives_sample()&#123; // CRT 运行时函数 void *p1 = malloc( 512 ); free( p1 ); // new complex&lt;int&gt; *p2 = new complex&lt;int&gt;; delete p2; // ::operator new() 全局函数, 可被重载 void *p3 = ::operator new( sizeof( int ) ); // 内部调用 malloc ::operator delete( p3 ); //内部调用delete // allocator 分配器, STL 容器分配内存的方式 void *p4 = allocator&lt;int&gt;().allocate( 7 ); allocator&lt;int&gt;().deallocate( (int *)p4, 7 );&#125; 3. new的初步探究c++的程序员基本都会用new来为对象分配一个堆内存，并且new会调用对应的构造函数，构造函数是用来初始化对象的，所以总结出new的功能是： 在堆中分配一块指定对象大小的内存 将返回的指针转换为指向对象类型的指针 通过指针调用对象相应的构造函数 4. 测试new的调用流程12345678910111213struct A&#123; int a; int b; A() &#123;&#125; A(int _a, int _b): a(_a), b(_b) &#123;&#125;&#125;;int main()&#123; A* tmp_a = new A(2, 8); delete tmp_a;&#125; 上面的4张图是在MSVC中反汇编的运行时代码。从第1张图可以看出，new调用了operator new，从第3张图可以看出，operator new内部调用了malloc。实际上编译器是在new的地方调用了对应的构造函数，并不是在new的内部，new只是编译器识别的一个标识符，并不是函数，编译器看到new后会malloc，然后调用构造函数。 VS2019可以看到operator new的源码： 123456789101112131415161718192021222324_CRT_SECURITYCRITICAL_ATTRIBUTEvoid* __CRTDECL operator new(size_t const size)&#123; for (;;) &#123; if (void* const block = malloc(size)) &#123; return block; &#125; if (_callnewh(size) == 0) &#123; if (size == SIZE_MAX) &#123; __scrt_throw_std_bad_array_new_length(); &#125; else &#123; __scrt_throw_std_bad_alloc(); &#125; &#125; // The new handler was successful; try to allocate again... &#125;&#125; 上面的operator new的作用是调用malloc分配内存。当malloc成功后直接返回。当malloc失败后，并不会再次malloc，而是调用_callnewh() new_handler()，这个函数的作用是向自己定义的函数索取内存，所以new_handler可以理解为释放一些缓存，调用完new_handler后，可能释放了内存，这个时候再尝试调用malloc获取内存。 5. delete的初步探究 6. 测试delete的调用流程12345678910111213141516using namespace std;struct A&#123; int a; int b; A() &#123;&#125; A(int _a, int _b) : a(_a), b(_b) &#123;&#125; ~A() &#123;&#125;&#125;;int main()&#123; A* tmp_a = new A(2, 8); delete tmp_a;&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"C++内存管理","slug":"C-内存管理","permalink":"https://yuanlehome.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"深度探索C++对象模型之构造、析构、拷贝语意学","date":"2020-06-18T13:35:42.000Z","path":"plA8MQtWi85PlNcz/","text":"第5章：构造、析构、拷贝语意学 可以定义和调用一个纯虚函数，不过只能被静态的调用（通过类作用域运算符），不能通过虚拟机制调用。 你声明了一个纯虚析构函数，就必须定义它。因为在你提供了声明前提下，每一个derived class destructor会被编译器加以扩展，以静态调用的方式调用其“每一个virtual base class”以及“上一层base class”的destructor。因此，只要缺乏任何一个base class destructor的定义，就会导致链接失败。 读到这儿，你可能会有疑问，对于普通的类（没有虚机制参与进来，派生类的析构函数中也会逐一调用基类的析构函数）我们也没有提供它析构函数的，那为什么不会导致链接失败呢？这是因为你没有写析构函数，编译器会默默给你提供一个，以便于在后面的派生类的析构函数中调用它。这里的重点是你没有提供，也就是说你没有声明，如果你声明了，但没有提供定义，同样会导致链接失败。 对于基类该不该将虚函数定义为const的，作者不建议。因为derived class中可能会修改自己的数据成员。 5.1 无继承情况下的对象构造当编译器遇到这样的定义： 1Point global; 在C之中，global被视为一个“临时性的定义”，因为它没有明确的初始化操作。一个“临时性的定义”可以在程序中发生多次。那些实例会被链接器折叠起来，只留下单独一个实体，被放在程序data segment中一个“特别保留给未初始化之global objects使用”的空间。由于历史的缘故，这块空间被称为BSS，是Block Started by Symbol的缩写。 而global在C++中被视为完全定义（它会阻止第二个或更多个定义）。C和C++的一个差异就在于，BSS data segment在C++中相对地不重要。C++的所有全局对象都被当作“初始化过的数据”来对待。 为继承做准备 虚函数的引入不仅仅是每个类对象增加了一个vptr，而且会引发编译器对类产生膨胀作用。我们所定义的构造函数，编译器会附加一些代码，以便vptr初始化。合成一个copy constructor和一个copy assignment operator，它们都不是trival。因为，如果point类对象被初始化或以一个派生类对象赋值，bitwise操作就存在问题了，vptr设置会出错。 C++编译器要求编译器尽量延迟nontrivial members的实际合成操作，直到遇到使用场合为止。如果在你的设计中存在很多以传值的方式返回局部类对象，提供一个拷贝构造函数就比较合理，因为这会触发编译器的NRV优化。 5.2 继承体系下的对象构造constructor可能内带大量的隐藏码，因为编译器会扩充每一个constructor，扩充程度视class T的继承体系而定。一般而言编译器所做的扩充操作大约如下： 记录在member initialization list中的data members初始化操作会被放进constrector的函数本身，并以members的声明顺序为顺序。 如果有数据成员为类对象，并被列于member initialization list中，那么任何明确指定的参数都应该传递过去。 如果有一个member并没有出现在member initialization list之中，但它有一个default constructor，那么该default constructor必须被调用。 在那之前，如果class object有vptr，它（们）必须被设定初值，指向适当的virtual table(s)。 在那之前，所有上一层的base class constructors必须被调用，以base class的声明顺序为序： 如果basc class被列于member initialization list中，那么任何明确指定的参数都应该传递过去。 如果base class没有被列于member initialization list中，而它有default constructor(或default memberwise copy constructor)，那么就调用之。 如果base class是多重继承下的第二或后继的base class，那么this指针必须有所调整。 在那之前，所有virtual base class constructors必须被调用，从左到右，从最深到最浅： 如果class被列于member initialization list中，那么如果有任何明确指定的参数，都应该传递过去。若没有列于list之中，而class有一个default constructor，也应该调用之。 此外，class中的每一个virtual base class subobject的偏移量必须在执行期可被存取。 如果class object是最底层（most-derived）的class，其constructors可能被调用；某些用以支持这个行为的机制必须被放进来。 说明书中接下来的章节对上面这些做了详细的叙述。全是重点，就不做总结了，自行看书。 第6章：执行期语意学很重要，不做总结了，自行看书。","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"实现一个在windows平台的定时更换壁纸的工具","date":"2020-06-14T05:00:42.000Z","path":"JFfWe2Uugfh1u70r/","text":"有没有感觉到自己的电脑桌面一成不变让人厌倦？虽然有一些诸如360桌面之类的软件可以使用，但弹窗、广告又太多！本文就教你用 python 实现一个简洁清爽的桌面壁纸定时更换工具。 本文使用的方法是用 python 实现一个定时更换壁纸的脚本，壁纸来源与自定义的文件夹内，因此你可以搜集一些你喜欢的壁纸图片放于该文件夹下，这样脚本程序便可以使你的电脑桌面轮流展示这些图片了。 比如我就把我喜欢的壁纸都收集在了 E:/wallpapers/ 文件夹下。 这里推荐几个好的壁纸来源网站 https://wallhaven.cc/ ，https://www.artstation.com/wlop 。 下面直接看代码。 1234567891011121314151617181920212223import win32conimport win32guiimport threadingimport osdef getImages(): # 这里的路径就是你放图片的文件夹路径 images_path = 'E:\\\\wallpapers\\\\' files = os.listdir(images_path) return images_path, filesdef set_wallpaper(it): path, images = getImages() image = path + images[it] it = (it + 1) % len(images) win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, image, 1+2) global timer # 我设置的是每60s更换一次，你可以根据需要自定义设置 timer = threading.Timer(60.0, set_wallpaper, (it,)) timer.start()if __name__ == '__main__': set_wallpaper(0) 为了方便运行，我们可以使用 pyinstaller 工具将该脚本程序转成 .exe 可执行文件。具体的方法可以看这篇文章 Python程序打包成exe可执行文件 。 生成可执行文件之后，运行就可以了。不过，为了每次开机程序都可以自动运行，我们需要进行一些设置。首先按 win+R 键打开运行窗口，输入 shell:startup 回车，这样会打开一个启动文件夹，这个文件夹下的软件在开机时都会自动启动，将你的可执行文件或其快捷方式放在这里就可以了。 这里可以直接下载我已经生成的可执行程序： https://pan.baidu.com/s/1ZZhG-H2nYz34TdkT6O1U0Q提取码：v9ng 使用方法就是在E盘下新建一个名为wallpapers的文件夹，然后把自己喜欢的照片放进去就好，即E:/wallpapers/ 。","tags":[{"name":"桌面壁纸工具","slug":"桌面壁纸工具","permalink":"https://yuanlehome.github.io/tags/%E6%A1%8C%E9%9D%A2%E5%A3%81%E7%BA%B8%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"https://yuanlehome.github.io/tags/python/"}]},{"title":"实现一个简易的Linux平台下的划词翻译工具","date":"2020-06-12T13:35:42.000Z","path":"KT2Sz9hHwziaJtFt/","text":"这里将要介绍的是一种在 Linux 平台实现的划词翻译工具，当然在考虑自己实现一个如此功能的工具前，本人也是在网上搜索了一些在 Linux 平台实现的类似的开源工具，例如 pdfTranslator，popup-dict，但它们的安装和配置都显得比较麻烦，而且使用起来也并不方便。 本人实现这个工具的初衷本是方便自己看一些英文文献和书籍的，极为方便，考虑到分享出去可以让更多人受惠，因此这里详细介绍一下它的实现步骤。 本文所实现的划词翻译工具主要有以下特性： 支持英文单词和短语到中文的翻译 划词翻译，终端显示 自动过滤选中文本中的换行等特殊字符 只依赖少数几个 Linux 命令工具 下面有动图进行演示。 本人所使用的环境是运行在 VMware 虚拟机下的 Linux 发行版 Ubuntu 18.04.3 LTS ，因此这里介绍的步骤可能与其他 Linux 发行版中的实现略有不同。下面就来一步一步的实现它吧。 一. 安装必要的命令 xclip 1$ sudo apt install xclip xclip 命令建立了终端和剪切板之间通道，可以用命令的方式将终端输出或文件的内容保存到剪切板中，也可以将剪切板的内容输出到终端或文件。详细的用法可以使用 man xclip，见其手册。这里介绍几个常用的用法。 1234$ xclip file_name # 文件内容保存到X window剪切板$ xclip -selection c file_name #文件内容保存到外部剪切板$ xclip -o # X window剪切板内容输出到终端显示$ xclip -selection c -o # 外部剪切板内容输出到终端显示 值得强调的是，这里所说的 X window 剪切板，简单的说就是你用鼠标选择的文本会实时的存放在这个剪切板，使用鼠标中键可以粘贴。而外部剪切板是保存你用 ctrl+c 复制的文本，ctrl+v 可以粘贴。这两个地方是不一样的。 translate-shell 1$ sudo apt install translate-shell 这是命令行版的谷歌翻译工具，之前叫做 Google Translate CLI 是一款借助谷歌翻译（默认）、必应翻译等来翻译的命令行翻译器。它让你可以在终端访问这些翻译引擎。 translate-shell 在大多数 Linux 发行版中都能使用。常用的方法如下： 12$ trans en:zh [word] # 英文到中文的单词翻译$ trans en:zh -b [text] # 简要的输出，进行文本翻译 需要注意的是，使用这个翻译工具需要你能够访问外网，或者通过修改 translate-shell 的默认翻译引擎，具体的方法这里就不阐述了。 二. 编程实现这个工具整体的思路就是 C 程序实时检测鼠标按键的动态，当检测到用户使用鼠标选择一段文本之后，调用 shell 脚本获取 X window 剪切板的内容进行翻译后输出到终端显示。 1. 定位鼠标设备文件 鼠标作为输入设备。其信息可以在文件 /proc/bus/input/devices 中，使用下列命令查看： 1234567891011$ sudo cat /proc/bus/input/devicesI: Bus=0011 Vendor=0002 Product=0013 Version=0006N: Name=\"VirtualPS/2 VMware VMMouse\"P: Phys=isa0060/serio1/input1S: Sysfs=/devices/platform/i8042/serio1/input/input4U: Uniq=H: Handlers=mouse0 event2 B: PROP=0B: EV=bB: KEY=70000 0 0 0 0B: ABS=3 其中的 Handlers 的值 event2 表示可以在 /dev/input/event2 文件下读取鼠标的状态。需要注意的是，对于不同的设备，读取鼠标的状态的文件可能不一样，比如也可能是 /dev/input/event3。我们可以使用下面的命令找到你的鼠标对应的是哪一个 event。 1$ sudo cat /dev/input/event2 | hexdump # 测试时改变数字即可 比如，当我运行上面这条命令之后，我移动鼠标、按鼠标左键/中键/右键，终端都会输出一些值，这就说明 event2 文件就是对应着我的鼠标。如果操作鼠标没有反应，说明这个就不是。你可以通过这种方法找到你的鼠标对应的 event 文件。 2. Linux 下获取按键响应 在 Linux 内核中，input 设备用 input_dev 结构体描述，使用 input 子系统实现输入设备驱动的时候，驱动的核心工作就是向系统报告按键、触摸屏、键盘、鼠标等输入事件（event*，通过 *input_event 结构体描述），不再需要关心文件操作接口，因为 input 子系统已经完成了文件操作接口 Linux/input.h 这个文件定义了 event 事件的结构体，API 和标准按键的编码等。 1234567891011121314151617181920212223242526// 结构体定义见 input.hstruct input_event&#123; struct timeval time; // 按键时间 __u16 type; // 事件类型 __u16 code; // 要模拟成什么按键 __s32 value; // 是按下还是释放&#125;;// 下面宏定义见 input-event-coses.h// type#define EV_KEY 0x01#define EV_REL 0x02#define EV_ABS 0x03// ...// code#define BTN_LEFT 0x110#define BTN_RIGHT 0x111#define BTN_MIDDLE 0x112// ...// value#define MSC_SERIAL 0x00#define MSC_PULSELED 0x01// ... 这里稍微介绍一下 type，指事件类型，常见的事件类型有：EV_KEY，按键事件，如键盘的按键（按下哪个键），鼠标的左键右键（是否击下）等；EV_REL，相对坐标，主要是指鼠标的移动事件（相对位移）；EV_ABS， 绝对坐标，主要指触摸屏的移动事件 。 3. 编写 C 程序 下面就可以编写程序来检测鼠标的动态了。首先在你的用户~目录下建立文件夹 Translator*。在 *Translator 里建立一个 ct.c 源文件，代码如下： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/input.h&gt;#include &lt;fcntl.h&gt;int main(void)&#123; int keys_fd; struct input_event t; // 注意这里打开的文件根据你自己的设备情况作相应的改变 keys_fd = open(\"/dev/input/event2\", O_RDONLY); if (keys_fd &lt;= 0) &#123; printf(\"open /dev/input/event2 error!\\n\"); return -1; &#125; while (1) &#123; read(keys_fd, &amp;t, sizeof(t)); if (t.type == EV_KEY) // 有键按下 if (t.code == BTN_LEFT) // 鼠标左键 if (t.value == MSC_SERIAL) // 松开 // 调用外部shell脚本 system(\"~/Translator/goTranslate.sh\"); &#125; close(keys_fd); return 0;&#125; 然后就是调用 gcc 编译器生成可执行文件 ct： 1$ gcc ct.c -o ct 4. 编写 shell 脚本翻译剪切板内容 在 Translator 里建立 goTranslate.sh 文件，内容如下： 123456789101112131415#!/bin/bashstr_old=$(cat ~/Translator/lastContent)str_new=$(xclip -o 2&gt;/dev/null | xargs)if [[ \"$str_new\" != \"$str_old\" &amp;&amp; $str_new ]]; then echo -e \"\\n\" count=$(echo \"$str_new\" | wc -w) if [ \"$count\" == \"1\" ]; then echo -n -e \"$str_new \" &gt;&gt;~/Translator/words echo \"$str_new\" | trans :zh-CN | tail -1 | cut -c 5- | sed \"s,\\x1b\\[[0-9;]*[a-zA-Z],,g\" | tee -a ~/Translator/words else echo \"$str_new\" | trans :zh-CN -b fi echo \"$str_new\" &gt;~/Translator/lastContentfi 原理非常简单，读者自行了解。这里我们还要在 Translator 里建立一个 lastContent.txt 文件作为缓存，目的是本次调用脚本时能够获取上一次调用时翻译的文本内容，如果和本次调用的翻译文本一样，则本次就不进行翻译。 *5. 设置 *ct 别名 ** 这里已经可以通过下面的命令运行程序了： 1$ sudo ~/Translator/ct 但是由于每次运行都要输出这么长的命令，因此我们在 ~/.bashrc 文件中加入下面一条命令。 1alias ct='sudo ~/Translator/ct' 这样，以后每次看英文文献时就可以在命令行下输入： 1$ ct 三. 结束语这里有一些小技巧。可以更方便的使用这个工具。比如，把终端设为置顶并缩小到合适的尺寸，这样在阅读文献划词翻译时终端屏幕不会遮挡我们的视线。 值得说明的是，由于本人完全是为了方便自己的使用，而且在搞出这么个工具时仅仅接触 Linux 系统才不到两周，所以里面的实现对于有经验的朋友来说略显的有些笨拙了，请理解哈。 个人觉得这个工具使用起来还是很方便的，你觉得呢？ 参考文章： https://blog.csdn.net/liang12360640/article/details/50350648 https://www.cnblogs.com/yangwindsor/articles/3454955.html https://blog.csdn.net/liang12360640/article/details/50s350648","tags":[{"name":"划词翻译","slug":"划词翻译","permalink":"https://yuanlehome.github.io/tags/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/"},{"name":"Linux","slug":"Linux","permalink":"https://yuanlehome.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://yuanlehome.github.io/tags/shell/"}]},{"title":"深度探索C++对象模型之function语意学","date":"2020-06-08T13:35:42.000Z","path":"rRW3gD4CDal4WhRJ/","text":"第4章：Function语意学4.1 静态成员函数function的调用方式 nonmember function、static member function、nonstatic member function的调用效率完全一样，因为，在内部都被编译器处理成相同的形式。而virtual member function的调用需要通过vptr所指向的virtual table，因此，效率有所降低。 static member function的主要特性就是它没有this指针。以下的次要特性统统根源于其主要特性： 它不能够直接存取其class中的nonstatic members； 它不能够被声明为const、volatile或virtual； 它不需要经由class object才被调用——虽然大部分时候它是这样被调用的。 若取一个static member function的地址不会得到指向其class member function类型的指针（不是return_type (class_type::*)(parameter_types)）。而是一个non-member函数指针（类型为return_type (*)(parameter_types)）。 4.2 虚拟成员函数在C++中，多态表示以一个指向public base class类型的pointer或reference，寻址出一个derived class object的意思。多态机能体现在通过pointer或reference对虚函数的调用身上。因此，识别一个class是否支持多态，唯一适当的方法就是看看它是否有任何virtual function。 为了支持多态，需要在执行期决议出正确的virtual function实例，这需要如下执行期信息的支持： 它所引用的对象的地址，也就是当前它自身的值； 所引用对象的真实类型。这可使我们选择正确的虚函数所在的实体； virtual function实体位置，也就是函数地址，以便我能够调用它。 在实现上，在每一个多态的class object身上增加两个member： 一个字符串或数字，表示class的类型； 一个指针，指向某表格，表格中带有程序的virtual function的执行期地址。 virtual function的地址是固定不变的，执行期不可能新增或替换，而表格的大小和内容在执行期不会改变，因此其建构和存取皆在编译期就可以完成。 为了找到virtual function的地址，需要： 为了找到表格，每一个class object被安插上一个由编译器内部产生的指针，指向该表格； 为了找到函数地址，每一个virtual function被指派一个表格索引值。 这些工作都由编译器完成。执行期要做的，只是在特定的virtual table slot（记录着virtual function的地址）中调用virtual function。这些virtual function可以是： 这个class所定义的函数实体。它override了一个base class virtual function函数实体； 继承自base class的函数实体。这是在derived class中决定不override的virtual function时的情况； 一个pure_virtual_called()函数实体。它既可以扮演pure virtual function的空间保卫者角色，也可以当做执行期异常处理函数（有时候会用到）。 单一继承 例如，对于如下的单一继承体系： virtual destriucior被赋值slot 1，而mult()被赋值slot 2。此例并没有mult()的函数定义，因为它是一个pure virtual function，所以pure _virtual_called()的函数地址会被放在slot 2中。如果该函数意外地被调用，通常的操作是结束掉这个程序。y()被赋值slot 3而z()被赋值slot 4。x()没有slot，因为x()并非virtual function。 此时，一共有三种可能性： 它可以继承base class所声明的virtual function的函数实体。正确地说，是该函数实体的地址会被拷贝到derived class的virtual table相对应的slot之中； 它可以使用自己的函数实体。这表示它自己的函数实体地址必须放在对应的slot之中； 它可以加人一个新的virtual function。这时候virtual table的尺寸会增大一个slot，而新的函数实体地址会被放进该slot之中。 Point2d的virtual table在slot 1中指出destructor，而在slot 2中指出mult()取代pure virtual function。它自己的y()函数实体地址放在slot 3，继承自Point的z()函数实体地址则放在slot 4。 类似的情况： Point3d的virtual table中的slot 1放置Point3d的destructor，slot 2放置Point3d::mult()函数地址。slot 3放置继承自Point2d的y()函数地址，slot 4放置自己的z()函数地址。 这个继承体系中的三个类的virtual table布局如下所示： 现在，如果我们有这样的式子: 1ptr-&gt;z(); 那么，我如何有足够的知识在编译时期设定virtual function的调用呢？ 一般而言，我并不知道ptr所指对象的真正类型。然而我知道，经由ptr可以存取到该对象的virtual table； 虽然我不知道哪一个z()函数实体会被调用，但我知道每一个z()函数地址都被放在slot 4。 这些信息使得编译器可以将该调用转化为： 1(*ptr-&gt;vptr[4])(ptr); 在一个单一继承体系中，virtual function机制的行为十分良好，不但有效率而且很容易塑造出模型。但是在多重继承和虚拟继承之中，就呵呵了。 多重继承和虚拟继承 懒得总结了，看是看懂了，乱七八糟的！ 4.3 指向Member Function的指针取一个nonstatic member function的地址，如果该函数是nonvirtual，则得到的结果是它在内存中真正的地址。然而这个值也是不完全的，它也需要被绑定于某个class object的地址上，才能够通过它调用该函数（以参数this指出）。 回顾一下，一个指向member function的指针，其声明语法如下： 1double (Point::*pmf)(); 然后我们可以这样定义并初始化该指针： 1double (Point::*coord)() = &amp;Point::x; 也可以这样指定其值： 1coord = &amp;Point::y; 想调用它，可以这么做： 123(origin.*coord)();// 或(ptr-&gt;*coord)(); 这些操作会被编译器转化为： 123(coord)(&amp;origin);// 和(coord)(ptr); 获得该函数在内存中的地址。然而面对一个virtual function，其地址在编译时期是未知的，所能知道的仅是virtual function在其相关之virtual table中的索引值，也就是说，对一个virtual member function取其地址，所能获得的只是一个索引值。 那么问题来了，假设我们有以下的Point声明： 1234567class Point&#123;public: // ... virtual ~Point(); virtual float z();&#125;; 取z()函数的地址得到的索引值是2，而不是函数地址。 12float (Point::*pmf)() = &amp;Point::z;Point *ptr = new Point3d; 那么如果通过pmf来间接调用z()函数的话： 12345(ptr-&gt;*pmf)();// 转化为(*ptr-&gt;vptr[(int)pmf]5(ptr); 那么如何知道pmf指向的是virtual function还是nonvirtual function，毕竟pmf如果对nonvirtual function取地址的话得到的是在内存中的地址。也就是说，pmf的内部定义需要允许该函数能够寻址出nonvirtual和virtual两个member function。 同时为了让执行member function的指针也能支持多重继承和虚拟继承，实现方法为使用一个结构体： 1234567891011// 用以支持在多重继承之下指向 member function 的指针struct __mptr&#123; int delta; int index; // virtual 函数 在 virtual table 的索引, 当 index 不指向 virtual table 时值为 -1 union &#123; ptrtofunc faddr; // nonvirtual 函数的地址 int voffset; &#125;;&#125;; 在这样的模型下： 12345(ptr-&gt;*pmf)();// 转化为(pmf.inidex &lt; 0) ? (*pmf.faddr)(ptr) : (*ptr-&gt;vptr[pmf.index](ptr)); 4.4 inline函数","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"深度探索C++对象模型之data语意学","date":"2020-05-28T13:35:42.000Z","path":"ShyaVw4WHERlLCqZ/","text":"第3章：Data语意学The size of class 12345678class X&#123; // char c; // 此时, sizeof(X) == 1, sizeof(Y) == 8, sizeof(Z) == 8, sizeof(A) == 16 char c; // 此时, sizeof(X) == 1, sizeof(Y) == 16, sizeof(Z) == 16, sizeof(A) == 24&#125;;class Y : public virtual X &#123; &#125;;class Z : public virtual X &#123; &#125;;class A : public Y, public Z &#123; &#125;; 一个类的大小主要受三个因素的影响： 语言支持的特性所造成的负担 比如，含虚函数的类会额外多一个vptr指针，含virtual base class会再多一个额外的指针（它或者指向virtual base class subobject，或者指向一个相关表格；表格中存放的若不是virtual base class subobject地址，就是其偏移量）。 编译器对于特殊情况所提供的优化处理 现代编译器的对于空基类的优化处理：一个empty virtual base class被视为derived class object最开头的一部分，也就是说它并没有花费任何的额外空间。因为既然有了members，就不需要原本为了empty class而安插的一个char。 alignment（内存对齐） 就是将数值调整到某数的整数倍。在64位计算机上，通常alignment为8 bytes，以使bus的“运输量”达到最高效率。 nonstatic data members放置的是“个别的class object”感兴趣的数据，static data members则放置的是“整个class”感兴趣的数据。 static data members被放置在程序的一个global data segment中，不会影响个别的class object的大小。在程序之中，不管该class被产生出多少个objects（经由直接产生或间接派生），static data member永远只存在一份实体（即使该class没有任何object实体，其static data members也已存在）。 3.1 data member的绑定类成员函数的argument list中的名称会在它们第一次遭遇时被适当地决议（resolved）完成。因此在extern和nested type name之间的非直觉绑定操作还是会发生。例如在下面的程序片段： 12345678910111213141516typedef std::string length;class Test&#123;public: // 参数列表中的 length 被决议成 std::string!!! // 里面的 val_ 被正确决议成 int void setVal(length val) &#123; val_ = val; &#125;private: typedef int length; length val_;&#125;; 所以这需要使用防御性的程序风格：将nested type name写在class的起始处！ 3.2 数据成员的布局下面这个template function，接受两个data member，然后判断谁先出现在class object之中。如果两个member都是不同的access sections中的第一个被声明者，此函数就可以用来判断哪一个section先出现： 123456template&lt;class class_type, class data_typel, class data_type2&gt;std::string access_order(data_type1 class_type::* mem1, data_type2 class_type::* mem2)&#123; assert(mem1 != mem2); return mem1 &lt; mem2 ? \"member 1 occurs first\" : \"member 2 occurs first\";&#125; 上述函数可以这样被调用： 1access_order(&amp;Point3d::y, &amp;Point3d::z); 3.3 data member的存取static data member 对于类中的静态数据成员，通过一个指针和通过一个对象来存取，效率完全相同，不论这个静态数据成员经过了多么复杂的继承体系。 若取一个static data member的地址不会得到指向其class member的指针（不是value_type class_type::*类型）。而是指向其数据类型的指针（类型为value_type*）。 12345678910111213141516171819class Point&#123;public: static int x; void func1() &#123; &#125; static void func2(int a) &#123; &#125;&#125;;int Point::x = 0;int main()&#123; auto p = &amp;Point::func1; // p 的类型是 void (Point::*p)() auto q = &amp;Point::func2; // q 的类型是 void (*q)(int a) auto p = &amp;Point::x; // r 的类型是 int* r&#125; 构造函数不能是静态成员函数：如果构造函数是静态成员函数，那么将不能访问非静态变量，也没办法完成初始化的工作。 non static data member 对于类中的非静态数据成员，通过一个指针和通过一个对象来存取，当此数据成员属于继承而来的virtual base class时，使用指针效率较低。如果使用对象直接存取，就不会有这些问题，其类型无疑是确定的，而即使它继承自virtual base class，members的offset位置也在编译时期就固定了。 欲对一个nonstatic data member进行存取操作，编译器需要把class object的起始地址加上data member的偏移量。举个例子： 1&amp;origin._y == &amp;origin + (&amp;Point3d::_y - 1); 请注意其中的-1操作。指向data member的指针，其offset值总是被加上1，这样可以使编译系统区分出是用以指出class的第一个member还是没有指出任何member的两种情况。 3.4 C++对象布局 个别struct的数据布局 单一继承而且没有virtual function时的数据布局 C++语言保证——出现在derived class中的base class subobject有其完整原样性 单一继承并含虚拟函数情况下的数据布局 多重继承 虚拟继承，使用pointer strategy和virtual table offset strategy 3.5 指向data member成员的指针取一个nonstatic data member的地址，将会得到它在class中的offset（指针类型为data_type class_type::*），取一个“绑定于真正class object身上的data member”的地址，将会得到该member在内存中的真正地址（指针类型为data_type*）。","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"深度探索C++对象模型之构造函数语意学","date":"2020-05-18T13:35:42.000Z","path":"FXn6nXyz1FEw9e8Y/","text":"第2章：构造函数语意学在这一章中，主要介绍编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”的冲击。 2.1 Default Constructor的构造操作对于未声明构造函数的类，只有在以下四种情况下编译器才会为它们合成默认构造函数： 类有一个类对象（Member Class Object）成员，且该成员含有默认构造函数（Default Constructor） 继承自带有默认构造函数（Default Constructor）的基类（Base class） 带有虚函数（Virtual function）的类 继承自虚基类（Virtual base class）的类 对于以上四种情况，C++标准把合成的默认构造函数叫隐式的有意义默认构造函数(implicit nontrivial default constructors)。被合成的构造函数只能满足编译器（而非程序）的需要，它之所以能够完成任务，是借着调用成员对象或基类的默认构造函数（情况1/2），或是为每一个对象初始化其虚函数机制或虚基类机制（情况3/4）。 至于没有存在上述四种情况，而又没有声明任何构造函数的类，那么它们拥有的是隐式无意义默认构造函数(implicit trivial default constructors)，实际上它们并不会被合成出来。 Default Constructor会在编译器需要的时候被产生出来，被合成出来的Constructor只执行编译器所需要的行为。如果程序有需要，定制Default Constructor的行为是程序员的责任。 “带有Default Constructor”的Member Class Object 如果有多个class member objects都要求constructor初始化操作，将如何呢？C++语言要求以“member objects在class中的声明次序”来调用各个constructors。这一点由编译器完成，它为每一个constructor安插程序代码，以“member声明次序”调用每一个member所关联的default constructors。这些码将被安插在explicit user code之前。举个例子： 123456789101112131415161718192021222324252627282930313233class Dopey&#123;public: Dopey(); ...&#125;;class Sneezy&#123;public: Sneezy(int); Sneezy(); ...&#125;;class Bashful&#123;public: Bashful(); ...&#125;;class Snow_White&#123; ...private: Dopey dopey; Sneezy sneezy; Bashful bashful; int mumble;&#125;; 如果Snow_White没有定义default constructor，就会有一个nontrivial constructor被合成出来，依序调用Dopey、Sneezy、Bashful的default constructors。然而如果Snow_White定义了下面这样的default constructor： 12345// 程序员所写的 default constructorSnow_White::Snow_White() : sneezy(1024)&#123; mumble = 2048;&#125; 它会被扩张为： 1234567891011// 编译器扩张后的 C++ 伪码Snow_White::Snow_White()&#123; // 调用其 constructor dopey.Dopey::Dopey(); Sneezy.Sneezy::Sneezy(1024); bashful.Bashful::Bashful(); // explicit user code mumble = 2048;&#125; “带有Default Constructor”的Base Class 类似的道理，如果一个没有任何constructors的class派生自一个“带有default constructor”的base class，那么这个derived class的default constructor会被视为nontrivial，并因此需要被合成出来。它将调用上一层base classes的default constructor（根据它们的声明次序）。对一个后继派生的class而言，这个合成的constructor和一个“被明确提供的default constructor”没有什么差异。 如果设计者提供多个constructors，但其中都没有default constructor呢？编译器会扩张现有的每一个constructors，将“用以调用所有必要之default constructors”的程序代码加进去。它不会合成一个新的default constructor，这是因为其它“由user所提供的constructors”存在的缘故。如果同时亦存在着“带有default constructors”的member class objects，那些default constructor也会被调用。 “带有（声明或继承）一个Virtual Function”的Class 123456789101112131415161718192021class Widget&#123;public: virtual void flip() = 0; ...&#125;;void flip(const Widget&amp; widget)&#123; widget.flip();&#125;// 假设 Bell 和 Whistle 都派生自 Widgetvoid foo()&#123; Bell b; Whistle w; flip(b); flip(w);&#125; 下面两个扩张操作会在编译期间发生： 一个virtual function table会被编译器产生出来，内放class的virtual functions地址。 在每一个class object中，一个额外的pointer member会被编译器合成出来，内含相关的class vtbl的地址。 此外，widget.flip()的虚拟引发操作会被重新改写，以使用widget的vptr和vtbl中的flip()条目： 123// 1 表示 flip() 在 virtual table 的固定索引// &amp;widget 代表要交给\"被调用的某个 flip() 实体\"的 this 指针(*widget.vptr[1])(&amp;widget)); 为了让这个机制发挥功效，编译器必须为每一个Widget（或其派生类之）object的vptr设定初值，放置适当的virtual table地址。对于class所定义的每一个constructor，编译器会安插一些码来做这样的事情。对于那些未声明任何constructors的classes，编译器会为它们合成一个default constructor，以便正确地初始化每一个class object的vptr。 “带有一个Virtual Base Class”的Class 编译器必须使virtual base class在其每一个derived class object中的位置，能够在执行期准备妥当。一种可能的做法是在derived class中安插一个指向每一个virtual base class的指针，所有“经由reference和pointer来存取其中virtual base class中数据的操作”都通过此指针完成。 同样地，这个virtual base class指针是在class object构建期间完成的，编译器的默认行为和3中的vptr的处理方式一样。 2.2 Copy Constructor的构造操作有三种情况会调用copy constructor： 对一个class object做明确的初始化操作 12345class X &#123;...&#125;;X x;X xx(x);X xx = x; 当class object被当作参数交给某个函数时 1234567extern void foo(X x);void bar()&#123; X xx; foo(xx); ...&#125; 当函数返回一个class object 123456X foo_bar()&#123; X xx; ... return xx;&#125; Default Memberwise Initialization 如果class没有提供一个explicit copy constructor又当如何？当class object以“相同class的另一个object”作为初值时，其内部是以所谓的default memberwise initialization完成的，也就是把每一个内建的或派生的data member的值，从某个object拷贝一份到另一个object身上。不过它并不会拷贝其中的member class object，而是以递归的方式施行memberwise initialization。 一个良好的编译器可以为大部分class objects产生bitwise copies，因为它们有bitwise copy semantics。copy constructors在必要的时候才由编译器产生出来。这个句子中的“必要”意指当class不展现bitwise copy semantics时。 Bitwise Copy Semantics C++ Standard把copy constructor区分为trivial和nontrivial两种。只有nontrivial的实体才会被合成于程序之中。决定一个copy constructor是否为trivial的标准在于class是否展现出所谓的“bitwise copy semantics”。 什么时候一个class不展现出Bitwise Copy Semantics呢？ 当class内含一个member object而后者的class声明有一个copy constructor时（不论是被class设计者明确地声明；或是被编译器合成）。 当class继承自一个base class而后者存在有一个copy constructor（再次强调，不论是被明确声明或是被合成而得）。 当class声明了一个或多个virtual functions时。 当class派生自一个继承串链，其中有一个或多个virtual base classes时。 有一点很值得注意：在被合成出来的copy constructor中，如整数、指针、数组等等的nonclass members也都会被复制。 重新设定virtual table的指针vptr 当编译器导入一个vptr到class之中时，该class就不再展现bitwise semantics了。编译器需要合成出一个copy constructor，以求将vptr适当地初始化。 base class object以另一个base class object作为初值，或derived class object以另一个derived class object作为初值，都可以直接靠“bitwise copy semantics”完成。当一个base class object以其derived class的object内容做初始化操作时，其vptr复制操作必须保证安全。此时，合成出来的base copy constructor会明确设定object的vptr指向base class的virtual table，而不是直接从右手边的class object中将其vptr现值拷贝过来。 处理virtual base class subject 和3同理，需要合成copy constructor来明确的设定virtual base class pointer的初值。 2.3 程序转化语意学已知有这样的定义： 1X x0; 下面有三个定义，每一个都明显地以x0来初始化其class object： 123456void foo_bar()&#123; X xl(x0); X x2 = x0; X x3 = X(x0);&#125; 必要的程序转化有两个阶段： 重写每一个定义，其中的初始化操作会被剥除。 class的copy constructor调用操作会被安插进去。 举个例子，在明确的双阶段转化之后，foo_bar()可能看起来像这样： 1234567891011121314// 可能的程序转换// C++ 伪码void foo_bar()&#123; // 注意没有初始化操作 X x1; X x2; X x3; // 编译器安插X copy construction的调用操作 x1.X::X(x0); x2.X::X(x0); x3.X::X(x0);&#125; 参数的初始化 把一个class object当做参数传给一个函数，相当于以下形式的初始化操作： 12// xx 代表形式参数, arg 代表真正的参数值X xx = arg; 返回值的初始化 已知下面这个函数定义： 123456X bar()&#123; X xx; // 处理 xx ... return xx;&#125; 这里有一个双阶段转化： 首先加上一个额外参数，类型是class object的一个reference。这个参数将用来放置被“拷贝建构（copy constructed）”而得的返回值。 在return指令之前安插一个copy constructor调用操作，以便将欲传回之object的内容当做上述新增参数的初值。 根据这样的算法，bar()转换如下： 12345678910void bar(X &amp;_result)&#123; X xx; // 编译器所产生的 default constructor 调用操作 xx.X::X(); // ... 处理 xx // 编译器所产生的 copy constructor result.X::X(xx); return;&#125; 现在编译器必须转换每一个bar()调用操作，以反映其新定义。例如： 1X xx = bar(); 将被转换为下列两个指令句： 123// 注意, 不必施行 default constructorX xx;bar(xx); NRV优化 已知下面这个函数定义： 123456X bar()&#123; X xx; // 处理 xx ... return xx;&#125; 编译器会把它优化为： 123456789void bar(X &amp;_result)&#123; // default constructor 调用操作 _result.X::X(); // ... 直接处理 _result return;&#125; 只有当程序提供了explicit copy constructor，编译器才会实施NRV优化。没有提供的话（编译器自己合成的），是不会实施NRV优化的。 copy constructor要还是不要？ 对于下面的3D坐标点类，这个class的设计者应该提供一个explicit copy constructor吗？ 12345678class Point3d&#123;public: Point3d(float x, float y, float z); // ...private: float _x, _y, _z;&#125;; 除非你预见该class需要大量的memberwise初始化操作，例如函数以传值（by value）的方式传回objects，那么提供一个copy constructor的explicit inline函数实体就非常合理——可以激活编译器提供的NRV优化。否则，不提供explicit copy constructor既快速又安全。 2.4 Member initialization list为了让你的程序能够被顺利编译，必须使用member initialization list的情况： 当初始化一个refercnce member时； 当初始化一个const member时； 当调用一个base class的constructor，而它拥有一组参数时； 当调用一个member class的constructor，而它拥有一组参数时。 在这四种情况之外，不使用member initialization list，程序可以被正确编译并执行，但是效率不彰。例如： 123456789101112class Word&#123;public: Word() &#123; _name = 0; _cnt = 0; &#125;private: String _name; int _cnt;&#125;; 下面是编译器对constructor可能的内部扩张结果： 1234567891011121314151617// C++ 伪码Word::Word(/* this pointer goes here */)&#123; // 调用 String default constructor _name.String::String(); // 产生临时性对象 String temp = String(0); // memberwise 地拷贝 _name _name.String::operator=(temp); // 摧毁暂时性对象 temp.String::~String(); _cnt = 0;&#125; 更有效率的实现方法： 12345// 较佳的方式Word::Word : _name(0)&#123; cnt = 0;&#125; 它会被扩张成这个样子： 1234567// C++ 伪码Word::Word(/* this pointer goes here */)&#123; // 调用 String(int) constructor _name.String::String(0); _cnt = 0;&#125; 编译器会一一操作initialization list，以member声明次序（不是由initialization list中的排列次序决定的）在constructor之内的explicit user code之前安插初始化操作。 调用一个member function以设定一个member的初值是可以的，因为此时this指针已经被构造妥当。 12345678910// X::xfoo() 被调用X::X(int val) : i(xfoo(val)), j(val)&#123; &#125;// 会被扩张为X::X(/* this pointer */, int val)&#123; i = this-&gt;xfoo(val); i = val;&#125; 注意：如果一个derived class member function被调用，其返回值被当做base class constructor的一个参数，这不是一个好主意！！！","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"深度探索C++对象模型之前言","date":"2020-05-08T13:35:42.000Z","path":"jOQUhpad0yAY7aMb/","text":"前言Simplifier是编译器的一部分，处于type checking和code generation之间。它用来转换内部的程序表现。有3种转换是任何对象模型都需要的： 与编译器息息相关的转换（Implementation-dependent transformations） 例如，当parser看到这个表达式： 1fct(); 它并不知道是否（a）这是一个函数调用操作，或者（b）这是overloaded calloperator在class object fct上的一种应用。默认情况下，这个式子所代表的是一个函数调用，但是当（b）的情况出现，Simplifier就要重写并调换call subtree。 语言语意转换（Language semantics transformations） 这包括constructor/destructor的合成和扩展、memberwise初始化、对于memberwise copy的支持、在程序代码中安插conversion operators、临时性对象，以及对constructor/destructor的调用。 程序代码和对象模型的转换（Code and object model transformations） 这包括对virtual functions、virtual base class和inheritance的一般支持、new和delete运算符、class objects所组成的数组、local static class instances、带有非常量表达式（nonconstant cxpression）之global object的静态初始化操作。 什么是C++对象模型？ 语言中直接支持面向对象程序设计的部分 对于各种支持的底层实现机制 第1章：关于对象在C语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。 C++在布局以及存取时间上主要的额外负担是由virtual引起，包括： virtual function机制——用以支持一个有效率的“执行期绑定” virtual base class——用以实现“多次出现在继承体系中的base class，有一个单一而被共享的实体” 此外，还有一些多重继承下的额外负担，发生在“一个derived class和其第二或后继之base class的转换”之间。 1.1 C++对象模型在C++中，有两种class data members：static和nonstatic，以及三种class member functions：static、nonstatic和virtual。 在C++对象模型中，nonstatic data members被配置于每一个class object之内，static data members则被存放在所有的class object之外。static和nonstatic function members也被放在所有的class object之外。virtual functions则以两个步骤支持之： 每一个class产生出一堆指向virtual functions的指针，放在表格之中。这个表格被称为 vtbl。 每一个class object被添加了一个指针，指向相关的virtual table。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）由每一个class的constructor、destructor和copy assignment运算符自动完成。 在虚拟继承的情况下，base class不管在继承串链中被派生（derived）多少次，永远只会存在一个实体（称为subobject）。 C++最初采用的继承模型并不运用任何间接性: base class subobject的data members被直接放置于derived class object中。这提供了对base class members最紧凑而且最有效率的存取。缺点就是: base class members的任何改变，包括增加﹑移除或改变类型等等，都使得所有用到“此base class或其derived class之objects”者重新编译。 virtual base class的原始模型是在class object中为每一个有关联的virtual base class加上一个指针。 对象模型如何影响程序？ 不同的对象模型，会导致“现有的程序代码必须修改”以及“必须加人新的程序代码”两个结果。例如下面这个函数，其中class X定义了一个copy constructor，一个virtual destructor，和一个virtual function foo： 123456789101112X foobar()&#123; X xx; X* px = new X; // foo 是一个虚函数 xx.foo(); px-&gt;foo(); delete px; return xx; // 这里会用到 copy constructor&#125; 这个函数有可能在内部被转化为： 1234567891011121314151617181920212223242526272829void foobar(X&amp; _result)&#123; // 构造 _result // _result 用来取代 local xx... _result.X::X(); // 扩展 ×* px= new x; px = _new(sizeof(X)); if(px != 0) px-&gt;X::X(); // 扩展 xx.foo() 但不使用 virtual 机制 // 以 _result 取代 xx foo(&amp;_result); // 使用 virtual 机制扩展 px-&gt;foo() (*px-&gt;vtbl[2])(px); // 扩展 delete px; if(px != 0) &#123; (*px-&gt;vtbl[1])(px); // destructor _delete(px); &#125; //不需使用 named return statement //不需要摧毁 local object xx return;&#125; 1.2 关键词所带来的差异 掌握struct和class关键字的差异 struct关键词的使用实现了C的数据萃取概念，而class关键词实现的是C++的ADT（Abstract Data Type）概念。 C程序员的巧计（C++中不可用）。例如把单一元素的数组放在一个struct的尾端，于是每个struct objects可以拥有可变大小的数组： 1234567891011struct mumble&#123; // stuff char pc[1];&#125;;// 从档案或标准输入装置中取得一个字符串 str// 然后为 struct 本身和该字符串配置足够的内存struct mumble *pmumble = (struct mumble*) malloc(sizeof(struct mumble) + strlen(str) + 1);strcpy(&amp;(pmumble-&gt;pc), str); C++中凡处于同一个access section的数据，必定保证以其声明次序出现在内存布局当中。然而被放置在多个access sections中的各笔数据，排列次序就不一定了。组合（composition)，而非继承，才是把C和C++结合在一起的唯一可行方法（conversion运算符提供了一个十分便利的萃取方法）： 12345678struct C_point &#123; ... &#125;;class Point&#123;public: operator C_point() &#123; return c_point_; &#125; // ...private: C_point c_point_; C struct在C++中的一个合理用途，是当你要传递“一个复杂的class object的全部或部分”到某个C函数中去时，struct声明可以将数据封装起来，并保证拥有与C兼容的空间布局。然而这项保证只在组合的情况下才存在。 1.3 对象的差异C++支持3种程序设计模型： 程序模型（面向过程） 抽象数据类型模型（基于对象模型）（封装） 面向对象模型（继承、多态） 在C++，多态只存在于一个个的public class体系中。nonpublic的派生行为以及类型为void*的指针可以说是多态，但它们并没有被语言明白地支持，也就是说它们必须由程序员通过明白的转型操作来管理。C++以下列方法支持多态： 经由一组隐含的转化操作。例如把一个derived class指针转化为一个指向其public base type的指针 1Shape *ps = new Circle(); 经由virtual function机制 经由dynamic_cast和typeid运算符 12if(Circle* pc = dynamic_cast&lt;Circle*&gt;(ps)) ... virtual function机制不只使得“当类型有所增加、修改、或删减时，我们的程序代码不需改变”。而且也使一个新的subtype的供应者不需要重新写出“对继承体系中的所有类型都共通”的行为和操作。 需要多少内存才能够表现一个class object？ nonstatic data members的总和大小 加上任何alignment（内存对齐） 加上为了支持virtual（function，base class）而由内部产生的额外负担 转型（cast）其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。 一个Base指针pb和一个Derived指针pd有什么不同？ 123Derived d;Base* pb = &amp;d;Derived* pd = &amp;d; 它们每个都指向Base object的第一个byte。其间的差别是，pd所涵盖的地址包含整个Derived object，而pb所涵盖的地址只包含Derived object中的Base subobject。 除了Base subobject中出现的members，你不能使用pb来直接处理Derived的任何members。例外是通过virtual机制或转型操作。 当一个base class object被直接初始化为（或是被指定为）一个derived class object时，derived object就会被切割，以塞人较小的base type内存中，derived type将没有留下任何蛛丝马迹。 下面这一组定义，其可能的内存布局为： 12345ZooAnimal za;ZooAnimal *pza;Bear b;Panda* pp = new Panda;pza = &amp;b;","tags":[{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"},{"name":"深度探索C++对象模型","slug":"深度探索C-对象模型","permalink":"https://yuanlehome.github.io/tags/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"}]},{"title":"Effective C++之模板与泛型编程","date":"2020-04-18T13:35:42.000Z","path":"MBICE5WlMJtd4Rku/","text":"第7章：模板与泛型编程条款41：了解隐式接口和编译期多态 哪一个重载函数被调用——发生在编译期 哪一个virtual函数被绑定——发生在运行期 class和template都支持接口和多态 对class而言，接口是显式的，以成员函数的签名为中心，多态则通过virtual函数发生在运行期。对template而言，接口是隐式的，以有效表达式为中心，多态则通过template具现化和函数重载解析发生于编译期。 条款42：了解typename的双重意义 当我们声明模板类型参数，class和typename的意义完全相同 12template&lt;typename T&gt;template&lt;class T&gt; typename用来标识嵌套从属类型名称 template内出现的名称如果相依于某个template参数，称这个名称为从属名称，如果丛属名称在class内呈嵌套状，称为嵌套从属名称。如果嵌套从属名称还指涉某种类型名称为嵌套从属类型名称 123456789101112131415161718// std::iterator_traits&lt;IterT&gt;::value_type 就是嵌套从属类型名称template&lt;typename IterT&gt;void workWithIterator(IterT iter)&#123; // 必须使用 typename 关键字标识 typename std::iterator_traits&lt;IterT&gt;::value_type temp(*iter); ...&#125;// 使用 typedef 少打几个字template&lt;typename IterT&gt;void workWithIterator(IterT iter)&#123; // 必须使用 typename 关键字标识 typedef typename std::iterator_traits&lt;IterT&gt;::value_type value_type; value_type temp(*iter); ...&#125; 不允许在base class list或member initialization list内使用typename作为base class的标识符 条款43：学习处理模板化基类内的名称假设我们需要撰写一个MsgSender类，它能够传送信息到若干不同的Company去。信息要不进行加密后的密文，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于template的解法： 1234567891011121314151617181920212223242526272829303132333435363738394041class CompanyA&#123;public: ... void sendCleartext(const string&amp; msg); void sendEncrypted(const string&amp; msg);&#125;;class CompanyB&#123;public: ... void sendCleartext(const string&amp; msg); void sendEncrypted(const string&amp; msg);&#125;;... // 针对其他公司设计的 classclass MsgInfo &#123;...&#125;; // 这个 class 以备将来产生信息template&lt;typename Company&gt;class MsgSender&#123;public: ... //构造函数、析构函数等等 void sendClear(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendCleartext(msg); &#125; void sendSecret(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendEncrypted(msg); &#125;&#125;; 现在假设我们想要在每次送出信息时log某些信息。derived class可轻易提供解决方法： 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log sendClear(info); // 调用 base class 函数, 这段码无法通过编译! ... // 将“传送后”的信息写至 log &#125; ...&#125;; 编译器会抱怨sendClear函数不存在，明明在那里，为什么？ 问题在于，当编译器看见class template LoggingMsgSender定义式时，并不知道它继承什么样的class。当然它继承的是MsgSender&lt;Company&gt;，但其中的Company是个template参数，不当LoggingMsgSender被具现化之前无法确切知道它是什么。而如果不知道Company是什么，就无法知道class MsgSender&lt;Company&gt;看起来像什么——更明确地说是没办法知道它是否有个sendClear函数。 具体点说，假设现在有个CompanyZ坚持只使用加密通讯： 12345678// 不提供 sendCleartext 函数class CompanyZ&#123;public: ... void sendEncrypted(const string&amp; msg); ...&#125;; 一般性的MsgSender template对CompanyZ并不合适，因为那个template提供了一个sendClearMsg函数，而这对CompanyZ对象并不合理。欲矫正这个问题，我们可以针对CompanyZ产生一个MsgSender特化版： 123456789101112131415// 全特化版本只提供 sendSecret 函数template&lt;&gt;class MsgSender&lt;CompanyZ&gt;&#123;public: ... //构造函数、析构函数等等 void sendSecret(const MsgInfo&amp; info) &#123; string msg; ... // 在这儿, 根据 info 产生信息 Company c; c.sendEncrypted(msg); &#125; ...&#125;; 这就解释了前面编译器拒绝那个调用的原因：它知道base class template有可能被特化，而那个特化版本可能不提供和一般性template相同的接口。因此它往往拒绝在templatized base class（本例的MsgSender&lt;Company&gt;）内寻找继承而来的名称（本例的SendClear)。 当我们从Object Oriented C++跨进Template C++（见条款1) ，继承就不像以前那样畅行无阻了 有三个解决令C++编译器“不进入templatized base class观察”的行为失效的办法： 使用this指针 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log this-&gt;sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 使用using声明 虽然using声明式在在条款33或在这里都可有效运作，但两处解决的问题其实不相同。前者是base class名称被derived class名称遮掩，而后者是编译器不进入base class作用域内查找，于是我们通过using告诉它，请它那么做。 1234567891011121314template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: using MsgSender&lt;Company&gt;::sendClear; ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 使用作用域运算符::明确指定 12345678910111213template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;&#123;public: ... // 构造函数、析构函数等等 void sendClearMsg(const MsgInfo&amp; info) &#123; ... // 将“传送前”的信息写至 log MsgSender&lt;Company&gt;::sendClear(info); // 调用 base class 函数 ... // 将“传送后”的信息写至 log &#125; ...&#125;; 即使如此，如果稍后这样做： 1234LoggingMsgSender&lt;Companyz&gt;zMsgSender;MsgInfo msgData;...zMsgSender.sendClearMsg(msgData); // 仍然无法通过编译 其中对sendClearMsg的调用动作将无法通过编译，因为在那个点上，编译器知道base class是个template特化版本MsgSender&lt;CompanyZ&gt;，而且它知道那个class不提供sendClear函数，而sendClear却是sendClearMsg尝试调用的函数。 条款44：将与基类无关的代码抽离template当你编写某个函数，其中某些部分的实现码和另一个函数的实现码实质相同，你会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。如果你正在编写某个class，而你明白其中某些部分和另一个class的某些部分相同，你也不会重复这共同的部分。你会把共同部分搬移到新class去，然后使用继承或复合（见条款32，38，39) ，令原先的class取用这共同特性。而原class的互异部分仍然留在原位置不动。 编写template时，也是做相同的分析，以相同的方式避免重复。然而在template代码中，重复是隐晦的：毕竟只存在一份template源码，所以你必须训练自己去感受当template被具现化多次时可能发生的重复。 举个例子，假设你想为固定尺寸的正方矩阵编写一个template。该矩阵的性质之一是支持逆矩阵运算。 123456789101112131415// template 支持 n x n 矩阵, 元素类型为 Ttemplate&lt;typename T, size_t n&gt;class squareMatrix&#123;public: ... void invert( ); // 求逆矩阵&#125;;SquareMatrix&lt;double, 5&gt; sml;...sm1.invert(); // 调用 SquareMatrix&lt;double, 5&gt;::invertsSquareMatrix&lt;double, 10&gt; sm2;...sm2.invert(); // 调用 SquareMatrix&lt;double, 10&gt;::invert 这会具现化两份invert。这些函数并非完完全全相同，因为其中一个操作的是5x5矩阵而另一个操作的是10x10矩阵，但除了常量5和10，两个函数的其他部分完全相同。这是template引出代码膨胀的一个典型例子。 第一次修改： 1234567891011121314151617181920212223242526// 与尺寸无关的 base classtemplate&lt;typename T&gt;class SquareMatrixBase&#123;protected: void invert(size_t matrixSize) // 以给定的尺寸求逆矩阵 &#123; ... &#125;&#125;;template&lt;typename T, size_t n&gt;class SquareMatrix : private SquareMatrixBase&lt;T&gt;&#123;private: // 声明为 private 是为了不让客户看见 using SquareMatrixBase&lt;T&gt;::invert; // 避免遮掩 base 版的 invert, 见条款 33public: ... void invert() &#123; this-&gt;invert(n); // inline 调用 base class 版的 invert // 为什么这儿出现 this-&gt; 见条款 43 // LYL 认为前面已经使用了 using, this-&gt; 应该也不需要了 &#125;&#125;; 这里的base class只是为了帮助derived class实现，不是为了表现SquareMatrix和SquareMatrixBase之间的is-a关系（关于private继承，见条款39)。 目前为止一切都好，但还有一些棘手的题目没有解决。SquareMatrixBase::invert如何知道该操作什么数据？虽然它从参数中知道矩阵尺寸，但它如何知道哪个特定矩阵的数据在哪儿？想必只有derived class知道。derived class如何联络其base class做逆运算动作？一个可能的做法是为SquareMatrixBase::invert添加另一个参数，可以是个指针，指向一块用来放置矩阵数据的内存地址。 第二次修改： 1234567891011121314151617181920212223242526272829303132template&lt;typename T&gt;class SquareMatrixBase&#123;protected: // 存储矩阵大小和一个指针, 指向矩阵数值 squareMatrixBase(size_t n, T* pMem) : size(n), pData(pMem) &#123;&#125; void invert() // 不用指定尺寸了 &#123; ... &#125; ...private: size_t size; // 矩阵的大小 T* pData; // 指针, 指向矩阵内容&#125;;template&lt;typename T, size_t n&gt;class SquareMatrix : private SquareMatrixBase&lt;T&gt;&#123;private: using SquareMatrixBase&lt;T&gt;::invert;public: SquareMatrix() : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125; void invert() &#123; this-&gt;invert(n); &#125; ...private: T data[n * n]; // 这里直接将数据矩阵存储在 SquareMatrix 对象内部 // 也可以使用动态内存分配的方案&#125;; 这个条款只讨论由non-type template parameter（非类型模板参数）带来的膨胀，其实type parameter（类型参数）也会导致膨胀。例如在许多平台上int和 long有相同的二进制表述，所以像vector&lt;int&gt;和vector&lt;long&gt;的成员函数有可能完全相同。某些链接器（linker）会合并完全相同的函数实现码，但有些不会，后者意味某些template被具现化为int和long两个版本，并因此造成代码膨胀。类似情况，所有指针类型都有相同的二进制表述，因此凡template持有指针者（例如list&lt;int*&gt;，list&lt;const int*&gt;，list&lt;SquareMatrix&lt;long, 3&gt;*&gt;等等）往往应该对每一个成员函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它们操作强型指针（strongly typed pointer，即T*），你应该令它们调用另一个操作无类型指针（untyped pointer，即void*）的函数，由后者完成实际工作。某些C++标准程序库实现版本的确为vector，deque和list等template做了这件事。 条款45：成员函数模板接受所有兼容类型内置指针是支持隐式转换的，比如derived class的指针可以隐式转换为base class指针，指向non-const对象的指针可以转换为指向const对象等等。 123456class Top &#123;...&#125;;class Middle : public Top &#123;...&#125;;class Bottom : public Middle &#123;...&#125;;Top* pt1 = new Middle; // 将 Middle* 转换为 Top*Top* pt2 = new Bottom; // 将 Bottom* 转换为 Top*const Top* = pt1; // Top* 转换为 const Top* 但是我们自己实现的智能指针模板类，想做到这样就稍稍有点麻烦了。我们希望下面的代码能够通过编译： 12345678910111213141516temmplate&lt;typename T&gt;class SmartPtr&#123;public: explicit SmartPtr(T* realPtr); // 智能指针通常以内置指针完成初始化 ...&#125;;// 将 SmartPtr&lt;Middle&gt;转 换为 SmartPtr&lt;Top&gt;SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(new Middle);// 将 SmartPtr&lt;Bottom&gt; 转换为 SmartPtr&lt;Top&gt;SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(new Bottom);// 将 SmartPtr&lt;Top&gt; 转换为 SmartPtr&lt;const Top&gt;SmartPtr&lt;const Top&gt; pct2 = ptl; 注意，这些赋值表达式需要调用的都是copy构造函数。这里的代码不能通过编译，因为如果以带有base-derived关系的B，D两类型分别具现化某个template，产生出来的两个具现体并不带有base-derived关系，所以编译器视SmartPtr&lt;Middle&gt;和SmartPtr&lt;Top&gt;为完全不同的class，为了获得我们希望获得的SmartPtr class之间的转换能力，我们必须将它们明确地编写出来。 我们应该为它写一个构造模板。这样的模板是所谓member function template，其作用是为class生成函数： 123456789template&lt;typename T&gt;class SmartPtr&#123;public: // member template, 为了生成 copy 构造函数 template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other); ...&#125;; 我们称之为泛化（generalized）copy构造函数。它并未被声明为explicit，那是因为内置指针类型之间的转换（例如从derived class指针转为base class指针）是隐式转换，所以让智能指针按照这种形式也属合理。 但是，这个为SmartPtr而写的“泛化copy构造函数”提供的东西比我们需要的更多。我们只希望根据一个SmartPtr&lt;Bottom&gt;创建一个SmartPtr&lt;Top&gt;，却不希望根据一个SmartPtr&lt;Top&gt;创建一个SmartPtr&lt;Bottomr&gt;，因为那对public继承而言（见条款32）是矛盾的。我们也不希望根据一个SmartPtr&lt;double&gt;创建一个SmartPtr&lt;int&gt;，我们必须从某方面对这一member template所创建的成员函数群进行挑拣。 假设SmartPtr遵循std::shared_ptr也提供一个get成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望： 12345678910111213template&lt;typename T&gt;class SmartPtr&#123;public: // 以 other 的 heldPtr 初始化 this 的 heldPtr template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other) : heldPtr(other.get()) &#123;...&#125; T* get() const &#123; return heldPtr; &#125; ...private: T* heldPtr; // 这个 SmartPtr 持有的内置指针&#125;; 这个行为只有当“存在某个隐式转换可将一个U*指针转为一个T*指针”时才能通过编译，而这正是我们想要的。 member function template（成员函数模板）的效用不限于构造函数，它常扮演的另一个角色是支持赋值操作。例如std::shared_ptr同时支持所有“来自兼容之内置指针、std::shared_ptr、std::weak_ptr”的构造行为以及赋值操作（std::weak_ptr除外）。赋值操作符和copy构造函数实现类似，故省略。 如果你声明member template用于“泛化copy构造”或“泛化assignment操作”你还是需要声明正常的copy构造函数和copy assignment操作符 条款5说过，编译器可能为我们产生四个成员函数，其中两个是copy构造函数和copy assignment操作符。现在，SmartPtr声明了一个泛化copy构造函数，而显然一旦类型T和U相同，泛化copy构造函数会被具现化为“正常的”copy构造函数。那么究竟编译器会暗自为SmartPtr生成一个copy构造函数呢？或当某个SmartPtr对象根据另一个同型的SmartPtr对象展开构造行为时，编译器会将“泛化copy构造函数模板”具现化呢？ member template并不改变语言规则：“如果程序需要一个copy构造函数，你却没有声明它，编译器会为你暗自生成一个”。在class内声明泛化copy构造函数（是个member template）并不会阻止编译器生成它们自己的copy构造函数（一个non-template），所以如果你想要控制copy构造的方方面面，你必须同时声明泛化copy构造函数和“正常的”copy构造函数。相同规则也适用于赋值操作。 条款46：需要类型转换时请为模板定义非成员函数条款24讨论过为什么惟有non-member函数才有能力“在所有实参身上实施隐式类型转换”，该条款并以Rational class的operator*函数为例。本条款将Rational和operator*模板化： 123456789101112131415161718192021template&lt;typename T&gt;class Rational&#123;public: // 条款 20 告诉你为什么参数以 passed by reference 方式传递 Rational(const T&amp; numerator = 0, const T&amp; denominator = 1); // 条款 28 告诉你为啥返回值以 passed by value 方式传递 // 条款 3 告诉你为啥它们是 const const T numerator() const; const T denominator() const; ...&#125;;template&lt;typename T&gt;const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 就像条款24一样，我们也希望支持混合式算术运算，然而以下代码却不能通过编译： 12Rational&lt;int&gt; oneHalf(1, 2);Rational&lt;int&gt; result &#x3D; oneHalf * 2; &#x2F;&#x2F; 错误!无法通过编译 在这里，编译器不知道我们想要调用哪个函数！它们试图找到什么函数被名为operator*的template具现化出来。它们知道它们应该可以具现化某个“名为operator*并接受两个Rational&lt;T&gt;参数”的函数，但为完成这一具现化行动，必须先算出T是什么。 为了推导T，它们看了看operator*调用动作中的实参类型。分别是Rational&lt;int&gt;（oneHalf的类型）和int（2的类型）。 以oneHalf进行推导，过程并不困难。第二参数的推导则没有这么顺利。operator*的第二参数被声明为Rational&lt;T&gt;，但传递给operator*的类型是int（2）。编译器如何根据这个2推算出T？你或许会期盼编译器使用Rational&lt;int&gt;的non-explicit构造函数将转换为Rational&lt;int&gt;，进而将T推导为int，然而template实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。 template class内的friend声明式可以指涉某个特定函数。这意味class Rational&lt;T&gt;可以声明operator*是它的一个friend函数。class template并不倚赖template实参推导，所以编译器总是能够在class Rational&lt;T&gt;具现化时得知T。因此： 12345678910111213141516template&lt;typename T&gt;class Rational&#123;public: ... friend const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs);&#125;;template&lt;typename T&gt;const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs)&#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125; 现在当对象oneHalf被声明为一个Rational&lt;int&gt;，class Rational&lt;int&gt;于是被具现化出来，而作为过程的一部分，friend函数operator*（接受Rational&lt;int&gt;参数）也就被自动声明出来。后者身为一个函数而非function template，因此编译器可在调用它时使用隐式转换函数（例如调用Rational的non-explicit构造函数）。 但是，虽然这段代码通过编译，却无法连接。 因为这个友元函数只被声明于Rational内，并没有被定义出来。我们意图令此class外部的operator* template提供定义式，是行不通的。既然我们没有提供定义式，连接器当然找不到它！ 最简单的方法就是，将函数本体放进class内： 12345678910111213template&lt;typename T&gt;class Rational&#123;public: ... friend template&lt;typename T&gt; const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) &#123; return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); &#125;&#125;; 为了让类型转换可能发生于所有实参身上，我们需要一个non-member函数（条款24）；为了令这个函数被自动具现化，我们需要将它声明在class内部；而在class内部声明non-member函数的唯一办法就是：令它成为一个friend。因此我们就这样做了。 当此friend函数过于复杂时，令其调用类外的辅助函数 12345678910111213141516171819202122template&lt;typename T&gt; class Rational; // 前向声明template&lt;typename T&gt;const Rational&lt;T&gt; doMultiply(const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp;rhs);&#123; return Rational&lt;T&gt;(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());&#125;template&lt;typename T&gt;class Rational&#123;public: ... friend const Rational&lt;T&gt;operator* (const Rational&lt;T&gt;&amp; lhs, const Rational&lt;T&gt;&amp; rhs) &#123; return doMultiply(lhs, rhs); &#125; ...&#125;; 作为一个template，doMultiply当然不支持混合式乘法，但它其实也不需要。它只被operator*调用，而operator*支持混合式操作。 条款47：traits classes表现类型信息STL迭代器分类： input迭代器 只能向前移动，一次一步，用户只能读取它所指的东西，而且只能读取一次，读完立即自动向前一步。程序库中的输入流迭代器istream_iterator就属于这一类。 output迭代器 只能向前移动，一次一步，用户只能涂写它所指的东西，而且只能涂写一次，写完立即自动向前一步。程序库中的输出流迭代器ostream_iterator就属于这一类。 forward迭代器 可以做上述两种迭代器做的事情，而且支持多次读写，读写完由用户自行决定是否前进。单向链表slist提供的迭代器就属于这一类。 bidirectional迭代器 除了能做forward迭代器做的事情，还可以向后移动。双向链表list以及set，mutilset，map，mutilmap提供的迭代器属于这一类。 random access迭代器 功能类似于内置指针，可以进行算数操作。vector，deque和string提供的迭代器属于这一类。 迭代器适配器 reverse迭代器 insert迭代器 back inserter front inserter general inserter stream迭代器 move迭代器 12345struct input_iterator_tag &#123;&#125;;struct output_iterator_tag &#123;&#125;;struct forward_iterator_tag : public input_iterator_tag &#123;&#125;;struct bidirectional iterator_tag : public forward_iterator_tag &#123;&#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag &#123;&#125;; 这些struct之间的继承关系是有效的is-a关系：所有forward迭代器都是input迭代器，依此类推。 关于iterator_trait的实现技术（参考书籍P227-P232） 条款48：认识template元编程 如题，以后买本书再专门去学吧！","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"},{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"}]},{"title":"Effective C++之继承与面向对象设计","date":"2020-04-10T13:35:42.000Z","path":"5pPP61A5gGyfCrjb/","text":"第6章：继承与面向对象设计条款32：确定你的public继承塑模出is-a关系 “public继承”意味is-a。适用于base class身上的每一件事情一定也适用于derived class身上，因为每一个derived class对象也都是一个base class对象 条款33：避免遮掩继承而来的名称 derived class的作用域被嵌套在base class作用域内 12345678910111213141516171819202122232425class Base&#123;private: int x;public: virtual void mf1() = 0; virtual void mf1(int); void mf2(); void mf2(double);&#125;;class Derived : public Base&#123;public: virtual void mf1(); void mf2();&#125;;Derived d;int x;...d.mf1(); // 没问题, 调用 Derived::mf1d.mf1(x); // 错误! 因为 Derived::mf1 遮掩了 Base::mf1d.mf2(); // 没问题, 调用 Derived::mf2d.mf2(x); // 错误! 因为 Derived::mf2 遮掩了 Base::mf2 这段代码中base class内所有名为mf1和mf2的函数都被derived class内的mf1和mf2函数遮掩掉了。从名称查找观点来看，Base::mf1和Base::mf2不再被Derived继承！ 实际上如果你正在使用public继承而又不继承那些重载函数，就是违反base和derived class之间的is-a关系，而条款32说过is-a是public继承的基石。因此你几乎总会想要推翻C++对“继承而来的名称”的缺省遮掩行为。 使用using声明式 1234567891011121314151617181920212223242526272829class Base&#123;private: int x; public: virtual void mf1() = 0; virtual void mf1(int); void mf2(); void mf2(double); ...&#125;;class Derived : public Base&#123;public: using Base::mf1; // 让 Base class 内名为 mf1 和 mf2 的所有东西 using Base::mf2; // 在 Derived 作用域内都可见, 并且 public virtual void mf1(); void mf2();&#125;;Derived d;int x;...d.mf1(); // 没问题, 调用 Derived::mf1d.mf1(x); // 现在没问题了, 调用 Based::mf1d.mf2(); // 没问题, 调用 Derived::mf2d.mf2(x); // 现在没问题了, 调用 Based::mf2 使用inline转交函数（forwarding function） 然而在private继承之下（见条款39），有时候你并不想继承base class的所有函数。假设Derived以private形式继承Base，而Derived唯一想继承的mf1是那个无参数版本。using声明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名函数在derived class中都可见。 1234567891011121314151617181920212223class Base&#123;public: virtual void mf1() = 0; virtual void mf1(int); ... // 与前同&#125;;class Derived : private Base&#123;public: virtual void mf1() // 转交函数 &#123; Base::mf1(); // 暗自成为 inline (见条款 30) &#125; ...&#125;;Derived d;int x;d.mf1(); // 很好, 调用的是 Derived::mf1d.mf1(x); // 错误! Base::mf1 被遮掩 条款34：区分接口继承和实现继承身为class设计者，有时候你会希望derived class只继承成员函数的接口，也就是声明；有时候你又会希望derived class同时继承函数的接口和实现，但又希望能够覆写（override）它们所继承的实现；又有时候你希望derived class同时继承函数的接口和实现，并且不允许覆写任何东西。 base类强烈影响以public形式继承它的derived class，因为： 成员函数的接口总是会被继承 声明一个pure virtual函数的目的是为了让derived类只继承函数接口 含有pure virtual函数的类属于抽象基类，不能被实例化。继承了它们的类必须重新声明此函数接口并给予实现。抽象基类可以给pure virtual函数提供定义，但调用它的唯一途径是“调用时指定其class的名称”。 声明impure函数的目的是让derived class继承该函数的接口和缺省实现 但是，允许impure virtual函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑XYZ航空公司设计的飞机继承体系。该公司只有A型和B型两种飞机，两者都以相同方式飞行。因此XYZ设计出这样的继承体系： 1234567891011121314class Airport &#123;...&#125;; // 用以表现机场class Airplane&#123;public: virtual void fly(const Airport&amp; destination); ...&#125;;void Airplane::fly(const Airport&amp; destination) &#123; ... // 缺省代码, 将飞机飞至指定的目的地&#125;class ModelA: public Airplane &#123;...&#125;;class ModelB: public Airplane &#123;...&#125;; 为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的fly实现”，Airplane::fly被声明为virtual。然而为了避免在ModelA和ModelB中撰写相同代码，缺省飞行行为由Airplane::fly提供，它同时被ModelA和ModelB继承。 现在，XYZ航空公司决定购买一种新式C型飞机。C型和A型以及B型的飞行方式不同。XYZ公司的程序员在继承体系中针对C型飞机添加了一个class，但由于他们急着让新飞机上线服务，竟忘了重新定义其fly函数： 12345678910class ModelC : public Airplane&#123; // 未声明fly函数&#125;;Airport PDX(... ); // PDX 是我家附近的机场Airplane* pa= new ModelC;...// 这将酿成大灾难pa-&gt;fly(PDX); // 调用 Airplane::fly 一种解救办法为切断“virtual函数接口”和其“缺省实现”之间的连接。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Airplane&#123;public: // 现在是 pure virtual 函数 virtual void fly(const Airport&amp; destination) = 0;protected: void defaultFly (const Airport&amp; destination);&#125;;void Airplane::defaultFly(const Airport&amp; destination)&#123; ... // 缺省行为, 将飞机飞至指定的目的地。&#125;class ModelA : public Airplane &#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly(destination); &#125;&#125;;class ModelB : public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; defaultFly (destination); &#125;&#125;;// 现在 ModelC class 不可能意外继承不正确的 fly 实现代码了// 因为 Airplane 中的 pure virtual 函数追使 ModelC 必须提供自己的 f1y 版本class ModelC: public Airplane&#123;public: virtual void fly(const Airport&amp; destination);&#125;;void ModelC::fly(const Airport&amp; destination)&#123; ... // 将 C 型飞机飞至指定的目的地&#125; 另一种解救方法是，利用“pure virtual函数必须在derived class中重新声明，但它们也可以拥有自己的实现”这一事实。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Airplane&#123;public: // 现在是 pure virtual 函数 virtual void fly(const Airport&amp; destination) = 0;&#125;;// 给予 pure virtual 函数实现void Airplane::fly(const Airport&amp; destination)&#123; ... // 缺省行为, 将飞机飞至指定的目的地&#125;class ModelA : public Airplane&#123;public: virtual void fly(const Airport&amp; destination) &#123; Airplane::fly(destination); // 通过指定其类名调用它 &#125; ...&#125;;class ModelB : public Airplane&#123;public: virtuai void fly(const Airport&amp; destination) &#123; Airplane::fly(destination); // 通过指定其类名调用它 &#125; ...&#125;;class ModelC : public Airplane&#123;public: virtual void fly(const Airport&amp; destination);&#125;;void ModelC::fly(const Airport&amp; destination)&#123; ... // 将 C 型飞机飞至指定的目的地&#125; 声明non-virtual函数的目的是为了derived class继承函数的接口及其强制性实现 non-virtual函数为其所属class建立的意义是不变性凌驾其特异性，所以它不该在derived class中被重新定义。 条款35：考虑virtual函数以外的其他选择假设你正在写一个视频游戏软件，你的游戏属于暴力砍杀类型，剧中人物存在被伤害而降低健康状态的情况。因此你决定提供一个成员函数 healthvalue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将healthvalue声明为virtual似乎是再明白不过的做法： 123456class GameCharacter&#123;public: virtual int healthvalue() const; // 返回人物的健康指数, // derived classes 可重新定义它&#125;; 现在考虑一些其它解法： 借助non-virtual interface(NVI)手法实现Template Method模式 保留healthvalue为public成员函数，但让它成为non-virtual，并调用一个private virtual函数进行实际工作： 123456789101112131415161718class GameCharacter&#123;public: int healthvalue() const // derived class 不重新定义它 &#123; ... // 做一些事前工作 int retval = doHealthvalue(); // 做真正的工作 ... // 做一些事后工作 return retval; &#125;// NVI 手法下没必要让 virtual 函数一定是 privateprivate: virtual int doHealthValue() const // derived class 可重新定义它 &#123; ... // 缺省算法, 计算健康指数。 &#125;&#125;; 这一基本设计，“令客户通过public non-virtual成员函数间接调用private virtual函数”，称为non-virtual interface(NVI)手法。它是所谓Template Method设计模式的一个独特表现形式。我把这个non-virtual函数（healthvalue）称为virtual函数的外覆器（wrapper) 。 NVI手法的一个优点隐藏在上述代码注释“做一些事前工作”和“做一些事后工作”之中。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证 class约束条件、验证函数先决条件等。“事后工作”可以包括互斥器解除锁定、验证函数的事后条件、再次验证class约束条件等。如果你让客户直接调用virtual函数，就没有任何好办法可以做这些事。 借助Function Pointer实现Strategy模式 另一个设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个函数指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算： 123456789101112131415161718192021class GameCharacter; // 前向声明// 以下函数是计算健康指数的缺省算法int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: typedef int (*HealthCalcFunc)(const GameCharacter&amp;); explicit GameCharacter (HealthCalcFunc hcf = defaultFealthCalc) : healthFunc(hcf) &#123;&#125; int healthvalue() const &#123; return healthFunc (*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 这种设计策略和前面介绍的方法相比提供了一些有趣的弹性： 同一人物类型的不同实体可以有不同的健康计算函数 123456789101112class EvilBadGuy : public GameCharacter&#123;public: explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc) : GameCharacter(hcf) &#123;...&#125; ...&#125;;int loseHealthQuickly(const GameCharacter&amp;); // 健康指数计算函数 1int loseHealthSlowly(const GameCharacter&amp;); // 健康指数计算函数 2EvilBadGuy ebg1(loseHealthQuickly); // 相同类型的人物搭配EvilBadGuy ebg2(loseHealthSlowly); // 不同的健康计算方式 某已知人物之健康指数计算函数可在运行期变更 例如GameCharacter可提供一个成员函数setHealthcalculator，用来替换当前的健康指数计算函数。 然而这种策略意味着，计算函数并不能访问“被计算健康指数的”那个对象的内部（non-public）成分。如果需要访问non-public成分进行精确计算，这就有问题了。 唯一能够解决的办法就是：弱化class的封装。例如，将健康计算函数声明为friend。或是为其实现的某一部分提供public访问函数。这需要你来权衡利弊进行抉择。 借助std::function实现Strategy模式 123456789101112131415161718192021class GameCharacter;int defaultHealthCalc(const GameCharacter&amp; gc);class GameCharacter&#123;public: // 不同之处 typedef std::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc; explicit GameCharacter (HealthCalcFunc hcf = defaultFealthCalc) : healthFunc(hcf) &#123;&#125; int healthvalue() const &#123; return healthFunc (*this); &#125; ...private: HealthCalcFunc healthFunc;&#125;; 那个签名代表的函数是“接受一个reference指向const GameCharacter，并返回int”。这个std::function类型（也就是我们所定义的HealthCalcFunc类型）产生的对象可以持有（保存）任何与此签名式兼容的可调用物。所谓兼容，意思是这个可调用物的参数可被隐式转换为const GameCharacter&amp;，而其返回类型可被隐式转换为int。 这就提供了很大的灵活性： 1234567891011121314151617181920212223242526272829303132333435363738short calcHealth(const GameCharacter&amp;); // 健康计算函数 // 注意其返回类型为 non-intstruct HealthCalculator&#123; // 为计算健康而设计的函数对象 int operator()(const GameCharacter&amp;) const &#123;...&#125;&#125;;class GameLevel&#123;public: float health(const GameCharacter&amp;) const; // 成员函数, 用以计算健康 // 注意其 non-int 返回类型&#125;;// 人物类型 1class EvilBadGuy: public GameCharacter&#123; ... // 同前&#125;;// 人物类型 2class EyeCandyCharacter: public GameCharacter&#123; // 假设其构造函数与 EvilBadGuy 同&#125;;// 人物 1, 使用某个函数计算健康指数EvilBadGuy ebg1(calcHealth);// 人物 2, 使用某个函数对象计算健康指数EyeCandyCharacter ecc1(HealthCalculator());GameLevel currentLevel;...// 人物 3, 使用某个成员函数计算健康指数EvilBadGuy ebg2(std::bind(&amp;GameLevel::health, &amp;currentLevel, _1)); 传统的Strategy模式 123456789101112131415161718192021222324252627282930313233343536373839404142class GameCharacter;class HealthCalcFunc&#123;public: virtual ~HealthCalcFunc() &#123;&#125; virtual int calc(const GameCharacter&amp; gc) const = 0;&#125;;class SlowHealthLoser : HealthCalcFunc&#123;public: virtual int calc(const GameCharacter&amp; gc) const &#123; ... &#125; ...&#125;;class FastHealthLoser : HealthCalcFunc&#123;public: virtual int calc(const GameCharacter&amp; gc) const &#123; ... &#125; ...&#125;;class GameCharacter&#123;public: explicit GameCharacter(HealthCalcFunc* phcf) : pHealthCalc(phcf) &#123;&#125; int healthValue() const &#123; return pHealthCalc-&gt;calc(*this); &#125;private: HealthCalcFunc* pHealthCalc;&#125;; 条款36：绝不重新定义继承而来的non-virtual函数 如题 条款37：绝不重新定义继承而来的缺省参数值本条款的讨论局限于“继承一个带有缺省参数值的virtual函数”：virtual函数是动态绑定（后期绑定，延迟绑定），而缺省参数值却是静态绑定（前期绑定，早绑定）。 123456789101112131415161718192021222324252627// 一个用以描述几何形状的classclass Shape&#123;public: enum ShapeColor&#123;Red, Green, Blue&#125;; // 所有形状都必须提供一个函数, 用来绘出自己 virtual void draw(ShapeColor color = Red) const = 0; ...&#125;;class Rectangle : public Shape &#123;public: // 注意, 赋予不同的缺省参数值, 这真糟糕! virtual void draw(ShapeColor color = Green) const; ...&#125;;class Circle : public shape&#123;public: virtual void draw(ShapeColor color) const; // 请注意，以上这么写则当客户以 对象 调用此函数一定要指定参数值 // 因为静态绑定下这个函数并不从其 base 继承缺省参数值 // 但若以指针或 reference 调用此函数, 可以不指定参数值 // 因为动态绑定下这个函数会从其 base 继承缺省参数值&#125;; 对象的静态类型就是它在程序中所声明的类型，对象的动态类型则是指“目前所指对象的类型” 123shape* ps; // 静态类型为 shape*, 无动态类型Shape* pc = new Circle; // 静态类型为 Shape*, 动态类型是 Circle*Shape* pr = new Rectangle; // 静态类型为 shape*, 动态类型是 Rectangle* 动态类型可在程序执行过程中改变（通常是经由赋值动作）： 12ps = pc; // ps 的动态类型如今是 circle*ps = pr; // ps 的动态类型如今是 Rectangle* virtual函数系动态绑定而来，意思是调用一个virtual函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。 12pr-&gt;draw(); // 调用的是 Rectangle::draw(shape::Red)! // 注意缺省参数是 Red 而不是 Green 此例之中，pr的动态类型是Rectangle*，所以调用的是Rectangle的virtual函数。Rectangle::draw函数的缺省参数值应该是Green，但由于pr的静态类型是shape*，所以此一调用的缺省参数值来自Shape class而非Rectangle class！这不符合预期。 解救方法是利用条款35中介绍的NVI手法替代virtual函数： 123456789101112131415161718192021class Shape&#123;public: enum shapeColor&#123;Red, Green, Blue&#125;; void draw(ShapeColor color = Red) const // 如今它是 non-virtual &#123; doDraw(color); // 调用一个 virtual &#125;private: virtual void doDraw(shapeColor color) const = 0; // 真正的工作在此处完成&#125;;class Rectangle : public Shape&#123;public: ...private: virtual void doDraw (ShapeColor color) const; // 注意, 不须指定缺省参数值 ...&#125;; 这个设计很清楚地使得draw函数的color缺省参数值总是Red。 条款38：通过复合塑模出has-a或is-implemented-in-terms-of当某种类型的对象内含其它对象时便形成了复合关系。 应用域 程序中的对象其实相当于你所塑造出来的世界中的某些事物。比如人，汽车，高楼大厦等。这样的对象属于应用域部分。 实现域 其它对象如缓冲区，互斥器，搜索树等纯粹是实现细节上的工具。这些对象相当于软件中的实现域。 当复合发生于应用域对象之间表现出has-a关系，当它发生于实现域内则表现出is-implemented-in-terms-of（根据某物实现出）的关系。 复合的意义和public继承完全不同 注意区分is-a和is-implemented-in-terms-of这两种对象关系。 条款39：明智而谨慎地使用private继承一个derived类继承base类有public、protected或private三种继承方式。 公有继承（public）（普遍使用） base类的public成员也是derived类的public成员，base类的protected成员也是derived类的protected成员 保护继承（protected）（基本不使用） base类的public和protected成员将成为derived类的protected成员。 私有继承（private）（少的情况使用） base类的public和protected成员将成为derived类的private成员。 无论哪一种继承方式，base类的private成员都不能直接被derived类访问，但是可以通过调用base类的public和protected成员间接来访问（如果base类提供了访问接口的话）。 private继承意味着is-implemented-in-terms-of private继承只限于软件实现层面，这就是为什么private继承后，base class的所有成分（除了private）在你的class内都是private，因为它们都只是实现细节而已。 尽可能使用复合，必要时才使用private继承 当derived类想要访问base class的protected成员时 当derived类为了重新定义base class的virtual函数时 现在考虑一个Widget类，它需要用到另一个计时器Timer类来实现一些业务。 123456 class Timer&#123;public: explicit Timer(int tickFrequecy); virtual void onTick() const; // 定时器每滴答一次, 此函数就调用一次&#125;； 为了让Widget重新定义Timer内的virtual函数，Widget必须继承自Timer。因为Widget不是个Timer，因此public继承不合适。必须以private方式继承： 123456class Widget&#123; ...private: virtual void onTick() const; // &#125;; 通过private继承，Timer的public onTick函数在Widget内变成private，而我们重新声明（定义）时仍然把它留在那儿。如果把onTick放进public内会误导客户以为他们可以调用它，那就违反了条款18。 另一种设计方案是采用复合 + public继承： 123456789101112131415class Widget&#123; ...private: // 在 Widget 内声明一个嵌套式 private class class WidgetTimer : public Timer &#123; public: // 以 public 方式继承并重新定义 virtual 函数 virtual void onTick() const; ... &#125;; WidgetTimer timer; ...&#125;; 采用第二种较为复杂的方式的两点理由： 你或许会想设计Widget使它得以拥有derived class，但同时你可能会想阻止derived class重新定义onTick。如果Widget继承自Timer，上面的想法就不可能实现，即使是private继承也不可能。但如果WidgetTimer是Widget内部的一个private成员并继承自Timer，Widget的derived class将无法取用WidgetTimer，因此无法继承它或重新定义它的virtual函数。 你或许会想要将Widget的编译依存性降至最低（条款31）。如果Widget继承Timer，当Widget被编译时Timer的定义必须可见，所以定义Widget的那个文件恐怕必须#include Timer.h。但如果WidgetTimer移出Widget所在文件之外而Widget内含指针指向一个WidgetTimer，Widget可以只带着一个简单的WidgetTimer前向声明式，不再需要#include任何与Timer有关的东西。很容易就实现了解耦。 EBO（empty base optimization） empty class指的是没有non-static成员变量，没有virtual函数，也没有virtual base class。于是这种class不占用理论上不占用任何内存空间。然而在实现技术上，C++要求独立（非附属）对象都必须有非零大小。 12345678910class Empty &#123; &#125;; // 没有任何需要存储的数据// 理论上 sizeof(HoldAnInt) = 4 字节(就一个 int)// 实际上 sizeof(HoldAnInt) = 8 字节class HoldAnInt&#123;private: int x; // 4 字节 Empty e; // 理论上应该不占据内存&#125;; C++编译器默认为empty class独立对象安插一个char（1字节） 由于内存对齐HoldAnInt的实际大小为4 + 1(内存对齐至 4) = 8 但这个约束不适用于derived class对象的base class成分（非独立）： 123456// 理论和实际上 sizeof(HoldAnInt) = 4 字节(就一个 int)class HoldAnInt : public Empty&#123;private: int x; // 4 字节&#125;; 现实中的empty class并非真是empty。往往内含typedef，enum，static成员变量，或non-virtual函数。STL就有许多技术用途的empty class，其中内含有用的成员（通常是typedef），包括base class unary_function和binary_function，这些是“用户自定义之函数对象”通常会继承的class。由于EBO，这样的继承很少增加derived class的大小。 条款40：明智而谨慎地使用多重继承 多重继承较单一继承复杂，可能导致歧义性 当继承的多个base具有同名成员函数时，derived类调用时会出现歧义。 有时多重继承不得不需要virtual继承，而这会带来额外的体积、运行速度、初始化复杂度等成本 比如这样的钻石继承体系： 这个继承体系中某个base class和某个derived class之间有一条以上的相通路线，假设File class有个成员变量fileName，那么IOFile从每一个base class各继承一份，所以其对象内会有两份fileName成员变量。然而IOFile对象只该有一个文件名称，所以名称fileName不该重复。 解决办法就是采用virtual继承： virtual继承带来的后果是： 使用virtual继承的那些class所产生的对象往往比使用non-virtual继承的class体积大 访问virtual base class的成员变量时，也比访问non-virtual base class的成员变量速度慢 另外，支配“virtual base class初始化”的规则比起non-virtual base class的情况远为复杂且不直观。virtual base class的初始化责任是由继承体系中的最低层（most derived）class负责的，这意味着： class若派生自virtual base而需要初始化，必须知道其virtual base class——不论那些base class距离多远。 当一个新的derived class加入继承体系中，它必须承担其virtual base class的初始化责任。 关于virtual继承的忠告： 非必要不使用virtual base。平常请使用non-virtual继承。 如果必须使用virtual base class，尽可能避免在其中放置数据。这么一来你就不需担心这些class身上的初始化（和赋值）所带来的诡异事情了。 最后看一个多重继承的应用例子——public继承某个Interface class和private继承某个协助实现的class。 （参考书籍P195-P198）","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"},{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"}]},{"title":"数据结构与算法之概论","date":"2020-04-04T05:54:42.000Z","path":"eSK55yN7G7dNea2c/","text":"数据结构相互之间存在一种或多种特定关系的数据元素的集合。研究数据结构，关心的是数据对象的描述以及相关操作函数的实现。 数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。如整型、浮点型等数值类型，以及声音、图像等非数值类型。 数据元素是组成数据的、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称作记录。 数据项一个数据元素可以由若干个数据项组成。它是数据不可分割的最小单位。 数据对象是性质相同的数据元素（即有相同的数量和类型的数据项）的集合，是数据的子集。 常见的数据结构 线性数据结构：向量vector（顺序存储）、链表list（链式存储）、栈stack和队列queue（优先队列）。 半线性数据结构：二叉树、搜索树（二叉搜索树BST、AVL树、B树、红黑树）、竞赛树等。 非线性数据结构：图。 哈希表hashtable、字典dictionary。 抽象数据类型 数据类型：指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 抽象数据类型：指一个数学模型及定义在该模型上的一组操作。可以理解为C++中的类class。它体现的是程序设计中问题分解、抽象和信息隐藏的特性。 抽象数据类型的标准格式12345678ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义Operation 操作1 操作2 ...endADT 算法算法是解决指定问题求解步骤的描述。在计算机中是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。 计算或信息处理指借助某种工具，按照一定的规则，以明确而机械的形式进行。 算法中的计算模型就是计算机，即信息处理工具。 算法必须具备的几大要素 输入：待处理的信息或问题。 输出：经处理的信息，即答案。 正确性：的确可以解决指定的问题。 确定性：任何一个算法都可以描述为一个由基本操作组成的序列。 可行性：每一基本操作都可实现，且能在常数时间内完成。 有穷性：对于任何输入，经有限次的基本操作，都可以得到输出。 一个好的算法 正确，即符合语法，能够编译、链接。 能够正确处理简单的、大规模的、一般性的、退化的、任意合法的输入。 健壮，能够辨别不合法的输入并做适当处理，而不致非正常退出。 可读，结构化 + 准确命名 + 注释 + …。 效率，运行速度尽可能快，用到的存储空间尽可能少。 常见的算法 查找 顺序查找、二分查找、插值查找、斐波那契查找、分块查找和哈希查找等。 排序 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序和希尔排序等。 递归、分而治之、动态规划、回溯法和分支定界法等。 要对数据结构和算法设计方法给予评价，就必须能够计算程序性能。 数据结构和算法的关系 数据结构(data structures) + 算法(algorithms) = 程序(programs) (data structures + algorithms) x efficiency = computation 程序性能分析是指分析一个程序对于内存空间和运行时间的需求。 空间复杂度指程序运行时临时占用内存的大小。广义上的概念是包括存储算法本身所占用的空间、算法的输入输出数据所占用的空间以及算法在运行过程中临时占用的存储空间这三个方面。 时间复杂度指运行程序所需要的时间。这里度量的是程序中基本操作执行的次数，它是问题规模n的函数f(n)。记T(n)=O(f(n))，它表示随问题规模n的增大，算法执行时间的增长率和f(n)相同，称作算法的渐进时间复杂度。 复杂度分析这里的复杂度分析通常指的是最坏时间复杂度分析。 常数阶O(1) 取前三个元素x = S[0]、y = S[1]和z = S[2]，这一步只需执行三次（从特定单元读取元素的）基本操作，耗费O(3)时间。接下来，为确定这三个元素的大小次序，最多需要做三次比较，也需O(3)时间。最后，输出居中的非极端元素只需O(1)时间。因此，上面取非极端元素算法的时间复杂度为：T(n) = O(3) + O(3) + O(1) = O(7) = O(1)。 对数阶O(logn) 根据右移运算的性质，每右移一位，n都至少缩减一半。也就是说，至多经过1 + log2n次循环，n必然缩减至0，从而算法终止。因此时间复杂度为：O(1 + log2n) = O(log2n) 。 线性阶O(n) 平方阶O(n) 时间复杂度为：O(2n^2 + n + 1) = O(n^2)。 常见的算法时间复杂度排序Ο(1) ＜ Ο(logn) ＜ Ο(n) ＜ Ο(nlogn) ＜ Ο(n^2) ＜ … ＜ Ο(2^n) ＜ Ο(n!)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://yuanlehome.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Effective C++之实现","date":"2020-04-01T13:35:42.000Z","path":"hNsvEFKo8ZJPUeMf/","text":"第5章：实现条款26：尽可能延后变量定义式的出现时间 应该延长变量的定义，直到非得使用它时 应该延后这份定义，直到能够给它初值实参 对于循环存在的情况： 做法A：定义于循环外 123456Widget w;for(int i = 0; i &lt; n; i++)&#123; w = 取决于 i 的某个值； ...&#125; 做法B：定义于循环内 12345for(int i = 0; i &lt; n; i++)&#123; Widget w(取决于 i 的某个值); ...&#125; 这两种写法的成本如下： 做法A：1个构造函数 + 1个析构函数 + n个赋值操作 做法B：n个构造函数 + n个析构函数 做法A会造成名称w的作用域比做法B更大 除非（1）你知道赋值成本比构造 + 析构成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法B。 条款27：尽量少做转型操作旧式C转型： T(expression) (T)expression 新式C++转型： const_cast&lt;T&gt;(expression) 用来将对象的常量性（const）转除（只有它能办到）。 dynamic_cast&lt;T&gt;(expression) 用来执行安全向下转型，也就是用来决定某对象是否归属继承体系中的某个类型。 reinterpret_cast&lt;T&gt;(expression) 用来执行低级转型，如将一个pointer to int 转为一个int。很少使用（在条款50中使用过一次）。 static_cast&lt;T&gt;(expression) 用来强迫隐式转换，例如将non-const对象转为const对象，将int转为double，将void*指针转为typed指针，或将pointer to base转为pointer to derived。 任何一种类型转换（无论显式转换还是隐式转换）往往都会令编译器编译出运行期间执行的码。如将int转为double会产生一些代码，因为int的底层表述不同于double的： 123int x, y;...double z = static_cast&lt;double&gt;(x) / y; 再比如： 1234class Base &#123;...&#125;;class Derived: public Base &#123;...&#125;;Derived d;Base* pb = &amp;d; // 隐喻的将 Derived* 转换为 Base* 这种情况下有时候会有一个偏移量在运行期被施行于Derived*身上，用来取得正确的Base*指针值。这个例子表明单一对象可能有一个以上的地址（以Base*指向它时的地址和以Derived*指向它时的地址）。 假设我们有个base class Window和一个derived class Specialwindow，两者都定义了virtual函数onResize。进一步假设Specialwindow的onResize函数被要求首先调用Window的onResize。下面实际上是错的实现方式： 12345678910111213141516171819202122class Window&#123;public: ... virtual void onResize () &#123;...&#125; // base onResize实现代码 ...&#125;;class Specialwindow: public Window&#123;public: ... // derived onResize 实现代码 virtual void onResize() &#123; static_cast&lt;Window&gt;(*this).onResize(); // 将 *this 转型为 Window, // 然后调用其 onResize; // 这不可行! ... // 这里进行 Specialwindow 专属行为 &#125; ...&#125;; 它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“*this对象之base class成分”的暂时副本身上的onResize！如果Window::onResize修改了对象内容，当前对象其实没被改动，改动的是副本。然而SpecialWindow::onResize内如果也修改对象，当前对象真的会被改动。这使当前对象进入一种“伤残”状态：其base class成分的更改没有落实，而derived class成分的更改倒是落实了。 正确的做法是： 1234567891011class Specialwindow: public Window&#123;public: ... virtual void onResize() &#123; Window::onResize(); // 调用 Window::onResize 作用于 *this 身上 ... &#125; ...&#125;; dynamic_cast的实现版本执行速度相当慢，应该在注重效率的代码中保持对dynamic_cast的警觉 优良的C++代码很少使用转型，我们应该尽可能隔离转型动作，通过将它隐藏在某个函数内，使得客户可以调用该函数而不需要将转型放进他们自己代码内 宁可使用新式转型，也不要使用旧式转型，前者很容易辨识出来 条款28：避免返回handles指向对象内部成分 handles指指针、引用和迭代器 成员变量的封装性最多只等于“返回其reference”的函数的访问级别 如果const成员函数不得不传出去一个reference，则最好将返回类型限定为const 有可能会导致空悬的handles，它的生命期却长于其所指对象 条款29：为“异常安全”而努力是值得的当异常被抛出时，带有异常安全性的函数会： 不泄露任何资源 不允许数据败坏 较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也少。异常安全码必须提供以下三个保证之一： 基本承诺 如果异常被抛出，程序内的任何事物仍然保证在有效状态（只要那是个合法状态）下，没有任何对象或数据结构会因此而败坏，所有对象处于一种内部前后一致的状态。 强烈保证 如果异常被抛出，程序状态不改变。 不抛掷保证 承诺绝不抛出异常，因为它们总能完成原先承诺的功能。 可以实现强烈保证的copy and swap技术：为你打算修改的对象做出copy一份副本，然后在副本身上做一切修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。带所有改变都成功后，再将修改后的副本和原对象swap。 1234567891011121314151617181920212223242526272829// 之所以实现为 struct 是因为其 PrettyMenu 的数据封装性// 已经由 pImpl 是 private 获得了保证class Image &#123;...&#125;;struct PMImpl&#123; std::shared_ptr&lt;Image&gt; bgImage; int imageChanges;&#125;;class PrettyMenu&#123; ...private: Mutex mutex; std::shared_ptr&lt;PMImpl&gt; pImpl; // pimpl idiom 详细描述见条款 31&#125;;void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123; using std::swap; // 见条款25 Lock ml(&amp;mutex); // 获得mutex的副本数据 std::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl)); pNew-&gt;bgImage.reset(new Image(imgSrc)); // 修改副本 ++pNew-&gt;imageChanges; swap(pImpl, pNew); // 置换(swap)数据, 释放 mutex) 注意，并非所有函数都可实现强烈保证或其具备现实意义。 函数提供的”异常安全保证“通常最高只等于其所调用各个函数提供的”异常安全保证“中的最弱者。 条款30：透彻了解inlining的里里外外inline函数是指将对此函数的每一个调用都以函数本体替换之。这将导致两种情况： 目标码增加（显然） 如果inline函数的体积很小，编译器对“函数本体”所产出的码可能比“函数调用”所产出的码小 inline只是对编译器的一个申请，不是强制命令，也就是说编译器可以拒绝将太过复杂（带有递归或循环）的函数进行inline。通过对函数使用inline关键字属于明确提出申请，将函数定义于类内属于隐喻申请。 将大多数inline限制在小型、被频繁调用的函数身上 inline函数通常一定被置于头文件内 因为大多数构建环境在编译过程中进行inlining，而为了将一个函数调用替换为被调用函数的本体，编译器必须知道那个函数长什么样子。 所有对virtual函数的inline申请都会被拒绝（因为对virtual函数的调用在运行期才确定） 条款31：将文件间的编译依存关系降至最低 将接口从实现中分离 12345678910111213class Person&#123;public: Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); string name() const; string birthDate() const; string address() const; ...private: string theName; // 实现细目 Date theBirthDate; // 实现细目 Address theAddress; // 实现细目&#125;; 这里的class无法通过编译，因为编译器没有取得其实现代码所用到的class string，Date，Address的定义式，通常应该在Person定义文件的最上方存在include头文件。 123#include &lt;string&gt;#include \"date.h\"#include \"address.h\" 不幸的是，这么一来便是在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其他头文件有任何改变，那么每一个含入Person class的文件就得重新编译，任何使用person class的文件也必须重新编译。这样的连串编译依存关系（cascading compilation dependencies）会对许多项目造成难以形容的灾难。 Handle classes：pimpl idiom(pointer to implenmentation) + 前向声明 把Person分割成两个class，一个只提供接口，另一个负责实现接口。 1234567891011121314151617181920212223242526272829#include &lt;string&gt; //标准程序库组件不该被前向声明#include &lt;memory&gt;// 使用前向声明而不是包含头文件, 这个很关键class PersonImpl; // Person 实现类// Person 接口用到的 classclass Date; class Address;class Person&#123;public: Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); string name() const; string birthDate() const; string address() const; ...private: shared_ptr&lt;PersonImpl&gt; pImpl; // 指针, 指向实现物 // 如果不这样做的话, 编译器在编译 Person 类的时候，必须知道 Person 类的大小 // 就不得不包含这三个实现细目 /* string theName; // 实现细目 Date theBirthDate; // 实现细目 Address theAddress; // 实现细目 */ // 然而一旦这样写, 前面的前向声明就没用了, 必须包含头文件&#125;; 这样一来，Person类的使用者就完全于Date，Address以及Person的实现细目相分离了。这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：实现上让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。 几个简单的设计策略： 如果使用object reference或object pointer可以完成任务，就不要使用object 你可以只靠一个类型声明式就定义出指向该类型的reference和pointer；但如果定义某类型的object，就需要用到该类型的定义式。 如果能够，尽量以class声明式替换class定义式 注意，当你声明一个函数而它用到某个class时，你并不需要该class的定义。 为声明式和定义式提供不同的头文件 对于前面代码中的前向声明，最好是提供一个声明式头文件，包含全部的前向声明。 下面式Person.cpp文件的部分实现： 12345678910#include &lt;Person.h&gt;#include &lt;PersonImpl.h&gt; // 注意，Person 和PersonImpl的成员函数完全相同, 两者接口完全相同Person::Person(const string&amp; name, const Date&amp; birthday, const Address&amp; addr) : pImpl(new PersonImpl(name, birthday,addr)) &#123;&#125;string Person::narne( ) const &#123;return pImpl-&gt;name();&#125;... Interface classes：abstract base class + factory函数 abstract base class通常没有成员变量，也没有构造函数，只有一个virtual析构函数和一组pure virtual函数。但Interface class的客户必须有办法为这种class创建新对象。他们通常调用一个特殊函数，此函数创建实际实现的derived class，这样的函数通常称为factory(工厂）函数（见条款13），它们返回智能指针指向动态分配所得对象，而该对象支持Interface class的接口。这样的函数又往往在Interface class内被声明为static： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 位于 Person.h// 抽象基类, 只有声明// 提供给客户使用的头文件class Person&#123;public: virtual ~Person(); virtual strng name() const = 0; virtual strng birthDate() const = 0; virtual string address() const = 0; // static 的 factory 函数 static shared_ptr&lt;Person&gt; create(const string&amp; name, const Date&amp; birthday, const Address&amp; addr); ...&#125;// 位于 Person.cpp#include \"Person.h\"class RealPerson: public Person&#123;public: RealPerson(const string&amp; name, const Date&amp; birthday, const Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125; virtual ~RealPerson() &#123;&#125; string name() const; string birthDate() const; string address() const;private: string theName; Date theBirthDate; Address theAddress;&#125;;... // 虚函数的实现码shared_ptr&lt;Person&gt; Person::create(const string&amp; name, const Date&amp; birthday, const Address&amp; addr)&#123; return shared_ptr&lt;Person&gt;(new RealPerson(name, birthday, addr));&#125; Handle classes和Interface classes解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"},{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"}]},{"title":"Effective C++之设计与声明","date":"2020-03-21T13:35:42.000Z","path":"S0Qfg61EKNlwLo15/","text":"第4章：设计与声明条款18：让接口容易被正确使用，不容易被误用 如果客户企图使用某个接口却没有获得所预期的行为，这个代码不应该通过编译；如果代码通过了编译，则它的行为就应该是客户想要的 欲达“让接口容易被正确使用，不容易被误用”的目的，必须考虑客户调用接口时可能做出什么样的错误 “促进正确使用”的办法包括接口的一致性，以及与内置类型兼容 “阻止误用”的办法包括建立新类型、限制在类型上的操作，束缚对象值以及消除客户的资源管理责任 条款19：设计class犹如设计type你应该带着“语言设计者当初设计语言内置类型时”一样的谨慎来研讨每一个class的设计。因为，重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结…全都在你手上。 新的type的对象应该如何创建和销毁？ 设计函数为类的构造函数和析构函数以及内存分配函数和释放函数（见条款49-52）。 对象的初始化和对象的赋值该有什么样的差别？ 决定了构造函数和赋值操作符的行为以及差异。 新type的对象被passed by value，意味着什么？ 取决于copy构造函数的实现。 什么新type的合法值？ 你的新type需要配合某个继承图系吗？ 见条款7、34、36。 你的新type需要什么样的转换？ explicit和operator关键字的使用。见条款15。 什么样的操作符和函数对此新type而言时合理的？ 见条款23、24、46。 什么样的标准函数应该驳回？ 见条款6。 谁该取用新type的成员？ 决定了数据成员是public、private还是protected，以及friend关键的使用。 什么是新type的“未声明接口”？ 见条款29。 你的新type有多么一般化？ 决定class template的使用。 你真的需要一个新type吗？ 条款20：宁以pass by reference to const替换pass by value 当把具有继承关系的类作为参数传递时，如果pass by value可能会出现“截断”问题。 条款21：必须返回对象时，别妄想返回其reference 绝不要返回指向一个local stack对象的pointer或reference 绝不要返回指向一个heap allocated对象的reference 除非有单例模式的设计要求，否则绝对不要返回指向一个local static对象的pointer或reference 条款22：将成员变量声明为private 客户访问数据的一致性 public里都是函数。 可以对成员变量有更精确的控制 可以实现成员变量的不可访问，只读、只写、读写访问。 封装性 将成员变量隐藏在函数接口背后，可以为所有可能的实现提供弹性。 从封装的角度看，只有两种权限：private（提供封装）和其它 protected并不比private更具封装性。 条款23：宁以non-member、non-friend替换member函数考虑一个用来表示网页浏览器的class，这个class提供的众多成员函数中，有用来清除下载元素高速缓冲区的，有用来清除访问过的历史记录的，有用来移除系统中所有cookies的。 12345678910111213141516171819202122232425262728class WebBrowser&#123;public: ... void clearCache(); void clearHistory(); void cleatCookies(); ...&#125;;// 客户想一整个执行所有的操作// 以提供一个 member 函数的方式class WebBrowser&#123;public: ... void clearEverthing(); ...&#125;;// 以提供一个 non-member 函数的方式void clearBrowser(WebBrowser&amp; wb)&#123; wb.clearCache(); wb.clearHistory(); wb.cleatCookies();&#125; 后者比较好。因为： 增加封装性 non-member non-friend将提供较大的封装性，因为它并不增加能够访问class内的private成分的函数数量。friend函数对class private成员的访问权力和member函数相同，两者对封装的冲击力度是一样的。 增加扩充机能性 在C++中，正确且自然的做法是： 123456namespace WebBrowserStuff&#123; class WebBrowser &#123;...&#125;; void clearBrowser(WebBrowser&amp; wb); // 为 WebBrowser “提供便利”的函数 ...&#125; namespace和class的不同是，前者可跨越多个源码文件而后者不能。 像WebBrowser这样的类可能有大量的“提供便利”函数，某些与书签有关，与打印有关，与cookie有关… 分离它们最直接的做法就是： 123456789101112131415161718// 头文件 WebBrowser.h 内namespace WebBrowserStuff&#123; class WebBrowser &#123;...&#125;; ... // 核心机能, 例如所有客户都想要的 non-member 函数&#125;// 头文件 WebBrowserBookmarks.h 内namespace WebBrowserStuff&#123; ... // 与书签相关的 non-member 函数&#125;// 头文件 WebBrowserCookies.h 内namespace WebBrowserStuff&#123; ... // 与 cookie 相关的 non-member 函数&#125; 将所有“便利函数”放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组“便利函数”。 条款24：若所有参数皆需类型转换，请为此采用non-member函数 有理数类Rational的实现 重点关注用来将两个有理数相乘的operator*操作符重载函数的实现方式。 条款25：考虑写出一个不抛异常的swap函数标准程序库提供的swap算法的典型实现为： 12345678910namespace std&#123; template&lt;typename T&gt; void swap(T&amp; a, T&amp; b) &#123; T temp(a); a = b; b = temp; &#125;&#125; 只要T类型支持copying函数（copy构造函数和copy assignment操作符）。对于用户自定义类型，效率低下（需要三次复制）。 现在考虑所谓的pimpl(pointer to implementation)实现手法： 1234567891011121314151617181920212223242526// 注意这是个模板类template&lt;typename T&gt;class WidgetImpl&#123;public: ... // 细节不重要private: ... // 有很多数据, 意味着复制时间很长&#125;;// 注意这是个模板类template&lt;typename T&gt;class Widget&#123;public: Widget(const Widget&lt;T&gt;&amp; rhs); // 关于 operator= 的一般性实现参考条款 10, 11, 12 Widget&amp; operator=(const Widget&lt;T&gt;&amp; rhs) &#123; ... *pImpl = *(rhs.pImpl); ... &#125;private: WidgetImpl&lt;T&gt;* pImpl; // 指向实际实现的对象&#125;; 一旦需要置换两个Widget对象值，我们实际唯一需要的是置换两个指针即可。但缺省的swap函数不知道这一点！ 下面是正确的实现步骤： 令Widget实现一个名为swap的public成员函数做真正的置换工作 123456789101112template&lt;typename T&gt;class Widget&#123;public: ... void swap(Widget&lt;T&gt;&amp; other) &#123; using std::swap; // 必须的 swap(pImpl, other.pImpl); // 直接置换指针即可 &#125; ...&#125; 将std::swap特化，令它调用该成员函数（当Widget是类时。这里的例子中，Widget是个模板类则不要这一步） 因为，C++只允许对class template偏特化，不允许对function template进行偏特化 12345678namespace std&#123; template&lt;&gt; void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; a.swap(); &#125;&#125; 声明一个non-member swap，令它调用member swap 123456// 注意, 要将它放在和 Widget&lt;T&gt; 同一个空间内(全局或者自定义的 namespace)template&lt;typename T&gt;void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)&#123; a.swap(b);&#125; 编程时，在调用swap置换对象的语句之前加上using std::swap声明 123456789// 客户代码template&lt;typename T&gt;void doSomething(T&amp; obj1. T&amp; obj2)&#123; using std::swap; // 令 std::swap 在此函数内可用 ... swap(obj1, obj2); // 这样一来, 编译器将为 T 类型对象调用最佳版本 swap ...&#125; 编译器首先在全局作用域或T所在命名空间内寻找T（在这里，T就是例子中的Widget哦）专属的swap（也就是步骤3中实现的）。如果没有实现这些，则调用std内的swap，如果步骤2还实现了特化版本，将会选中特化版本。 劝告，member swap绝不可抛出异常 具体参考条款29。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"},{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"}]},{"title":"Effective C++之资源管理","date":"2020-03-15T13:35:42.000Z","path":"ojSMOM86r5rbvAqL/","text":"第3章：资源管理条款13：以对象管理资源 RAII(Resource Acquisition Is Initialization) 使用new获取资源后于同一条语句内以它初始化某个资源管理对象。利用当管理对象离开作用域被销毁时自动调用其析构函数的机制确保资源被释放。不直接用new和delete，多用智能指针。 智能指针在其析构函数中做delete动作而非delete[]动作 因此，不要在动态分配来的数组身上使用智能指针（虽然它仍然会通过编译）。 条款14：在资源管理类中小心copying行为 当不想RAII类被复制时可以继承Uncopyable类 将智能指针施于heap-based资源身上是个好主意，但并不是所有资源都是heap-based的，比如互斥器mutex，mutex就不可复制。 条款15：在资源管理类中提供对原始资源的访问 显示转换（安全） 例如，shared_ptr类就提供可一个get成员函数来返回智能指针内部的原始指针。 operator隐式转换（调用方便） 123456789101112131415161718class A&#123; ... // operator 可以实现隐式转换函数 operator B() const &#123; return b; &#125; ...private: B b; // B 类型对象成员&#125;;// 接受 B 类型对象的一个函数void func(B b);A a;func(a); // a 会被编译器隐式转换为 B 类型对象 条款16：使用new和delete时要采用相同的形式 编译器在给数组分配内存时，会包括数组大小的记录 这样的好处是，delete[]时知道需要调用多少次析构函数。 不要对数组形式进行typedef动作 条款17：以独立语句将new来的对象置入智能指针考虑这样两个函数： 12int priority(); // 调用这个函数不排除会发生异常void processWidget(shared_ptr&lt;Widget&gt; pw, int priority); 如果这样调用编译不通过，因为shared_ptr接收原始指针的构造函数是explicit的： 1processWidget(new Widget, priority()); 如果这样调用可能会造成内存泄漏： 1processWidget(shared_ptr&lt;Widget&gt;(new Widget), priority()); 因为编译器在编译这条语句时，实际上会创建三个动作： 调用priority() 执行new Widget 调用shared_ptr的构造函数 而C++编译器安排这三个动作的次序是不确定的。 如果执行次序是这样： 执行new Widget 调用priority() 调用shared_ptr的构造函数 一旦中途priority()导致异常，那么new返回的原始指针并未交给智能指针保管，将造成资源泄露。 正确的做法： 12shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority()); 因为，编译器对“跨越语句的各项操作”没有重新排列执行次序的自由。","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"},{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"}]},{"title":"Effective C++之构造、析构、赋值运算","date":"2020-03-08T13:35:42.000Z","path":"MeCvwFxjI4asjddf/","text":"第2章：构造、析构、赋值运算条款05：了解C++默默编写并调用哪些函数 编译器会暗自为class创建default构造函数、copy构造函数、copy assignment操作符以及析构函数 对于class内含reference成员或const成员，编译器拒绝为其生成copy构造函数和copy assignment操作符 因为C++不允许reference改指向不同的对象以及更改const成员。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝 为驳回编译器自动提供的函数，可将相应的成员函数声明为private并且不予实现。 掌握Uncopyable类的实现机制 将构造函数和析构函数设置为protected的 将拷贝构造函数和拷贝赋值运算符设置为private的 12345678910class Uncopyable&#123;protected: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable &amp;); const Uncopyable &amp;operator=(const Uncopyable &amp;);&#125;; 条款07：为多态基类声明virtual析构函数 带多态性质的base class应该声明一个virtual析构函数 当class内至少含有一个virtual函数，才为它声明virtual析构函数 class的设计目的如果不是作为base class使用，或不是为了具备多态性，就不该声明virtual析构函数 然而，有时候你希望拥有一个抽象类，但没有任何需要的pure virtual方法，怎么办？ 由于abstract class（不能实例化）总是被期望当作多态基类，多态基类又需要virtual析构函数，而pure virtual函数会导致abstract class，因此可将析构函数声明为pure virtual并且给出默认实现。 12345678// 小技巧:pure virtual 析构函数class AWOV&#123;public: virtual ~AWOV() = 0;&#125;;AWOV::~AWOV() &#123;/* default */&#125; 条款08：别让异常逃离析构函数 析构函数绝对不要吐出异常 假设有一个类负责数据库的连接： 12345678class DBConnection&#123;public: ... static DBConnection create(); void close(); // 关闭联机, 失败则抛出异常&#125;; 为了确保客户不忘记在DBConnection对象上调用close函数，一个合理的想法是创建一个用来管理DBConnection资源的类，并在析构函数中调用close。 123456789101112class DBConn&#123;public: ... ~DBConn() &#123; db.close(); &#125; private: DBConnection db;&#125;; 用户可以写出这样的代码 1234&#123; DBConn dbc(DBConnection::create()); ...&#125; // 区块作用域结束，调用析构函数销毁对象 如果被析构函数调用的函数close可能抛出异常，析构函数应该捕获异常然后吞下它们或者结束程序。 一个好的策略是，开放一个close接口供用户调用，把调用close的责任从DBConn析构函数手上移到用户手上。 1234567891011121314151617181920212223242526272829class DBConn&#123;public: ... void close() &#123; db.close(); closed = true; &#125; ~DBConn() &#123; if(!closed) &#123; try &#123; db.close(); // 关闭连接（如果客户没做的话） &#125; catch(...) &#123; 日志记录下对 close 调用的失败; ... &#125; &#125; &#125; private: DBConnection db; bool closed;&#125;; 因此，如果客户需要对某个操作函数运行期间的异常作出反应，那么class应该提供一个接口执行该操作。如果close的确发生了异常，而客户没有调用close接口进行处理，DBConn只能吞下或结束程序。 条款09：绝不在析构和构造函数中调用virtual函数 派生类对象内的基类成分会在派生类自身成分被构造之前先被构造 基类构造期间，虚函数绝不会下降到派生类层 需要注意的是，有时类有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复时会把相同的初始化代码放到一个init函数中实现，如果这时在init函数中同样调用了虚函数，情况是一样的但比较隐秘。 条款10：令赋值操作符operator=返回一个reference to *this 为了实现连续赋值 条款11：在operator=中处理自我赋值 有些自我赋值并不明显，如通过指针或引用 假设你建立一个class来保存一个指针指向一块动态分配的位图（bitmap）： 1234567class Bitmap &#123;...&#125;;class Widget&#123; ...private: Bitmap* pb; // 指向一个从 heap 分配而得的对象&#125;; 错误的operator=实现为： 1234567// 自我赋值不安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; delete pb; pb = new Bitmap(*rhs,pb); return *this;&#125; 可通过一个“证同测试”来检验： 12345678910// 自我赋值安全, 但不具备异常安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; if(this == &amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs,pb); return *this;&#125; 所谓的异常安全指的是，如果new Bitmap发生异常，会导致Widget最终会持有一个指针指向一块被删除的Bitmap。 12345678910// 具备异常安全, 则自动具备自我赋值安全Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* oldPb = pb; // 记住之前的 pb pb = new Bitmap(*rhs,pb); delete oldPb; return *this;&#125; 使用更好的copy and swap技术： 1234567891011121314151617181920212223class Bitmap &#123;...&#125;;class Widget&#123; ... void swap(Widget&amp; rhs) &#123; ... // 交换 *this 和 rhs 的数据, 见条款 25 &#125; ...&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; // 提升点效率 ? // if(this == &amp;rhs) // return *this; Widget temp(rhs); // copy swap(temp); // swap return *this;&#125; 条款12：复制对象时勿忘每一个成分 每一个成分包括对象内所有成员变量以及所继承的基类成分 在拷贝构造函数中的初始化列表中调用所继承的类的拷贝构造函数 在拷贝赋值操作符函数中调用所继承的类的拷贝赋值操作符函数 不要尝试让拷贝构造函数和拷贝赋值操作符函数互相调用","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"},{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"}]},{"title":"Effective C++之让自己习惯C++","date":"2020-03-01T13:35:42.000Z","path":"l4snoL8SUW9lGasI/","text":"第1章：让自己习惯C++条款01：视C++为一个语言联邦 将C++视为由4个次语言组成的联邦： C：没有模板、没有异常、没有重载… Object-Oriented C++：类、封装、继承、多态、虚函数、动态绑定等等； Template C++：泛型编程部分； STL：是一个Template程序库，容器、迭代器、算法以及函数对象。 从某个此语言切换到另一个时，高效编程守则可能会发生变化。比如，C-like类型（内置类型）pass by value更好；对于Object-Oriented C++而言，pass by reference to-const更好；再切换到STL，由于迭代器和函数对象都是在C指针之上塑造出来的，pass by value守则再次适用。 条款02：尽量以const，enum，inline替换#define 对于单纯常量，最好以const对象或enum hack替换#define 1234567891011121314// 记号名称未进入符号表, 难以调试// 在多处出现目标码, 尤其浮点常量// 无作用域概念, 不提供任何封装性#define ASPECT_RATIO 1.653// 常量会被编译器看到, 进入符号表// 导致较小量的目标码, 因为只有一份// 可放置在类内或 namespace 中限制其作用域const double AspectRatio = 1.653;// 可以放在类或 namespace 中// 令 NumTurns 成为 5 的记号名称, 一般用在类中做常量用// 行为像 #define, 对 const 取地址合法，对 enum 和 #define 取地址就不合法enum &#123;NumTurns = 5&#125;; 对于形似函数的宏，最好用inline（或模板）函数替换 宏中的变量有可能会被运算多次。 条款03：尽可能使用const const作用于迭代器 STL迭代器是以指针为根据塑模出来的，其作用就像个T*指针。声明迭代器为const只是声明一个const指针（作用就像T* const），表明的是迭代器本身不可变，但其所指的值是可以改动的。如果希望迭代器所指的值不可改动，需要的是const_iterator。 123456789std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();*iter = 10; // 正确++iter; // 错误std::vector&lt;int&gt;::const_iterator citer = vec.begin();*citer = 10; // 错误++citer; // 正确 将operator*的返回类型声明为const-by-value const可被施加于任何作用域内的对象、函数参数（常用pass-by-reference-to-const），函数返回类型、类成员函数本体 const施加于成员函数 成员函数上的const限定符意味着不能修改non-mutable，non-static类数据成员。 当const和non-const成员函数有着实质等价的实现时，令non-const成员函数调用const版本可避免代码重复 12345678910111213141516171819202122232425262728293031class TextBook&#123;public: ... const char&amp; operator[](std::size_t position) const &#123; ... // 边界检验 ... // 日记数据访问 ... // 检验数据完整性 return text[position]; &#125; /* char&amp; operator[](std::size_t position) &#123; ... // 边界检验 ... // 日记数据访问 ... // 检验数据完整性 return text[position]; &#125; */ char&amp; operator[](std::size_t position) &#123; // 调用 const_cast 移除对象身上的 const // 调用 static_cast 为 *this 加上 cosnt return const_cast&lt;char &amp;&gt;( static_cast&lt;const TextBook&amp;&gt;(*this)[position] ); &#125;private: std::string text;&#125;; const版本成员函数调用non-const版本不合法 条款04：确定对象被使用前已先被初始化 为内置型对象进行手工初始化，因为C++并不保证初始化它们 构造函数使用成员初始化列表，初始化顺序与在类中声明顺序一致 为避免“跨编译单元内定义的non-local static对象的初始化问题”，以local对象替换non-local static对象 static对象包括global对象、定义与namespace作用域内的对象、在class内、函数内、以及在file作用域内被声明为static的对象 函数内的static被称为local static对象，其它static对象被称为non-local static对象 程序结束时，static对象会被自动销毁，也就是它们的析构函数在main函数结束时被自动调用 编译单元是指产出单一目标文件的源码文件以及所含入的头文件 现在有两个源码文件，每个至少含入一个non-local static对象，其中一个non-local static对象用到了另一个non-local static对象，而被用到的尚未被初始化。 1234567891011121314151617181920212223// 文件 FileSystem.cpp 中class FileSystem&#123;public: ... std::size_t numDisks()const; // 众多成员函数之一 ...&#125;;extern FileSystem tfs; // 预备给客户使用的对象, non-local static 对象// 文件 Directory.cpp 中class Directory&#123;public: Directory(); // 构造函数 ...&#125;;Directory::Directory()&#123; ... std::size_t disks = tfs.numDisks(); // 使用 tfs 对象 ...&#125; 现在客户决定创建一个Directory对象，用来放置临时文件： 1Directory tempDir; // 为临时文件而做出的目录 这个时候就会出现初始化次序带来的问题。由于tfs和tempDir是不同的人在不同的时间于不同的源码文件中创建出来的，因此初始化次序不一定。 解决方法： 12345678910111213141516171819202122232425262728// 文件 FileSystem.cpp 中class FileSystem&#123;public: ... std::size_t numDisks() const; // 众多成员函数之一 ...&#125;;FileSystem&amp; tfs() // 用于创建预备给客户使用的对象的函数&#123; static FileSystem fs; // local static 对象 return fs;&#125;// 文件 Directory.cpp 中class Directory&#123;public: Directory(); // 构造函数 ...&#125;;Directory::Directory()&#123; ... // 这样就保证了被使用对象先被初始化 std::size_t disks = tfs().numDisks(); // 使用 tfs() 创建对象 ...&#125;","tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://yuanlehome.github.io/tags/Effective-C/"},{"name":"C++","slug":"C","permalink":"https://yuanlehome.github.io/tags/C/"}]}]